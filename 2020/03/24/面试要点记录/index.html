<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,面试,shell," />










<meta name="description" content="（一）面向对象的三个基本特征：封装、继承、多态 （二）bash shell （三）图q （四）IO库 （五）搜狗 （六）手写代码 （七）SAP （八）进程间的通信方式（IPC,inter-Process Communication） 进程创建fork和vfork 进程和线程的区别 线程有什么是共享的什么是私有的 进程的三种基本状态 windows命名管道和Linux命名管道的区别 win">
<meta property="og:type" content="article">
<meta property="og:title" content="面试要点记录">
<meta property="og:url" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="翟安然&#39;s Blog">
<meta property="og:description" content="（一）面向对象的三个基本特征：封装、继承、多态 （二）bash shell （三）图q （四）IO库 （五）搜狗 （六）手写代码 （七）SAP （八）进程间的通信方式（IPC,inter-Process Communication） 进程创建fork和vfork 进程和线程的区别 线程有什么是共享的什么是私有的 进程的三种基本状态 windows命名管道和Linux命名管道的区别 win">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/seekgseekp.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/qiuck_sort.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/baidu1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/baidu2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/baidu3.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/baidu4.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/baidu5.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/sensor.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/zhaoyin.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/LWP.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BA%BF%E7%A8%8B.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/lock.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/struct.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/fflush.jpg">
<meta property="article:published_time" content="2020-03-24T13:59:01.000Z">
<meta property="article:modified_time" content="2020-10-15T05:38:58.000Z">
<meta property="article:author" content="翟安然">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/seekgseekp.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/24/面试要点记录/"/>





  <title>面试要点记录 | 翟安然's Blog</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">翟安然's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="翟安然">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="翟安然's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试要点记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-24T21:59:01+08:00">
                2020-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

<ul>
<li><a href="#一面向对象的三个基本特征封装-继承-多态">（一）面向对象的三个基本特征：封装、继承、多态</a></li>
<li><a href="#二bash-shell">（二）bash shell</a></li>
<li><a href="#三图">（三）图q</a></li>
<li><a href="#四io库">（四）IO库</a></li>
<li><a href="#五搜狗">（五）搜狗</a></li>
<li><a href="#六手写代码">（六）手写代码</a></li>
<li><a href="#七sap">（七）SAP</a></li>
<li><a href="#八进程间的通信方式ipcinter-process-communication">（八）进程间的通信方式（IPC,inter-Process Communication）</a><ul>
<li><a href="#进程创建fork和vfork">进程创建fork和vfork</a></li>
<li><a href="#进程和线程的区别">进程和线程的区别</a></li>
<li><a href="#线程有什么是共享的什么是私有的">线程有什么是共享的什么是私有的</a></li>
<li><a href="#进程的三种基本状态">进程的三种基本状态</a></li>
<li><a href="#windows命名管道和linux命名管道的区别">windows命名管道和Linux命名管道的区别</a></li>
<li><a href="#windows多线程通信的方法主要有三种">windows多线程通信的方法主要有三种：</a></li>
<li><a href="#死锁死锁产生的原因死锁的必要条件怎么处理死锁">死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？</a></li>
</ul>
</li>
<li><a href="#九sql">（九）SQL</a></li>
<li><a href="#十一百度">（十一）百度</a><ul>
<li><a href="#百度后台开发cphp实习">百度后台开发c++/PHP实习</a></li>
<li><a href="#百度b2b后台开发cphp提前批">百度B2B后台开发c++/PHP提前批</a><ul>
<li><a href="#百度二面">百度二面：</a></li>
</ul>
</li>
<li><a href="#百度正式批一面">百度正式批一面</a><ul>
<li><a href="#static函数">static函数</a></li>
<li><a href="#inline">inline</a></li>
<li><a href="#c中-内联编译限制">C++中 内联编译限制</a></li>
<li><a href="#构造函数可以是虚函数吗">构造函数可以是虚函数吗</a></li>
<li><a href="#socket手撸">socket手撸</a></li>
</ul>
</li>
<li><a href="#二面">二面</a></li>
<li><a href="#三面">三面</a><ul>
<li><a href="#hash与红黑树的区别">Hash与红黑树的区别：</a><ul>
<li><a href="#拉链法的优点与开放定址法相比拉链法有如下几个优点">拉链法的优点与开放定址法相比，拉链法有如下几个优点</a></li>
</ul>
</li>
<li><a href="#线性探测法优缺点">线性探测法优缺点</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#十二网易">（十二）网易</a></li>
<li><a href="#十三腾讯">（十三）腾讯</a><ul>
<li><a href="#腾讯测开实习">腾讯测开实习</a></li>
<li><a href="#腾讯后台开发基础框架提前批一面">腾讯后台开发基础框架提前批一面</a></li>
</ul>
</li>
<li><a href="#十四招商银行信用卡中心">（十四）招商银行信用卡中心</a></li>
<li><a href="#十五快手">（十五）快手</a><ul>
<li><a href="#c工程师-ai平台">c++工程师-AI平台</a></li>
</ul>
</li>
<li><a href="#十六猿辅导">（十六）猿辅导</a><ul>
<li><a href="#二面-1">二面</a></li>
</ul>
</li>
<li><a href="#十七阿里">（十七）阿里</a></li>
<li><a href="#十八华为">（十八）华为</a><ul>
<li><a href="#正式批">正式批</a><ul>
<li><a href="#一-概述">一、概述</a></li>
<li><a href="#二-编译过程">二、编译过程</a></li>
<li><a href="#三-链接过程">三、链接过程</a></li>
<li><a href="#为创建可执行文件链接器必须要完成的主要任务">为创建可执行文件，链接器必须要完成的主要任务</a></li>
<li><a href="#四-加载过程">四、加载过程</a></li>
<li><a href="#字符串分隔符分隔和定义比较函数">字符串分隔符分隔和定义比较函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#十九腾讯测开">（十九）腾讯测开</a></li>
<li><a href="#二十美团">（二十）美团</a><ul>
<li><a href="#美团测开实习">美团测开实习</a></li>
<li><a href="#美团数据开发快驴事业部">美团数据开发（快驴事业部）</a><ul>
<li><a href="#二面-2">二面</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#二十一中兴捧月模拟大赛">（二十一）中兴捧月模拟大赛</a></li>
<li><a href="#二十二招银网络">（二十二）招银网络</a><ul>
<li><a href="#正式批-1">正式批</a><ul>
<li><a href="#二面-3">二面</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#二十三字节">（二十三）字节</a></li>
<li><a href="#二十四小米">（二十四）小米</a><ul>
<li><a href="#一面">一面</a></li>
</ul>
</li>
<li><a href="#二十五滴滴">（二十五）滴滴</a><ul>
<li><a href="#非分布式系统中的线程">非分布式系统中的线程</a></li>
<li><a href="#分布式系统中的线程">分布式系统中的线程</a></li>
<li><a href="#优点">优点</a></li>
<li><a href="#缺点">缺点</a></li>
<li><a href="#虚拟地址va如何转换成物理地址pa空间">虚拟地址（VA）如何转换成物理地址（PA）空间</a></li>
</ul>
</li>
<li><a href="#二十六网易">（二十六）网易</a><ul>
<li><a href="#1-mvc举例-其他设计模式工厂模式-适配器模式-策略模式">1. MVC举例 其他设计模式:工厂模式  适配器模式  策略模式</a><ul>
<li><a href="#一简单工厂模式-工厂方法模式-抽象工厂模式">(一)简单工厂模式  工厂方法模式   抽象工厂模式</a></li>
</ul>
</li>
<li><a href="#2-activity生命周期httpsdeveloperandroidgooglecnguidecomponentsactivitiesactivity-lifecyclehlzh-cn">2. activity生命周期</a></li>
<li><a href="#315个android通用流行框架httpswwwoschinanetnews7383615-android-general-popular-frameworks">3.15个android通用流行框架</a></li>
<li><a href="#cc和java的区别">c/c++和java的区别</a></li>
</ul>
</li>
<li><a href="#二十七知识点">（二十七）知识点</a><ul>
<li><a href="#1-vector源码初始设置值">1. vector源码初始设置值</a></li>
<li><a href="#2-linux内存管理">2. linux内存管理</a></li>
<li><a href="#3-内置类型和复合类型">3. 内置类型和复合类型</a></li>
<li><a href="#4-c模板和java泛型有什么区别">4. c++模板和java泛型有什么区别</a></li>
<li><a href="#5布隆过滤器httpswwwcnblogscomqdhxhzp11259078html">5.布隆过滤器</a></li>
<li><a href="#6nosql和sql的区别httpswwwcnblogscomjeakevenp5402095html">6.NoSQL和SQL的区别</a></li>
<li><a href="#7-为什么要分堆和栈">7. 为什么要分堆和栈</a></li>
<li><a href="#8-c线程中的几种锁">8. c++线程中的几种锁</a></li>
<li><a href="#9-git-log">9. git log</a></li>
<li><a href="#10-kill进程是进程通信linux内核发送sigkill信号给进程">10. kill进程是进程通信：linux内核发送SIGKILL信号给进程</a></li>
<li><a href="#11-windows消息驱动机制和时间驱动机制">11. windows消息驱动机制和时间驱动机制</a></li>
<li><a href="#12-linux设备驱动机制">12. Linux设备驱动机制</a></li>
<li><a href="#10-字节二面编程题1-求36进制的和-2-判断树是否对称">10. 字节二面编程题：1、求36进制的和 2、判断树是否对称</a></li>
<li><a href="#11-堆排序是原地算法空间复杂度o1">11. 堆排序是原地算法，空间复杂度O(1)。</a></li>
<li><a href="#12-常见数据结构的查找-插入-删除时间复杂度">12. 常见数据结构的查找、插入、删除时间复杂度</a></li>
<li><a href="#13-使用递归函数需要注意防止栈溢出">13. <strong>使用递归函数需要注意防止</strong>栈溢出**。</a></li>
<li><a href="#14-递归时间复杂度">14. 递归时间复杂度</a></li>
<li><a href="#15-struct和class的区别">15. struct和class的区别</a></li>
<li><a href="#16-两种通用的遍历树的策略">16. 两种通用的遍历树的策略</a></li>
<li><a href="#17-stdfuntion和stdbind参考httpsblogcsdnnetqq_38410730articledetails103637778">17. std::funtion和std::bind参考</a></li>
<li><a href="#18-函数对象定义了调用操作符的类对象">18. 函数对象：定义了调用操作符（）的类对象。</a></li>
<li><a href="#19-解决hash冲突的三种方法">19. 解决hash冲突的三种方法</a></li>
<li><a href="#20-文件描述符-打开文件描述符表-文件表-inode节点">20. 文件描述符、打开文件描述符表、文件表、inode节点</a></li>
<li><a href="#21-查找路由器地址">21. 查找路由器地址</a></li>
<li><a href="#22-conststaticinline默认内部链接内部链接的符号不能在别的编译单元中使用若要实现共享则要定义于头文件函数和变量默认外部链接外部链接的符号在整个程序范围内都是可以使用的这就要求其他编译单元不能导出相同的符号不然就会报duplicated-external-symbols">22. const/static/inline默认内部链接（内部链接的符号不能在别的编译单元中使用），若要实现共享，则要定义于头文件；函数和变量默认外部链接（外部链接的符号在整个程序范围内都是可以使用的，这就要求其他编译单元不能导出相同的符号（不然就会报duplicated external symbols）</a></li>
<li><a href="#23-readwritefsync和freadfwritefflush都是对文件进行操作那她们有什么区别呢">23. read/write/fsync和fread/fwrite/fflush都是对文件进行操作，那她们有什么区别呢</a></li>
<li><a href="#24-tcp协议保证数据传输可靠性的主要方式httpsblogcsdnnetliuchenxia8articledetails80428157">24.  TCP协议保证数据传输可靠性的主要方式</a></li>
<li><a href="#25-linux-虚拟内存和物理内存的理解httpsgithubcomdurant35durant35githubioissues24">25. Linux 虚拟内存和物理内存的理解</a></li>
<li><a href="#26socket通信httpswwwcnblogscomfengffp10984251html">26.Socket通信</a></li>
<li><a href="#27索引使用原则httpswwwcnblogscomwangxusummerp5329813html">27.索引使用原则</a></li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->


<h2 id="（一）面向对象的三个基本特征：封装、继承、多态"><a href="#（一）面向对象的三个基本特征：封装、继承、多态" class="headerlink" title="（一）面向对象的三个基本特征：封装、继承、多态"></a>（一）面向对象的三个基本特征：封装、继承、多态</h2><ol>
<li>继承</li>
</ol>
<ul>
<li>子类对象可以直接调用父类中的成员函数</li>
<li>子类对象可以直接赋值给父类对象。</li>
<li>子类对象可以直接初始化父类对象。</li>
<li>父类引用可以直接引用子类对象。</li>
<li>父类指针可以直接指向子类对象。</li>
</ul>
<a id="more"></a>

<ul>
<li>子类初始化一定会先初始化父类，析构顺序相反。</li>
<li>虚继承对构造函数的影响：<a href="https://blog.csdn.net/dqjyong/article/details/8028888?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">指南</a>。构造函数的调用可能内带大量的隐藏码，因为编译器会对构造函数进行扩充，一般而言编译器所作的扩充规则如下：</li>
</ul>
<p>（1）记录在成员初始化列表中的数据成员的初始化操作会被放到构造函数本身中，<strong>按照数据成员声明的顺序</strong></p>
<p>（2）如果有一个数据成员没有出现在初始化列表中，但是它有一个默认构造函数，那么这个默认构造函数会被调用</p>
<p>（3）在那之前，如果有虚函数表，会调整虚函数表指针</p>
<p>（4）在那之前，会对上一层基类的构造函数进行调用</p>
<p>（5）在那之前，所有虚基类的构造函数必须被调用，按照声明的继承顺序从左往右，从最深到最浅的顺序</p>
<p>继承的优点：</p>
<p>（1）继承使得所有的子类的公共部分都放在了父类中，使得代码得到了共享。提高了代码的重用性，避免了重复。</p>
<p>（2）继承可使得修改或扩展继承而来的实现都较为容易</p>
<p>（3）使类与类之间产生联系，为多态提供了前提</p>
<p>继承的缺点：</p>
<p>（1）继承具有入侵性（即继承必须拥有父类的所有非私有属性和方法）</p>
<p>（2）父类变，子类变</p>
<p>（2）继承破坏封装，父类实现细节暴露给子类，增大了两个类之间的耦合性</p>
<ol start="2">
<li>多态:C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</li>
</ol>
<ul>
<li>运行期多态发生的三个必要条件：<ol>
<li>要有继承。</li>
<li>要有虚函数重写。</li>
<li>父类指针或引用 指向 子类对象。</li>
</ol>
</li>
<li>运行期多态的优缺点</li>
</ul>
<p>（1）优点：提高了代码的维护性（由继承保证）和扩展性（由多态保证）</p>
<p>（2）缺点：</p>
<ol>
<li>运行期间进行虚函数绑定，提高了程序运行开销</li>
<li>庞大的类继承层次，对接口的修改易影响类继承层次</li>
<li>由于虚函数在运行期确定，所以编译器无法对虚函数进行优化</li>
<li>虚表指针增加了对象空间，类也多了一张虚函数表。</li>
</ol>
<ul>
<li>虚析构函数：在多态时，要调用析构函数时，注意在父类的析构成员函数前加virtual。</li>
<li>动态绑定必须使用指针或者引用，不能使用<code>.</code></li>
<li>虚函数表指针在内存中的分布:<a href="https://blog.csdn.net/li1914309758/article/details/79916414" target="_blank" rel="noopener">参考</a></li>
<li>编译期多态</li>
</ul>
<p>对模板参数而言，多态是通过模板具现化和函数重载解析实现的。<strong>以不同的模板参数具现化导致调用不同的函数</strong>，这就是所谓的编译期多态。</p>
<p>（1）编译期多态优点</p>
<ol>
<li>泛型编程</li>
<li>在编译器完成多态，提高运行期效率</li>
<li>具有很强的适配性和松耦合性，对于特殊类型可由模板偏特化、全特化来处理</li>
</ol>
<p>（2）编译期多态缺点</p>
<ol>
<li>程序可读性降低，代码调试困难</li>
<li>无法实现模板分离编译，当工程很大时，编译时间不可小觑</li>
<li>无法处理异质对象集合</li>
</ol>
<ol start="3">
<li>重载/重写（覆盖）/重定义（隐藏）</li>
</ol>
<ul>
<li>重载（overload）-编译时的多态性</li>
</ul>
<p>（1）重载只能通过不同的参数样式（参数类型、个数、顺序至少有一个不相同），不能通过访问权限、返回类型、抛出的异常进行重载。</p>
<ul>
<li>重写（override）-运行时的多态性</li>
</ul>
<p>（1）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p>
<p>（2）被定义为final的方法不能被重写。</p>
<ul>
<li>重定义（隐藏hiding）</li>
</ul>
<p>（1）隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base display()"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base show()"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>&#123; <span class="built_in">display</span>(); show(); &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base fun(string)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base fun(int)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;<span class="comment">//overload:两个fun函数在Base类的内部被重载  </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">function</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span>:</span><span class="keyword">public</span> Base  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"ClassA display()"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;<span class="comment">//override:基类中display为虚函数，且参数列表一直，故此处为重写  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"ClassA fun(int,int)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;<span class="comment">//redefining:fun函数在Base类中不为虚函数，故此处为重定义  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"ClassA show()"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;<span class="comment">//redefining:理由同上  </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;&#125;<span class="comment">//overload:注意这是重载而不是重写，因为参数列表不同，在编译时ClassA中其实还有个编译器自己偷偷加上的从Base继承来的int function()&#123;&#125;;  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    ClassA a;  </span><br><span class="line">    Base *base=&amp;a;  </span><br><span class="line">    base-&gt;exec();<span class="comment">//display()是ClassA的，因为覆盖了，show()是Base自己的  </span></span><br><span class="line">    a.exec();<span class="comment">//结果同上,子类对象可以直接调用父类中的成员函数  </span></span><br><span class="line">    a.show();<span class="comment">//show()是ClassA重定义的  </span></span><br><span class="line">    base-&gt;fun(<span class="number">1</span>);<span class="comment">//fun()是Base自己的，因为直接从对象base调用  </span></span><br><span class="line">    a.fun(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//fun()是ClassA重定义的  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="function">ClassA <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Base <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">ClassA <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Base <span class="title">show</span><span class="params">()</span><span class="comment">//父类中的成员函数直接调用自身的Base show()</span></span></span><br><span class="line"><span class="function">ClassA <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Base <span class="title">fun</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">ClassA <span class="title">fun</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::f(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::g(int) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::h(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base *pb = &amp;d;</span><br><span class="line">    Derived *pd = &amp;d;</span><br><span class="line">    <span class="comment">// Good : behavior depends solely on type of the object</span></span><br><span class="line">    pb-&gt;f(<span class="number">3.14f</span>); <span class="comment">//Derived::f(float) 3.14</span></span><br><span class="line">    pd-&gt;f(<span class="number">3.14f</span>); <span class="comment">//Derived::f(float) 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bad : behavior depends on type of the pointer</span></span><br><span class="line">    pb-&gt;g(<span class="number">3.14f</span>); <span class="comment">//Base::g(float) 3.14</span></span><br><span class="line">    pd-&gt;g(<span class="number">3.14f</span>); <span class="comment">//Derived::g(int) 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bad : behavior depends on type of the pointer</span></span><br><span class="line">    pb-&gt;h(<span class="number">3.14f</span>); <span class="comment">//Base::h(float) 3.14</span></span><br><span class="line">    pd-&gt;h(<span class="number">3.14f</span>); <span class="comment">//Derived::h(float) 3.14</span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数Derived::f(float)覆盖了Base::f(float)</span></span><br><span class="line"><span class="comment">//函数Derived::g(int)隐藏了Base::g(float)，而不是重载</span></span><br><span class="line"><span class="comment">//函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>三者</th>
<th>作用域</th>
<th>有无virtual</th>
<th>函数名</th>
<th>参数列表</th>
<th>返回类型</th>
</tr>
</thead>
<tbody><tr>
<td>重载</td>
<td>相同</td>
<td>可有可无</td>
<td>相同</td>
<td>不同</td>
<td>可同可不同</td>
</tr>
<tr>
<td>重写</td>
<td>不同</td>
<td>必有</td>
<td>相同</td>
<td>相同</td>
<td>相同（协变）</td>
</tr>
<tr>
<td>隐藏</td>
<td>不同</td>
<td>可有可无</td>
<td>相同</td>
<td>可同可不同</td>
<td>可同可不同</td>
</tr>
</tbody></table>
<h2 id="（二）bash-shell"><a href="#（二）bash-shell" class="headerlink" title="（二）bash shell"></a>（二）bash shell</h2><ul>
<li><p>bash是borne again shell的缩写，是shell的一种,Linux上默认采用的是bash。</p>
</li>
<li><p>Shell 是一个 C 语言编写的程序，一般都是放在<code>/bin</code>或者<code>/user/bin</code>目录下，当前 Linux 系统可用的 Shell 都记录在<code>/etc/shells</code>文件中。<code>/etc/shells</code>是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令查看它。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/shells <span class="comment">#通过 cat 命令来查看当前 Linux 系统的可用 Shell</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$SHELL</span> <span class="comment">#查看当前Linux默认的shell，输出 SHELL 环境变量</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$BASH_VERSION</span> <span class="comment">#查看shell版本</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置取消alias：<a href="http://c.biancheng.net/linux/alias.html" target="_blank" rel="noopener">指南</a></li>
<li>PHP即“<a href="https://baike.baidu.com/item/超文本" target="_blank" rel="noopener">超文本</a><a href="https://baike.baidu.com/item/预处理器" target="_blank" rel="noopener">预处理器</a>”，是一种通用<a href="https://baike.baidu.com/item/开源/246339" target="_blank" rel="noopener">开源</a><a href="https://baike.baidu.com/item/脚本语言/1379708" target="_blank" rel="noopener">脚本语言</a>。PHP是一种在服务器端执行的嵌入HTML文档的脚本语言。PHP 独特的语法混合了C、Java、Perl 以及 PHP 自创新的语法，它可以比 CGI 或者 Perl 更快速的执行动态网页，主要适用于<a href="https://baike.baidu.com/item/Web/150564" target="_blank" rel="noopener">Web</a>开发领域。</li>
</ul>
<h2 id="（三）图"><a href="#（三）图" class="headerlink" title="（三）图"></a>（三）图</h2><ol>
<li>拓扑排序</li>
</ol>
<ul>
<li>一个有向无环图可以有<strong>一个或多个</strong>拓扑排序序列。</li>
<li>判断有向图是否有环的两种方法：(1)拓扑排序 (2)DFS</li>
</ul>
<ol start="2">
<li><p>五大常用算法</p>
<ol>
<li>分冶法</li>
</ol>
<p>分治法所能解决的问题一般具有以下几个特征：</p>
<p>  1) 该问题的规模缩小到一定的程度就可以容易地解决</p>
<p>  2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p>
<p>  3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p>
<p>  4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</p>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p>
<p><strong>第二条特征是应用分治法的前提</strong>它也是大多数问题可以满足的，此特征反映了递归思想的应用；</p>
<p><strong>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征</strong>，如果<strong>具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法</strong>。</p>
<p><strong>第四条特征涉及到分治法的效率</strong>，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但<strong>一般用动态规划法较好</strong>。可用分冶法求解的一些经典问题：二分查找；快速排序。</p>
<ol start="2">
<li><p>动态规划</p>
<p>(1)  最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
<p>(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>(3) 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。</p>
</li>
</ol>
<p>递归常常用于分冶算法和动态规划算法中。</p>
<ol start="3">
<li>贪心算法</li>
</ol>
<p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。</p>
<p>从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的地求得更好的解。当达到算法中的某一步不能再继续前进时，算法停止。该算法存在问题：</p>
<ul>
<li><p>不能保证求得的最后解是最佳的；</p>
</li>
<li><p>不能用来求最大或最小解问题；</p>
</li>
<li><p>只能求满足某些约束条件的可行解的范围。</p>
</li>
</ul>
<p><strong>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</strong>贪心算法和动态规划的区别：</p>
<ul>
<li><p>贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解则不作保留；动态规划：全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有的局部最优解 。求一个问题的最优解相当于遍历所有的子集来找最优解，但是这样解随着解空间的维度成指数增长，动态规划其实就是一种遍历，但是他是带备忘录的遍历，我前面算到的子问题，到这儿我不在计算，我直接调用之前保存的值，这样就节省了大量的时间。</p>
</li>
<li><p>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常自顶向下的方式进行。</p>
</li>
<li><p>根据以上两条可以知道，贪心不能保证求得的最后解是最佳的，一般复杂度低；而动态规划本质是穷举法，可以保证结果是最佳的，复杂度高。</p>
</li>
</ul>
<ol start="4">
<li>回溯法</li>
</ol>
<p>在包含问题的所有解的解空间树中，按照<strong>深度优先搜索的策略</strong>，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>
<p>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p>
<p>而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>
<ol start="5">
<li>分支界限法</li>
</ol>
<p><strong>回溯法以深度优先的方式搜索解空间树T</strong>，而<strong>分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T</strong>。</p>
<p> 分支限界法的<strong>搜索策略是</strong>：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</p>
</li>
</ol>
<ol start="3">
<li>最小生成树-Prim算法和Kruskal算法</li>
</ol>
<p>a. 最小生成树</p>
<p>生成树是连通图的<strong><em>\</em>最小连通子图**</strong>。所谓最小是指：若在树中任意增加一条边，则将出现一个回路；若去掉一条边，将会使之变成非连通图。按照该定义，<strong>n个顶点的连通网络的生成树有n个顶点，n-1条边</strong>。生成树各边的权值总和称为生成树的权，<strong><em>\</em>权最小的生成树称为最小生成树**</strong>。常见的构造最小生成树的方法有Prim算法和Kruskal算法。</p>
<p>b. Prim算法：选取与当前节点连接的权值最小边</p>
<p>c. Kruskal算法：所有边按权值从小到大排序，依次选取不使最小生成树存在回路的最小权值边</p>
<ol start="4">
<li>最短路径-Dijkstra算法和Floyd算法：<a href="https://www.jianshu.com/p/92e46d990d17" target="_blank" rel="noopener">具体代码参考</a></li>
</ol>
<p>a. Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。注意该算法要求图中不存在负权边。</p>
<p>主要思想：通过“边”来松弛v1顶点到其余各个顶点的路程。</p>
<p>b. Floyd算法</p>
<p><strong>Floyd-Warshall算法</strong>（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd算法是一个经典的动态规划算法。</p>
<h2 id="（四）IO库"><a href="#（四）IO库" class="headerlink" title="（四）IO库"></a>（四）IO库</h2><ol>
<li><p>当操作符改变流的格式状态时，通常改变后的状态对所以后续IO都生效。setw类似endl不改变输出流的内部状态，只决定下一个输出的大小。</p>
</li>
<li><p>操作符hex(0x)、oct(0)、dec只影响整型运算对象，浮点型的表示形式不受影响。使用nouppercase、noshoubase和dec来重置流状态。</p>
</li>
<li><p><code>showbase</code>:当打印整型值时显示进制</p>
<p><code>ios::internal</code>:数值的符号位在域宽内左对齐,数值右对齐,中间由填充字符填充 </p>
<p><code>setfill()</code>：允许一个字符替代默认的字符填补空白</p>
<p><code>setbase</code>：将整数设置为b进制</p>
</li>
<li><p><code>cout.setf()</code>的作用是通过设置格式标志来控制输出形式；<code>cin&gt;&gt;noskipws</code>设置<code>cin</code>读取空白符;</p>
<p><code>cin&gt;&gt;skipws</code>将<code>cin</code>恢复到默认状态，丢弃空白符</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf ( <span class="built_in">std</span>::ios::hex, <span class="built_in">std</span>::ios::basefield );<span class="comment">//set hex as the basefield</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf ( <span class="built_in">std</span>::ios::showbase );      <span class="comment">//activate showbase</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">100</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//输出0x100</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.unsetf ( <span class="built_in">std</span>::ios::showbase );   <span class="comment">//deactivate showbase</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">100</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//输出100</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>未格式化输出中<code>is.get()</code>将is的下一个字节作为int返回，头文件cstdio定义了一个名为EOF的const，用来检测返回的值是否是文件末尾，而不必记忆表示文件尾的实际数值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;<span class="comment">//使用一个int,而不是char来保存get()的返回值,否则循环可能永远不会停止，循环也可能会在遇见'\377'的字符提前终止（-1转换为一个singed char会得到'\377'）</span></span><br><span class="line"><span class="comment">//循环读取并输出输入中的所有数据</span></span><br><span class="line"><span class="keyword">while</span>((ch=<span class="built_in">cin</span>.<span class="built_in">get</span>())!=EOF)</span><br><span class="line">    <span class="built_in">cout</span>.<span class="built_in">put</span>(ch);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>istream和ostream类通常不支持随机访问，只有fstream、sstream支持。</li>
</ol>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/seekgseekp.png" alt="随机访问标记"></p>
<h2 id="（五）搜狗"><a href="#（五）搜狗" class="headerlink" title="（五）搜狗"></a>（五）搜狗</h2><ol>
<li>STL : std::map/std::set std::unordered_map/std::unordered_set结构 </li>
</ol>
<p>std::map:红黑树，自动排序，稳定查找插入删除时间复杂度O(lgn)，空间占用高，因为红黑树每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间</p>
<p>std::unordered_map:哈希表，无序，快速查找插入删除，insert/find/erase的平均时间复杂度是O(1)，但是最坏复杂度是O(N)，相比于map空间占用更高，哈希表建立比较耗费时间，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表地址顺序从前往后依次遍历的</p>
<p>存储小对象，内存消耗依次是：vector &lt;&lt;map &lt;&lt;unordered_map;当存储的对象增大时，vector的优势变得并不明显。因为随着对象增大，用于存储对象的空间所占的比例越来越大。因此单从内存消耗的角度来看，当存储的是小对象时，vector占很大的优势。但是，当存储的对象本身大小增大时，它的优势变得不再那么明显。</p>
<p>hash表：（1）插入删除接近常量，大o表示法最快的方式（2）哈希表查询也快,但是底层存储结构是数组，一旦创建无法改变大小（3）哈希表无法用来有序遍历</p>
<p><a href="https://blog.csdn.net/ff_simon/article/details/101055134" target="_blank" rel="noopener">二叉树/平衡二叉树/红黑树/b树/b+树</a></p>
<ol start="2">
<li>顺序容器</li>
</ol>
<p>vector:可变大小数组，支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢，vector插入insert删除erase时间复杂度均是O(n)</p>
<p>deque:双端队列，支持快速随机访问。在头尾部位置插入/删除速度很快</p>
<p>list:双向链表。支持双向顺序访问，在链表任何位置进行插入/删除操作速度都很快</p>
<p>forward_list:单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快</p>
<p>array:固定大小数组，支持快速随机访问。不能添加或删除元素</p>
<p>string:与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快</p>
<p>除固定大小的array外，其他容器都提供高效、灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器大小。string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入和删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。而且添加一个元素有时可能还需要分配额外的存储空间。在这种情况下，每个元素必须都移动到新的存储空间中。</p>
<p>list和forward_list两个容器添加和删除操作都很快，但是不支持元素的随机访问，为了访问一个元素，只能遍历整个容器，与vector、deque、array相比，这两个容器的额外内存开销很大。</p>
<ol start="3">
<li>指针大小由当前CPU运行模式的寻址位数决定</li>
</ol>
<p>32位处理器上32位操作系统的32位编译器，指针大小4字节。<br>32位处理器上32位操作系统的16位编译器，指针大小2字节。<br>32位处理器上16位操作系统的16位编译器，指针大小2字节。<br>16位处理器上16位操作系统的16位编译器，指针大小2字节。</p>
<p>这从结果看起来指针的大小和编译器有关？？</p>
<p>　　实际不是这样的，有这样的结果是因为以上几种情况，处理器当前运行模式的寻址位数是不一样的，如下：</p>
<p>　Intel 32位处理器32位运行模式，逻辑寻址位数32，指针也就是32位，即4个字节<br>　Intel 32位处理器16位虚拟机运行模式，逻辑寻址位数16，指针也就是16位，即2个字节</p>
<p>编译器的作用是根据目标硬件（即CPU）的特性将源程序编译为可在该硬件上运行的目标文件。如果一个编译器支持某32位的CPU，那么它就可以将源程序编译为可以在该CPU上运行的目标文件。该源程序中指针大小也会被编译器根据该CPU的寻址位数（如32位）编译选择为4字节。</p>
<ul>
<li>sizeof和strlen的区别 </li>
</ul>
<p>❀第一个例子：<br>char* ss = “0123456789”;<br>1、sizeof(ss)的结果是4,ss是指向字符串常量的字符指针<br>2、sizeof(*ss)的结果是1，*ss是第一个字符 </p>
<p>❀第二个例子：<br>char ss[] = “01233456789”;<br>1、sizeof(ss)结果是11，ss是数组，计算到’\0’的位置，因此是10+1<br>2、sizeof(*ss)结果是1，*ss是第一个字符 </p>
<p>❀第三个例子<br>char ss[100] = “0123456789”;<br>1、sizeof(ss)的结果是100，ss表示在内存中预分配的大小：100*1<br>2、strlen(ss)的结果是10，它的内部实现是用一个循环计算字符串的长度，直到’\0’为止。 </p>
<p>❀第四个例子<br>int ss[100] = {0,1,2,3,4,5,6,7,8,9};<br>1、sizeof(ss)的结果是400，ss表示在内存中的大小，为100<em>4<br>2、strlen(ss)错误，strlen的参数只能是char</em>，且必须是以’\0’结尾的。</p>
<ol start="4">
<li>OSI模型：应用层（HTTP FTP（基于TCP）  DNS(基于UDP（客户端和服务器）和TCP（服务器和服务器））） 表示层（加密   SSL握手协议） 会话层（建立和维持会话，并能使会话获得同步   SSL记录协议）  传输层（TCP/UDP端到端 段Segment 数据报文）  网络层 (IP ICMP ARP RARP数据包Packet)  数据链路层(逻辑链路控制子层（LLC）媒体访问控制子层（MAC）数据帧Frame)   物理层(物理介质Bit)</li>
</ol>
<p><strong>消息（message）：</strong>是指起始点和目的地都在网络层以上（经常在<strong>应用层</strong>）的信息单元。</p>
<p>SSL握手协议：它建立在SSL记录协议之上，用于在实际的数据传输开始之前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<p>SSL记录协议：它建立在可靠的传输（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能。</p>
<p>TCP/UDP五层模型：应用层  传输层  网络层  数据链路层  物理层</p>
<ol start="5">
<li>编程内存的基本构成（堆、存储区别）</li>
</ol>
<p><strong>1、内存</strong></p>
<p>（1）静态内存（静态分配）：发生在程序编译和链接阶段，存在于程序的整个生命周期，内存大小固定，不占用CPU资源</p>
<ul>
<li>全局/静态存储区</li>
</ul>
<p>（i）.bss段：存放未初始化的全局变量和静态变量</p>
<p>（ii）.data段（全局初始化区）：存放初始化的全局变量和static变量</p>
<ul>
<li><p>常量存储区 :常量字符串就是放在这里的。 程序结束后由系统释放。虚函数表在常量存储区。</p>
</li>
<li><p>代码区（.txt段）：存放函数体的二进制代码，虚函数存放在代码区。</p>
</li>
</ul>
<p>注意：</p>
<p>​    函数指针指向Code区，是程序运行的指令代码，数据指针指向Data,Heap,Stack    区，是程序依赖以运行的各种数据。</p>
<p>​    在文件作用域声明inline函数默认为static存储类型,const常量默认为static存储，    如果加上extern，则为外部存储类型</p>
<p>（2）动态内存（动态分配）：发生在程序调入和执行阶段，根据程序的需要分配和释放，其大小可变，占用CPU资源</p>
<ul>
<li><p>堆：<strong>链表结构，有序数组链表，程序通过调用malloc和new分配，调用free和delete释放；堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，链表的遍历方向是由低地址向高地址</strong>。堆的大小受限于计算机系统中有效的虚拟内存4G。由此可见，堆获得的空间比较灵活，也比较大。<strong>堆中的存储内容一般是在堆的头部用一个字节存放堆的大小</strong>。</p>
</li>
<li><p>栈：<strong>线性结构，有序数组，由编译器自动分配与释放，速度较快，是一块连续的内存的区域</strong>，存储函数（包括main函数）的方法调用、函数参数、内部局部变量、返回地址和CPU系统提供的两个特殊的寄存器用于标识位于系统栈顶端的栈帧（(1)ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈的上面一个栈帧的栈顶。(2) EBP：基址指针寄存器(extended base pointer)-其内存放着一个指针，该指针永远指向系统栈上面一个栈帧的底部），存储地址由高地址向低地址，栈顶的地址和栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，提示Stack Overflow，出现溢出现象。栈中的存储内容<strong>在函数调用时，第一个进栈的是主函数后的下一条指令（函数调用语句的下一条可执行语句）的地址</strong>，然后是函数的各个参数，在大多数的C编译器中，<strong>参数是由右往左入栈的，然后是函数中的局部变量</strong>。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。函数退出时，其占用内存被收回；进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。</p>
</li>
<li><p>堆栈的区别：</p>
<p>  1、管理方式不同（堆手动分配释放new/delete；栈编译器自动分配和释放）：栈内存由一个栈指针来开辟和回收，栈内存是从高地址向低地址增长的，增长时，栈指针向低地址方向移动，指针的地址值也就相应的减小；回收时，栈指针向高地址方向移动，地址值也就增加。所以栈内存的开辟和回收都只是指针的加减，由此相对于分配堆内存可以获得一定的性能提升）。<br>  2、空间大小不同（堆32位系统可达4G;栈Linux 10M,Windows 1M）<br>  3、能否产生碎片不同（栈实现方式采用数据结构中的栈实现，具有(LIFO)的顺序特点，没有物理碎片；堆为一块一块的内存，可以产生物理碎片）<br>  4、生长方向不同（堆从低地址到高地址；栈从高地址到低地址）<br>  5、分配方式不同（堆动态分配， 堆是运行时确定内存大小；栈动静分配都可以，栈的动态使用alloca,栈在编译时即可确定内存大小）<br>  6、分配效率不同（堆效率低；栈由于其实现方式，在分配速度上比堆快的多。分配一块栈内存不过是简单的移动一个指针）<br>  7、申请后系统的响应不同<br>  栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 </p>
<p>  堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。 另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中<br>  8、栈为线程私有而堆为线程共享</p>
</li>
<li><p>栈数据的写入跟读出不需要提供地址，而是根据写入的顺序决定读出的顺序。通用寄存器、主存储器、输入输出设备存储数据时均需要编址。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp </span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;  <span class="comment">//a存储在全局初始化区 ，静态内存，0存储在常量区随程序结束而释放</span></span><br><span class="line"><span class="keyword">char</span> *p1;  <span class="comment">//全局未初始化区 ，静态内存</span></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">4</span>);  <span class="comment">//p存储在全局初始化区，静态内存，分配得来的4存储在堆区</span></span><br><span class="line">main() </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> b;  <span class="comment">//栈 ，编译时</span></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">"abc"</span>;  <span class="comment">//栈 ，运行时赋值</span></span><br><span class="line"><span class="keyword">char</span> *p2; <span class="comment">// 栈 </span></span><br><span class="line"><span class="keyword">char</span> *p3 = <span class="string">"123456"</span>;  <span class="comment">//"123456\0"在常量区（不同于数组数据可存储在数组里），编译时就确定下来，静态内存，p3在栈上。 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>； <span class="comment">//全局（静态）初始化区 </span></span><br><span class="line">p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); </span><br><span class="line">p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>); </span><br><span class="line"><span class="comment">//分配得来的10和20字节的区域就在堆区。 </span></span><br><span class="line"><span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>);  <span class="comment">//"123456\0"放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 </span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">char</span>* p = <span class="string">"Hello World1"</span>;</span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">"Hello World2"</span>;</span><br><span class="line">p[<span class="number">2</span>] = <span class="string">'A'</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">char</span>* p1 = <span class="string">"Hello World1"</span>; </span><br><span class="line"><span class="comment">//这个程序是有错误的，错误发生在p[2] = 'A'这行代码处，为什么呢，是变量p和变量数组a都存在于栈区的（任何临时变量都是处于栈区的，包括在main（）函数中定义的变量）。但是，数据“Hello World1”和数据“Hello World2”是存储于不同的区域的。因为数据“Hello World2”存在于数组中，所以，此数据存储于栈区，对它修改是没有任何问题的。因为指针变量p仅仅能够存储某个存储空间的地址，数据“Hello World1”为字符串常量，所以存储在静态存储区。虽然通过p[2]可以访问到静态存储区中的第三个数据单元，即字符‘l’所在的存储的单元。但是因为数据“Hello World1”为字符串常量，不可以改变，所以在程序运行时，会报告内存错误。并且，如果此时对p和p1输出的时候会发现p和p1里面保存的地址是完全相同的。换句话说，在数据区只保留一份相同的数据。</span></span><br></pre></td></tr></table></figure>

<p><strong>2、内存申请函数</strong></p>
<ul>
<li>malloc calloc realloc alloca的区别</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">realloc</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">unsigned</span> newsize)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> numElements, <span class="keyword">size_t</span> sizeOfElement)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> * __cdecl  <span class="title">alloca</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="built_in">free</span>将<span class="built_in">malloc</span>申请的内存最终需要通过该函数进行释放. </span><br><span class="line">sbrk则是增加数据段的大小;</span><br></pre></td></tr></table></figure>

<p>都在stdlib.h函数库内，它们的返回值都是请求系统分配的地址,如果请求失败就返回NULL.<br>  (1)函数malloc()<br>    在内存的动态存储区中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度，返回该区域的首地址。由于没有初始化内存的内容，所以调用malloc后一般调用函数memset来初始化这部分内存空间。<br>  (2)函数calloc()<br>    与malloc相似,参数sizeOfElement为申请地址的单位元素长度,numElements为元素个数，即在内存中申请numElements*sizeOfElement字节大小的连续地址空间，返回该区域的首地址。初始化所分配的内存空间，设置为0。</p>
<p><strong>malloc() 函数和calloc ()函数的主要区别是前者不能初始化所分配的内存空间，而后者能</strong>。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是 0；反之，如果这部分内存空间曾经被分配、释放和重新分配，则其中可能遗留各种各样的数据。也就是说，<strong>使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常运行，但经过一段时间后(内存空间已被重新分配)可能会出现问题</strong>。  calloc() 函数会将所分配的内存空间中的每一位都初始化为零，也就是说，如果你是为字符类型或整数类型的元素分配内存，那么这些元素将保证会被初始化为零；如果你是<strong>为指针类型的元素分配内存，那么这些元素通常(但无法保证)会被初始化为空指针</strong>；如果你是为实数类型的元素分配内存，那么这些元素可能(只在某些计算机中)会被初始化为浮点型的零。</p>
<p>  (3)函数realloc()<br>给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度.如果在该存储区后有足够的空间可供扩充，则可在原存储区位置上向高地址方向扩充，并返回传送给它的同样的指针值。如果在原存储区后没有足够的空间，则realloc分配另一个足够大的存储区，将现存的512个元素数组的内容复制到新分配的存储区。因为这种存储区可能会移动位置，所以不应当使用任何指针指在该区中。注意，realloc的最后一个参数是存储区的newsize(新长度)，不是新、旧长度之差。作为一个特例，若ptr是一个空指针，则realloc的功能与malloc相同，用于分配一个指定长度newsize的存储区。</p>
<p>（4）alloca()是在栈(stack)上申请空间的，而栈内存一般可以由编译器自动释放。既然是在栈内申请内存，这就决定了其固有的局限性。其一是不适用于那些比创建它们的函数生命周期更长的结构；其二是不具可移植性，而且在没有传统堆栈的机器上很难高效地实现。这是因为当它的返回值直接传入另一个函数时会带来问题。这就决定了alloca()不宜使用在需要广泛移植的程序中，这也是很多人不太提倡使用alloca()的一个原因。</p>
<ul>
<li><p><a href="https://blog.csdn.net/mmshixing/article/details/51679571" target="_blank" rel="noopener">Linux malloc底层实现原理</a></p>
</li>
<li><p>malloc和free的操作原则</p>
</li>
</ul>
<blockquote>
<p>1) 配对使用，避免内存泄漏和多重释放（C语言提供了malloc和free两个系统函数，完成对堆内存的申请和释放。而C++则提供了两个关键字new和delete）。</p>
<p>2) 尽量在同一层上使用，不要像上面那种，malloc在函数中，而free在函数外。最好在同一调用层上使用这两个函数。</p>
<p>3) malloc分配的内存一定要初始化。free后的指针一定要设置为NULL。 </p>
<p>注意：new/delete是关键字，效率高于malloc和free。<br>new/delete 主要是用在类对象的申请和释放。申请的时候会调用构造器完成初始化，释放的时候，会调用析构器完成内存清理。</p>
</blockquote>
<p><strong>3、new和malloc的区别</strong></p>
<ul>
<li><p>属性</p>
<p>new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持。</p>
</li>
<li><p>参数</p>
<p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p>
</li>
<li><p>返回类型</p>
<p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p>
</li>
<li><p>自定义类型</p>
</li>
</ul>
<p>new做两件事：分配内存和调用类的构造函数，new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为什么有了malloc还要设计new</span></span><br><span class="line"><span class="keyword">delete</span>：调用类的析构函数和释放内存。<span class="keyword">delete</span>先调用析构函数，然后调用<span class="keyword">operator</span> <span class="keyword">delete</span>函数释放内存（通常底层使用<span class="built_in">free</span>实现）。</span><br><span class="line"></span><br><span class="line">而<span class="built_in">malloc</span>和<span class="built_in">free</span>只是分配和释放内存。<span class="built_in">malloc</span>/<span class="built_in">free</span>是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>重载</p>
<p>  C++允许重载new/delete操作符，malloc不允许重载。</p>
</li>
<li><p><strong>内存区域</strong></p>
</li>
</ul>
<p>　　new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</p>
<ul>
<li><p>分配失败</p>
<p>new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p>
</li>
<li><p>内存泄漏</p>
<p>内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc确不可以。</p>
</li>
</ul>
<p><strong>4、delete和free的区别</strong></p>
<ol>
<li><p><strong>new/delete是关键字，而free/malloc是库函数，需要头文件支持;</strong>free对应的是malloc；delete对应的是new；free用来释放malloc出来动态内存，delete用来释放new出来的动态内存空间。</p>
</li>
<li><p><strong>无论释放几个空间大小，free只传递指针，多个对象时delete需加[]</strong>。数组的时候int* <em>p=(int</em>)malloc(10*sizeof(int)) 释放的时候 free(p)即可；这是因为编译器对malloc做了一些特殊的处理，以保证可以正确释放内存。而当int *p=new int[10]释放的时候应为delete []p，注意[]的作用说明释放的是一个数组的内存，如果delete p则只是释放的p[0]，其余9个int的内存没有释放；这是因为当指明为[]的时候，编译器实际上是做了一个循环来释放这个数组的所有内存。</p>
</li>
<li><p>在类和对象的时候会有很大区别。在使用malloc和free来处理动态内存的时候，仅仅是释放了这个对象所占的内存，而不会调用这个对象的析构函数；使用new和delete就可以既释放对象的内存的同时，调用这个对象的析构函数。<strong>delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）</strong>。</p>
</li>
</ol>
<p><strong>共同之处：</strong></p>
<p>它们都是只把指针所指向的内存释放掉了，并没有把指针本身干掉。在free和delete之后，都需要把指向清理内存的指针置为空，即p=NULL，否则指针指向的内存空间虽然释放了，但是指针p的值还是记录的那块地址，该地址对应的内存是垃圾，p就成了“野指针”。同样会使人认为p是个合法的指针，如果程序较长，我们通常在使用一个指针前会检查p！=NULL，这样就起不到作用了。此时如果再释放p指向的空间，编译器就会报错，因为释放一个已经被释放过的空间是不合法的。而将其置为NULL之后再重复释放就不会产生问题，因为delete一个0指针是安全的。</p>
<p><strong>指针和动态申请的内存空间总结如下：</strong></p>
<p><strong>1.</strong>   <strong>指针消亡了，并不表示它指示的动态内存会自动释放；</strong></p>
<p><strong>2.</strong>   <strong>动态内存释放掉了，如果这个内存是一个动态对象，则并不表示一定会调用这个对象的析构函数；</strong></p>
<p><strong>3.   动态内存释放掉了，并且调用了析构函数，并不表示指针会消亡或者自动变成了NULL。</strong></p>
<p><strong>c内存存储</strong></p>
<p><strong>在C++中，内存区分为6个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区、代码区</strong>；</p>
<p><strong>在C中，C内存区分为5个区堆、栈、全局/静态存储区、常量存储区、代码区</strong></p>
<p>堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。</p>
<p>为什么栈生长方向是从高地址到低地址？<strong>最大程度地共用剩余的地址空间，达到利用率的最大化</strong>。如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。</p>
<ol start="6">
<li><p>快速排序  堆排序</p>
</li>
<li><p>给你100个数找出最大的前五十个</p>
</li>
</ol>
<ul>
<li>partition 时间复杂度O(n)</li>
<li>最小堆 时间复杂度O(nlgk)  (海量数据)</li>
<li>mutiset 时间复杂度O(n)空间复杂度O(n)</li>
</ul>
<ol start="8">
<li>笔试题：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">提示：优先写源码，源码有难度可以写伪代码 或 思路。</span><br><span class="line">要求：c或c++, 尽量使得时间复杂度较低，写出完整代码。</span><br><span class="line">题目：查找元素element在非降序正整数数组a中的最左下标位置,数组大小为<span class="built_in">size</span>.</span><br><span class="line">例子：元素<span class="number">2</span>在数组a[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">21</span>]的最左位置为<span class="number">2.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchRange</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"><span class="keyword">int</span> middle=(right-left)/<span class="number">2</span>+left;</span><br><span class="line"><span class="keyword">if</span>(a[middle]==target)&#123;</span><br><span class="line">middle-=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(a[middle]==target)midlle--;</span><br><span class="line"><span class="keyword">return</span> middle+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[middle]&lt;target)</span><br><span class="line">left=middle+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right=middle<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_pos</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> element)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">size</span>==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">int</span> leftIndex=searchBoundEqual(a,<span class="number">0</span>,<span class="built_in">size</span><span class="number">-1</span>,element);</span><br><span class="line">      <span class="keyword">if</span>(leftIndex==<span class="built_in">size</span>||a[leftIndex]!=target)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">return</span> leftIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">find</span>(a,a+<span class="built_in">size</span>,target);</span><br></pre></td></tr></table></figure>

<h2 id="（六）手写代码"><a href="#（六）手写代码" class="headerlink" title="（六）手写代码"></a>（六）手写代码</h2><p>一个数组中有多个整数， 其中有两个重复的数字，如何找出来，考虑一下时间复杂度和空间复杂度<br> 给两个字符串A和B，找出A对于B的最长前缀。<br> 单链表逆序<br> 一个链表的连续区间和最大值，及其对应区<br> 数组中，连续和最大的区间<br> 判断一个链表是否有环，并确定环的位置，如何确定两个链表是否有相同的部分<br> 写个小程序，一个数组，长100，里边乱序分布数字1-100，在数组中随机挑选一个位置的数字，将其替换为-1，如何判断，被替换掉的数字是多少？<br> 跳台阶，一次跳1个，也可以跳2个，问，n个台阶有多少种跳法</p>
<p>dfs bfs dp迷宫</p>
<p>最小圆覆盖</p>
<p>1）任意选取距离最远两点p1、p2，以p1p2做直径画圆；</p>
<p>2）如果所有点都在圆内，则该圆即为包括所有点的最小圆；否则选取圆外一点距离圆心最远点pi,寻找覆盖pi和集合Di-1的最小圆<code>Di=MiniDiskWithPoints({p1，p2，p3......pi-1}，pi)</code>，循环第（2）步直到Di包括所有点，即得到最小包围圆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function MiniDiskWithPoints（P，q）</span><br><span class="line">Input：由平面上n个点构成的一个集合P，以及另外一个点q</span><br><span class="line">Output：在满足“边界穿过q”的前提下，P的最小包围圆</span><br><span class="line">    <span class="number">1.</span>令D1为对应于&#123;p1，q&#125;的最小包围圆</span><br><span class="line">    <span class="number">2.f</span><span class="keyword">or</span>   j ← <span class="number">2</span> to n</span><br><span class="line">    <span class="number">3.</span>   <span class="keyword">do</span> <span class="keyword">if</span>    pj ∈Dj<span class="number">-1</span></span><br><span class="line">    <span class="number">4.</span>      then    Dj ← Dj<span class="number">-1</span></span><br><span class="line">    <span class="number">5.</span>      <span class="keyword">else</span>    Dj ← MiniDiskWithPoints&#123;&#123;p1，p2,p3......pj<span class="number">-1</span>&#125;，pj，pi&#125;</span><br><span class="line">    <span class="number">6.</span><span class="keyword">return</span>    Dn</span><br><span class="line">Function MiniDiskWithPoints（P，q1，q2）</span><br><span class="line">Input：由平面上n个点构成的一个集合P，以及另外两个点q1，q2</span><br><span class="line">Output：在满足“边界穿过q1，q2”的前提下，P的最小包围圆</span><br><span class="line"><span class="number">1.</span>       令D0为对应于q1，q2的最小包围圆</span><br><span class="line"><span class="number">2.</span>       <span class="keyword">for</span>   k ← <span class="number">1</span> to n</span><br><span class="line"><span class="number">3.</span>            <span class="keyword">do</span> <span class="keyword">if</span>    pk∈Dk<span class="number">-1</span></span><br><span class="line"><span class="number">4.</span>                    then    Dk ← Dk<span class="number">-1</span></span><br><span class="line"><span class="number">5.</span>                    <span class="keyword">else</span>    Dk ← q1，q2和pk确定的圆</span><br><span class="line"><span class="number">6.</span>        <span class="keyword">return</span>    Dn</span><br></pre></td></tr></table></figure>

<p>给定一个无序数组，求这个数组变为有序后相邻元素之差的最大值是多少，要求时间复杂度是O(n)</p>
<ul>
<li><p>方法一：排序，计算。时间复杂度O(nlgn)，空间复杂度O(1)</p>
</li>
<li><p>方法二：std::multiset，计算。时间复杂度O(n),空间复杂度O(n)</p>
</li>
<li><p>方法三：<a href="https://blog.csdn.net/weixin_38426554/article/details/95785743" target="_blank" rel="noopener">桶排序</a>。时间复杂度O(n),空间复杂度O(n)</p>
</li>
</ul>
<p>算法题给定一个长字符串zesfjjk和一个短字符串xsfjx，求短字符串在长字符串中出现的最长部分是什么？sfj</p>
<p><a href="https://blog.csdn.net/hackbuteer1/article/details/6686931" target="_blank" rel="noopener">最长公共子字符串</a></p>
<h2 id="（七）SAP"><a href="#（七）SAP" class="headerlink" title="（七）SAP"></a>（七）SAP</h2><ol>
<li>linux命令</li>
</ol>
<p>查找  vi  保存  修改权限</p>
<ol start="2">
<li>C和c++的区别</li>
</ol>
<ul>
<li>c++兼容c。区块（blocks）、语句（statements）、预处理器（preprocessors）、内置数据类型（build-in data types）、数组（arrays）、指针（pointers）等统统来源于c。</li>
<li>c仅支持面向过程，c++还支持面向对象：包含封装、继承、多态三大特性和虚函数、虚函数表指针、虚基类表指针等。</li>
<li>c++包含泛型编程、模板元编程。</li>
<li>c++包含STL。</li>
</ul>
<h2 id="（八）进程间的通信方式（IPC-inter-Process-Communication）"><a href="#（八）进程间的通信方式（IPC-inter-Process-Communication）" class="headerlink" title="（八）进程间的通信方式（IPC,inter-Process Communication）"></a>（八）进程间的通信方式（IPC,inter-Process Communication）</h2><p>同一主机中两个进程间的通信由操作系统决定，不同主机间的通信进程通过网络交换报文进行。</p>
<ol>
<li><p>信号：用于通知进程某个事件已经发生</p>
</li>
<li><p>管道：读写操作符合先进先出原则，对于两端的进程而言就是文件，向管道中写入数据时,linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。</p>
</li>
</ol>
<ul>
<li><p>无名管道pipe:半双工的通信方式，数据单向流动，只能在具有亲缘关系的进程间使用，从结构上看，无名管道没有文件路径名，不占用文件目录项，因此文件目录结构中的链表不适用于这种文件，它只是存在于打开文件结构中的一个临时文件，依附于进程临时存在。</p>
</li>
<li><p>命名管道FIFO:半双工，数据单向流动，允许无亲缘关系进程间的通信，FIFO是一种永久性的机制，它具有普通的UNIX系统文件名。在系统下可利用mkfifo命令建立永久的管道，除非刻意删除它，否则它将一直保持在系统中。</p>
</li>
<li><p><strong>联系</strong>：</p>
</li>
</ul>
<p>1) 通信数据只存在于内存缓冲页面中；</p>
<p>2) 都是半双工通信；</p>
<ul>
<li><strong>区别</strong>：</li>
</ul>
<p>(1)无名管道是无名的，有名管道是有名的；</p>
<p>(2)无名管道只能用于父子进程或兄弟进程之间的通信，而有名管道可用于任意两进程之间通信；</p>
<p>(3)无名管道是无形的，即无名管道的 inode 结构不是在磁盘上存储的，而是临时生成的，而有名管道的 inode 结点在磁盘上。</p>
<ol start="3">
<li>消息队列：消息的链表存放在内核中并由消息队列标识符标识，克服了信号传递信息少，管道只能承载无格式字节流以及缓冲器大小受限等缺点，但只有在内核重启时才能删除一个消息队列，内核重启也就是系统重启。</li>
<li>共享内存：最快的IPC方式，映射一段能被其他进程所访问的内存。往往与其他通信机制如信号两两配合使用，来实现进程间的同步和通信。</li>
<li>信号量Semaphore:信号量是一个计数器，可以用来控制多个进程对共享资源的访问。常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>套接字Socket:套接字也是一种进程间通信机制，包括IPC 套接字（即 Unix 套接字）给予进程在相同设备（主机）上基于通道的通信能力；而网络套接字给予进程运行在不同主机的能力，因此也带来了网络通信的能力。IPC 套接字依赖于本地系统内核的支持来进行通信。网络套接字需要底层协议的支持，例如 TCP（传输控制协议）或 UDP（用户数据报协议），包括流套接字（TCP/IP）和数据报套接字（UDP/IP），利用三元组（<strong>ip地址，协议，端口</strong>）构成套接字；传输层实现端到端的通信，传输层连接的端点叫做套接字。</li>
</ol>
<h3 id="进程创建fork和vfork"><a href="#进程创建fork和vfork" class="headerlink" title="进程创建fork和vfork"></a>进程创建fork和vfork</h3><ul>
<li><p>进程描述符task_struct</p>
</li>
<li><p>fork后操作系统会复制一个与父进程完全相同的子进程，两个进程共享代码空间，但数据空间相互独立，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别作不同的工作，也就是分岔了。</p>
</li>
<li><p>fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为调用了exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为调用了exec，exec负责读取可执行文件并将其载入地址空间开始运行，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</p>
<pre><code>fork之后内核会通过将子进程放在队列的前面，以让子进程先执行，因为一般紫禁城都会马上调用exec()函数，这样可以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能会开始向地址空间写入。</code></pre><p>fork时子进程获得父进程数据空间、堆和栈的复制，所以变量的地址（当然是虚拟地址）也是一样的。每个进程都有自己的虚拟地址空间，不同进程的相同的虚拟地址显然可以对应不同的物理地址。因此地址相同（虚拟地址）而值不同没什么奇怪。<br>具体过程是这样的：<br>fork子进程完全复制父进程的栈空间，也复制了页表，但没有复制物理页面，所以这时虚拟地址相同，物理地址也相同，但是会把父子共享的页面标记为“只读”（类似mmap的private的方式），如果父子进程一直对这个页面是同一个页面，知道其中任何一个进程要对共享的页面“写操作”，这时内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为“可写”，留给另外一个进程使用。</p>
</li>
<li><h3 id="fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别："><a href="#fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别：" class="headerlink" title="fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别："></a>fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别：</h3><ol>
<li>fork ()：子进程拷贝父进程的数据段、代码段<br>vfork ()：子进程与父进程共享数据段、代码段，子进程不能向地址空间写入。</li>
<li>fork ()父子进程的执行次序不确定<br>vfork 保证子进程先运行，子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，知道子进程退出或执行exec()。</li>
<li>若vfork ()调用exec 或<code>_exit()</code> 之前子进程依赖于父进程的进一步动作，会导致死锁。</li>
</ol>
<p><strong>现在由于在执行fork()时引入了写时拷贝页并且明确了子进程先执行，vfork()的好处就仅限于不拷贝父进程的页表项了，另外最好不要使用vfork()（如果exec调用失败，试想会发生什么）</strong></p>
</li>
</ul>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>​         （1）进程是资源分配和调度的一个独立单元，而线程是CPU调度和分派的基本单元<br>​          （2）一个进程至少包括一个线程，并且同一个进程的所有线程共享整个进程的资源，因此线程执行时一般都要进行同步和互斥<br>​          （3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束<br>​          （4）线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的<br>​          （5）进程间通信IPC需要特别的方法，线程间可以直接读写进程数据段（如全局变量）来进行通信。</p>
<h3 id="线程有什么是共享的什么是私有的"><a href="#线程有什么是共享的什么是私有的" class="headerlink" title="线程有什么是共享的什么是私有的"></a>线程有什么是共享的什么是私有的</h3><p>线程共享的环境包括：</p>
<p>  1.进程数据段、代码段 </p>
<p>  2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯) </p>
<p>  3.进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p>
<p>线程独立的资源包括：</p>
<p>1.线程ID</p>
<p>2.寄存器组的值</p>
<p>由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。</p>
<p>3.线程的堆栈</p>
<p>堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。</p>
<p>4.线程的错误返回码</p>
<p>由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。</p>
<p>5.线程的信号屏蔽码</p>
<p>6.线程的优先级</p>
<p>注：线程有自己的私有属性线程控制块TCB，进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志。</p>
<h3 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h3><ul>
<li><p>就绪状态：当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态就称为就绪状态；</p>
</li>
<li><p>执行状态：当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态；</p>
</li>
<li><p>阻塞状态：正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而进入阻塞状态。引起进程阻塞的事件有很多种，例如，等待I/O完成、申请缓冲区不能满足、等待信号等。</p>
</li>
<li><p>进程三种状态间的转换  </p>
</li>
</ul>
<blockquote>
<p>执行–&gt;就绪：时间片完；优先级更高的进程占用CPU</p>
<p>就绪–&gt;执行：被调度；</p>
<p>执行–&gt;阻塞：等待事件，io请求；</p>
<p>阻塞-&gt;就绪：io完成</p>
</blockquote>
<p>一个进程在运行期间，不断地从一种状态转换到另一种状态，它可以多次处于就绪状态和执行状态，也可以多次处于阻塞状态。<br>A. 就绪—&gt;执行<br>处于就绪状态的进程，当进程调度程序为之分配好了处理机后，该进程便由就绪状态转换为执行状态；<br>B. 执行—&gt;就绪<br>处于执行状态的进程在其执行过程中，因分配给它的一个时间片已经用完而不得不让出处理机，于是进程从执行状态转换为就绪状态；<br>C. 执行—&gt;阻塞<br>正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态；<br>D. 阻塞—&gt;就绪<br>处于阻塞状态的进程，若其等待的事件已经发生，于是进程便从阻塞状态转变为就绪状态。</p>
<ul>
<li>线程同步</li>
</ul>
<p>临界区就是访问和操作共享数据的代码段，多个执行线程并发访问同一个资源通常是不安全的。</p>
<p>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区，读/写锁，条件变量。</p>
<p>内核同步的方法：原子操作、自旋锁、完成变量，信号量，互斥体。<br>1、互斥体:为协调共同对一个共享资源的单独访问而设计的。<br>2、信号量:为控制一个具有有限数量用户资源而设计。<br>3、完成变量:用来通知线程有一些事件已发生，从而启动后继任务的开始。</p>
<p>4、自旋锁：一个被征用的自旋锁使得请求它的线程在等待锁重新可用时自旋（特别浪费处理器时间）</p>
<ul>
<li>线程间通信：由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）。</li>
<li>进程间的通信则不同，它的数据空间的独立性���定了它的通信相对比较复杂，需要通过操作系统。以前进程间的通信只能是单机版的，现在操作系统都继承了基于套接字（socket）的进程间的通信机制。这样进程间的通信就不局限于单台计算机了，也可以实现不同操作系统间的网络通信，eg.windows和Linux操作系统通过Socket进行进程间通信。</li>
<li>windows进程通信</li>
</ul>
<p><em>标准的Windows</em>进程间通信方法有三种：匿名管道、命名管道（又叫<em>FIFO</em>，命名管道可以控制读消息的长度，一个命名管道可以有多个实例，具体通信还是一对一）、邮槽（<em>MailSlot</em>）。共享内存也可用于windows进程通信，但因为其实是<em>Windows</em>“内存映射文件”的一个特殊用法，所以不算作标准的windows进程间通信方法。</p>
<table>
<thead>
<tr>
<th align="center">对比点</th>
<th align="center">匿名管道</th>
<th align="center">命名管道</th>
<th align="center">邮槽</th>
<th></th>
<th align="center">共享内存</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">消息格式</td>
<td align="center">字符</td>
<td align="center">二进制</td>
<td align="center">数据包</td>
<td></td>
<td align="center">-</td>
<td></td>
</tr>
<tr>
<td align="center">工作模式</td>
<td align="center">半双工</td>
<td align="center">全双工</td>
<td align="center">单向</td>
<td></td>
<td align="center">双向</td>
<td></td>
</tr>
<tr>
<td align="center">访问模式</td>
<td align="center">只能在一台机器上</td>
<td align="center">可以跨网络</td>
<td align="center">可以跨网络</td>
<td></td>
<td align="center">只能在一台机器上</td>
<td></td>
</tr>
<tr>
<td align="center">通信模式</td>
<td align="center">一对一，父子进程用</td>
<td align="center">一对多，不同进程均可用</td>
<td align="center">广播机制</td>
<td></td>
<td align="center">-</td>
<td></td>
</tr>
</tbody></table>
<h3 id="windows命名管道和Linux命名管道的区别"><a href="#windows命名管道和Linux命名管道的区别" class="headerlink" title="windows命名管道和Linux命名管道的区别"></a>windows命名管道和Linux命名管道的区别</h3><table>
<thead>
<tr>
<th align="center">对比点</th>
<th align="center">Linux命名管道</th>
<th align="center">Windows命名管道</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">消息格式</td>
<td align="center">字节流</td>
<td align="center">二进制</td>
<td align="center">windows更牛</td>
</tr>
<tr>
<td align="center">工作模式</td>
<td align="center">半双工</td>
<td align="center">全双工</td>
<td align="center">windows更牛</td>
</tr>
<tr>
<td align="center">访问模式</td>
<td align="center">只能在一台机器上</td>
<td align="center">可以跨网络</td>
<td align="center">windows更牛</td>
</tr>
</tbody></table>
<ul>
<li>windows线程通信</li>
</ul>
<p>windows下，一个典型的线程拥有自己的堆栈、寄存器（包括程序计数器PC，用于指向下一条应该执行的指令在内存中的位置），而代码段、数据段、打开文件这些进程级资源是同一进程内多个线程所共享的。因此同一进程的不同线程可以很方便的通过全局变量（数据段）进行通信，使用多线程相对于多进程来说有很多优点：</p>
<ul>
<li>① 无需跨进程边界；</li>
<li>② 程序逻辑和控制方式简单；</li>
<li>③ 所有线程可以直接共享内存和变量等；</li>
<li>④ 线程方式消耗的总资源比进程方式好；</li>
</ul>
<h3 id="windows多线程通信的方法主要有三种："><a href="#windows多线程通信的方法主要有三种：" class="headerlink" title="windows多线程通信的方法主要有三种："></a>windows多线程通信的方法主要有三种：</h3><p><strong>1.全局变量</strong></p>
<p>由于同一进程下的线程之间共享数据空间。当需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，来告诉编译器这个全局变量是“易变”（更直接的讲是“直接存取原始内存地址”，更明确的说是不要编辑器去读缓存中的数据，而是直接从内存中获取变量的值）的，让编译器不要对这个变量进行优化。</p>
<p><strong>2.Message消息机制</strong><br>常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，<br>PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。</p>
<p><strong>3.CEvent对象</strong></p>
<p>CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。</p>
<ul>
<li>Linux线程通信</li>
</ul>
<p>线程间无需特别的手段进行通信，因为线程间可以共享数据结构，也就是一个全局变量可以被两个线程同时使用。不过要注意的是线程间需要做好同步，一般用mutex。</p>
<h3 id="死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？"><a href="#死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？" class="headerlink" title="死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？"></a>死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？</h3><p>​            (1）相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态<br>​          （2）系统资源不足、相互竞争资源、请求资源顺序不当<br>​          （3）互斥、不可剥夺、循环等待、请求与保持<br>​          （4）因为互斥是不可改变的，所以只能破坏其他三个条件中的一个来解除死锁，方法：</p>
<ul>
<li><p>破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中。</p>
</li>
<li><p>破坏”请求与保持条件“：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。</p>
</li>
<li><p>破坏“循环等待”条件：资源有序分配（将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程）</p>
</li>
</ul>
<h2 id="（九）SQL"><a href="#（九）SQL" class="headerlink" title="（九）SQL"></a>（九）SQL</h2><ol>
<li>一致性哈希？渐进性哈希？</li>
</ol>
<p>一致性哈希是一种特殊的哈希算法，目的是解决分布式缓存的问题。在移除或者添加一个服务器时，能���尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式<a href="https://baike.baidu.com/item/哈希表/5981869" target="_blank" rel="noopener">哈希表</a>( Distributed Hash Table，DHT) 中存在的动态伸缩等问题。</p>
<p>  首先，对存储节点的哈希值进行计算，其将存储空间抽象为一个环，将存储节点配置到环上。环上所有的节点都有一个值。其次，对数据进行哈希计算，按顺时针方向将其映射到离其最近的节点上去。当有节点出现故障离线时，按照算法的映射方法，受影响的仅仅为环上故障节点开始逆时针方向至下一个节点之间区间的数据对象，而这些对象本身就是映射到故障节点之上的。当有节点增加时，比如，在节点A和B之间重新添加一个节点H，受影响的也仅仅是节点H逆时针遍历直到B之间的数据对象，将这些重新映射到H上即可，因此，当有节点出现变动时，不会使得整个存储空间上的数据都进行重新映射，解决了简单哈希算法增删节点，重新映射所有数据带来的效率低下的问题。</p>
<p>渐进性哈希</p>
<p>  当hash表满员时（或负载因子高于阈值时）会进行rehash,也就是重新调整空间大小，并拷贝原来的数据。这里rehash就是优化效率的关键。例如假设有1w个元素，rehash时要拷贝1w元素到新的空间，这样势必会成为很大的负担。<br>  redis的数据库使用字典来作为底层实现的，对数据库的增删查改操作也是构建在对字典的操作之上。redis的字典使用hash表作为底层实现。</p>
<p>  redis作为一个广泛使用的内存数据库，时间和空间效率都是至关重要的。（redis的根本就是一个大的hashmap，所以对hashmap的优化十分重视）</p>
<p>  redis采用渐进式rehash优化效率。</p>
<p>  何为渐进式rehash？就是把拷贝节点数据的过程平摊到后续的操作中，而不是一次性拷贝。所谓平摊到后续的操作中，就是对节点操作，例如再次插入，查找，删除，修改时都会进行拷贝。</p>
<ol start="2">
<li>友元函数注意事项</li>
</ol>
<p>1）必须在类的说明中说明友元函数，说明时以关键字friend开头，后跟友元函数的函数原型，友元函数的说明可以出现在类的任何地方，包括在private和public部分；<br>2）注意友元函数不是类的成员函数，所以友元函数的实现和普通函数一样，在实现时不用”::”指示属于哪个类，只有成员函数才使�������”::”作用域符号；<br>3）友元函数不能直接访问类的成员，只能访问对象成员，<br>4）友元函数可以访问对象的私有成员，但普通函数不行；<br>5）调用友元函数时，在实际参数中需要指出要访问的对象，<br>6）友元的声明只能出现在类定义的内部（最好在类定义开始或者结束前的位置集中声明友元），仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，必须在友元声明之外再转名对函数进行一次声明。每个类负责控制自己的友元类或友元函数，友元关系不存在传递性。类与类之间的友元关系不能继承.</p>
<ol start="3">
<li>模板</li>
</ol>
<p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>
<p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>
<h2 id="（十一）百度"><a href="#（十一）百度" class="headerlink" title="（十一）百度"></a>（十一）百度</h2><h3 id="百度后台开发c-PHP实习"><a href="#百度后台开发c-PHP实习" class="headerlink" title="百度后台开发c++/PHP实习"></a>百度后台开发c++/PHP实习</h3><ol>
<li><a href="https://blog.csdn.net/vivian187/article/details/93043070" target="_blank" rel="noopener">c++中构造函数或析构函数定义为protected</a></li>
</ol>
<p>通常将拷贝构造函数和operator=(赋值操作符重载)声明成private，但是没有实现体。这个的目的是禁止一个类的外部用户对这个类的对象进行复制动作。</p>
<ol start="2">
<li>c++设计模式：<a href="https://blog.csdn.net/wuzhekai1985/category_9260796.html" target="_blank" rel="noopener">参考</a></li>
</ol>
<p>（1）工厂模式</p>
<ul>
<li>简单工厂模式：switch</li>
<li>工厂方法模式：一个工厂抽象接口和多个具体生成对象的工厂。比简单工厂模式多的一点优点就是遵循了开放-封闭原则，使得模式的灵活性更强</li>
<li>抽象工厂模式：客户端要使用时必须知道是哪一个工厂并且是哪一组的产品抽象类。每一个工厂子类负责产生一族产品，而子类的一种方法产生一种类型的产品。在客户端看来只有AbstractProductA和AbstractProductB两种产品，使用的时候也是直接使用这两种产品。而通过工厂来识别是属于哪一族产品。</li>
</ul>
<p>工厂模式和简单工厂模式要求产品子类必须要是同一类型的，拥有共同的方法，这就限制了产品子类的扩展。于是为了更加方便的扩展，抽象工厂模式就将同一类的产品子类归为一类，让他们继承同一个抽象子类，我们可以把他们一起视作一组，然后好几组产品构成一族。</p>
<p>（2）策略模式</p>
<ul>
<li>直接通过参数指定，传入一个特定算法的指针（暴露了算法）</li>
<li>直接通过参数指定，只不过不是传入指针，而是一个标签（switch和简单工厂结合）</li>
<li>模板实现</li>
</ul>
<p>（3）适配器模式：系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要适应于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。</p>
<p>（4）单例模式：由于构造函数是私有的，因此无法通过构造函数实例化，可以通过调用静态成员函数GetInstance在类内部构造实例。用户访问唯一实例的方法只有GetInstance()成员函数。GetInstance()使用懒惰初始化，也就是说它的返回值是当这个函数首次被访问时被创建的。这是一种防弹设计——所有GetInstance()之后的调用都返回相同实例的指针。单例模式通过类本身来管理其唯一实例，唯一的实例是类的一个普通对象，但设计这个类时，让它只能创建一个实例并提供对此实例的全局访问。唯一实例类Singleton在静态成员函数中隐藏创建实例的操作。习惯上把这个成员函数叫做Instance()，它的返回值是唯一实例的指针。<a href="https://blog.csdn.net/hackbuteer1/article/details/7460019" target="_blank" rel="noopener">参考</a></p>
<p>（5）原型模式：拷贝构造函数</p>
<p>（6）模板方法模式：定义操作的骨架，依次调用子类实现的函数</p>
<p>（7）建造者模式（直接传入特定类型对象作为参数）</p>
<ol start="3">
<li>最长回文子串</li>
<li>数组中未出现最小正整数</li>
</ol>
<p>（1） arr为整数1,2,3…N的一个随机排列，那个未出现的最小正整数就是N+1。</p>
<p>（2） arr中有小于1或者大于N的数出现(我们称之为“不合法”的数)，则未出现的最小正整数一定在1到N中间（因为数组一共只有N个数，如果出现不合法的数，则出现的1到N之间的数的个数一定小于N，故一定有没有出现的数）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),改变了原数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missMinNum</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>; <span class="comment">//l表示已经从1到L已经出现（左边界），l的初值为0。</span></span><br><span class="line">        <span class="keyword">int</span> r = arr.length; <span class="comment">//如果一个数字过大（不合法），就会被扔掉，用r表示这个右边界，r初始值为arr长度。</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[l] == l +<span class="number">1</span>)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[l]&gt; r || arr[l] &lt;= l || arr[arr[l] - <span class="number">1</span>] == arr[l])<span class="comment">//太小、太大、重复</span></span><br><span class="line">                arr[l] =arr[--r];<span class="comment">//r-1且要把当前r的值保存下来，替换掉已经遍历过的l位的值</span></span><br><span class="line">            <span class="keyword">else</span><span class="comment">//合法但是没有在理想的位置上</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = arr[l];</span><br><span class="line">                arr[l] =arr[arr[l] - <span class="number">1</span>];</span><br><span class="line">                arr[temp - <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回不存在的那个数字，或者right+1==l+1</span></span><br><span class="line">        <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</span></span><br><span class="line"><span class="comment">//循环遍历，时间复杂度O(n),改变了数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> right=nums.<span class="built_in">size</span>();</span><br><span class="line">        innt i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;right;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==i)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;=right)</span><br><span class="line">                nums[i]=nums[--right];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                swap(nums[i],nums[nums[i]]);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回不存在的那个数字,或者i==right</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">解法二：二分查找时间复杂度O(lgn)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//左闭右闭</span></span><br><span class="line">        <span class="keyword">int</span> right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==mid)</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个index!=nums[index]的index</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li><p>内存管理</p>
</li>
<li><p>udp为什么会丢包？如何减少丢包？</p>
</li>
</ol>
<p>1、接收端处理时间过长（接收端采用多线程回调机制或尽量简化处理数据包到重新回到监听状态的中间过程）</p>
<p>2、发送包过大，超过接收者缓存（使用setsocketopt修改接收端缓冲区大小）</p>
<p>3、发送包的频率过高（发送端sleep）</p>
<p>4、网络不稳定或拥塞（改善网络环境或实现丢包处理）</p>
<ol start="7">
<li>TCP/UDP传输的应用  TCP流量控制  拥塞机制：慢启动  拥塞避免  快重传  快恢复</li>
<li>非递归快排</li>
</ol>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/qiuck_sort.png" alt="快速排序递归排序非递归排序"></p>
<ol start="9">
<li>封装、继承、多态的目的 </li>
</ol>
<p>封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用，派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性。</p>
<p>最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种方法的目的了。</p>
<ol start="10">
<li>磁盘的随机读写和顺序读写</li>
</ol>
<p>顺序读写：文件指针只能从头移动到尾，SAS机械硬盘主要是看顺序读写性能</p>
<p>随机读写：文件指针可以根据需要随意移动，寻道时间和旋转延迟，SSD固态盘主要看随机读写性能</p>
<ol start="11">
<li>对称密钥加密和非对称密钥加密的区别</li>
</ol>
<p>对称密钥：又称私钥加密，即<strong>信息的发送方和接收方用一个密钥去加密和解密数据</strong>。它的最大优势是加/解密速度快，适合于对大数据量进行加密，但密钥管理困难，安全性低。</p>
<p>非对称密钥加密系统：又称公钥密钥加密，它<strong>需要使用一对密钥来分别完成加密和解密操作</strong>，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。公钥机制灵活，安全性高，但加密和解密速度却比对称密钥加密慢得多。</p>
<ol start="12">
<li><p>垃圾回收机制</p>
</li>
<li><p>Linux操作系统的主要组成部分：内核，shell,文件系统，应用程序</p>
</li>
</ol>
<ul>
<li>文件系统索引结构B+树</li>
</ul>
<ol start="14">
<li>IO  cache 用法</li>
</ol>
<p><strong>Buffer</strong>（缓冲区）是系统两端处理<strong>速度平衡</strong>（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到<strong>流量整形</strong>的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。<br><strong>Cache</strong>（缓存）则是系统两端处理<strong>速度不匹配</strong>时的一种<strong>折衷策略</strong>。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。</p>
<p>常规文件系统操作（调用read/fread/write等类函数）中，函数的调用过程：</p>
<p>VFS所隐含的主要思想在于引入了一个通用的文件模型（common file model)，这个模型能够表示所有支持的文件系统。linux内核对每个文件读写操作都必须使用一个指针，指向要访问的具体文件系统的适当函数。换句话说，当应用程序对read()或是write()调用引起内核调用相应的sys_read()或是sys_write()服务例程，文件在内核内存中是由一个file数据结构来表示的。这种数据结构中包含一个称为f_op的字段，该字段中包含一个指向专对某一个文件系统(如sysfs虚拟文件系统)的读写函数指针，sys_read()或是sys_write()查找到指向该函数的指针，并调用它。这样一来，应用程序的read()或是write()就被转化为相对间接的调用：</p>
<p>file-&gt;f_op-&gt;read() 或 file-&gt;f_op-&gt;write()</p>
<ul>
<li><p><strong>读文件</strong><br>1、进程调用库函数向内核发起读文件请求；</p>
<p>2、内核通过检查进程的文件描述符定位到虚拟文件系统VFS的已打开文件列表表项；</p>
<p>3、调用该文件可用的系统调用函数read()</p>
<p>3、read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode；</p>
<p>4、在inode中，通过文件内容偏移量计算出要读取的页；</p>
<p>5、通过inode找到文件对应的address_space；</p>
<p>6、在address_space中访问该文件的页缓存树，查找对应的页缓存结点：</p>
<p>（1）如果页缓存命中，那么直接返回文件内容；</p>
<p>（2）如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第6步查找页缓存；</p>
<p>7、文件内容读取成功。</p>
<p><strong>写文件</strong><br>前5步和读文件一致，在address_space中查询对应页的页缓存是否存在：</p>
<p>6、如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。</p>
<p>7、如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。</p>
<p>8、一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：</p>
<p>（1）手动调用sync()或者fsync()系统调用把脏页写回</p>
<p>（2）pdflush进程会定时把脏页写回到磁盘</p>
<p>同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。</p>
</li>
</ul>
<p>将磁盘上的数据缓存在内存中，加速文件的读写。实际上，在一般情况下，read/write是只跟缓存打交道的。read就直接从缓存读数据。如果要读的数据还不在缓存中，则触发一次读盘操作，然后等待磁盘上的数据被更新到磁盘高速缓存中；write也是直接写到缓存里去，然后就不用管了。后续内核会负责将数据写回磁盘。为了实现这样的缓存，每个文件的inode内嵌了一个address_space结构，通过inode-&gt;i_mapping来访问。address_space结构中维护了一棵radix树，用于磁盘高速缓存的内存页面就挂在这棵树上。而既然磁盘高速缓存是跟文件的inode关联上的，则打开这个文件的每个进程都共用同一份缓存。</p>
<ol start="15">
<li><p>bitmap   磁盘一亿个数查询target，内存4g</p>
</li>
<li><p>linux创建管道命令</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo [options] NAME  #创建有名管道</span><br></pre></td></tr></table></figure>

<ol start="17">
<li>git命令行</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;name&gt;  <span class="comment">#创建分支</span></span><br><span class="line">git merge &lt;name&gt;   <span class="comment">#合并分支</span></span><br></pre></td></tr></table></figure>

<ol start="18">
<li>动态链接库和静态链接库的区别:<a href="https://www.cnblogs.com/cyyljw/p/10949660.html" target="_blank" rel="noopener">参考</a></li>
</ol>
<p>（一）静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，lib中的指令都全部被直接包含在最终生成的exe文件中了（链接器从静态链接库获取所有被引用函数的二进制代码和库一起放到可执行文件中）。但是若使用dll动态链接库，该dll不必被包含在最终的exe文件中，它允许可执行模块（dll或exe文件）仅包含在运行时定位dll函数的可执行代码的所需信息，执行文件执行时可以动态地引用和卸载这个与exe独立的dll文件。如果某个目标文件需要的函数在参与链接的目标文件中找不到的话，链接器就报错了。目标文件中有两个重要的接口来提供这些信息：一个是符号表，另外一个是重定位表。</p>
<p>（二）静态链接库不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。 </p>
<p>（三）动态链接库基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，<strong>当程序在运行到指定的代码时，去执行共享内存中已经加载的动态库可执行代码</strong>，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件,也就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果在当前工程中有多处对dll文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但是如果有多处对lib文件中同一个函数的调用，那么执行时，该函数将在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝。</p>
<p><strong>静态链接的优点</strong> </p>
<p>   (1) 代码装载速度快，执行速度略比动态链接库快，在程序发布的时候就不需要的依赖库（不需要带着库一块发布），程序可以独立执行； </p>
<p>   (2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 </p>
<p>  <strong>动态链接的优点</strong> </p>
<p>   (1) DLL 节省内存，减少页面交换，节省磁盘空间，多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝；</p>
<p>   (2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；</p>
<p>   (3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；</p>
<p>   (4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。</p>
<p>  <strong>静态链接和动态链接的不足之处</strong></p>
<p>   (1) 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；如果静态库有更新的话，所有可执行文件都得重新链接才能用上新的静态库，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统死掉</p>
<p>   (2) 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。但是由于是运行时加载，可能会影响程序的前期执行性能。</p>
<ol start="20">
<li>从源程序到执行程序的过程（<code>编译</code>）:<a href="https://blog.csdn.net/zhoudonghao4381/article/details/80811906" target="_blank" rel="noopener">参考</a></li>
</ol>
<ul>
<li>预编译</li>
<li>编译：<strong>把预编译之后生成的xxx.i或xxx.ii文件，进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成和优化，生成相应的汇编代码文件.s。</strong></li>
<li>汇编：<strong>将汇编代码转变成机器可以执行的指令(机器码文件)</strong>，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)，还有<strong>一个问题——变量a和数组arr的地址还没有确定</strong>。</li>
<li>链接：静态链接和动态链接，生成二进制可执行文件.out或.exe</li>
</ul>
<p><code>运行</code>：在控制台输入./可执行文件路径或在资源管理器中双击可执行文件就可运行可执行程序，程序实际上是操作系统装载运行的，操作系统能理解程序的二进制文件格式，然后分配程序执行所需的栈空间、代码段、静态存储区、映射堆空间地址等，操作系统会创建一个进程结构体来管理进程，然后将进程放入就绪队列，等待CPU调度运行。</p>
<p>编译器把一个cpp编译为目标文件的时候，除了要在目标文件里写入cpp里包含的数据和代码，还要至少提供3个表：未解决符号表，导出符号表和地址重定向表。</p>
<ol start="21">
<li>mysql怎么创建索引 （索引是一种高效获取数据库数据的数据结构） ？为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引？</li>
</ol>
<ul>
<li><p>MySQL 提供了三种创建索引的方法：</p>
<p>（1）使用 CREATE INDEX 语句</p>
<p>（2）ALTER TABLE</p>
<p>（3）CREATE TABLE</p>
</li>
</ul>
<ol start="22">
<li>为什么B+树（有序数组+平衡多叉树）比B树（有序数组链表+平衡多叉树）更适合文件索引系统？<a href="https://blog.csdn.net/weixin_30531261/article/details/79312676" target="_blank" rel="noopener">扩展</a></li>
</ol>
<p>（1）B+树空间利用率更高，因为B+树的内部节点只是作为索引使用，而不像B树那样每个节点都需要存储硬盘指针。</p>
<p>（2）增删文件（节点）时，效率更高，因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</p>
<h3 id="百度B2B后台开发c-PHP提前批"><a href="#百度B2B后台开发c-PHP提前批" class="headerlink" title="百度B2B后台开发c++/PHP提前批"></a>百度B2B后台开发c++/PHP提前批</h3><ol>
<li>项目整个框架流程  为什么使用音频而不是用上层http传输  技术难点</li>
<li>两道编程题  一道数学题</li>
</ol>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/baidu1.jpg" alt></p>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/baidu2.jpg" alt></p>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/baidu3.jpg" alt></p>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/baidu4.jpg" alt></p>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/baidu5.jpg" alt></p>
<h4 id="百度二面："><a href="#百度二面：" class="headerlink" title="百度二面："></a>百度二面：</h4><ol>
<li>为什么四次挥手FIN和ACK不能合成一帧？</li>
</ol>
<p>因为TCP全双工通信，FIN表示关闭发送但是仍可以接受数据，当服务端收到客户端发的FIN时自己可能还有数据没发完，但是如果收到FIN后不立刻发送ACK，而是等FIN一块发送，客户端会一直超时重传，造成资源浪费。</p>
<ol start="2">
<li>线程和进程的错误返回码有什么不同   线程和进程的区别和优缺点   线程间通信</li>
</ol>
<p>线程正确返回0  异常返回非0</p>
<p>进程正确返回非负数  异常返回负数</p>
<p>它们都能提高程序的并发度，提高程序运行效率和响应时间。线程和进程在使用上各有优缺点。 线程执行开销比较小，但不利于资源的管理和保护，而进程相反。</p>
<p>线程共享进程的公有数据，相当于全局变量，<strong>本质上就是“共享内存”式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。</strong></p>
<p>线程间的通信方式</p>
<p># 锁机制：包括互斥锁、条件变量、读写锁<br>*互斥锁提供了以排他方式防止数据结构被并发修改的方法。<br>*读写锁允许多个线程同时读共享数据，而对写操作是互斥的。<br>*条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。<br># 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量<br># 信号机制(Signal)：类似进程间的信号处理<br>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你必须定义一个 `main()` 函数入口。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mall</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Mall(<span class="keyword">int</span> n):len(n)&#123;</span><br><span class="line">    p= (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>* p;</span><br><span class="line">  ~Mall()&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">      <span class="keyword">delete</span> [] p;</span><br><span class="line">      p=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> len; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Mall <span class="title">point</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="built_in">point</span>.p[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>对一个二叉树进行z型遍历，如以下二叉树</span><br><span class="line">               <span class="number">1</span> </span><br><span class="line">        <span class="number">2</span>            <span class="number">3</span></span><br><span class="line"><span class="number">4</span>          <span class="number">5</span>       <span class="number">6</span>    <span class="number">7</span></span><br><span class="line">输出的结果为：<span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line">  </span><br><span class="line">queue1   queue2</span><br><span class="line"><span class="number">1</span>        <span class="number">3</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">root </span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">traverlse</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">  <span class="built_in">stack</span>&lt;TreeNode*&gt; st1;</span><br><span class="line">  <span class="built_in">stack</span>&lt;TreeNode*&gt; st2</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">stack</span>&lt;TreeNode*&gt;&gt; st&#123;st1,st2&#125;;</span><br><span class="line">  <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">  st[flag].push(root);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">while</span>(!st[flag].empty()||!st[flag].empty())&#123;</span><br><span class="line">    TreeNode* node=st[flag].top();</span><br><span class="line">    res.push_back(node.val);</span><br><span class="line">    st[flag].pop();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(node-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        st[<span class="number">1</span>-flag].push(node-&gt;left);</span><br><span class="line">      <span class="keyword">if</span>(node-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">        st[<span class="number">1</span>-flag].push(node-&gt;right);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(node-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">        st[<span class="number">1</span>-flag].push(node-&gt;right);</span><br><span class="line">      <span class="keyword">if</span>(node-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        st[<span class="number">1</span>-flag].push(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st[flag].empty())&#123;</span><br><span class="line">      flag=<span class="number">1</span>-flag;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">traversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">  <span class="built_in">deque</span>&lt;pair&lt;TreeNode*,<span class="keyword">int</span>&gt;&gt; deq;</span><br><span class="line">  deq.push_back(pair&lt;TreeNode*,<span class="keyword">int</span>&gt;(root,<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">  <span class="keyword">int</span> pre=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!deq.empty())&#123;</span><br><span class="line">    <span class="keyword">auto</span> node=deq.front();</span><br><span class="line">    deq.pop_front();</span><br><span class="line">    <span class="keyword">if</span>(node.second==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(pre==<span class="number">1</span>)&#123;</span><br><span class="line">        res.resize(res.<span class="built_in">size</span>()+tmp.<span class="built_in">size</span>());</span><br><span class="line">        copy(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>(),res.<span class="built_in">begin</span>()+res.<span class="built_in">size</span>());</span><br><span class="line">        tmp.<span class="built_in">clear</span>();</span><br><span class="line">        pre=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      res.push_back(node.first-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      tmp.insert(tmp.<span class="built_in">begin</span>(),node.first-&gt;val);</span><br><span class="line">      pre=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span>(node.first-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">    deq.push_back(pair&lt;TreeNode*,<span class="keyword">int</span>&gt;(node.first-&gt;left,<span class="number">1</span>-node.second));</span><br><span class="line">  <span class="keyword">if</span>(node.first-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">    deq.push_back(pair&lt;TreeNode*,<span class="keyword">int</span>&gt;(node.first-&gt;right,<span class="number">1</span>-node.second));     </span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="百度正式批一面"><a href="#百度正式批一面" class="headerlink" title="百度正式批一面"></a>百度正式批一面</h3><h4 id="static函数"><a href="#static函数" class="headerlink" title="static函数"></a>static函数</h4><p>静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，只能在创建对象后通过对象来调用，因为它需要当前对象的地址可以访问类中的任意成员；而静态成员函数没有 this 指针，不需要当前对象的地址，只能访问静态成员（包括静态成员变量和静态成员函数），可以通过类来直接调用。</p>
<h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><p>1、inline与#define</p>
<p>内联函数是代码被插入到调用者代码处的函数。如同 #define 宏，内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（“过程化集成”）被编译器优化。 </p>
<p>2、区别</p>
<p>(1)内联函数在编译时展开，是进行参数传递，先将内联函数编译完成生成的函数体直接插入被调用的地方，减少了压栈，跳转和返回的操作，但是占用了更多内存；而宏是由预处理器对宏进行展开,是简单的文本替换，替换完成后进入编译.宏并不是简单的参数传递（很难处理一些特定情况，如ADD(z++))。宏不能进行调试,当预处理搜索#define定义的符号时，字符串常量并不被搜索。内联函数和宏均使代码变长。</p>
<p>(2)内联函数会检查参数类型，宏定义不检查函数参数 ，所以内联函数更安全。</p>
<p>(3)宏不是函数，而inline函数是函数,但没有普通函数调用时的额外开销 (压栈,跳转,返回),内联函数是一种特殊的函数,具有普通函数的特征.</p>
<p>(4)宏在定义时要小心处理宏参数，（一般情况是把参数用括弧括起来）。</p>
<p>3、inline的使用</p>
<p>(1)在C++中，在类的内部定义了函数体的函数，被默认为是内联函数。而不管你是否有inline关键字。</p>
<p>(2)在内联函数内不允许用循环语句、开关语句和递归调用等，且函数体不宜过长,否则作为普通函数处理。inline关键字表示建议使用内联。编译器可以检测定义的内联函数是否满足要求，如果不满足就会当作普通函数调用（内联函数不能递归，内联函数不能太大）。</p>
<p>(3)在你调用一个内联函数之前，这个函数一定要在之前有声明或已定义为inline,如果在前面声明为普通函数，而在调用代码后面才定义为一个inline函数，程序可以通过编译，但该函数没有实现inline</p>
<p>(4)如果一个inline函数会在多个源文件中被用到，那么必须把它定义在头文件中。解析：如果内联函数fun()定义在某个编译单元A中，那么其他编译单元中调用fun()的地方时，可以编译通过（此时并没有展开，结合第三条，此时虽然头文件声明了该inline函数，但此时调用时，还没定义，所以作为普通函数处理）。当链接时将无法解析该符号，出现链接错误。 因为inline函数是作为内部连接存在的，只能够被本模块访问。</p>
<h4 id="C-中-内联编译限制"><a href="#C-中-内联编译限制" class="headerlink" title="C++中 内联编译限制"></a>C++中 内联编译限制</h4><p>1.不能存在任何形式的循环语句.</p>
<p>2.不能存在过多的条件判断语句.</p>
<p>3.函数体不能过于庞大.当函数体的执行开销大于压栈,跳转和返回所用的开销时,那么内联将无意义.</p>
<p>4.内联函数声明必须在调用语句之前.</p>
<p>相同点：<br>两者都是可以加快程序运行效率，使代码变得更加通用</p>
<p>不同点：</p>
<pre><code>1.内联函数的调用是传参，宏定义只是简单的文本替换

2.内联函数可以在程序运行时调用，宏定义是在程序编译进行

3.内联函数有类型检测更加的安全，宏定义没有类型检测

4.内联函数在运行时可调试，宏定义不可以

5.内联函数可以访问类的成员变量，宏不可以

6.类中的成员函数是默认的内联函数</code></pre><p>误解一：inline函数没有单独的函数体，也不能取地址。</p>
<p>事实：inline修饰并不会改变函数的通常语义，仍可通过函数指针调用：</p>
<p>误解二：inline和virtual不能同时修饰一个函数。</p>
<p>事实：inline和virtual并不冲突，可以同时修饰函数</p>
<p>误解三：virtual函数即使声明为inline，由于是late binding，无法判断实际调用的版本，编译器也无法展开。</p>
<p>事实：虚函数调用并不总是late binding；late binding发生在通过指针或引用来调用函数的时候，在其它情况下理论上是可能对 virtual inline的函数进行展开的</p>
<p>误解四： inline函数一定是internal linkage/no linkage的。</p>
<p>inline 与函数的linkage无关。inline函数同样可以用static和extern修饰，并具备同一般函数相同的linkage。标准要求 external linkage的inline函数在所有编译单元中具有相同的地址。external linkage的inline函数内定义的静态变量同样应在所有编译单元中表现为单一对象，具有相同的地址。</p>
<h4 id="构造函数可以是虚函数吗"><a href="#构造函数可以是虚函数吗" class="headerlink" title="构造函数可以是虚函数吗"></a>构造函数可以是虚函数吗</h4><h4 id="socket手撸"><a href="#socket手撸" class="headerlink" title="socket手撸"></a>socket手撸</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Multi&#123;</span><br><span class="line">public:</span><br><span class="line">Multi()&#123;&#125;;</span><br><span class="line">void product()&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lk(mu);</span><br><span class="line">    noEmpty.wait(lk,!deq.empty());</span><br><span class="line">    deq.push_back(1);</span><br><span class="line">    hasMessage.notify_one();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">void consumer()&#123;    </span><br><span class="line">    unique_lock&lt;mutex&gt; lk(mu);</span><br><span class="line">    hasMessage.wait(lk,!deq.empty());</span><br><span class="line">    deq.pop_back();</span><br><span class="line">    noEmpty.notify_one();</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">    condition_variable noEmpty;</span><br><span class="line">    condition_variable hasMessage;</span><br><span class="line">    mutex mu;</span><br><span class="line">    deque&lt;int&gt; deq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Singleton&#123;</span><br><span class="line">public:</span><br><span class="line">    static shared_ptr&lt;T&gt; getInstance()&#123;</span><br><span class="line">        if(instance&#x3D;&#x3D;nullptr)&#123;</span><br><span class="line">            lock_guard&lt;mutex&gt; lk(mu);</span><br><span class="line">            if(instance&#x3D;&#x3D;nullptr)&#123;</span><br><span class="line">                instance&#x3D;make_shared&lt;T&gt;()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Singleton()&#123;&#125;;</span><br><span class="line">private:</span><br><span class="line">    Singleton()&#123;&#125;;</span><br><span class="line">    static mutex mu;</span><br><span class="line">    static shared_ptr&lt;T&gt; instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;int a;</span><br><span class="line">    &#x2F;&#x2F;cin &gt;&gt; a;</span><br><span class="line">    cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>TCP UDP区别  TCP三次握手四次挥手  流量控制 拥塞避免算法<br>1）给定一个文件，包含1亿个ip，每个ip一行，要求统计出现次数最多的ip地址，100M内存</p>
<p>答：1亿个ip，100000000*32/8/1024/1024=381MB,所以不能完全加载到内存中。可以考虑分而治之的策略；</p>
<p>按照IP地址的hash(IP)%1024值，将海量日志存储到1024个小文件中，每个小文件最多包含4M个IP地址。<br>对于每个小文件，可以构建一个IP作为key，出现次数作为value的hash_map，并记录当前出现次数最多的1个IP地址。有了1024个小文件中的出现次数最多的IP，我们就可以轻松得到总体上出现次数最多的IP。</p>
<p>注：IP地址最多有2^32=4G种取值可能</p>
<p>2）最快速度求两个数组交集算法<br>比如 A={6，2，4，1},B={2，9，4，3}，那么A&amp;B={2，4}。</p>
<p>方法一：<br>排序+双指针</p>
<p>方法二：<br>unordered_map</p>
<h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ol>
<li>拉链法跟线性探测法的比较  什么场景使用什么好  hash 表的概念，应用</li>
</ol>
<h4 id="Hash与红黑树的区别："><a href="#Hash与红黑树的区别：" class="headerlink" title="Hash与红黑树的区别："></a>Hash与红黑树的区别：</h4><p>权衡三个因素: 查找速度, 数据量, 内存使用，可扩展性，有序性。</p>
<p>hash查找速度会比RB树快，而且查找速度基本和数据量大小无关，属于常数级别;而RB树的查找速度是log(n)级别。并不一定常数就比log(n) 小，因为hash还有hash函数的耗时。当元素达到一定数量级时，考虑hash。但若你对内存使用特别严格， 希望程序尽可能少消耗内存，那么hash可能会让你陷入尴尬，特别是当你的hash对象特别多时，你就更无法控制了，而且 hash的构造速度较慢。</p>
<p>红黑树是有序的，Hash是无序的，根据需求来选择。<br>红黑树占用的内存更小（仅需要为其存在的节点分配内存），而Hash事先应该分配足够的内存存储散列表,即使有些槽可能弃用<br>红黑树查找和删除的时间复杂度都是O(logn)，Hash查找和删除的时间复杂度都是O(1)。</p>
<p>哈希函数构造原则：<br>1、计算简单<br>2、散列地址尽量分布均匀</p>
<p>处理冲突的处理方式<br>(1)线性探测法：线性探查、二次探查、伪随机探查<br>(2)拉链法<br>(3)再散列法<br>(4)公共溢出区</p>
<h5 id="拉链法的优点与开放定址法相比，拉链法有如下几个优点"><a href="#拉链法的优点与开放定址法相比，拉链法有如下几个优点" class="headerlink" title="拉链法的优点与开放定址法相比，拉链法有如下几个优点"></a>拉链法的优点与开放定址法相比，拉链法有如下几个优点</h5><p>①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</p>
<p>②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况，可扩展性强</p>
<p>③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</p>
<p>④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</p>
<p>一般来说，使用 散列表 会比 红黑树 快很多。但具体还是要看 哈希函数 的计算效率。但是 散列表 无法保证顺序，所以如果你需要进行有关顺序的操作，应该使用 红黑树 或者 二叉搜索树 。</p>
<p>对于 线性探测 来说动态调整数组大小是必要的，不然会产生死循环。</p>
<p>拉链法 的删除操作比较方便，直接链表修改地址即可。而 线性探测 删除操作很复杂，而且 线性探测 耗费的内存比拉链法要多。</p>
<h4 id="线性探测法优缺点"><a href="#线性探测法优缺点" class="headerlink" title="线性探测法优缺点"></a>线性探测法优缺点</h4><p>优点：无需附加空间（指针、链表、溢出区）<br>探测序列具有局部性，可以利用系统缓存，减少IO</p>
<p>缺点：耗费时间&gt;O(1)<br>冲突增多——以往的冲突会导致后续的连环冲突，发生惨烈的车祸</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">散列表的装填因子</span><br><span class="line">散列表的装填因子定义为：α&#x3D; 填入表中的元素个数 &#x2F; 散列表的长度</span><br><span class="line">α是散列表装满程度的标志因子。由于表长是定值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小</span><br></pre></td></tr></table></figure>

<p>rehash</p>
<ol start="2">
<li>shared_ptr有什么好处针对单例模式，写个单例模式</li>
</ol>
<p>int main () {<br>    T* t = new T();<br>    return 0;<br>}</p>
<p>mutex 改成 spin一个定制的mutex指定或者不指定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Singleton&#123;</span><br><span class="line">public:</span><br><span class="line">    static shared_ptr&lt;T&gt; getInstance()&#123;</span><br><span class="line">        if(instance&#x3D;&#x3D;nullptr)&#123;</span><br><span class="line">            unique_lock&lt;mutex&gt; lk(mu);</span><br><span class="line">            if(instance&#x3D;&#x3D;nullptr)&#123;</span><br><span class="line">                instance&#x3D;make_shared&lt;T&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Singleton()&#123;&#125;;</span><br><span class="line">private:</span><br><span class="line">    Singleton()&#123;&#125;;</span><br><span class="line">    static shared_ptr&lt;T&gt; instance;</span><br><span class="line">    static mutex mu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;int a;</span><br><span class="line">    &#x2F;&#x2F;cin &gt;&gt; a;</span><br><span class="line">    cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>插入排序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void insertsort(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">    if(nums.size()&#x3D;&#x3D;0||nums.size()&#x3D;&#x3D;1)return;</span><br><span class="line">    &#x2F;&#x2F;在这里一遍遍历选出最小值，放在第一位可去掉内循环的j&gt;&#x3D;1</span><br><span class="line">    for(int i&#x3D;1;i&lt;nums.size();i++)&#123;</span><br><span class="line">        </span><br><span class="line">        for(int j&#x3D;i;j&gt;&#x3D;1;j--)&#123;</span><br><span class="line">            int ans&#x3D;nums[j];</span><br><span class="line">            if(nums[j]&lt;nums[j-1])</span><br><span class="line">                nums[j]&#x3D;nums[j-1];</span><br><span class="line">             else&#123;</span><br><span class="line">                 nums[j]&#x3D;ans;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">                 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;int a;</span><br><span class="line">    &#x2F;&#x2F;cin &gt;&gt; a;</span><br><span class="line">    vector&lt;int&gt; nums&#123;2,1,5,3,4,6&#125;;</span><br><span class="line">    insertsort(nums);</span><br><span class="line">    for(auto&amp; num:nums)</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="（十二）网易"><a href="#（十二）网易" class="headerlink" title="（十二）网易"></a>（十二）网易</h2><ol>
<li>海量数据找到最小的k个数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大堆，时间复杂度O(nlgk),空间复杂度O(k)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;&gt; inSet;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLeastNumbers</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;data,inSet&amp; leastNumbers,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">1</span> || data.<span class="built_in">size</span>()&lt;k)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;itn&gt;::const_iterator iter=data.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(;iter!=data.<span class="built_in">end</span>();++iter)&#123;</span><br><span class="line">        <span class="keyword">if</span>(leastNumbers.<span class="built_in">size</span>()&lt;k)</span><br><span class="line">            leastNumbers.insert(*iter);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(*iter&lt;*leastNumbers.<span class="built_in">begin</span>())&#123;</span><br><span class="line">                leastNumbers.erase(leastNumbers.<span class="built_in">begin</span>());</span><br><span class="line">            	leastNumbers.insert(*iter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当我们可以修改输入数组时，可用partition函数，时间复杂度为O(n)</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>重载一个运算符原则：</p>
<p>1.不能改变运算符的初始意义。</p>
<p>2.不能改变运算符的参数数目。如重载运算符+时只用一个操作数是错误的。</p>
<p>3.运算符函数不能包括缺省的参数。</p>
<p>4.绝大部分C++运算符都可以重载，除以下的例外：</p>
<p><code>.   ::   .*  ?</code></p>
<p>5．除赋值运算符外，其它运算符函数都可以由派生类继承。</p>
<p>6.运算符重载不改变运算符的优先级和结合性，也不改变运算符的语法结构，即单目、双目运算符只能重载为单目、双目运算符。</p>
<p>7.运算符的重载实际上是函数的重载。编译程序对运算符重载的选择，遵循函数重载的选择原则。当遇到不很明显的运算符时，编译程序将去寻找参数匹配的运算符函数。</p>
<p>8.运算符重载可使程序更简洁，使表达式更直观，增强可读性。但使用不宜过多。</p>
<p>9.重载运算符含义必须清楚.</p>
</li>
</ol>
<p>   <strong>重载的形式:成员函数形式 和 友元函数形式</strong></p>
<p>   (1) 一般情况下，单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数。<br>   (2) 以下双目运算符不能重载为类的友元函数：=、()、[]、-&gt;。<br>   (3) 类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。<br>   (4) 若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好。<br>   (5) 若运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则只能选用友元函数。<br>   (6) 当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一　个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部　类型的对象，该运算符函数必须作为一个友元函数来实现。<br>   (7) 当需要重载运算符具有可交换性时，选择重载为友元函数。</p>
<ol start="4">
<li><p>二叉树的高度和节点数</p>
<p>具有n个结点的完全二叉树的高度为log(n+1)向上取整，或者(logn)向下取整+1</p>
<p>高度为h完全二叉树最后一层有n+1-2^(h-1)个结点;完全二叉树第k层至多有2^（k-1）个结点<br>满二叉树深度为h，则有2^h-1个结点；第k层的节点数目为2^（k-1）</p>
</li>
</ol>
<h2 id="（十三）腾讯"><a href="#（十三）腾讯" class="headerlink" title="（十三）腾讯"></a>（十三）腾讯</h2><h3 id="腾讯测开实习"><a href="#腾讯测开实习" class="headerlink" title="腾讯测开实习"></a>腾讯测开实习</h3><ol>
<li>static变量？ static函数为什么只能用static变量？</li>
</ol>
<p>（1）静态成员变量：</p>
<ul>
<li>静态成员变量属于整个类所有，生命期不依赖于任何对象，为程序的生命周期</li>
<li>可以通过类名直接访问公有静态成员变量，也可以通过对象名访问公有静态成员变量</li>
<li>静态成员变量在类外单独分配空间,变量地址是指向其数据类型的指针</li>
<li>静态成员变量是静态存储的，在程序内部位于全局/静态存储区</li>
<li>static数据成员可以作为成员函数的默认实参。非static数据成员，不能用作成员函数的默认实参，因为它的值不能独立于所属对象而使用。分析：静态数据成员如果未初始化，系统自动会给它初始化为某个缺省值(如int初始化为0, 指针初始化为NULL等)。 所以一旦定义，其值已确定，可以作为类成员函数的缺省参数。当在类的外部定义static成员时，无须重复指定static关键字。static关键字只能用于类定义体内部的声明中，定义不能标示为static。static数据成员必须在类定义体的外部定义。不像普通的数据成员，static成员不是通过类构造函数进行初始化，而是应该在定义时初始化。一般将static数据成员的定义放在包含类的非内联成员函数定义的文件中。 一般的讲，static数据成员和普通数据成员一样，不能在类的定义体中初始化。static数据成员一般在定义时候初始化。这个规则的一个例外是，只要初始化式是一个常量表达式，const static 数据成员就可以在类的定义体中初始化</li>
</ul>
<p>（2）静态成员函数:</p>
<ul>
<li>类内使用static修饰的特殊成员函数，属于整个类所有，没有this指针（这就是它仅能访问类的静态数据和静态成员函数的原因）,函数地址类型是个“nonmember 函数指针”</li>
<li>只能直接访问静态成员变量和静态成员函数，调用这个函数不会访问或者修改任何对象非static数据成员</li>
<li>可以通过类名直接访问类的公有静态成员函数，也可以通过对象名访问类的公有静态成员函数</li>
<li>不能将静态成员函数声明为虚函数、const和volatile</li>
</ul>
<p>其实很好理解，类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，函数地址类型是个“nonmember 函数指针”。static 并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。静态数据成员在&lt;定义或说明&gt;时前面加关键字 static。 静态成员初始化与一般数据成员初始化不同：</p>
<p>　　初始化在类体外进行，而前面不加 static，以免与一般静态变量或对象相混淆；初始化时不加该成员的访问权限控制符 private、public；初始化时使用作用域运算符来标明它所属类；所以我们得出静态数据成员初始化的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;&#x3D;&lt;值&gt;</span><br></pre></td></tr></table></figure>

<p>（3）为何static成员函数不能为virtual</p>
<ol>
<li><p>static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。</p>
</li>
<li><p>静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有this指针。</p>
<p>虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.<br>对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual.<br>虚函数的调用关系：this -&gt; vptr -&gt; vtable -&gt;virtual function</p>
</li>
</ol>
<p>（4）为何static成员函数不能为const函数<br>对于一个定义为const的函数，传递的是const的this指针，说明不能更改对象的属性，而对static成员的函数不需传递this指针，所有就不需要用const来修饰static的成员函数了！就说const属性的作用就是对被传递的this指针加以限定，而对static成员函数的调用根本不传递this指针，所有不需const来修饰static的成员函数<del>~</del> 从对象模型上来说，类的非static成员函数在编译的时候都会扩展加上一个this参数，const的成员函数被要求不能修改this所指向的这个对象；而static函数编译的时候并不扩充加上this参数，自然无所谓const。 因为const成员函数的const是修饰this所指指物的也就是this将会被声明为const CLASSNAME*。 而static不存在this指针，所以const对static member function的修饰是无效的。 static member怎么看都是活在CLASSNAME NAMESPACE中的普通事物。<br>  volatile的道理也是如此。volatile 与const类似 ，volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。</p>
<p>(9) 为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们又重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p>
<p>设置静态成员的目的，是为了将和某些类紧密相关的全局变量和全局函数写到类里面，形式上成为一个整体。使用 sizeof 运算符计算对象所占用的存储空间时，不会将静态成员变量计算在内。对上面的 CRectangle 类来说，sizeof(CRectangle) 的值是 8。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> nTotalArea;  <span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> nTotalNumber;  <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTotal</span> <span class="params">()</span></span>;  <span class="comment">//静态成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>主键索引和非主键索引的区别？</li>
</ol>
<p>非主键索引的叶子节点存放的是<strong>主键的值</strong>，而主键索引的叶子节点存放的是<strong>整行数据</strong>，其中非主键索引也被称为<strong>二级索引</strong>，而主键索引也被称为<strong>聚簇索引</strong>。</p>
<ol start="3">
<li>孤儿进程  僵尸进程</li>
</ol>
<p><strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p>
<p><strong>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</strong>假如它的父进程没有安装SIGCHLD信号处理函数来处理子进程（也即使wait或者waitpid等待儿子结束），又没有显示忽略该信号，那子进程就会一直保持僵尸状态。只有在父进程结束之后，才由init进程接管子进程，为他收尸（好凄惨啊），这个时候才能说子进程才真正的消失在Linux内核中。</p>
<p><strong>僵尸进程的避免</strong></p>
<p>⒈父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。</p>
<p>⒉ 如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler，因为子进程结束后， 父进程会收到该信号，可以在handler中调用wait回收。</p>
<p>⒊ 如果父进程不关心子进程什么时候结束，那么可以用signal（SIGCHLD,SIG_IGN） 通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收， 并不再给父进程发送信号。</p>
<p>⒋ 还有一些技巧，就是fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做。</p>
<ol start="4">
<li><p>链表的选择排序</p>
</li>
<li><p>二叉树的最长路径和</p>
</li>
<li><p>数独</p>
</li>
<li><p>迷宫</p>
</li>
<li><p>printf函数是从右向左计算入栈，输出顺序从左往右；函数调用参数的时候，从右往左依次执行所有会改变变量数值的式子，遇到后置自增的式子则直接把此时的变量代入，得到该自增式的值。全部执行完成后再从左往右依次把改变后的变量值代入各个除后置自增式以外的所有式子，此时这些式子的值是最终要代入函数的参数。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by anranzhai on 2020/4/17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>, (i++) - (--j), j = (i += <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>, i, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>,(k++,k++),k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>,l,(l++,l++));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a=<span class="number">11</span>, a++, a++);</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a, a + <span class="number">1</span>, a = <span class="number">3</span>);</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a++, a++, a = <span class="number">3</span>);</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a = <span class="number">11</span>, a = <span class="number">22</span>, a = <span class="number">33</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>, ++b,++b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>, ++b,b++);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v&#123;<span class="string">'a'</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(vec)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(v)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s=<span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span></span><br><span class="line"><span class="number">6</span>  <span class="number">4</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2</span></span><br><span class="line"><span class="number">11</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">11</span> <span class="number">11</span> <span class="number">11</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">i++=<span class="number">1</span>;<span class="comment">//错误，后置源码定义函数返回const int右值</span></span><br><span class="line">++i=<span class="number">1</span>;<span class="comment">//正确,前置源码定义函数返回int&amp;左值</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>sizeof</p>
</li>
<li><pre><code class="c++"><span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>,(k++,k++),k); <span class="comment">//为什么带括号？</span>
&lt;!--￼<span class="number">22</span>--&gt;
</code></pre>
</li>
</ol>
<h4 id="正式批一面"><a href="#正式批一面" class="headerlink" title="正式批一面"></a>正式批一面</h4><ol>
<li>数据库B+树索引和哈希索引的区别</li>
</ol>
<p>哈希文件也称为散列文件，是利用哈希存储方式组织的文件，亦称为直接存取文件。它类似于哈希表，即根据文件中关键字的特点，设计一个哈希函数和处理冲突的方法，将记录哈希到存储设备上。</p>
<p>在哈希文件中，是使用一个函数（算法）来完成一种将关键字映射到存储器地址的映射，根据用户给出的关键字，经函数计算得到目标地址，再进行目标的检索。</p>
<p>哈希索引优点<br>①.快速查询：参与索引的字段只要进行Hash运算之后就可以快速定位到该记录，时间复杂度约为1</p>
<p>哈希索引缺点<br>①.哈希索引只包含哈希值和行指针，所以不能用索引中的值来避免读取行<br>②.哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序和范围查询<br>③.哈希索引也不支持部分索引列查询，因为哈希索引始终是使用索引列的全部数据进行哈希计算的。<br>④.哈希索引只支持等值比较查询，如=，IN()，&lt;=&gt;操作<br>⑤.如果哈希冲突较多，一些索引的维护操作的代价也会更高</p>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95.png" alt></p>
<p>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</p>
<p>从示意图中也能看到，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</p>
<p>同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</p>
<p>哈希索引也不支持多列联合索引的最左匹配规则；</p>
<p>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题</p>
<p>hash结构的特点：检索效率非常高，索引的检索可以一次到位，O(1)。B树需要从根节点到枝节点，最后才能到叶节点进行多次I/O操作，所以hash的效率远远高于B树的效率。</p>
<p><strong>为什么数据库索引还是用B树结构呢？</strong></p>
<p>1、hash索引仅满足“=”、“IN”和“&lt;=&gt;”查询，不能使用范围查询</p>
<p>因为hash索引比较的是经常hash运算之后的hash值，因此只能进行等值的过滤，不能基于范围的查找，因为经过hash算法处理后的hash值的大小关系，并不能保证与处理前的hash大小关系对应。</p>
<p>2、hash索引无法被用来进行数据的排序操作</p>
<p>由于hash索引中存放的都是经过hash计算之后的值，而hash值的大小关系不一定与hash计算之前的值一样，所以数据库无法利用hash索引中的值进行排序操作。</p>
<p>3、对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</p>
<p>4、Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</p>
<p>对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。</p>
<p>（因此：键值重复率低的适合用B树索引）</p>
<p><strong>b-tree完全基于key的比较，和二叉树相同的道理，相当于建个排序后的数据集，使用二分法查找算法，实际上也非常快，而且受数据量增长影响非常小</strong>。</p>
<ol start="2">
<li><p>实现栈 push pop max</p>
</li>
<li><p>实现优先队列 大顶堆</p>
</li>
</ol>
<p>插入和删除都是O(log(n))的时间复杂度</p>
<ol start="4">
<li><h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p>
<p>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p>
<p>AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。</p>
<p>AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。</p>
</li>
<li><p>转发和重定向的区别</p>
</li>
</ol>
<p><strong>页面跳转的两种实现方式：请求转发和重定向；</strong></p>
<p><strong>请求转发：</strong></p>
<p>客户首先发送一个请求到服务器端，服务器端发现匹配的servlet，并指定它去执行，当这个servlet执行完之后，它要调用getRequestDispacther()方法，把请求转发给指定的student_list.jsp,整个流程都是在服务器端完成的，而且是在同一个请求里面完成的，因此servlet和jsp共享的是同一个request，在servlet里面放的所有东西，在student_list中都能取出来，因此，student_list能把结果getAttribute()出来，getAttribute()出来后执行完把结果返回给客户端。整个过程是一个请求，一个响应。</p>
<p><strong>重定向：</strong></p>
<p>客户发送一个请求到服务器，服务器匹配servlet，servlet处理完之后调用了sendRedirect()方法，立即向客户端返回这个响应，响应行告诉客户端你必须要再发送一个请求，去访问student_list.jsp，紧接着客户端收到这个请求后，立刻发出一个新的请求，去请求student_list.jsp,这里两个请求互不干扰，相互独立，在前面request里面setAttribute()的任何东西，在后面的request里面都获得不了。可见，在sendRedirect()里面是两个请求，两个响应。（服务器向浏览器发送一个302状态码以及一个location消息头，浏览器收到请求后会向再次根据重定向地址发出请求）</p>
<p><strong>转发：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;&#x2F;test.jsp&quot;).forward(request, response);</span><br></pre></td></tr></table></figure>

<p><strong>重定向：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(&quot;&#x2F;test.jsp&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>区别：</strong></p>
<p>1、请求次数：重定向是浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，转发是服务器收到请求后为了完成响应跳转到一个新的地址；重定向至少请求两次，转发请求一次；</p>
<p>2、地址栏不同：重定向地址栏会发生变化，转发地址栏不会发生变化；</p>
<p>3、是否共享数据：重定向两次请求不共享数据，转发一次请求共享数据（在request级别使用信息共享，使用重定向必然出错）；</p>
<p>4、跳转限制：重定向可以跳转到任意URL，转发只能跳转本站点资源；</p>
<p>5、发生行为不同：重定向是客户端行为，转发是服务器端行为；</p>
<p><strong>使用：</strong></p>
<p>1、可以利用request的域对象的特点，由源组件向其中存放写数据；</p>
<p>2、可以让用户访问到存放在WEB-INF目录中的目标资源；</p>
<p>3、重定向的速度比转发慢，因为浏览器还得发出一个新的请求，所以如果在使用转发和重定向都无所谓的时候建议使用转发；</p>
<p>4、因为转发只能访问当前WEB的应用程序，所以不同WEB应用程序之间的访问，特别是要访问到另外一个WEB站点上的资源的情况，这个时候就只能使用重定向了。</p>
<p>转发的时候你的地址栏内容不会变，发过去的请求也在，也就是说request中的内容没有改变，可以使用request进行值传递。而重定向的过程地址栏发生改变，你的请求也在重定向的时候丢失，原因是在第二次请求时，是再一次对服务器的访问，服务器会重写request内容。</p>
<table>
<thead>
<tr>
<th></th>
<th>转发</th>
<th>重定向</th>
</tr>
</thead>
<tbody><tr>
<td>请求次数</td>
<td>浏览器仅发送一次请求、一次响应</td>
<td>发送两次请求，两次响应</td>
</tr>
<tr>
<td>地址栏是否变化</td>
<td>地址栏不发生变化</td>
<td>地址栏变成重定向的地址</td>
</tr>
<tr>
<td>范围</td>
<td>只能转到本项目的Servlet或其他页面</td>
<td>能重定向到不只本项目的Servlet或者其他页面</td>
</tr>
<tr>
<td>实施及地址</td>
<td>是有服务器转发的，根目录为项目地址</td>
<td>是由浏览器再次请求，根目录是浏览器目录</td>
</tr>
</tbody></table>
<p><strong>用到重定向和转发时要注意的问题：</strong></p>
<p><strong>在做增删改请求操作的时候不可用转发，只能用重定向</strong></p>
<p><strong>原因：</strong>由于转发之后地址栏不变，请求（request）内容不变，再次刷新页面的时候，请求将再次发送，造成重复操作执行，造成错误。</p>
<p><strong>在做查询操作时，只能转发，不能使用重定向。</strong></p>
<p><strong>原因：</strong>重定向后请求会将原本的查询请求覆盖，刷新之后将得不到要查询的数据。</p>
<ol start="6">
<li>|管道和&gt;重定向有什么区别</li>
</ol>
<p>重定向是直接把输出转到文件去，重定向符号后面接文件</p>
<p>管道后面应该接的是命令，不是文件。管道左侧命令的输出作为管道右侧命令的输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左边的命令应该有标准输出|右边的命令应该接受标准输入</span><br><span class="line">左边的命令应该有标准输出&gt;右边只能是文件</span><br><span class="line">左边的命令应该有标准输入&lt;右边只能是文件</span><br></pre></td></tr></table></figure>

<p><strong><code>管道</code></strong>就是一个进程与另一个进程之间通信的通道，它通常是用作把一个进程的输出通过管道连接到另一个进程的输入。它是半双工运作的，想要同时双向传输需要使用两个管道。管道又可以分为匿名管道和命名管道，而<code>shell</code>中使用到的是匿名管道，例如命令<code>ls | grep main.c</code>，使用了管道来连接了两条命令来执行，能够快速地让我们知道当前目录下是否有 <code>main.c</code> 文件。</p>
<p>管道的本质是<strong>内存中的缓冲区</strong>，可以看作是打开到内存中的文件。所以需要使用两个文件描述符来索引它，一个表示<strong>读端</strong>，一个表示<strong>写端</strong>。并且规定，<strong>数据只能从读端读取、只能往写端写入</strong>。管道创建成功后，就可以直接使用 <code>read()</code>和 <code>write()</code>函数对管道进行数据的读写。而因为shell中都是使用标准输入输出对管道进行读写的，例如<code>ls | grep main.c</code>就是将 ls 的标准输出写到了管道写端，而 grep 的标准输入则从管道读端读取</p>
<p><strong>重定向</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">形式</span><br><span class="line">标准输入</span><br><span class="line">代码为 0 ,使用&lt;或&lt;&lt;</span><br><span class="line">标准输出</span><br><span class="line">代码为 1 ,使用 &gt;与1&gt;或 &gt;&gt;</span><br><span class="line">标准错误输出</span><br><span class="line">代码为 2 ,使用 2&gt;或 2&gt;&gt;</span><br><span class="line">&gt;与1&gt;相同,&gt;代表了默认是重定向标准输出</span><br><span class="line">1&gt;: 以覆盖的方法将『正确的数据』输出到指定的文件或装置上;</span><br><span class="line">1&gt;&gt;: 以累加的方法将『正确的数据』输出到指定的文件或装置上;</span><br><span class="line">2&gt;: 以覆盖的方法将『错误的数据』输出到指定的文件或装置上;</span><br><span class="line">2&gt;&gt;: 以累加的方法将『错误的数据』输出到指定的文件或装置上;</span><br><span class="line">总之两个代表追加..</span><br><span class="line">下面这句</span><br><span class="line">find &#x2F;home -name .bashrc &gt; list_right 2&gt; list_error</span><br><span class="line">将会将find执行结果保存,其中标准输出保存到list_right,错误输出保存到list_error,这两个文件:</span><br><span class="line">若不存在则创建</span><br><span class="line">若存在则覆盖</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>符号</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>&gt;</code></td>
<td>标准输出重定向</td>
</tr>
<tr>
<td><code>2&gt;</code></td>
<td>标准错误输出重定向</td>
</tr>
<tr>
<td><code>&gt;&amp;</code></td>
<td>标准输出与标准错误输出全部重定向</td>
</tr>
<tr>
<td><code>&gt;&amp;1</code></td>
<td>标准输出</td>
</tr>
<tr>
<td><code>&gt;&amp;2</code></td>
<td>标准错误输出</td>
</tr>
<tr>
<td><code>1&gt;&amp;2</code></td>
<td>将标准输出转成标准错误输出</td>
</tr>
<tr>
<td><code>2&gt;&amp;1</code></td>
<td>将标准错误输出转成标准输出</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>&gt;&gt;</code></td>
<td>追加标准输出重定向</td>
</tr>
<tr>
<td><code>2&gt;&gt;</code></td>
<td>追加标准错误输出重定向</td>
</tr>
<tr>
<td><code>&gt;&gt;&amp;</code></td>
<td>追加标准输出与标准错误输出全部重定向</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">command &gt; file</td>
<td align="left">将输出重定向到 file。</td>
</tr>
<tr>
<td align="left">command &lt; file</td>
<td align="left">将输入重定向到 file。</td>
</tr>
<tr>
<td align="left">command &gt;&gt; file</td>
<td align="left">将输出以追加的方式重定向到 file。</td>
</tr>
<tr>
<td align="left">n &gt; file</td>
<td align="left">将文件描述符为 n 的文件重定向到 file。</td>
</tr>
<tr>
<td align="left">n &gt;&gt; file</td>
<td align="left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td>
</tr>
<tr>
<td align="left">n &gt;&amp; m</td>
<td align="left">将输出文件 m 和 n 合并。</td>
</tr>
<tr>
<td align="left">n &lt;&amp; m</td>
<td align="left">将输入文件 m 和 n 合并。</td>
</tr>
<tr>
<td align="left">&lt;&lt; tag</td>
<td align="left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>
</tr>
</tbody></table>
<p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ command &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>vi命令</li>
</ol>
<p>L ：光标移至屏幕最后行</p>
<h2 id="（十五）快手"><a href="#（十五）快手" class="headerlink" title="（十五）快手"></a>（十五）快手</h2><ol>
<li><p>容器的选择：<a href="https://blog.csdn.net/gogokongyin/article/details/51178378" target="_blank" rel="noopener">vector/deque/list的差别</a></p>
<p>1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector<br>2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list<br>3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。</p>
</li>
<li><p>vector自定义类的要求</p>
</li>
</ol>
<p>自定义的类必须有默认构造函数，因为vector会调用默认构造函数来初始化元素的对象。编译器隐式声明默认构造函数的条件：</p>
<p>· 该类没有显式声明任何构造函数。</p>
<p>· 数据成员中没有const和reference。–因为要初始化，凡是有引用类型的成员变量或者常量类型的变量的类，不能有缺省构造函数。默认构造函数没有对引用成员提供默认的初始化机制，也因此造成引用未初始化的编译错误。并且必须使用初始化列表进行初始化const对象、引用对象。</p>
<p>满足则隐式生成默认构造函数。这里强调“任何”，是指即使用户自定义了复制构造函数或一个需要多个参数的构造函数，默认构造函数也不会被隐式声明了。在定义一个类时要保证有默认的构造函数。同时要求：<br>   1、Copy构造函数：<a href="https://www.jianshu.com/p/025ae7b51ca8" target="_blank" rel="noopener">原理</a><br>   2、赋值=操作符<br>   3、能够销毁对象的析构函数<br>  另外：<br>   1、可用的缺省构造函数，序列型容器必须，用于初始化元素<br>   2、==操作符定义，用于判断相等<br>   3、&lt;操作符定义，关联型容器必须，用于缺省排序</p>
<ol start="3">
<li>程序状态字PSW(Program Status Word)</li>
</ol>
<p>指在电脑中，一段包含被<a href="https://baike.so.com/doc/5354536-5590000.html" target="_blank" rel="noopener">操作系统</a>和潜在<a href="https://baike.so.com/doc/2368908-2504815.html" target="_blank" rel="noopener">硬件</a>使用的程序状态信息的<a href="https://baike.so.com/doc/176561-186541.html" target="_blank" rel="noopener">内存</a>或<a href="https://baike.so.com/doc/2368908-2504815.html" target="_blank" rel="noopener">硬件</a>区域。一般用一个专门的寄存器来指示处理器状态。在计算机系统中，表明系统运行状态的部件是<strong>程序状态字</strong>。</p>
<p>程序状态字PSW(Program Status Word)包括的状态位有<strong>进位标志位(CF)</strong>、<strong>结果为零标志位(ZF)</strong>、<strong>符号标志位(SF)</strong>、<strong>溢出标志位(OF)</strong>、<strong>陷阱标志位(TF)</strong>、<strong>中断使能(中断屏蔽)标志位(IF)</strong>、<strong>虚拟中断标志位(VIF)</strong>、<strong>虚拟中断待决标志位(VIP)</strong>、<strong>I0特权级别(IOPL)</strong>。</p>
<ol start="4">
<li>类型变量所占字节数</li>
</ol>
<table>
<thead>
<tr>
<th>算术类型</th>
<th>32</th>
<th>64</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>char</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>char*</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>8</td>
</tr>
</tbody></table>
<p>指针类型存储的是所指向变量的地址，所以32位机器只需要32bit，而64位机器需要64bit。数据类型占内存的位数实际上与操作系统的位数和编译器（不同编译器支持的位数可能有所不同）都有关，具体某种数据类型占字节数需要编译器根据操作系统位数间进行协调好后分配内存大小。</p>
<h3 id="c-工程师-AI平台"><a href="#c-工程师-AI平台" class="headerlink" title="c++工程师-AI平台"></a>c++工程师-AI平台</h3><ol>
<li>智能指针  控制块（在堆里）有两个引用计数：强引用计数（ shared_ptr）  弱引用计数（weak_ptr）   分配器、删除器等</li>
<li><a href="https://www.jianshu.com/p/594357dff57e" target="_blank" rel="noopener">压栈</a>    <a href="https://www.zhihu.com/question/22444939" target="_blank" rel="noopener">编译器做了什么</a></li>
<li>虚函数内存构造   虚函数表在哪存储</li>
</ol>
<p>C++中<strong>虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。</strong></p>
<ol start="4">
<li>tcp/udp的区别  http如何基于tcp还是udp<br>MTU:以太网帧的最大长度，MTU一般为1500<br>MSS：TCP数据报文中数据段的最大长度<br>MSS=MTU-20字节TCP报头-20字节IP报头</li>
</ol>
<p>MSS是TCP报文中数据段的最大长度，前面说了可以是无限的，为什么又冒出个MSS呢？</p>
<p>其实这是考虑到传输的效率，每次传送的数据最大长度太小会增加开销，显然；太大的话在IP层要进行分片，终点时要重组，出错还要重传，所以都会增加开销。因此要合理选择一个最大报文长度，原则是尽可能大，只要到IP层不用分片即可。而IP数据包所经历的路径是动态变化的，因此不同路径上最大不用分片的MSS不同。一般情况下，在建立连接的时候告诉对方自己的MSS，若未填写，则默认为536字节。<br>一般情况下MSS取值使得以太网帧恰好不超过MTU，即若不考虑TCP和IP报文头的可选字段，则MSS与MTU的差值为40，即MSS=MTU-20字节TCP报头-20字节IP报头，那么在以太网环境下，MSS值一般就是1500-20-20=1460字节。</p>
<ol start="5">
<li>switch跳转表  if<br>swtich case在流程众多的时候，编译器会引入跳转表这一数据结构对汇编进行优化，而不是jmp进入每一分支进行逻辑判断.</li>
</ol>
<blockquote>
<p>跳转表是一个数组，表项i是一个代码段的地址，这个代码段实现<strong>当开关索引值等于i时程序应该采取的动作</strong>。程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。和使用一个很长的if else相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。GCC根据开关情况的数量和开关情况的稀疏程度来翻译开关语句。当开关情况<strong>数量较多，并且值的跨度范围比较小</strong>时，就会使用跳转表。</p>
<p>switch语句会将跳转地址按顺序排在数组中，以传入的值为下标，取出数组里的数据，跳转到此地址执行代码，且有一条单独的ja xxxxxxxx语句跳转到default。如果case的数字从0开始且连续，则满足此理想情况。如果case里的值较大，则减去某个值修剪一下。如果case值有间隔但又不算太大，则将对应的“空隙”填充为default的跳转地址。</p>
</blockquote>
<ol start="6">
<li>进程是cpu单独给分配地址空间和资源，但是线程才是cpu的执行单位</li>
</ol>
<p>[密码强度检测]<br>编写一个检查给定字符串是否为安全密码的函数，函数原型为<br>bool IsSafePassword(const char* s);</p>
<p>输入:</p>
<ol>
<li><p>s是以\0结尾的标准c字符串，且不为空串</p>
</li>
<li><p>s中仅可能出现下面的字符<br>1)大写字母 A到Z<br>2)小写字母 a到z<br>3)数字 0-9<br>4)以下5个特殊字符<br>@ # $ &amp; _</p>
</li>
</ol>
<p>输出:<br>如果密码长度大于等于8，并且至少包含大写字母/小写字母/数字/特殊字符中任意三种，返回true<br>其他情况，返回false</p>
<p>限制:<br>只可以使用strcpy,strlen,strcmp,memcpy,strchr这几个标准库函数，也不能使用除了int，char，bool，float以外的其他数据类型</p>
<p>注意:<br>本题主要是为了考察候选人对编程语言的理解程度和思维的灵活度，所以代码编写上请力求简洁高效，不要考虑注释，编码风格和可维护性，可复用性等问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSafePassword</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> level=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p=s;*p!=<span class="string">'\0'</span>;p++)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(*p))&#123;</span><br><span class="line">            level|=(<span class="number">1</span>&lt;&lt;<span class="number">2</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*p&gt;=<span class="string">'A'</span>&amp;&amp;*p&lt;=<span class="string">'Z'</span>)</span><br><span class="line">           level|=<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*p&gt;=<span class="string">'a'</span>&amp;&amp;*p&lt;=<span class="string">'z'</span>)</span><br><span class="line">           level|=(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*p==<span class="string">'@'</span>||*p==<span class="string">'#'</span>)</span><br><span class="line">           used[<span class="number">3</span>]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span></span><br><span class="line">    <span class="keyword">return</span> len&gt;=<span class="number">8</span>&amp;&amp;(level==<span class="number">7</span>||level==<span class="number">11</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int a;</span></span><br><span class="line">    <span class="comment">//cin &gt;&gt; a;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二面</p>
<ol>
<li><p>智能指针</p>
</li>
<li><p>消息同步 </p>
</li>
<li><p>volatile</p>
</li>
<li><p>使用new/delete如何避免内存泄漏</p>
</li>
</ol>
<p>RAII是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。</p>
<p><strong>如果把资源用类进行封装起来，对资源操作都封装在类的内部，在构造函数new分配资源，在析构函数中进行delete释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。</strong></p>
<ol start="5">
<li>MVC</li>
</ol>
<p><a href="https://baike.baidu.com/item/MVC" target="_blank" rel="noopener">MVC</a>全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p>
<p><strong>Model（模型）</strong>是应用程序中用于处理应用程序数据逻辑的部分。<br>　　通常模型对象负责在数据库中存取数据。</p>
<p><strong>View（视图）</strong>是应用程序中处理数据显示的部分。<br>　　通常视图是依据模型数据创建的。</p>
<p><strong>Controller（控制器）</strong>是应用程序中处理用户交互的部分。<br>　　通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</p>
<p>MVC开始是存在于桌面程序中的，M是指业务模型，V是指<a href="https://baike.baidu.com/item/用户界面" target="_blank" rel="noopener">用户界面</a>，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。比如一批统计数据可以分别用<a href="https://baike.baidu.com/item/柱状图" target="_blank" rel="noopener">柱状图</a>、<a href="https://baike.baidu.com/item/饼图" target="_blank" rel="noopener">饼图</a>来表示。C存在的目的则是确保M和V的同步，一旦M改变，V应该同步更新。</p>
<p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<p>Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。<br>View（视图） - 视图代表模型包含的数据的可视化。<br>Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleBuffer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CircleBuffer(<span class="keyword">int</span> val):n(val),index(<span class="number">0</span>)&#123;</span><br><span class="line">        a=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=n)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        a[index++]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    ~CircleBuffer()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] a;</span><br><span class="line">        a=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span>* a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int a;</span></span><br><span class="line">    <span class="comment">//cin &gt;&gt; a;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="（十六）猿辅导"><a href="#（十六）猿辅导" class="headerlink" title="（十六）猿辅导"></a>（十六）猿辅导</h2><ol>
<li><p>static    static const  函数不能是static const<br>不能同时用const和static修饰成员函数:<br>const修饰的函数表示在该函数体内不能修改成员的值，会在函数中添加一个隐式的参数const this*.<br>static修饰的函数没有this指针，与const的用法冲突。<br>static const = const static能修饰数据成员变量</p>
</li>
<li><p>new 和 malloc</p>
</li>
<li><p>进程和线程   单核cpu有多线程的必要吗<br>处理器的数量和并不影响程序结构, 所以不管处理器的个数多少, 程序都可以通过使用多线程得到简化. 而且, 即使多线程程序在串行化任务上不得不阻塞, 由于某些线程在阻塞的时候还有另一些线程可以运行, 所以多线程程序在单处理器上运行还是可以改善响应时间和吞吐量.</p>
</li>
<li><p>pc 和 android开发网络这块有什么不同<br>手机要考虑网络容易异常中断（进电梯，突然断网等）<br>数据流量和wifi处理相同，都是获取network权限。</p>
</li>
<li><p>传感器权限怎么添<br><a href="https://blog.csdn.net/xiayu98020214/article/details/8702722?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-3-8702722.nonecase&utm_term=android%20%E8%8E%B7%E5%8F%96%E9%99%80%E8%9E%BA%E4%BB%AA%E6%9D%83%E9%99%90" target="_blank" rel="noopener">SENSOR_ENABLE SENSOR_INFO</a><br><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/sensor.png" alt></p>
</li>
<li><p>散列表就是哈希表<br>冲突的处理方式也有很多，下面介绍几种。</p>
</li>
</ol>
<p>（1）开放地址法（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。</p>
<p>（2）再哈希法：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</p>
<p>（3）链地址法：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的，我们会在后面着重学习这种方式。</p>
<p>（4）建立一个公共溢出区：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。</p>
<ol start="7">
<li>扑克牌顺子<br>限定语言：Javascript_V8、Python、C++、Javascript、Php、C#、Java<br>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsContinuous( vector&lt;int&gt; numbers ) &#123;</span><br><span class="line">        if(numbers.size()&#x3D;&#x3D;0)return false;</span><br><span class="line">        vector&lt;int&gt; fren(14,0);</span><br><span class="line">        int minval&#x3D;INT32_MAX;</span><br><span class="line">        for(int i&#x3D;0;i&lt;numbers.size();i++)&#123;</span><br><span class="line">            fren[numbers[i]]++;</span><br><span class="line">            if(numbers[i]!&#x3D;0&amp;&amp;fren[numbers[i]]&gt;1)</span><br><span class="line">                return false;</span><br><span class="line">            if(numbers[i]!&#x3D;0&amp;&amp;minval&gt;numbers[i])</span><br><span class="line">                minval&#x3D;numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int zerocnt&#x3D;fren[0];</span><br><span class="line">        int size&#x3D;0;</span><br><span class="line">        for(int i&#x3D;minval;i&lt;14&amp;&amp;size&lt;numbers.size();i++)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            if(fren[i]&#x3D;&#x3D;0)&#123;</span><br><span class="line">                zerocnt--;</span><br><span class="line">                if(zerocnt&lt;0)</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3></li>
<li>了解的设计模式 mvc是设计模式吗</li>
<li>单核有必要多线程没  有必要</li>
<li>引用和指针的区别</li>
<li>反转单链表 M 到 N 之间节点。</li>
</ol>
<p>input：<br>0123456789<br>M：3 N：9<br>（3，9]<br>output:<br>0123987654</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;一定要考虑m为负数和n大于节点个数的情况</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(int value)&#123;</span><br><span class="line">        val&#x3D;value;</span><br><span class="line">        next&#x3D;nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ListNode* rever(ListNode* head,int m,int n)&#123;</span><br><span class="line">    if(m&lt;0)m&#x3D;-1;</span><br><span class="line">    ListNode* cur&#x3D;head;</span><br><span class="line">    ListNode* pre&#x3D; nullptr;</span><br><span class="line">    for(int i&#x3D;0;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        pre&#x3D;cur;</span><br><span class="line">        cur&#x3D;cur-&gt;next;</span><br><span class="line">        if(cur&#x3D;&#x3D; nullptr)</span><br><span class="line">            return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* con&#x3D;pre;</span><br><span class="line">    ListNode* tail&#x3D;cur;</span><br><span class="line">    ListNode* nextListNode;</span><br><span class="line">    for(;m&lt;n;m++)&#123;</span><br><span class="line">        nextListNode&#x3D;cur-&gt;next;</span><br><span class="line">        cur-&gt;next&#x3D;pre;</span><br><span class="line">        pre&#x3D;cur;</span><br><span class="line">        cur&#x3D;nextListNode;</span><br><span class="line">        if(cur&#x3D;&#x3D; nullptr)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(con!&#x3D; nullptr)</span><br><span class="line">        con-&gt;next&#x3D;pre;</span><br><span class="line">    else</span><br><span class="line">        head&#x3D;pre;</span><br><span class="line">    tail-&gt;next&#x3D;cur;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;int a;</span><br><span class="line">    &#x2F;&#x2F;cin &gt;&gt; a;</span><br><span class="line">    ListNode* zero&#x3D;new ListNode(0);</span><br><span class="line">    ListNode* one&#x3D;new ListNode(1);</span><br><span class="line">    ListNode* two&#x3D;new ListNode(2);</span><br><span class="line">    ListNode* three&#x3D;new ListNode(3);</span><br><span class="line">    ListNode* four&#x3D;new ListNode(4);</span><br><span class="line">    ListNode* five&#x3D;new ListNode(5);</span><br><span class="line">    ListNode* six&#x3D;new ListNode(6);</span><br><span class="line">    ListNode* seven&#x3D;new ListNode(7);</span><br><span class="line">    ListNode* eight&#x3D;new ListNode(8);</span><br><span class="line">    ListNode* nine&#x3D;new ListNode(9);</span><br><span class="line">    zero-&gt;next&#x3D;one;</span><br><span class="line">    one-&gt;next&#x3D;two;</span><br><span class="line">    two-&gt;next&#x3D;three;</span><br><span class="line">    three-&gt;next&#x3D;four;</span><br><span class="line">    four-&gt;next&#x3D;five;</span><br><span class="line">    five-&gt;next&#x3D;six;</span><br><span class="line">    six-&gt;next&#x3D;seven;</span><br><span class="line">    seven-&gt;next&#x3D;eight;</span><br><span class="line">    eight-&gt;next&#x3D;nine;</span><br><span class="line">    ListNode* n&#x3D;rever(zero, -2,12);</span><br><span class="line">    while(n!&#x3D;nullptr)&#123;</span><br><span class="line">        cout&lt;&lt;n-&gt;val&lt;&lt;&quot; &quot;;</span><br><span class="line">        n&#x3D;n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（十七）阿里"><a href="#（十七）阿里" class="headerlink" title="（十七）阿里"></a>（十七）阿里</h2><ol>
<li>可以用数据结构红黑树/哈希表存储五万个数查询是否存在x</li>
<li>数据量众多，哈希表地址冲突怎么办 可以直接添加链表等</li>
<li>c++新特性</li>
<li>虚函数</li>
<li>数组和链表的区别  单向链表 双向链表</li>
<li>析构函数 private  堆栈</li>
<li>二叉树的建立  存储结构</li>
<li>如何用vector实现队列 <ul>
<li>deque的内存模型：指针数组+vector  </li>
<li>简易实现可以使用int值记录头和尾下标 </li>
</ul>
</li>
<li>static和const的区别</li>
</ol>
<ul>
<li>const定义的常量在超出其作用域之后其空间会被释放。存储在动态区，可以通过取址直接操作指向的内存的值，以绕过编译器对其只读的限制检查；而static定义的静态常量在函数执行后不会释放其存储空间。static修饰的变量作为程序运行时的静态变量，存储于内存的静态区，静态区的数据初始化工作由操作系统在加载完程序后执行main函数前进行。操作系统在加载完程序后，将常量区中存放的变量初值复制给静态变量，完成其初始化。static变量的内存只被分配一次，其值在下次调用时仍维持上次的值。</li>
<li>static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化；static关键字只能用于类定义体内部的声明中，定义时不能标示为static。</li>
<li>const成员变量也不能在类定义处初始化，只能通过</li>
<li>初始化列表进行，并且必须有构造函数，运行期间将不能再对const属性进行修改。</li>
</ul>
<p><strong>const成员函数主要目的是防止成员函数修改对象的内容。</strong>const成员函数不能修改成员变量的值，但可以访问成员变量。</p>
<p><strong>static成员函数主要目的是作为类作用域的全局函数。</strong>不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致：1、不能直接存取类的非静态成员变量，调用非静态成员函数2、不能被声明为virtual</p>
<p>*<em>static const 和 const static *</em>含义相同，有两种用法，一种是作为预编译声明，一种是作为类的静态常量属性。当作为预编译声明时，static const 属性必须在声明时即指定值，而且类型仅限基本数据类型，保证了程序的健壮性。const static常量存在于内存的常量区，有操作系统加载程序时，加载到内存的常量区。所以可以对其取址，但是不能对该区的内存进行写操作，因为这个区从操作系统级进行了只读限定，任何对该内存区的写操作会导致程序崩溃。</p>
<h2 id="（十八）华为"><a href="#（十八）华为" class="headerlink" title="（十八）华为"></a>（十八）华为</h2><ol>
<li>std::thread  线程的启动  线程库</li>
<li>MySQL内联和外联</li>
<li>给定一个字符串  找出出现频率最高的字符  频率相同比较index小的  输出第一个值</li>
<li>单例的安全性</li>
</ol>
<h3 id="正式批"><a href="#正式批" class="headerlink" title="正式批"></a>正式批</h3><ol>
<li>线程切换过程   </li>
</ol>
<p>内核级线程切换只能在内核态完成，线程切换时，必然需要将旧线程的<code>task_struct</code>从内核切出，将新线程的切入，带来上下文切换。除此之外，还需要切换寄存器、程序计数器、线程栈（包括操作栈、数据栈）等；用户级线程如果是不同进程中线程的切换，则必然引起用户态与内核态的切换，如果是同一进程中的线程切换，则不需转换到内核空间，可直接由线程库管理。</p>
<ol start="2">
<li><p>编译：词法分析  语法分析  语义分析   中间代码生成和优化   目标代码生成和优化   生成可执行文件</p>
</li>
<li><p>程序编译，链接过程</p>
<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>C语言的编译链接过程要把我们编写的一个c程序（源代码）转换成可以在硬件上运行的程序（可执行代码），需要进行编译和链接。<strong>编译就是把文本形式源代码翻译为机器语言形式的目标文件的过程。链接是把目标文件、操作系统的启动代码和用到的库文件进行组织形成最终生成可加载、可执行代码的过程</strong>。</p>
</li>
<li><p>预处理器：将.c 文件转化成 .i文件，使用的gcc命令是：gcc –E，对应于预处理命令cpp；</p>
</li>
<li><p>编译器：将.c/.h文件转换成.s文件，使用的gcc命令是：gcc –S，对应于编译命令 cc –S；</p>
</li>
<li><p>汇编器：将.s 文件转化成 .o文件，使用的gcc 命令是：gcc –c，对应于汇编命令是 as；</p>
</li>
<li><p>链接器：将.o文件转化成可执行程序，使用的gcc 命令是： gcc，对应于链接命令是 ld；</p>
</li>
<li><p>加载器：将可执行程序加载到内存并进行执行，loader和ld-linux.so。</p>
</li>
</ol>
<h4 id="二、编译过程"><a href="#二、编译过程" class="headerlink" title="二、编译过程"></a>二、编译过程</h4><p>编译过程又可以分成两个阶段：编译和汇编。</p>
<p>2.1编译<br>编译是指编译器读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码。</p>
<p>源文件的编译过程包含两个主要阶段：</p>
<p>第一个阶段是预处理阶段，在正式的编译阶段之前进行。预处理阶段将根据已放置在文件中的预处理指令来修改源文件的内容。</p>
<p>主要是以下几方面的处理：</p>
<p>宏定义指令，如 #define a b 对于这种伪指令，预编译所要做的是将程序中的所有a用b替换，但作为字符串常量的 a则不被替换。还有 #undef，则将取消对某个宏的定义，使以后该串的出现不再被替换。<br>条件编译指令，如#ifdef，#ifndef，#else，#elif，#endif等。 这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉<br>头文件包含指令，如#include “FileName”或者#include 等。 该指令将头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。<br>特殊符号，预编译程序可以识别一些特殊的符号。 例如在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。<br>头文件的目的主要是为了使某些定义可以供多个不同的C源程序使用，这涉及到头文件的定位即搜索路径问题。头文件搜索规则如下：</p>
<p>所有header file的搜寻会从-I开始<br>然后找环境变量 C_INCLUDE_PATH,CPLUS_INCLUDE_PATH,OBJC_INCLUDE_PATH指定的路径<br>再找默认目录(/usr/include、/usr/local/include、/usr/lib/gcc-lib/i386-linux/2.95.2/include……)</p>
<p>第二个阶段编译、优化阶段，编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。 </p>
<p>2.2汇编<br>汇编实际上指汇编器(as)把汇编语言代码翻译成目标机器指令的过程。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。目标文件由段组成。通常一个目标文件中至少有两个段：</p>
<p>代码段：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。<br>数据段：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。</p>
<p>2.3目标文件(Executable and Linkable Format)<br>可重定位(Relocatable)文件：由编译器和汇编器生成，可以与其他可重定位目标文件合并创建一个可执行或共享的目标文件；<br>共享(Shared)目标文件：一类特殊的可重定位目标文件，可以在链接(静态共享库)时加入目标文件或加载时或运行时(动态共享库)被动态的加载到内存并执行；<br>可执行(Executable)文件：由链接器生成，可以直接通过加载器加载到内存中充当进程执行的文件。</p>
<p>2.4 静态库与动态库<br>静态库（static library）就是将相关的目标模块打包形成的单独的文件。使用ar命令。</p>
<p>静态库的优点在于：</p>
<p>程序员不需要显式的指定所有需要链接的目标模块，因为指定是一个耗时且容易出错的过程；<br>链接时，连接程序只从静态库中拷贝被程序引用的目标模块，这样就减小了可执行文件在磁盘和内存中的大小。<br>动态库(dynamic library)是一种特殊的目标模块，它可以在运行时被加载到任意的内存地址，或者是与任意的程序进行链接。</p>
<p>动态库的优点在于：</p>
<p>更新动态库，无需重新链接；对于大系统，重新链接是一个非常耗时的过程；<br>运行中可供多个程序使用，内存中只需要有一份，节省内存。</p>
<h4 id="三、链接过程"><a href="#三、链接过程" class="headerlink" title="三、链接过程"></a>三、链接过程</h4><p><strong>链接器主要是将有关的目标文件彼此相连接生成可加载、可执行的目标文件。链接器的核心工作就是符号表解析和重定位</strong>。</p>
<p>3.1 链接的时机：<br>编译时，就是源代码被编译成机器代码时（静态链接器负责）；<br>加载时，也就是程序被加载到内存时（加载器负责）；<br>运行时，由应用程序来实施（动态链接器负责）。<br>3.2 链接的作用（软件复用）：<br>使得分离编译成为可能；<br>动态绑定(binding):使定义���实现、使用分离<br>3.3 静态库搜索路径(由静态链接器负责)<br>gcc先从-L寻找；<br>再找环境变量LIBRARY_PATH指定的搜索路径；<br>再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的。<br>3.4 动态库搜索路径(由动态链接器负责)<br>编译目标代码时指定的动态库搜索路径-L；<br>环境变量LD_LIBRARY_PATH指定的动态库搜索路径；<br>配置文件/etc/ld.so.conf中指定的动态库搜索路径；<br>默认的动态库搜索路径/lib /usr/lib/ /usr/local/lib<br>3.5 静态链接（编译时）<br>链接器将函数的代码从其所在地（目标文件或静态链接库中）拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。</p>
<h4 id="为创建可执行文件，链接器必须要完成的主要任务"><a href="#为创建可执行文件，链接器必须要完成的主要任务" class="headerlink" title="为创建可执行文件，链接器必须要完成的主要任务"></a>为创建可执行文件，链接器必须要完成的主要任务</h4><ol>
<li><strong>符号解析：把目标文件中符号的定义和引用联系起来</strong>;</li>
<li><strong>重定位：把符号定义和内存地址对应起来，然后修改所有对符号的引用</strong>。</li>
</ol>
<p>3.6 动态链接（加载、运行时）<br>在此种方式下，函数的定义在动态链接库或共享对象的目标文件中。在编译的链接阶段，动态链接库只提供符号表和其他少量信息用于保证所有符号引用都有定义，保证编译顺利通过。动态链接器(ld-linux.so)链接程序在运行过程中根据记录的共享对象的符号定义来动态加载共享库，然后完成重定位。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。  </p>
<h4 id="四、加载过程"><a href="#四、加载过程" class="headerlink" title="四、加载过程"></a>四、加载过程</h4><p>加载器把可执行文件从外存加载到内存并进行执行。 </p>
<p>加载器首先创建如上图所示的内存映像，然后根据段头部表，把目标文件拷贝到内存的数据和代码段中。然后，加载器跳转到程序入口点（即符号_start 的地址），执行启动代码（startup code）</p>
<ol start="4">
<li><p>GDB调试线程   线程core dump问题怎么解决  线程死锁怎么解决（编程过程中）<br>查看core日志<br><a href="https://blog.csdn.net/shixin_0125/article/details/72805665" target="_blank" rel="noopener">GDB调试core dump</a><br><a href="https://blog.csdn.net/lixiaogang_theanswer/article/details/90675394?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">GDB调试多线程死锁</a></p>
</li>
<li><p>怎么处理消息传输的同步异步问题</p>
</li>
<li><p>机试题目哪里有问题</p>
</li>
<li><p>项目可以用读写锁  优化互斥锁   项目用的是条件变量-信号机制通知</p>
</li>
<li><p>自旋锁   sleep 没有释放锁，其他线程不能占用cpu</p>
</li>
</ol>
<p>wait  释放锁，线程被阻塞，等待被唤醒<br>生产者消费者可用读写锁和循环队列优化</p>
<ol start="9">
<li>手撕memmove源码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">memmove</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">char</span>* source,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dest==source)&#123;</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dest&lt;source&amp;&amp;dest+n&gt;source)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dest[i]=source[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dest&gt;source&amp;&amp;source+n&gt;dest)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dest[i]=source[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(dest,source,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>数组的度就是数组中数的最大频率，找出与数组的度相等的最短子数组的元素</li>
</ol>
<p>eg:输入：1,2,1,3，4，2</p>
<p>输出：1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; nmap;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; leftright;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nmap.count(nums[i]))&#123;</span><br><span class="line">            leftright[nums[i]].first=i;</span><br><span class="line">            leftright[nums[i]].second=i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            leftright[nums[i]].second=i;</span><br><span class="line">        &#125;</span><br><span class="line">        nmap[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxfren=INT32_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n:nmap)&#123;</span><br><span class="line">        maxfren=<span class="built_in">max</span>(maxfren,n.second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minlen=INT32_MAX;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; m:leftright)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nmap[m.first]==maxfren)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.second.second-m.second.first+<span class="number">1</span>&lt;minlen)&#123;</span><br><span class="line">                minlen=m.second.second-m.second.first+<span class="number">1</span>;</span><br><span class="line">                num=m.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表+双指针</span></span><br><span class="line"><span class="comment">//双指针法，首先扫描一遍求出数组的额度，然后用哈希表维护一个双指针指向的区间。如果右侧元素进入导致某个树出现的次数和度相等。</span></span><br><span class="line"><span class="comment">//那么就不断挪动左侧指针，使得右侧元素能够保持这个度的最小区间。 然后维护这个最小值即可。</span></span><br><span class="line"><span class="comment">//时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxSub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; nmap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        nmap[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxfren=INT32_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n:nmap)&#123;</span><br><span class="line">        maxfren=<span class="built_in">max</span>(maxfren,n.second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">int</span> minlen=INT32_MAX;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()&amp;&amp;j&lt;nums.<span class="built_in">size</span>();)&#123;</span><br><span class="line">        tmp[nums[j]]++;</span><br><span class="line">        <span class="keyword">if</span>(tmp[nums[j]]==maxfren)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=j&amp;&amp;tmp[nums[j]]==maxfren)&#123;</span><br><span class="line">                tmp[nums[i]]--;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minlen&gt;j-i+<span class="number">2</span>)&#123;</span><br><span class="line">                minlen=j-i+<span class="number">2</span>;</span><br><span class="line">                num=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串分隔符分隔和定义比较函数"><a href="#字符串分隔符分隔和定义比较函数" class="headerlink" title="字符串分隔符分隔和定义比较函数"></a>字符串分隔符分隔和定义比较函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> s,<span class="keyword">int</span> n):name(s),cnt(n)&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"><span class="comment">//直接在类内重载&lt;运算符</span></span><br><span class="line"><span class="comment">//    bool operator&lt; (const Person&amp; two) const&#123;//一定要加const</span></span><br><span class="line"><span class="comment">//        if(cnt==two.cnt)&#123;</span></span><br><span class="line"><span class="comment">//            if(name.find(two.name)||two.name.find(name))</span></span><br><span class="line"><span class="comment">//                return name.length()&lt;two.name.length();</span></span><br><span class="line"><span class="comment">//            else</span></span><br><span class="line"><span class="comment">//                return name&lt;two.name;</span></span><br><span class="line"><span class="comment">//        &#125; else</span></span><br><span class="line"><span class="comment">//            return cnt&gt;two.cnt;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类外设计比较函数类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Isshort</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//一定要加public，不然编译不过去</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; one,<span class="keyword">const</span> Person&amp; two)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(one.cnt==two.cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(one.name.<span class="built_in">find</span>(two.name)||two.name.<span class="built_in">find</span>(one.name))</span><br><span class="line">                <span class="keyword">return</span> one.name.length()&lt;two.name.length();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> one.name&lt;two.name;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> one.cnt&gt;two.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getStar</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &amp;str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; people;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> per:str)&#123;</span><br><span class="line">        people.emplace_back(per.first,per.second);</span><br><span class="line">    &#125;</span><br><span class="line">   sort(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>(),Isshort());</span><br><span class="line"><span class="comment">//在函数上直接添加lamda表达式</span></span><br><span class="line"><span class="comment">//       [](const Person &amp;one,const Person&amp; p)&#123;</span></span><br><span class="line"><span class="comment">//        if(one.cnt==p.cnt)&#123;</span></span><br><span class="line"><span class="comment">//            if(one.name.find(p.name)||p.name.find(one.name))</span></span><br><span class="line"><span class="comment">//                return one.name.length()&lt;p.name.length();</span></span><br><span class="line"><span class="comment">//            else</span></span><br><span class="line"><span class="comment">//                return one.name&lt;p.name;</span></span><br><span class="line"><span class="comment">//        &#125; else</span></span><br><span class="line"><span class="comment">//            return one.cnt&gt;p.cnt;</span></span><br><span class="line"><span class="comment">//    &#125;);</span></span><br><span class="line">    <span class="keyword">return</span> (*people.cbegin()).name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; str;</span><br><span class="line"><span class="comment">//这样输入无法正常停止，遇见'.'或者换行符'\n'或者结束符'EOF'才能停止</span></span><br><span class="line"><span class="comment">//    while(getline(cin,s,','))&#123;</span></span><br><span class="line"><span class="comment">//        if(s=="\n")</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line"><span class="comment">//        if(s[0]&lt;'A'||s[0]&gt;'Z')&#123;</span></span><br><span class="line"><span class="comment">//            cout&lt;&lt;00001&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        for(int i=1;i&lt;s.size();i++)&#123;</span></span><br><span class="line"><span class="comment">//            if(s[i]&lt;'a'||s[i]&gt;'z')&#123;</span></span><br><span class="line"><span class="comment">//                cout&lt;&lt;00001&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if(str.count(s))</span></span><br><span class="line"><span class="comment">//            str[s]++;</span></span><br><span class="line"><span class="comment">//        else</span></span><br><span class="line"><span class="comment">//            str[s]=1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="comment">//字符串分隔符的两种办法find和strtok</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* delim=<span class="keyword">new</span> <span class="keyword">char</span>(<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">char</span>* data=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(s.<span class="built_in">size</span>()* <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    copy(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),data);</span><br><span class="line">    <span class="keyword">char</span>* per=strtok(data,delim);</span><br><span class="line">    <span class="keyword">while</span>(per!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*per&lt;<span class="string">'A'</span>||*per&gt;<span class="string">'Z'</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">00001</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p=per+<span class="number">1</span>;*p!=<span class="string">'\0'</span>;p++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*p&lt;<span class="string">'a'</span>||*p&gt;<span class="string">'z'</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="number">00001</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str.count(per))</span><br><span class="line">            str[per]++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            str[per]=<span class="number">1</span>;</span><br><span class="line">        per=strtok(<span class="literal">NULL</span>,delim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    for(auto start=s.begin();start&lt;=s.end();)&#123;</span></span><br><span class="line"><span class="comment">//        auto it=find(start,s.end(),',');</span></span><br><span class="line"><span class="comment">//        auto per=s.substr(start-s.begin(),it-start);</span></span><br><span class="line"><span class="comment">//        if(per[0]&lt;'A'||per[0]&gt;'Z')&#123;</span></span><br><span class="line"><span class="comment">//            cout&lt;&lt;00001&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        for(int i=1;i&lt;per.size();i++)&#123;</span></span><br><span class="line"><span class="comment">//            if(per[i]&lt;'a'||per[i]&gt;'z')&#123;</span></span><br><span class="line"><span class="comment">//                cout&lt;&lt;00001&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if(str.count(per))</span></span><br><span class="line"><span class="comment">//            str[per]++;</span></span><br><span class="line"><span class="comment">//        else</span></span><br><span class="line"><span class="comment">//            str[per]=1;</span></span><br><span class="line"><span class="comment">//        start=it+1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:str)&#123;</span><br><span class="line">        sum+=p.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&lt;=<span class="number">0</span>||sum&gt;=<span class="number">100</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">00001</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> star=getStar(str);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; star&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="（十九）腾讯测开"><a href="#（十九）腾讯测开" class="headerlink" title="（十九）腾讯测开"></a>（十九）腾讯测开</h2><ol>
<li>多态用法示例</li>
<li>测试用例举例(测试边界)</li>
<li>用两个栈实现单向队列</li>
<li>TCP与UDP区别总结：<br>1、TCP面向连接（要先通过三次握手建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务，有拥塞控制和流量控制。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付， UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是全双工的不可靠信道</li>
<li>哈希算法</li>
<li>指针和引用的区别</li>
</ol>
<ul>
<li>指针可以为空，引用不可以为空，引用是对象的别名，定义一个引用的时候必须初始化。因此使用指针之前必须做判空操作，引用就不必，引用是类型安全的，而指针不是。</li>
<li>sizeof引用的大小是所指变量的大小；sizeof指针是指针本身的大小-四个字节。</li>
<li>指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名，引用不改变指向，指针可以，所以有常量指针没有常量引用。自增(++)操作对引用的操作是改变所指对象内容，对指针的操作是使指针指向下一个对象。</li>
<li>引用使用时无需解引用（*）,指针需要解引用。</li>
</ul>
<ol start="7">
<li>指针传递和引用传递的区别：<a href="https://blog.csdn.net/weixin_41256281/article/details/90545595" target="_blank" rel="noopener">参考</a></li>
</ol>
<table>
<thead>
<tr>
<th>传递方式</th>
<th>函数定义</th>
<th>函数调用</th>
<th>函数内对A修改</th>
</tr>
</thead>
<tbody><tr>
<td>值传递</td>
<td>fun(int a)</td>
<td>fun(x)</td>
<td>外部不变</td>
</tr>
<tr>
<td>指针传递</td>
<td>fun(int *a)</td>
<td>fun(&amp;x)</td>
<td>外部同步更改</td>
</tr>
<tr>
<td>引用传递(c++)</td>
<td>fun(int &amp;a)</td>
<td>fun(x)</td>
<td>外部同步更改</td>
</tr>
</tbody></table>
<ul>
<li>指针传递本质上是值传递，传递的是一个地址值。被调函数的形参作为被调函数的局部变量处理，是实参指针复制构造的一个临时对象，会在栈中开辟内存空间存放由主调函数传进来的实参值，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行操作。如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。</li>
<li>引用传递，引用形参相当于是实参的别名，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</li>
<li>从编译的角度讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后不会再更改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象则不能更改。</li>
<li>指针和引用的区别：</li>
</ul>
<p>（1）引用是别名，创建的同时必须被初始化，一旦被初始化就不能改变引用关系，不能为NULL；指针是变量，独立可变可空</p>
<p>（2）引用是间接寻址；指针是直接寻址</p>
<p>（3）引用有类型检查；指针无类型检查</p>
<ul>
<li>指针形参是指向实参地址的指针，我们可以通过访问这个地址来修改另一个变量；而引用形参相当于是实参的别名，对引用的操作就是对实参的操作 </li>
<li>指针可以有多级，引用只有一级 </li>
<li>传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改 </li>
<li>指针的大小一般是4个字节，引用的大小取决于被引用对象的大小 </li>
<li>指针可以为空，引用不可以。 </li>
</ul>
<p><strong>在函数参数传递的时候，什么时候传值，什么时候使用指针，什么时候使用引用</strong>？<br>基础类型传值、类对象作为参数传递的时候使用引用、多态对象以及分配在堆上的对象传指针。</p>
<p>返回局部变量的引用是没有意义的；对栈空间大小比较敏感（比如递归）的时候使用引用；使用引用传递不需要创建临时变量，开销要更小</p>
<p><strong>补充</strong></p>
<ul>
<li><p>传值：如果参数是整形、字符等基础类型，用传值的方法是最快的，也是最简单的。对于一些很大的对象，因为会使用拷贝构造函数构造一个新的对象，内存开销比较大，如果对象是多态的，因为C++会调用新创建的User对象的复制构造函数，而默认的复制构造函数只会把需要的属性复制到新对象里，引起所谓的切割现象。 </p>
</li>
<li><p>传指针：在C++古生代，传指针是传值之外的唯一方法。与传值相比较，需要考虑内存管理的问题，在栈上分配的对象通常就不能传递指针，因为函数返回之后栈上的对象会被析构，这时的指针就会成为野指针，引用它会造成内存访问异常。即使对象是在堆上分配的，传指针里也同样要考虑分配错误等问题。不过，与传值相比，传指针对付大型对象和多态对象很有效，而且，使用指针形式传递的变量在运行过程中可以被修改。 传引用似乎结合了两者的优点。</p>
</li>
<li><p>传引用：与传指针一样，传引用能很好地对付大型对象多态对象，而且相对于传指针，传引用通常是不需要考虑内存管理的问题，因为只能使用另一个已经初始化的变量来初始化引用。一切看起来似乎都很美好。不过优点往往也是缺点，引用类型的变量不适合作为类的属性，因为引用一旦初始化就不能改变其指向的对象。</p>
</li>
</ul>
<h2 id="（二十）美团"><a href="#（二十）美团" class="headerlink" title="（二十）美团"></a>（二十）美团</h2><h3 id="美团测开实习"><a href="#美团测开实习" class="headerlink" title="美团测开实习"></a>美团测开实习</h3><ol>
<li>函数指针和指针函数的区别</li>
</ol>
<ul>
<li>函数指针其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">声明格式：类型说明符 (*函数名) (参数)</span><br><span class="line">函数指针是需要把一个函数的地址赋值给它，有两种写法：</span><br><span class="line">fun = &amp;Function；</span><br><span class="line">fun = Function;</span><br><span class="line">取地址运算符&amp;不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。</span><br><span class="line">调用函数指针的方式也有两种：</span><br><span class="line">x = (*fun)();</span><br><span class="line">x = fun();</span><br></pre></td></tr></table></figure>

<ul>
<li>指针函数就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。</li>
</ul>
<ol start="2">
<li>屏幕适配</li>
</ol>
<ul>
<li>屏幕尺寸：手机对角线的物理尺寸 单位：英寸（inch），1英寸=2.54cm</li>
</ul>
<p>Android手机常见的尺寸有5寸、5.5寸、6寸，6.5寸等等</p>
<ul>
<li>屏幕分辨率：手机在横向、纵向上的像素点数总和</li>
</ul>
<p>一般描述成屏幕的“宽x高”=AxB 含义：屏幕在横向方向（宽度）上有A个像素点，在纵向方向（高）有B个像素点 例子：1080x1920，即宽度方向上有1080个像素点，在高度方向上有1920个像素点。单位：px（pixel），1px=1像素点</p>
<p>UI设计师的设计图会以px作为统一的计量单位</p>
<p>Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920</p>
<ul>
<li>屏幕像素密度:每英寸的像素点数 单位：dpi（dots per ich）</li>
</ul>
<p>假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpi=(横向分辨率^<span class="number">2</span>+纵向分辨率^<span class="number">2</span>)^(<span class="number">1</span>/<span class="number">2</span>)/屏幕尺寸</span><br></pre></td></tr></table></figure>

<ul>
<li>屏幕适配的解决方案：<a href="https://blog.csdn.net/coderinchina/article/details/94736938?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">参考</a></li>
</ul>
<p>1、自定义像素适配：(屏幕真实横纵分辨率/默认横纵分辨率)*所设置的横纵长=适配横纵长</p>
<p>2、百分比适配（添加依赖）</p>
<p>3、修改density实现屏幕适配</p>
<p>4、限定符适配</p>
<ol start="2">
<li>SQL语句</li>
<li>微信登录测试内容</li>
<li>为什么选测开</li>
<li>支付宝咻咻咻原理</li>
</ol>
<h3 id="美团数据开发（快驴事业部）"><a href="#美团数据开发（快驴事业部）" class="headerlink" title="美团数据开发（快驴事业部）"></a>美团数据开发（快驴事业部）</h3><ol>
<li>三次握手  四次挥手</li>
<li>数据库索引   原理   结构     什么时候用  优缺点  b+树</li>
<li>哈希树原理</li>
<li>hadoop(不会)</li>
</ol>
<p>10,8,3,6,2,7：股价</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchHigh</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minprice=INT32_MAX;</span><br><span class="line">    <span class="keyword">int</span> maxpro=INT32_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i]&lt;minprice)</span><br><span class="line">            minprice=res[i];</span><br><span class="line">        maxpro=<span class="built_in">max</span>(maxpro,res[i]-minprice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxpro;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int a;</span></span><br><span class="line">    <span class="comment">//cin &gt;&gt; a;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">10</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret=searchHigh(vec);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给订单表order_table(dt,order_id,customer_id,amount)</p>
<p>dt：下单日期，yyyymmdd</p>
<p>order_id：订单ID</p>
<p>customer_id：客户 ID</p>
<p>amount：销售额</p>
<p>求每天的新客数</p>
<p>求每个月销售额TOP50的客户</p>
<p>substr(dt,1,6)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//现场</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">DISTINCT</span> customer_id) <span class="keyword">as</span> customer_num</span><br><span class="line"><span class="keyword">from</span> order_table</span><br><span class="line"><span class="keyword">where</span> dt== <span class="number">20200901</span> <span class="keyword">and</span> </span><br><span class="line">    customer_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">select</span> customer_id</span><br><span class="line">                        <span class="keyword">from</span> order_table</span><br><span class="line">                        <span class="keyword">where</span> dt!=<span class="number">20200901</span>)</span><br><span class="line"><span class="keyword">select</span> customer_id</span><br><span class="line"><span class="keyword">from</span>  (<span class="keyword">select</span> customer_id,<span class="keyword">sum</span>(amount) </span><br><span class="line">        <span class="keyword">from</span> order_table</span><br><span class="line">        <span class="keyword">where</span> dt <span class="keyword">like</span> <span class="string">'202009%'</span></span><br><span class="line">        <span class="keyword">Group</span> <span class="keyword">by</span> customer_id</span><br><span class="line">        <span class="keyword">limit</span> <span class="number">50</span>)</span><br><span class="line">        </span><br><span class="line">//正确答案</span><br><span class="line"><span class="keyword">select</span> customer_id,<span class="keyword">sum</span>(amount) <span class="keyword">as</span> monthamount</span><br><span class="line"><span class="keyword">from</span> order_table</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">substr</span>(dt,<span class="number">1</span>,<span class="number">6</span>)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> monthamount <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h4 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h4><ol>
<li>公司项目技术难点</li>
<li>对未来职业是怎么选择的   怎么理解数据开发工程师</li>
<li>收集整个西安用户使用手机占比   作为一个学生的身份</li>
</ol>
<h2 id="（二十一）中兴捧月模拟大赛"><a href="#（二十一）中兴捧月模拟大赛" class="headerlink" title="（二十一）中兴捧月模拟大赛"></a>（二十一）中兴捧月模拟大赛</h2><ol>
<li>具体负责部分，项目难点</li>
<li>OFDM特性，使用的通信协议</li>
<li>static</li>
</ol>
<ul>
<li><em>静态常量数据成员可以在类内初始化<strong>(</strong>即类内声明的同时初始化<strong>)</strong>，也可以在类外，即类的实现文件中初始化，不能在构造函数中初始化，也不能在构造函数的初始化列表中初始化；</em></li>
<li>静态非常量数据成员只能在类外，即类的实现文件中初始化，也不能在构造函数中初始化，不能在构造函数的初始化列表中初始化；</li>
<li>非静态的常量数据成员不能在类内初始化，也不能在构造函数中初始化，而只能且必须在构造函数的初始化列表中初始化；</li>
<li>非静态的非常量数据成员不能在类内初始化，可以在构造函数中初始化，也可以在构造函数的初始化列表中初始化；</li>
</ul>
<ol start="4">
<li>inline</li>
<li>inline和define的区别</li>
<li>英文自我介绍</li>
</ol>
<h2 id="（二十二）招银网络"><a href="#（二十二）招银网络" class="headerlink" title="（二十二）招银网络"></a>（二十二）招银网络</h2><ol>
<li>项目线程池使用队列（b站线程池？）</li>
<li>char数组构造初始化和strcpy和string转char自动加‘\0’</li>
<li>数据成员构造顺序</li>
<li>手撕复制构造函数深度拷贝</li>
<li>sql增删改查</li>
</ol>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/zhaoyin.jpg" alt="手撕sql增删改查和复制构造函数深拷贝"></p>
<h3 id="正式批-1"><a href="#正式批-1" class="headerlink" title="正式批"></a>正式批</h3><ol>
<li>union all 和union的区别</li>
</ol>
<p>Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；</p>
<p>Union All：对两个结果集进行并集操作，包括重复行，不进行排序；</p>
<p>Intersect：对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序；</p>
<p>Minus：对两个结果集进行差操作，不包括重复行，同时进行默认规则的排序。</p>
<ol start="2">
<li>第三笔记账失败，回滚还是继续进行（直接不把这笔记账记在这里）</li>
<li>全局变量和局部变量的区别</li>
</ol>
<p>1)作用域：</p>
<p>​    全局变量作用于整个程序；</p>
<p>​    局部变量作用于当前函数。</p>
<p>2)内存分配：</p>
<p>​    全局变量内存分配在自由分配区；</p>
<p>​    局部变量分配在栈区。</p>
<p>3)生存周期不同</p>
<p>​    全局变量：跟随系统的创建而创建，销毁而销毁；</p>
<p>​    局部变量：局部函数内部，甚至局部循环体内部，退出就不存在。</p>
<p>4)使用方式：</p>
<p>​    全局变量一旦申明后，可以在程序的任意位置被使用；</p>
<p>​    局部变量只可在局部函数使用。</p>
<ol start="4">
<li>假设你有一个数组，其中第 <em>i</em> 个元素是股票在第i天的价格。你有一次买入和卖出的机会。（只有买入了股票以后才能卖出）。请你设计一个算法来计算可以获得的最大收益。</li>
<li>已知类String的原型为：<br>class String<br>{<br>public:<br>   String(const char *str = NULL);// 普通构造函数<br>   String(const String &amp;other);  // 拷贝构造函数<br>   ~String(void);  // 析构函数<br>   String &amp; operate =(const String &amp;other);// 赋值函数<br>private:<br>   char *m_data;// 用于保存字符串<br>};<br>请编写其中的拷贝构造函数：<br>   String(const String &amp;other);</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="literal">NULL</span>);<span class="comment">// 普通构造函数</span></span><br><span class="line">     <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span> &amp;other)&#123;</span><br><span class="line">         m_data=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(other.m_data)+<span class="number">1</span>);</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">memcpy</span>(m_data,other.m_data,<span class="built_in">strlen</span>(other.m_data));</span><br><span class="line">     &#125;;    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">     ~<span class="keyword">String</span>(<span class="keyword">void</span>);    <span class="comment">// 析构函数</span></span><br><span class="line">     <span class="keyword">String</span> &amp; operate =(<span class="keyword">const</span> <span class="keyword">String</span> &amp;other);<span class="comment">// 赋值函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">char</span> *m_data;<span class="comment">// 用于保存字符串</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int a;</span></span><br><span class="line">    <span class="comment">//cin &gt;&gt; a;</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二面-3"><a href="#二面-3" class="headerlink" title="二面"></a>二面</h4><ol>
<li>QT 前端跟后端怎么发送信号的  用的什么函数</li>
<li>消息队列用什么存储的deque   线程池使用的存储的线程array和任务list</li>
<li>输出数组中连续子数组和为N的子数组总共有多少个</li>
<li>生产者速度快  消费者速度慢  怎么优化buffer</li>
</ol>
<h2 id="（二十三）字节"><a href="#（二十三）字节" class="headerlink" title="（二十三）字节"></a>（二十三）字节</h2><ol>
<li>链表去重</li>
</ol>
<p>数据结构：</p>
<p>(1)单向链表去重 </p>
<p>  输入：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5</p>
<p>  输出：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>(2) 单向链表删除重复项</p>
<p>  输入：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5</p>
<p>  输出：2-&gt;3-&gt;5</p>
<p>指针pre和cur，遇到重复的节点就直接删除</p>
<ol start="2">
<li>mysql优化</li>
</ol>
<p>分区</p>
<p>慢查询优化</p>
<ol start="3">
<li><p>按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。<a href="https://blog.csdn.net/moses1213/article/details/51984102" target="_blank" rel="noopener">对升序的栈进行排序</a></p>
<p>Stack= [1,4,3,5,2] —&gt; </p>
<p>result= [5,4,3,2,1]</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&amp; s1)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    s2.push(s1.top());</span><br><span class="line">    s1.pop();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(s1.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.top()&gt;=s2.top())&#123;</span><br><span class="line">            s2.push(s1.top());</span><br><span class="line">            s1.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=s1.top();</span><br><span class="line">            s1.pop();</span><br><span class="line">            <span class="keyword">while</span>(!s2.empty()&amp;&amp;s2.top()&gt;tmp)&#123;</span><br><span class="line">                s1.push(s2.top());</span><br><span class="line">                s2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s2.push(tmp);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>给定元素全为非负整数的非空数组<strong>nums</strong>，数组的<strong>度</strong>等于出现最多的元素的次数。找到具有和<strong>nums</strong>相同<strong>度</strong>的连续子串的最小长度。<a href="https://blog.csdn.net/love905661433/article/details/83992603" target="_blank" rel="noopener">数组的度</a></p>
<p> Input:[1,5,5,3,5,1] Output:4</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; indexmap;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cntmap;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>=INT32_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cntmap.count(nums[i]))&#123;</span><br><span class="line">            indexmap[nums[i]].push_back(i);</span><br><span class="line">            indexmap[nums[i]].push_back(i);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            indexmap[nums[i]][<span class="number">1</span>]=i;</span><br><span class="line">        cntmap[nums[i]]++;</span><br><span class="line">        <span class="built_in">max</span>=<span class="built_in">std</span>::<span class="built_in">max</span>(<span class="built_in">max</span>,cntmap[nums[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len=INT32_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; cnt:cntmap)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt.second==<span class="built_in">max</span>)&#123;</span><br><span class="line">            len=<span class="built_in">std</span>::<span class="built_in">min</span>(len,indexmap[cnt.first][<span class="number">1</span>]-indexmap[nums[cnt.first]][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>项目介绍  技术难点</li>
<li>堆栈实现队列  push  pop  count</li>
<li>对字节的了解 对未来的规划</li>
<li>概率题：a赢2局结束；b赢3局结束。ab赢的概率都是0.5。求a,b赢的概率</li>
</ol>
<h2 id="（二十四）小米"><a href="#（二十四）小米" class="headerlink" title="（二十四）小米"></a>（二十四）小米</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol>
<li>智能指针   智能指针相对裸指针的优点   双重检验锁的必要性</li>
<li>c++内存管理  重点分区  堆（从低到高）栈（从高到低）</li>
<li>看过哪些书</li>
<li>面试官自己对部门的介绍   想在哪工作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//懒汉模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInstance</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;MyInstance&gt; <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(myinstance==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">lt</span><span class="params">(mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(myinstance==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                myinstance=make_shared&lt;MyInstance&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myinstance;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MyInstance()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MyInstance()&#123;&#125;</span><br><span class="line">    mutex mt;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;MyInstance&gt; myinstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int a;</span></span><br><span class="line">    <span class="comment">//cin &gt;&gt; a;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二面：</p>
<ol>
<li>指针大小   指针存储地址</li>
</ol>
<p>sizeof(int*)     16位系统           2</p>
<p>​                         32位系统x86   4</p>
<p>​                         64位系统          8</p>
<p>sizeof(char*)=sizeof(int*)</p>
<ol start="2">
<li>字节对齐32位系统     char    int     short int</li>
</ol>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>字节大小</th>
<th>数值范围</th>
</tr>
</thead>
<tbody><tr>
<td>short int (短整型）</td>
<td>2 字节</td>
<td>-32 768 〜+32 767</td>
</tr>
<tr>
<td>unsigned short int (无符号短整型）</td>
<td>2 字节</td>
<td>0 〜+65 535</td>
</tr>
<tr>
<td>int (整型)</td>
<td>4 字节</td>
<td>-2 147 483 648 〜+2 147 483 647</td>
</tr>
<tr>
<td>unsigned int (无符号整型）</td>
<td>4 字节</td>
<td>0 〜4 294 967 295</td>
</tr>
<tr>
<td>long int (长整型）</td>
<td>4 字节</td>
<td>-2 147 483 648 〜+2 147 483 647</td>
</tr>
<tr>
<td>unsigned long int (无符号长整型）</td>
<td>4 字节</td>
<td>0 〜4 294 967 295</td>
</tr>
<tr>
<td>long long int (超长整型）</td>
<td>8字节</td>
<td>-9 223 372 036 854 775 808~9 223 372 036 854 775 807</td>
</tr>
<tr>
<td>unsigned long long int (无符号超长整型）</td>
<td>8字节</td>
<td>048 446 744 073 709 551 615</td>
</tr>
</tbody></table>
<p>注意，超长整型和无符号超长整型是在 C++11 中引入的。</p>
<ol start="3">
<li>linux命令  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l<span class="comment">#具体文件信息</span></span><br><span class="line">grep<span class="comment">#定位关键字</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>git命令</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建分支</span></span><br><span class="line">git branch [name]</span><br><span class="line">git checkout -b [name]</span><br><span class="line"><span class="comment">#拉代码</span></span><br><span class="line">git pull</span><br><span class="line"><span class="comment">#克隆代码</span></span><br><span class="line">git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个链表，实现删除链表第 K 个节点的函数。</span></span><br><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="comment">//[1,2,3,4,5],3</span></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2,4,5&#125;</span></span><br><span class="line"><span class="function">ListNode* <span class="title">deleteK</span><span class="params">(ListNode* head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* cur=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* prenode=cur-&gt;pre;</span><br><span class="line">    prenode-&gt;next=cur-&gt;next;</span><br><span class="line">    cur-&gt;next-&gt;pre=prenode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> cur;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（二十五）滴滴"><a href="#（二十五）滴滴" class="headerlink" title="（二十五）滴滴"></a>（二十五）滴滴</h2><p>一面</p>
<ol>
<li>快排处理海量数据</li>
<li>外部排序 胜者树 败者树</li>
<li>索引</li>
<li>kill -9 中-9 SIGKILL 不可捕获不可忽略</li>
<li>分布式数据库  redis   线程池实现的几种方式，分布式线程</li>
</ol>
<p>分布式数据库系统 （DDBS）包含分布式数据库管理系统（DDBMS）和分布式数据库（DDB)。在分布式数据库系统中，一个应用程序可以对数据库进行透明操作，数据库中的数据分别在不同的局部数据库中存储、由不同的 DBMS进行管理、在不同的机器上运行、由不同的操作系统支持、被不同的通信网络连接在一起。</p>
<p>一个分布式数据库在逻辑上是一个统一的整体，在物理上则是分别存储在不同的物理节点上。一个应用程序通过网络的连接可以访问分布在不同地理位置的数据库。它的分布性表现在数据库中的数据不是存储在同一场地。更确切地讲，不存储在同一计算机的存储设备上。这就是与集中式数据库的区别。从用户的角度看，一个分布式数据库系统在逻辑上和集中式数据库系统一样，用户可以在任何一个场地执行全局应用。就好像那些数据是存储在同一台计算机上，有单个数据库管理系统（DBMS）管理一样，用户并没有什么感觉不一样。</p>
<p>主要优点：<br>（1）具有灵活的体系结构。<br>（2）适应分布式的管理和控制机构。<br>（3）经济性能优越。<br>（4）系统的可靠性高、可用性好。<br>（5）局部应用的响应速度快。<br>（6）可扩展性好，易于集成现有系统。</p>
<p>主要缺点：<br>（1）系统开销大，主要花在通信部分。<br>（2）复杂的存取结构，原来在集中式系统中有效存取数据的技术，在分布式系统中都不再适用。<br>（3）数据的安全性和保密性较难处理。</p>
<p>redis是非关系型数据库NoSQL，高性能的键值数据库，存储在内存，效率高价格昂贵。性能和并发两个角度去答。</p>
<p>性能：<br>我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存，这样，后面的请求就去缓存中读取，请求使得能够迅速响应。</p>
<p>并发：<br>在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用的的Redis的做一个缓冲操作，让请求先访问到的Redis的的，而不是直接访问数据库。</p>
<p>redis的优势：1，运行在内存，速度快。</p>
<p>2，数据虽在内存，但是提供了持久化的支持，即可以将内存中的数据异步写入到硬盘中，同时不影响继续提供服务。</p>
<p>3，支持数据结构丰富（string（字符串），list（链表），set（集合），zset（sorted set - 有序集合））和Hash（哈希类型，md5加密出来的那个串）</p>
<h3 id="非分布式系统中的线程"><a href="#非分布式系统中的线程" class="headerlink" title="非分布式系统中的线程"></a>非分布式系统中的线程</h3><p>　　多线程最显著的好处来自以下事实：那就是在只拥有单线程的进程中，一旦执行了造成阻塞的系统调用，整个进程就被阻塞了。</p>
<p>　　多线程技术在大型应用程序上下文中也是很有用的。这种应用程序一般是作为一组写作的程序开发出来的，其中每一个程序都通过独立的进程进行。例如UNIX系统，程序间写作是通过进程间通信(IPC）机制实现的。这套机制中通常包括已命名管道、消息队列以及共享内存段。左右IPC机制都有一个主要的缺陷，就是其中的通信需要开销庞大的上下文切换：</p>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2.png" alt>
　　</p>
<p>　　由于IPC需要内核干预才能进行，因此，要进行IPC的进程一般首先要从用户模式切换到内核模式，需要改变MMU中的内存映像，同时还要刷新TLB。在内核中进行进程上下文的切换，随后就可以从内核模式切换回用户模式以使得通信的另一方能够激活。后一次切换也同样需要改变MMU映像并且刷新TLB。</p>
<p>　　一般采用用户级线程和内核级线程的混合模式（LWP），LWP运行在单个重量级进程的上下文中，每个进程可以包含多个LWP，除了LWP外，系统还提供用户级线程包，向应用程序提供了创建和销毁线程等普通操作。另外，包中还提供了用于线程同步的工具，比如互斥变量和条件变量。重要的是，线程包完全在用户空间中实现的。也就是说，执行这些线程操作不需要内核的干预。<br><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/LWP.png" alt></p>
<h3 id="分布式系统中的线程"><a href="#分布式系统中的线程" class="headerlink" title="分布式系统中的线程"></a>分布式系统中的线程</h3><p>1、多线程客户</p>
<p>　　在广域网上构建的分布式系统需要隐藏较长的进程间消息传播的时间。在广域网中，传输的延迟很容易达到上百毫秒，甚至几秒。</p>
<p>　　在很多情况下，Web文档是由HTML文件组成的，HTML文件中包含有纯文本文件以及图像组、图标等。为了获得Web文档中每一个组成部分，浏览器必须建立TCP/IP连接，读取输入数据并将数据传递给显示组件。首先将文本显示出来以便用户查看，并且提供页面滚动之类的功能，同时继续获取组成页面的其他文件，比如图像等。在收到这些文件之后再显示它们。用户不必等待浏览器取得整个页面的所有组件就能够查看页面。</p>
<p>　　以多线程客户的模式来开发浏览器可以显著地使问题简化。每个线程都与服务器简历一个独立连接以获取数据。在使用多线程客户的时候，可以与不同服务器副本建立连接，这样就可以并行地进行数据传输了，并且确保整个Web文档完全显示出来所需的时间与使用无复制的服务器的情况相比要短得多。</p>
<p>2、多线程服务器</p>
<p>　　考虑一下文件服务器的组织结构，该文件服务器可能会偶尔由于等待磁盘操作而阻塞。文件服务器一般等待输入的文件操作请求，随后执行该请求，最后送回应答。下图中，有一个称为分发器(dispatcher)的线程，由它来读取文件操作请求。客户发送请求到服务器的某个已知端点。在对请求进行检查以后，服务器选择一个空闲的（也就是阻塞的）工作着线程，由它来处理该请求。<br><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BA%BF%E7%A8%8B.png" alt="分布式"></p>
<p>　　工作者线程在本地文件系统上执行阻塞的read调用，执行该调用将会导致该线程被挂起直到数据从磁盘上读出为止。如果该线程被挂起了，就选择另一个线程接着执行。</p>
<ol start="6">
<li><p>工厂模式的应用场景</p>
</li>
<li><p>质因数分解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Prime(int n)&#123;</span><br><span class="line">	for(int i&#x3D;2;i&lt;&#x3D;n&amp;&amp;n&gt;1;)&#123;</span><br><span class="line">		if(n%i&#x3D;&#x3D;0)&#123;</span><br><span class="line">			n&#x2F;&#x3D;i;</span><br><span class="line">			cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">		&#125;else</span><br><span class="line">			i++;</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二面</p>
</li>
<li><p>thread join  future  mutex condition_variable async</p>
</li>
<li><p>语文排名第二名  <a href="https://www.cnblogs.com/52XF/p/4209211.html" target="_blank" rel="noopener">数据库分页查询</a> 数据库分页操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT &#96;keyword_rank&#96;.* FROM &#96;keyword_rank&#96; WHERE (advertiserid&#x3D;&#39;59&#39;) LIMIT 0,1;</span><br><span class="line">而这个SQL，limit后面是从第0条开始读，读取1条信息。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SQL Server TOP 子句用于规定要返回的记录的数目。</span><br><span class="line"></span><br><span class="line">对于拥有数千条记录的大型表来说，TOP 子句是非常有用的。</span><br><span class="line"></span><br><span class="line">注释：并非所有的数据库系统都支持 TOP 子句。</span><br><span class="line"></span><br><span class="line">SQL Server 的语法：</span><br><span class="line">SELECT TOP number|percent column_name(s)</span><br><span class="line">FROM table_name</span><br><span class="line"></span><br><span class="line">从 &quot;Persons&quot; 表中选取 头两条记录:</span><br><span class="line">SELECT TOP 2 * FROM Persons</span><br><span class="line"></span><br><span class="line">从 &quot;Persons&quot; 表中选取 50% 的记录:</span><br><span class="line">SELECT TOP 50 PERCENT * FROM Persons</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1、查询出没有重复值的第二名，即假如最高的身高是182，有几个人同时身高是182，则查出身高小于182的的最高的身高值。</span><br><span class="line"></span><br><span class="line">1&gt;、方式1：</span><br><span class="line"></span><br><span class="line">select MAX(height) from users where height &lt; (select MAX(height) from users );</span><br><span class="line">意义：先查询出最高的身高值，然后查询身高小于该值的最高身高。</span><br><span class="line"></span><br><span class="line">2&gt;、方式2：</span><br><span class="line"></span><br><span class="line">select top 1 height from users where height not in (select MAX(height) from users) order by height desc;</span><br><span class="line">意义：先查询出最高的身高，排除该身高，然后将数据进行排序（降序），查询出当前的第一条数据。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">3&gt;、方式3：使用RANK（）函数</span><br><span class="line"></span><br><span class="line">rank函数考虑到了over子句中排序字段值相同的情况，值相同的时候RANK函数得到的值相等。</span><br><span class="line"></span><br><span class="line">select top 1 height from (</span><br><span class="line">select *,RANK() OVER (ORDER BY height desc) AS Rank from users</span><br><span class="line">) t where rank&lt;&gt;1</span><br><span class="line">意义：给每一个记录一个行号，使用RANK函数，去掉身高值最高的记录（重复值的rank函数获得值相同）。</span><br><span class="line"></span><br><span class="line">　　</span><br><span class="line"></span><br><span class="line">2、查询出可能与最高身高值相同的第二名，即假如身高最高是182，有几个人同时是182身高，第二名依然是182.</span><br><span class="line"></span><br><span class="line">1&gt;、方式1：</span><br><span class="line"></span><br><span class="line">select top 1 * from  (select top 2 height from users order by height desc) s order by height asc;</span><br><span class="line">意义：将数据按照身高（降序）排列，查询出前面的两项，然后将这两项按照身高升序，查询第一项目。 </span><br><span class="line"></span><br><span class="line">2&gt;、方式2：row_number函数的用途是非常广泛，这个函数的功能是为查询出来的每一行记录生成一个序号（不考虑重复值）。</span><br><span class="line"></span><br><span class="line">select top 1 height from (</span><br><span class="line">select *,ROW_NUMBER() OVER (ORDER BY height desc) AS Rank from users</span><br><span class="line">) t where rank&lt;&gt;1</span><br><span class="line">　　意义：给每一个记录一个行号ROW_NUMBER使用函数，去掉身高值最高的记录（重复值的ROW_NUMBER函数获得值不同）。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>虚拟内存优缺点</li>
</ol>
<p>虚拟内存技术其实就是将用户逻辑内存和物理内存分开，这在现有物理内存有限的情况下，为程序员提供了巨大的虚拟内存，这里需要注意的是物理地址是可以按页帧来组织的，且分配给进程的物理页帧也可能是不连续的，这就需要内存管理单元(MMU)将逻辑页映射到内存的物理页帧，使不连续的物理内存碎片在用户角度开来是连续的存储空间。</p>
<p>虚拟存储技术<br>基本思想：利用大容量的外存来扩充内存，产生一个比有限的实际内存空间大得多的、逻辑的虚拟内存空间，简称虚存。<br>操作系统把程序当前使用的部分保留在内存，而把其他部分保存在磁盘上，并在需要时在内存与磁盘之间动态交换</p>
<p>在一个程序的运行那个过程中，由CPU产生虚拟地址，该虚拟地址经过MMU转换成物理地址，然后使用该物理地址去访问内存。那么虚拟地址存在的原因是什么呢？为何不能由CPU直接产生物理地址呢？</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>更高效的使用物理内存，它将主存看成是一个存储在磁盘空间上的地址空间的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。允许程序员不受内存存储的限制，虚拟内存也允许进程很容易地共享文件和地址空间。一定程度的提高反映速度。减少对物理内存的读取从而保护内存延长内存使用寿命。在计算机系统中物理内存是有限的，对于一般的计算机来说，物理内存一般为4G或者8G. 对于现代多任务的通用系统来说这显然是不够的。试想假如我们需要看一个4G大小以上的视频，这时物理内存就不够了。在存在虚拟地址的情况下，可以为每个程序分配足够大小的虚拟地址空间，但是这些地址空间在一开始并没有真正的对应物理地址，而是在真正使用的时候才去对应。这样在访问后边的地址空间的时候就可以将前边当前没有在访问的物理页释放掉，或者交换到硬盘中。这样这个物理页又可以去对应新的虚拟地址。从而使物理内存可以充分的利用。</li>
<li>使用虚拟地址可以使内存的管理更加便捷，为进程提供了一致的地址空间。在程序编译的时候就会生成虚拟地址，对于不同的机器或者对于同一台机器的不同时间，该虚拟地址可以对应不同的物理页。试想，如果没有虚拟地址，那么编译时产生的物理地址在某些机器上可能已经被占用而不能访问。从而导致程序需要重新编译。</li>
<li>保护了每个进程的地址空间不被其他进程破坏。在使用虚拟地址的时候，暴露给程序员永远都是虚拟地址，而具体的物理地址在哪里，这个只有系统才了解，提高了系统的封装性。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>占用一定的物理硬盘空间；加大了对硬盘的读写；设置不得当会影响整机稳定性与速度。</p>
<p>使用了虚拟地址，那么下一个问题来了，如何将虚拟地址转换成物理地址。在现代计算系统中提供了一个MMU单元，可以将虚拟地址转换成物理地址。具体的转换方式是使用了分页机制。及通过虚拟地址索引页表，通过页表获取真实的物理地址。</p>
<h3 id="虚拟地址（VA）如何转换成物理地址（PA）空间"><a href="#虚拟地址（VA）如何转换成物理地址（PA）空间" class="headerlink" title="虚拟地址（VA）如何转换成物理地址（PA）空间"></a>虚拟地址（VA）如何转换成物理地址（PA）空间</h3><p>虚拟内存的存储单元为page（一般为4~8Kb）<br>同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟也是否缓存在 DRAM 的某个地方。如果命中缓存，那么虚拟内存系统还必须确认这个虚拟页存在哪个物理页中。如果没有命中缓存，那么虚拟内存系统必须判断虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM，替换这个牺牲页。</p>
<p>这些功能由软硬件联合提供，包括操作系统软件，MMU 中的地址翻译硬件和一个存放在物理内存中叫页表（page table）的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换成物理地址时都会读取页表。</p>
<ol start="4">
<li>c++内存管理</li>
</ol>
<p>堆 栈 常量存储区 静态全局存储区 代码区 自由存储区  </p>
<ol start="5">
<li>命名空间 spacename</li>
</ol>
<p>命名空间这个概念可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。</p>
<p>标准C++库中的所有标识符都是在一个名为std的命名空间中定义的，或者说标准头文件中的函数、类、对象和模板实在命名空间std中定义的。一般用using namespace语句对命名空间std进行声明，这样可以不必对每个命名空间成员一一进行处理，在文件的开头加入如下语句：<br>using namespace std;<br>这样，在std中定义和声明的所有标识符在本文件中都可以作为全局变量来使用。</p>
<ol start="6">
<li><p><a href="https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/" target="_blank" rel="noopener">二分求幂:递归或迭代</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener">重复的字符串leetcode 459:KMP</a></p>
</li>
<li><p>数据库中删除语句Drop、Delete、Truncate的相同点和不同点的比较</p>
</li>
</ol>
<p>数据库删除语句的分别介绍：<br>Delete：用于删除表中的行（注：可以删除某一行；也可以在不删除表的情况下（即意味着表的结构、属性、索引完整）删除所有行）</p>
<p>语法：删除某一行：Delete From 表名称  Where 列名称=值</p>
<p>删除所有行： Delete From 表名称       或     Delete *  From  表名称</p>
<p>Drop：用于删除表（注：将表的结构、属性、索引也会被删除。）</p>
<pre><code>语法：Drop  Table 表名称</code></pre><p>Truncate：用于删除表内的数据（注：仅删除表内的数据，不删除表本身，相当于Delete语句不写Where子句一样）</p>
<p>语法：Truncate Table  表名称</p>
<p>数据库中删除语句的相同点和不同点的比较：</p>
<p>相同点：<br> 1.truncate和不带where子句的delete，以及drop都能删除表内的数据</p>
<p> 2.truncate和delete只删除表数据保留表结构</p>
<p>不同点：</p>
<ol>
<li>truncate table tablename<br>删除表内容释放表空间保留表结构(即：只删除表内的数据，不删除表本身。相当于Delete语句不写where子句一样)，不使用事务处理即和事务无关</li>
</ol>
<p>truncate 语句缺省情况下将空间释放到 minextents个 extent，<br>除非使用reuse storage；truncate 会将高水线复位(回到最开始)。</p>
<ol start="2">
<li>delete table tablename [where子句]<br>delete属于数据操作语言（DML），不能自动提交事务，需commit提交<br>这个操作会放到 rollback segement 中，事务提交之后才生效；<br>如果有相应的 trigger，执行的时候将被触发。</li>
</ol>
<p>delete 语句不影响表所占用的 extent，高水线(high watermark)保持原位置不动</p>
<ol start="3">
<li>drop table tablename<br>drop属于数据定义语言（DDL）可以自动提交事务；<br>drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)【删除表数据同时删除表结构】；<br>依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。</li>
</ol>
<p>drop 语句将表所占用的空间全部释放。</p>
<p>删除数据的速度，一般来说: drop&gt; truncate &gt; delete</p>
<p>使用场合：<br>当你不再需要该表时， 用 drop;<br>当你仍要保留该表，但要删除所有记录时， 用 truncate;<br>当你要删除部分记录时（always with a where clause), 用 delete.</p>
<p>注意：<br>对于有主外键关系的表，不能使用truncate而应该使用不带where子句的delete语句，由于truncate不记录在日志中，不能够激活触发器</p>
<ol start="9">
<li>数据库优化</li>
<li>缺页中断</li>
</ol>
<p>页缺失（英语：Page fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等）指的是当软件试图访问已映射在虚拟地址空间中，但是并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。</p>
<p>缺页中断发生时的事件顺序如下：</p>
<p>1) 硬件陷入内核，在内核堆栈中保存程序计数器。大多数机器将当前指令的各种状态信息保存在特殊的CPU寄存器中。<br>2) 启动一个汇编代码例程保存通用寄存器和其他易失的信息，以免被操作系统破坏。这个例程将操作系统作为一个函数来调用。<br>3) 当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看它在缺页中断时正在做什么。<br>4) 一旦知道了发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致。如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。<br>5) 如果选择的页框“脏”了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用。<br>6) 一旦页框“干净”后（无论是立刻还是在写回磁盘后），操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面被装入后，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行。<br>7) 当磁盘中断发生时，表明该页已经被装入，页表已经更新可以反映它的位置，页框也被标记为正常状态。<br>8) 恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令。<br>9) 调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程。<br>10) 该例程恢复寄存器和其他状态信息</p>
<h2 id="（二十六）网易"><a href="#（二十六）网易" class="headerlink" title="（二十六）网易"></a>（二十六）网易</h2><h3 id="1-MVC举例-其他设计模式-工厂模式-适配器模式-策略模式"><a href="#1-MVC举例-其他设计模式-工厂模式-适配器模式-策略模式" class="headerlink" title="1. MVC举例 其他设计模式:工厂模式  适配器模式  策略模式"></a>1. MVC举例 其他设计模式:工厂模式  适配器模式  策略模式</h3><h4 id="一-简单工厂模式-工厂方法模式-抽象工厂模式"><a href="#一-简单工厂模式-工厂方法模式-抽象工厂模式" class="headerlink" title="(一)简单工厂模式  工厂方法模式   抽象工厂模式"></a>(一)简单工厂模式  工厂方法模式   抽象工厂模式</h4><p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg" alt></p>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg" alt><br>抽象工厂模式最大的缺点。在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：<br> (1) 增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。<br> (2) 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。</p>
<h4 id="（二）适配器模式"><a href="#（二）适配器模式" class="headerlink" title="（二）适配器模式"></a>（二）适配器模式</h4><p> 适配器模式：是在想使用一个已经存在的类，但是他的接口并不符合要求，因为在编码过程中要遵循对扩展开放，对修改关闭的原则，所以不能对原有类进行修改，这时便需要使用适配器模式。eg,stack和queue是deque的适配器。</p>
<h4 id="（三）策略模式"><a href="#（三）策略模式" class="headerlink" title="（三）策略模式"></a>（三）策略模式</h4><p> 策略模式：定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化；使用的关键点是面向对象/面向接口编程。eg,游戏中武士可以不断更换武器就是根据传入不同的子类武器对象对环境类中的父类数据成员进行初始化，sh实现对不同武器的调用。</p>
<p><a href="https://www.cnblogs.com/ivy-xu/p/6638663.html" target="_blank" rel="noopener">适配器模式和策略模式的区别</a></p>
<h3 id="2-activity生命周期"><a href="#2-activity生命周期" class="headerlink" title="2. activity生命周期"></a>2. <a href="https://developer.android.google.cn/guide/components/activities/activity-lifecycle?hl=zh-cn" target="_blank" rel="noopener">activity生命周期</a></h3><h3 id="3-15个android通用流行框架"><a href="#3-15个android通用流行框架" class="headerlink" title="3.15个android通用流行框架"></a>3.<a href="https://www.oschina.net/news/73836/15-android-general-popular-frameworks" target="_blank" rel="noopener">15个android通用流行框架</a></h3><h3 id="c-c-和java的区别"><a href="#c-c-和java的区别" class="headerlink" title="c/c++和java的区别"></a>c/c++和java的区别</h3><p>Java和C都是指令式语言，</p>
<p>不同的是：</p>
<p>（1）Java有面向对象（OO,Object Oritended）成分在里面，而C是完全面向过程的，C的高级版本C++、C#支持面向对象。</p>
<p>（2）Java中采用在某个类中定义一种公用静态的变量来完成定义全局变量的功能；而不是在所有类之外定义全局变量。</p>
<p>（3）Java不支持头文件；而C和C++语言中都是用头文件来定义类的原型、全局变量、库函数等。</p>
<p>（4）Java不支持宏定义，而是使用关键字final来定义变量；而C++在采用宏定义来实现常量定义。</p>
<p>（5）Java中不包含结构和联合，所有内容都封装在类里面；而C和C++中结构和联合的所有成员均为公用，这就带来了安全性问题。</p>
<p>（6）Java中不再使用指针，既省略了指针，每个指向对象的变量其实都是指针；而指针在C和C++中却是最灵活、最易出错的数据类型。</p>
<p>（7）Java跨平台，既不同的操作系统都可以通过JVM（Java Virtual Machine（Java虚拟机））来解释Java程序，而C、C++、C#则是与平台（CPU+OS+Compiler）相关的，有些指令只在某些操作系统中才能执行。原因是：Java是解释型语言，所有代码都会翻译成统一的、与系统无关的bytecode，然后放到JVM上运行，而C是编译式语言，代码要先通过编译器转换成与系统相关的中间代码，然后才能运行。也可以理解为Java中，int类型总是32位的，而在C和C++中，对于不同的平台，同一个数据类型分配不同的字节数，同样是int类型，在16位的操作系统（16位的寄存器，16位的编译器）下，为2个字节既16位；在32位的操作系统（32位的寄存器、32位的编译器）下，为4个字节既32位。这使得C语言造成不可移植性，而Java具有跨平台性。</p>
<p>（8）Java不支持系统调用，既无法与操作系统进行交互，这是由它的跨平台的特点决定的，而C则可以调用系统中的指令，如fork()。这也是为何Java中只有线程（Thread）概念而没有进程（Process）概念，而C两者都有。</p>
<p>（9）在内存分配方面：<br>       Java中对内存的分配是动态的，采用面向对象的机制，用运算符new为每个对象分配内存空间。然而Java无法对内存进行控制，也可以说实际内存会随着程序运行情况而改变。在程序运行中，每个Java系统自动对内存进行扫描，对长期不用的空间作为“垃圾”进行收集（采用Gabbage Collection机制），使得系统资源得到更充分地利用。按照这种机制，程序员不必关注内存管理问题，使得Java程序得编写变得简单明了，并且避免了由于内存管理方面的差错而导致系统出问题。而另外两个都是通过指针对内存进行人为分配的：C语言通过malloc()和free()这两个库函数来分别实现分配内在和释放内存空间；C++语言则是通过运算符new()和delete()来分配和释放内存。在C和C++的这种机制中，程序员必须非常仔细地处理内存的使用问题。一方面，如果对已释放的内存或者是未曾分配的内存做释放，都会造成死机；另一方面，若是对长期不用的或是不再使用的内存不释放，则会浪费系统资源，甚至因此造成资源枯竭。</p>
<h2 id="（二十七）知识点"><a href="#（二十七）知识点" class="headerlink" title="（二十七）知识点"></a>（二十七）知识点</h2><h3 id="1-vector源码初始设置值"><a href="#1-vector源码初始设置值" class="headerlink" title="1. vector源码初始设置值"></a>1. vector源码初始设置值</h3><p>设置初始值为0或者未设置的话分配1<br>否则为初始值的二倍</p>
<h3 id="2-linux内存管理"><a href="#2-linux内存管理" class="headerlink" title="2. linux内存管理"></a>2. linux内存管理</h3><ul>
<li>虚拟内存</li>
<li>物理内存：Linux内核管理物理内存是通过分页机制实现的</li>
</ul>
<h3 id="3-内置类型和复合类型"><a href="#3-内置类型和复合类型" class="headerlink" title="3. 内置类型和复合类型"></a>3. 内置类型和复合类型</h3><p>内置类型包括算术类型和空类型。算术类型分为整型和浮点型，其中整型包括字符型和布尔型。</p>
<p>复合类型主要包括：引用、指针、数组。</p>
<h3 id="4-c-模板和java泛型有什么区别"><a href="#4-c-模板和java泛型有什么区别" class="headerlink" title="4. c++模板和java泛型有什么区别"></a>4. c++模板和java泛型有什么区别</h3><p>（1） 在C ++中，泛型函数/类只能在标头中定义，因为编译器会针对不同的类型(使用其调用)生成不同的函数。因此编译速度较慢。在Java中，编译不会带来很大的损失，但是Java使用一种称为”擦除”的技术，其中泛型在运行时被擦除，因此在运行时Java实际上正在调用…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Something sum(Something a, Something b) &#123; return a.add ( b ); &#125;</span><br></pre></td></tr></table></figure>
<p>（2）Java泛型是转换对象的包装器;c++是编译多态，模板基本上是经过修饰的预处理器/宏集<br>（3）c++可以使用原始类型参数，java不能使用基本类型参数只能使用引用类型eg,Integer<br>注：Java语法比C ++语法更冗长，并且没有很多C ++功能(例如运算符重载，多重继承，析构函数等</p>
<h3 id="5-布隆过滤器"><a href="#5-布隆过滤器" class="headerlink" title="5.布隆过滤器"></a>5.<a href="https://www.cnblogs.com/qdhxhz/p/11259078.html" target="_blank" rel="noopener">布隆过滤器</a></h3><p>布隆过滤器是由一个很长的bit数组和一系列哈希函数组成的。</p>
<p>数组的每个元素都只占1bit空间，并且每个元素只能为0或1。</p>
<p>布隆过滤器还拥有k个哈希函数，当一个元素加入布隆过滤器时，会使用k个哈希函数对其进行k次计算,得到k个哈希值，并且根据得到的哈希值，在维数组中把对应下标的值置位1。</p>
<p>判断某个数是否在布隆过滤器中，就对该元素进行k次哈希计算，得到的值在位数组中判断每个元素是否都为1，如果每个元素都为1，就说明这个值在布隆过滤器中。</p>
<h3 id="6-NoSQL和SQL的区别"><a href="#6-NoSQL和SQL的区别" class="headerlink" title="6.NoSQL和SQL的区别"></a>6.<a href="https://www.cnblogs.com/jeakeven/p/5402095.html" target="_blank" rel="noopener">NoSQL和SQL的区别</a></h3><p>SQL (Structured Query Language) 数据库，指关系型数据库。主要代表：SQL Server，Oracle，MySQL(开源)，PostgreSQL(开源)。<br>NoSQL（Not Only SQL）泛指非关系型数据库。主要代表：MongoDB，Redis，CouchDB。</p>
<h3 id="7-为什么要分堆和栈"><a href="#7-为什么要分堆和栈" class="headerlink" title="7. 为什么要分堆和栈"></a>7. 为什么要分堆和栈</h3><ol>
<li>堆中存的是对象（相应栈中只需记录堆中的一个地址即可），运行时确定内存大小；栈中存的是基本数据类型和堆中对象的引用，在编译时即可确定内存大小。堆栈分离使得动态增长成为可能。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。</li>
<li>堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li>
</ol>
<p><strong>为什么不把基本类型放堆中呢？</strong><br>因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。</p>
<p><strong>为什么堆是线程共享的而栈不是？</strong><br>（1）Stack常用来存放函数的参数，函数中使用的局部变量，存放过程活动记录，不同线程之间不同需要区分开来，如果多个线程共享一个Stack会非常的凌乱，不方便使用。<br>（2）使用共享Heap的目的是为了高效的数据共享</p>
<p>实质是为了解决一个问题：线程间通信。想要实现线程间通信，目前有两种方法：<br>（1）共享内存方式shared memory（共享堆）：最大的优势是快速<br>（2）消息传递方式message passing（不需要共享堆）：优势在于安全</p>
<h3 id="8-c-线程中的几种锁"><a href="#8-c-线程中的几种锁" class="headerlink" title="8. c++线程中的几种锁"></a>8. c++线程中的几种锁</h3><p>（1）自旋锁：CPU循环请求锁 spin_lock 适合于短时间的轻量级的加锁机制(中断异常 可延迟函数(中断下半部，不可睡眠))<br>（2）互斥锁: mutex<br>（3）条件锁：condition——variable std::condition_variable works only with std::unique_lock<a href="std::mutex">std::mutex</a>;<br>（4）读写锁: 可同时读，只能一个写  c++17 shared_mutex<br>shared_lock是read lock。搭配std::shared_mutex使用，被锁后仍允许其他线程执行同样被shared_lock的代码。<br>lock_guard和unique_lock是write lock。被锁后不允许其他线程执行被shared_lock或unique_lock的代码。</p>
<p>** 数据库中的锁**<br><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/lock.png" alt></p>
<p><strong>数据库隔离级别</strong><br>了解了数据的锁机制，数据库的隔离级别也就好理解多了。每一种隔离级别满足不同的数据要求，使用不同程度的锁。</p>
<p>Read Uncommitted，读写均不使用锁，数据的一致性最差，也会出现许多逻辑错误。</p>
<p>Read Committed，使用写锁，但是读会出现不一致，不可重复读。</p>
<p>Repeatable Read, 使用读锁和写锁，解决不可重复读的问题，但会有幻读。</p>
<p>Serializable, 使用事务串形化调度，避免出现因为插入数据没法加锁导致的不一致的情况。</p>
<h3 id="9-git-log"><a href="#9-git-log" class="headerlink" title="9. git log"></a>9. git log</h3><h3 id="10-kill进程是进程通信：linux内核发送SIGKILL信号给进程"><a href="#10-kill进程是进程通信：linux内核发送SIGKILL信号给进程" class="headerlink" title="10. kill进程是进程通信：linux内核发送SIGKILL信号给进程"></a>10. kill进程是进程通信：linux内核发送SIGKILL信号给进程</h3><h3 id="11-windows消息驱动机制和时间驱动机制"><a href="#11-windows消息驱动机制和时间驱动机制" class="headerlink" title="11. windows消息驱动机制和时间驱动机制"></a>11. windows消息驱动机制和时间驱动机制</h3><h3 id="12-Linux设备驱动机制"><a href="#12-Linux设备驱动机制" class="headerlink" title="12. Linux设备驱动机制"></a>12. Linux设备驱动机制</h3><ul>
<li>字符设备</li>
<li>块设备</li>
<li>网络设备</li>
</ul>
<h3 id="10-字节二面编程题：1、求36进制的和-2、判断树是否对称"><a href="#10-字节二面编程题：1、求36进制的和-2、判断树是否对称" class="headerlink" title="10. 字节二面编程题：1、求36进制的和 2、判断树是否对称"></a>10. 字节二面编程题：1、求36进制的和 2、判断树是否对称</h3><h3 id="11-堆排序是原地算法，空间复杂度O-1-。"><a href="#11-堆排序是原地算法，空间复杂度O-1-。" class="headerlink" title="11. 堆排序是原地算法，空间复杂度O(1)。"></a>11. 堆排序是原地算法，空间复杂度O(1)。</h3><p>堆在逻辑上是特殊的完全二叉树，在存储结构上是顺序表。一般用数组实现。堆只分为大堆和小堆大堆：树的父亲节点必须比它的叶子节点大；小堆：树中父亲节点比它的叶子小，只有这两种特殊的情况下一个数组才能被称为堆。</p>
<pre><code>- 自底向上构建堆时间复杂度O（n）：从最后一个非叶子结点开始循环遍历直到根结点

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span>; i != <span class="number">0</span>; i--)</span><br><span class="line">		sink(n, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

- 自顶向下构建堆时间复杂度O（nlogn）：从根结点开始

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            swim(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="12-常见数据结构的查找、插入、删除时间复杂度"><a href="#12-常见数据结构的查找、插入、删除时间复杂度" class="headerlink" title="12. 常见数据结构的查找、插入、删除时间复杂度"></a>12. 常见数据结构的查找、插入、删除时间复杂度</h3><table>
<thead>
<tr>
<th align="center">数据结构</th>
<th align="center">访问</th>
<th align="center">查找</th>
<th align="center">插入</th>
<th align="center">删除</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数组</td>
<td align="center">O(1)</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">有序数组</td>
<td align="center">O(1)</td>
<td align="center">O(logn)</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">链表</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">有序链表</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">二叉查找树</td>
<td align="center">O(logn)</td>
<td align="center">O(logn)</td>
<td align="center">O(logn)</td>
<td align="center">O(logn)</td>
</tr>
<tr>
<td align="center">哈希表</td>
<td align="center">—</td>
<td align="center">O(1)</td>
<td align="center">O(1)</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/struct.png" alt="常见数据结构插入查找删除复杂度"></p>
<h3 id="13-使用递归函数需要注意防止栈溢出-。"><a href="#13-使用递归函数需要注意防止栈溢出-。" class="headerlink" title="13. 使用递归函数需要注意防止栈溢出**。"></a>13. <strong>使用递归函数需要注意防止</strong>栈溢出**。</h3><p>在计算机中，<strong>函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出</strong><code>fact(1000)</code>。**</p>
<pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> n</span>==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></code></pre><p>​    </p>
<pre><code>**尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。**

上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，主要是要把每一步的乘积传入到递归函数中：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">fact_iter</span><span class="params">(n, <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">fact_iter</span><span class="params">(num, product)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> num </span>== <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br></pre></td></tr></table></figure>

**栈帧**
每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数的返回地址和局部变量。

栈帧也叫过程活动记录，是编译器用来实现过程/函数调用的一种数据结构。从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等。

栈是从高地址向低地址延伸的。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着所需要的各种信息。寄存器ebp指向当前的栈帧的底部（高地址），寄存器esp指向当前的栈帧的顶部（低地址）。

注意：EBP指向当前位于系统栈最上边一个栈帧的底部，而不是系统栈的底部。严格说来，“栈帧底部”和“栈底”是不同的概念;ESP所指的栈帧顶部和系统栈的顶部是同一个位置。</code></pre><h3 id="14-递归时间复杂度"><a href="#14-递归时间复杂度" class="headerlink" title="14. 递归时间复杂度"></a>14. 递归时间复杂度</h3><p>master公式：</p>
<p>T [n] = aT[n/b] + f (n)（直接记为T [n] = aT[n/b] + T (N^d)）</p>
<p>其中 a &gt;= 1 and b &gt; 1 是常量，其表示的意义是n表示问题的规模，a表示递归的次数也就是生成的子问题数，b表示每次递归是原来的1/b之一个规模，f（n）表示分解和合并所要花费的时间之和。</p>
<p>解法：<br>①当d&lt;logb a时，时间复杂度为O(n^(logb a))<br>②当d=logb a时，时间复杂度为O((n^d)*logn)<br>③当d&gt;logb a时，时间复杂度为O(n^d)</p>
<h3 id="15-struct和class的区别"><a href="#15-struct和class的区别" class="headerlink" title="15. struct和class的区别"></a>15. struct和class的区别</h3><ul>
<li><p>默认成员访问说明符：struct-public;class-private</p>
</li>
<li><p>默认派生访问说明符:   struct-public;class-private</p>
</li>
<li><p>构造函数不同：（1）结构体不能包含显示地无参数构造函数，在自定义构造函数中必须为所有成员赋值。结构体成员将自动初始化为它们的默认值。（2）结构体不能包含以下形式的初始值设定类：base(argument-list)</p>
</li>
<li><p>关于使用大括号初始化</p>
</li>
</ul>
<p>当struct和class中都定义了构造函数，就不能使用大括号对其进行初始化;若没有定义构造函数，struct可以使用{ }进行初始化，而只有当class的所有数据成员及函数为public时，可以使用{ }进行初始化;所以struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。</p>
<ul>
<li><p>class能用于表示模板类型；struct不能</p>
<p>注意：<strong>c++ struct能包含成员函数；struct能继承；struct能实现多态</strong></p>
<p><strong>在面向c的过程中，struct是值类型，栈中创建（栈资源却很有限，因此struct常用来处理作为基类型对待的小对象）；class是引用类型，堆中创建;struct不能包含任何函数，无继承，无多态;对于结构体中的实例字段成员，不能在声明时赋值初始化;可以直接使用大括号对所有数据成员进行初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">test A=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="comment">//完全可以</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="16-两种通用的遍历树的策略"><a href="#16-两种通用的遍历树的策略" class="headerlink" title="16. 两种通用的遍历树的策略"></a>16. 两种通用的遍历树的策略</h3><ul>
<li>深度优先搜索（DFS）</li>
</ul>
<p>采用深度作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回根到达另一个分支。深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为前序遍历，中序遍历和后序遍历。</p>
<ul>
<li>宽度优先搜索（BFS）</li>
</ul>
<p>按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。</p>
<h3 id="17-std-funtion和std-bind参考"><a href="#17-std-funtion和std-bind参考" class="headerlink" title="17. std::funtion和std::bind参考"></a>17. std::funtion和std::bind<a href="https://blog.csdn.net/qq_38410730/article/details/103637778" target="_blank" rel="noopener">参考</a></h3><h3 id="18-函数对象：定义了调用操作符（）的类对象。"><a href="#18-函数对象：定义了调用操作符（）的类对象。" class="headerlink" title="18. 函数对象：定义了调用操作符（）的类对象。"></a>18. 函数对象：定义了调用操作符（）的类对象。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sort</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;str2)</span> <span class="keyword">const</span>  <span class="comment">//带两个参数</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> str1 &gt; str2;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">然后我们可以用这个类作为参数来初始化<span class="built_in">set</span>容器：</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, Sort&gt; myset;  <span class="comment">//带比较函数的set构造函数,并用函数对象Sort初始化</span></span><br><span class="line">myset.insert(<span class="string">"A"</span>);  </span><br><span class="line">myset.insert(<span class="string">"B"</span>);  </span><br><span class="line"><span class="comment">//输出为：B，A。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upper</span> </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Upper(<span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">0</span>):m_min(<span class="built_in">min</span>)&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">const</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value &gt;= m_min;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">int</span> m_min;  </span><br><span class="line">&#125;;  </span><br><span class="line">从而这样调用 find_if 函数：</span><br><span class="line"></span><br><span class="line">find_if( dest.<span class="built_in">begin</span>(), dest.<span class="built_in">end</span>(), Upper(<span class="number">10</span>) );</span><br><span class="line"></span><br><span class="line">首先生成类 Upper 的对象，并用 <span class="number">10</span> 初始化，调用find_if 时将用该函数对象进行判断。</span><br></pre></td></tr></table></figure>

<h3 id="19-解决hash冲突的三种方法"><a href="#19-解决hash冲突的三种方法" class="headerlink" title="19. 解决hash冲突的三种方法"></a>19. 解决hash冲突的三种方法</h3><p>哈希函数的构造方法很多，常用的有直接定址法、数字分析法、平方取中法、折叠法、除留余数法、随机数法等，一般常用除留余数法。</p>
<ul>
<li>开放地址法：线性探测、二次探测</li>
<li>链地址法：又称拉链法，将所有具有相同哈希地址的而不同关键字的元素连接到同一个单链表中。如果选定的哈希表长度为m，则可以将哈希表定义为一个有m个头指针组成的指针数组。</li>
<li>再散列法：有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。</li>
<li>建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表</li>
</ul>
<h3 id="20-文件描述符、打开文件描述符表、文件表、inode节点"><a href="#20-文件描述符、打开文件描述符表、文件表、inode节点" class="headerlink" title="20. 文件描述符、打开文件描述符表、文件表、inode节点"></a>20. 文件描述符、打开文件描述符表、文件表、inode节点</h3><p>在内核中每一个打开的文件都需要由3种数据结构来进行维护：</p>
<p>1）每个进程对应一张<strong>打开文件描述符表</strong>，这是进程级数据结构，也就是每一个进程都各自有这样一个数据结构；</p>
<p>2）内核维持一张打开文件表，<strong>文件表</strong>由多个文件表项组成，这是系统级数据结构，也就是说这样的数据结构是针对于整个内核而言的，每个进程都可共享的；</p>
<p>3.每个打开的文件对应一个i节点（i-node）数据结构（Linux下只有i节点没有v节点），由于这是每一个打开的文件与之对应的，因此这也是一个系统级数据结构，存在于内核中，非进程所独有。</p>
<p>不同进程打开现存文件或新建文件时，内核会返回一个<strong>文件描述符</strong>（file descriptor），它是个非负整数。对于每一个进程，都会分配一个PCB数据结构，它其中包含了该进程的所有信息，而在代码实现上，这个数据结构名为<strong>task_struct</strong>， 在<strong>task_struct</strong>中，有一个成员变量名为<strong>files</strong>，这是一个描述打开文件信息的变量，其类型为<strong>struct files_struct *</strong>。在所有进程的PCB（Process Control Block）中均会保存一份<strong>打开文件描述符表</strong>，实际上就是files_struct 中的成员struct file * fd_array[NR_OPEN_DEFAULT]它是一个指针数组，数组每一个元素都是一个指向file类型的指针，可想而知，这些指针都会指向一个打开的文件，并且file这一数据结构就是用来描述一个打开的文件的，<strong>而我们所说的文件描述符，实际上就是这个指针数组的索引</strong>。这也是为什么文件描述符是非负整数。文件描述符就是这个表的索引（数组下标），每个表项都有一个指向已打开文件的指针（数组的内容），<strong>具体是指向文件表中该文件对应的表格项</strong>。</p>
<p>在Linux系统中，已打开的文件形成<strong>打开文件表</strong>（open file table），存放在<strong>内核空间</strong>（系统级）中，并由系统里的所有进程共享。该表中每个表格保存了一个打开文件的全部信息，如下所示：</p>
<ul>
<li>当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）；</li>
<li>打开文件时所使用的状态标识（即，open()的flags参数）；<br>文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）；</li>
<li>与信号驱动相关的设置；</li>
<li>对该文件<strong>i-node</strong>对象的引用；</li>
<li>文件类型（例如：常规文件、套接字或FIFO）和访问权限；</li>
<li>一个指针，指向该文件所持有的锁列表；</li>
<li>文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳；</li>
</ul>
<p>文件表项的数据结构就是file结构体，而在实际上内核中也并不存在这样一张文件表，只是每个打开的文件都对应一个file结构体，也就是一个文件表项，<strong>打开文件描述符表**</strong>struct file * fd_array[NR_OPEN_DEFAULT]**数组中的每一项都会指向这样一个文件表项。</p>
<p>文件描述符是一个POSIX标准下的概念，为系统调用接口，常见于Linux系统。Windows也是声称遵循POSIX标准的，所以Windows也有文件描述符等概念，但不常用。文件描述符的分配规则： 从当前未被分配的最小整数处分匹配，特别的有：标准输入（stdin）的文件描述符是 0；标准输出（stdout）的文件描述符是 1；标准错误（stderr）的文件描述符是 2。</p>
<p>通过inode结构，可以知道文件数据块的在磁盘上的位置以及文件大小等信息，这样才能使得进程能够通过file结构体来找到磁盘上相应文件的位置来进行文件读写。理解inode，要从文件储存说起。文件存储在硬盘上，硬盘的最小存储单位叫做“扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。操作系统读取硬盘的时候，不会一个个扇区的读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。这种由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的是4KB，即连续八个sector组成一个block。文件数据都储存在“块”中，那么很显然，我们还必须找到一个地方储存文件的“元信息”，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做<strong>inode</strong>即，<strong>即索引节点</strong>。</p>
<p>注意：</p>
<ul>
<li>同一个进程的不同文件描述符可以指向同一个文件；</li>
<li>不同进程可以拥有相同的文件描述符；</li>
<li>不同进程的同一个文件描述符可以指向不同的文件（一般也是这样，除了 0、1、2 这三个特殊的文件）；</li>
<li>不同进程的不同文件描述符也可以指向同一个文件。</li>
</ul>
<h3 id="21-查找路由器地址"><a href="#21-查找路由器地址" class="headerlink" title="21. 查找路由器地址"></a>21. 查找路由器地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat</span><br><span class="line">ip route</span><br><span class="line">route</span><br></pre></td></tr></table></figure>

<h3 id="22-const-static-inline默认内部链接（内部链接的符号不能在别的编译单元中使用），若要实现共享，则要定义于头文件；函数和变量默认外部链接（外部链接的符号在整个程序范围内都是可以使用的，这就要求其他编译单元不能导出相同的符号（不然就会报duplicated-external-symbols）"><a href="#22-const-static-inline默认内部链接（内部链接的符号不能在别的编译单元中使用），若要实现共享，则要定义于头文件；函数和变量默认外部链接（外部链接的符号在整个程序范围内都是可以使用的，这就要求其他编译单元不能导出相同的符号（不然就会报duplicated-external-symbols）" class="headerlink" title="22. const/static/inline默认内部链接（内部链接的符号不能在别的编译单元中使用），若要实现共享，则要定义于头文件；函数和变量默认外部链接（外部链接的符号在整个程序范围内都是可以使用的，这就要求其他编译单元不能导出相同的符号（不然就会报duplicated external symbols）"></a>22. const/static/inline默认内部链接（内部链接的符号不能在别的编译单元中使用），若要实现共享，则要定义于头文件；函数和变量默认外部链接（外部链接的符号在整个程序范围内都是可以使用的，这就要求其他编译单元不能导出相同的符号（不然就会报duplicated external symbols）</h3><h3 id="23-read-write-fsync和fread-fwrite-fflush都是对文件进行操作，那她们有什么区别呢"><a href="#23-read-write-fsync和fread-fwrite-fflush都是对文件进行操作，那她们有什么区别呢" class="headerlink" title="23. read/write/fsync和fread/fwrite/fflush都是对文件进行操作，那她们有什么区别呢"></a>23. read/write/fsync和fread/fwrite/fflush都是对文件进行操作，那她们有什么区别呢</h3><ol>
<li>read/write和fread/fwrite区别</li>
</ol>
<ul>
<li>fread是带缓冲的,read不带缓冲.</li>
<li>fopen是标准c里定义的,open是POSIX中定义的.</li>
<li>fread可以读一个结构.read在<a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">Linux</a>/unix中读二进制与普通文件没有区别.</li>
<li>fopen不能指定要创建文件的权限.open可以指定权限.</li>
<li>fopen返回指针,open返回文件描述符(整数).</li>
<li>linux/unix中任何设备都是文件,都可以用open,read.</li>
</ul>
<p>如果文件的大小是8k。</p>
<p>你如果用read/write，且只分配了2k的缓存，则要将此文件读出需要做4次系统调用来实际从磁盘上读出。</p>
<p>如果你用fread/fwrite，则系统自动分配缓存，则读出此文件只要一次系统调用从磁盘上读出。</p>
<p>也就是用read/write要读4次磁盘，而用fread/fwrite则只要读1次磁盘。效率比read/write要高4倍。</p>
<p>如果程序对内存有限制，则用read/write比较好。</p>
<p>都用fread 和fwrite,它自动分配缓存,速度会很快,比自己来做要简单。如果要处理一些特殊的描述符,用read 和write,如套接口,管道之类的</p>
<p>系统调用write的效率取决于你buf的大小和你要写入的总数量，如果buf太小，你进入内核空间的次数大增，效率就低下。而fwrite会替你做缓存，减少了实际出现的系统调用，所以效率比较高。</p>
<p>read/write/fsync： </p>
<ol>
<li><p>linux底层操作；</p>
</li>
<li><p>内核调用， 涉及到进程上下文的切换，即用户态到核心态的转换，这是个比较消耗性能的操作。</p>
</li>
</ol>
<p>fread/fwrite/fflush： </p>
<ol>
<li><p>c语言标准规定的io流操作，建立在read/write/fsync之上</p>
</li>
<li><p>在用户层， 又增加了一层缓冲机制，用于减少内核调用次数，但是增加了一次内存拷贝。</p>
</li>
</ol>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/fflush.jpg" alt></p>
<p><strong>fflush和fsync的联系和区别</strong></p>
<p>1.提供者fflush是libc.a中提供的方法，fsync是系统提供的系统调用。</p>
<p>2.原形fflush接受一个参数FILE *.fflush(FILE *);fsync接受的时一个Int型的文件描述符。fsync(int fd);</p>
<p>3.功能fflush:是把C库中的缓冲调用write函数写到磁盘[其实是写到内核的缓冲区]。fsync：是把内核缓冲刷到磁盘上。 </p>
<p>c库缓冲—–fflush———〉内核缓冲——–fsync—–〉磁盘</p>
<p>补充：</p>
<ol>
<li><p>对于输入设备，调用fsync/fflush将清空相应的缓冲区，其内数据将被丢弃;</p>
</li>
<li><p>对于输出设备或磁盘文件，fflush只能保证数据到达内核缓冲区，并不能保证数据到达物理设备, 因此应该在调用fflush后，调用fsync(fileno(stream))，确保数据存入磁盘。</p>
</li>
</ol>
<h3 id="24-TCP协议保证数据传输可靠性的主要方式"><a href="#24-TCP协议保证数据传输可靠性的主要方式" class="headerlink" title="24.  TCP协议保证数据传输可靠性的主要方式"></a>24.  <a href="https://blog.csdn.net/liuchenxia8/article/details/80428157" target="_blank" rel="noopener">TCP协议保证数据传输可靠性的主要方式</a></h3><ol>
<li>校验和</li>
<li>序列号</li>
<li>确认应答</li>
<li>超时重传</li>
<li>连接管理</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ol>
<h3 id="25-Linux-虚拟内存和物理内存的理解"><a href="#25-Linux-虚拟内存和物理内存的理解" class="headerlink" title="25. Linux 虚拟内存和物理内存的理解"></a>25. <a href="https://github.com/Durant35/durant35.github.io/issues/24" target="_blank" rel="noopener">Linux 虚拟内存和物理内存的理解</a></h3><p>每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址<br>所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。<br>进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录<br>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）<br>当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常<br>缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘。<br>每个进程都有一个自己的页表，使得某逻辑地址对应于某个物理内存。 正因为每个进程都有一个自己的页表，使得相同的逻辑地址映射到不同的物理内存。</p>
<h3 id="26-Socket通信"><a href="#26-Socket通信" class="headerlink" title="26.Socket通信"></a>26.<a href="https://www.cnblogs.com/fengff/p/10984251.html" target="_blank" rel="noopener">Socket通信</a></h3><h3 id="27-索引使用原则"><a href="#27-索引使用原则" class="headerlink" title="27.索引使用原则"></a>27.<a href="https://www.cnblogs.com/wangxusummer/p/5329813.html" target="_blank" rel="noopener">索引使用原则</a></h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          
            <a href="/tags/shell/" rel="tag"># shell</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/" rel="next" title="C++易混点">
                <i class="fa fa-chevron-left"></i> C++易混点
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/25/Git%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" rel="prev" title="Git操作注意事项">
                Git操作注意事项 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">翟安然</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#（一）面向对象的三个基本特征：封装、继承、多态"><span class="nav-number">1.</span> <span class="nav-text">（一）面向对象的三个基本特征：封装、继承、多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（二）bash-shell"><span class="nav-number">2.</span> <span class="nav-text">（二）bash shell</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（三）图"><span class="nav-number">3.</span> <span class="nav-text">（三）图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（四）IO库"><span class="nav-number">4.</span> <span class="nav-text">（四）IO库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（五）搜狗"><span class="nav-number">5.</span> <span class="nav-text">（五）搜狗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（六）手写代码"><span class="nav-number">6.</span> <span class="nav-text">（六）手写代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（七）SAP"><span class="nav-number">7.</span> <span class="nav-text">（七）SAP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（八）进程间的通信方式（IPC-inter-Process-Communication）"><span class="nav-number">8.</span> <span class="nav-text">（八）进程间的通信方式（IPC,inter-Process Communication）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程创建fork和vfork"><span class="nav-number">8.1.</span> <span class="nav-text">进程创建fork和vfork</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别："><span class="nav-number">8.2.</span> <span class="nav-text">fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程和线程的区别"><span class="nav-number">8.3.</span> <span class="nav-text">进程和线程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程有什么是共享的什么是私有的"><span class="nav-number">8.4.</span> <span class="nav-text">线程有什么是共享的什么是私有的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的三种基本状态"><span class="nav-number">8.5.</span> <span class="nav-text">进程的三种基本状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#windows命名管道和Linux命名管道的区别"><span class="nav-number">8.6.</span> <span class="nav-text">windows命名管道和Linux命名管道的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#windows多线程通信的方法主要有三种："><span class="nav-number">8.7.</span> <span class="nav-text">windows多线程通信的方法主要有三种：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？"><span class="nav-number">8.8.</span> <span class="nav-text">死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（九）SQL"><span class="nav-number">9.</span> <span class="nav-text">（九）SQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（十一）百度"><span class="nav-number">10.</span> <span class="nav-text">（十一）百度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#百度后台开发c-PHP实习"><span class="nav-number">10.1.</span> <span class="nav-text">百度后台开发c++&#x2F;PHP实习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#百度B2B后台开发c-PHP提前批"><span class="nav-number">10.2.</span> <span class="nav-text">百度B2B后台开发c++&#x2F;PHP提前批</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#百度二面："><span class="nav-number">10.2.1.</span> <span class="nav-text">百度二面：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#百度正式批一面"><span class="nav-number">10.3.</span> <span class="nav-text">百度正式批一面</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static函数"><span class="nav-number">10.3.1.</span> <span class="nav-text">static函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inline"><span class="nav-number">10.3.2.</span> <span class="nav-text">inline</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-中-内联编译限制"><span class="nav-number">10.3.3.</span> <span class="nav-text">C++中 内联编译限制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数可以是虚函数吗"><span class="nav-number">10.3.4.</span> <span class="nav-text">构造函数可以是虚函数吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#socket手撸"><span class="nav-number">10.3.5.</span> <span class="nav-text">socket手撸</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二面"><span class="nav-number">10.4.</span> <span class="nav-text">二面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三面"><span class="nav-number">10.5.</span> <span class="nav-text">三面</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash与红黑树的区别："><span class="nav-number">10.5.1.</span> <span class="nav-text">Hash与红黑树的区别：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#拉链法的优点与开放定址法相比，拉链法有如下几个优点"><span class="nav-number">10.5.1.1.</span> <span class="nav-text">拉链法的优点与开放定址法相比，拉链法有如下几个优点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线性探测法优缺点"><span class="nav-number">10.5.2.</span> <span class="nav-text">线性探测法优缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（十二）网易"><span class="nav-number">11.</span> <span class="nav-text">（十二）网易</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（十三）腾讯"><span class="nav-number">12.</span> <span class="nav-text">（十三）腾讯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#腾讯测开实习"><span class="nav-number">12.1.</span> <span class="nav-text">腾讯测开实习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#正式批一面"><span class="nav-number">12.1.1.</span> <span class="nav-text">正式批一面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AJAX"><span class="nav-number">12.1.2.</span> <span class="nav-text">AJAX</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（十五）快手"><span class="nav-number">13.</span> <span class="nav-text">（十五）快手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c-工程师-AI平台"><span class="nav-number">13.1.</span> <span class="nav-text">c++工程师-AI平台</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（十六）猿辅导"><span class="nav-number">14.</span> <span class="nav-text">（十六）猿辅导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二面-1"><span class="nav-number">14.1.</span> <span class="nav-text">二面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（十七）阿里"><span class="nav-number">15.</span> <span class="nav-text">（十七）阿里</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（十八）华为"><span class="nav-number">16.</span> <span class="nav-text">（十八）华为</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#正式批"><span class="nav-number">16.1.</span> <span class="nav-text">正式批</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、概述"><span class="nav-number">16.1.1.</span> <span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、编译过程"><span class="nav-number">16.1.2.</span> <span class="nav-text">二、编译过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、链接过程"><span class="nav-number">16.1.3.</span> <span class="nav-text">三、链接过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为创建可执行文件，链接器必须要完成的主要任务"><span class="nav-number">16.1.4.</span> <span class="nav-text">为创建可执行文件，链接器必须要完成的主要任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、加载过程"><span class="nav-number">16.1.5.</span> <span class="nav-text">四、加载过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串分隔符分隔和定义比较函数"><span class="nav-number">16.1.6.</span> <span class="nav-text">字符串分隔符分隔和定义比较函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（十九）腾讯测开"><span class="nav-number">17.</span> <span class="nav-text">（十九）腾讯测开</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（二十）美团"><span class="nav-number">18.</span> <span class="nav-text">（二十）美团</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#美团测开实习"><span class="nav-number">18.1.</span> <span class="nav-text">美团测开实习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#美团数据开发（快驴事业部）"><span class="nav-number">18.2.</span> <span class="nav-text">美团数据开发（快驴事业部）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二面-2"><span class="nav-number">18.2.1.</span> <span class="nav-text">二面</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（二十一）中兴捧月模拟大赛"><span class="nav-number">19.</span> <span class="nav-text">（二十一）中兴捧月模拟大赛</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（二十二）招银网络"><span class="nav-number">20.</span> <span class="nav-text">（二十二）招银网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#正式批-1"><span class="nav-number">20.1.</span> <span class="nav-text">正式批</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二面-3"><span class="nav-number">20.1.1.</span> <span class="nav-text">二面</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（二十三）字节"><span class="nav-number">21.</span> <span class="nav-text">（二十三）字节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（二十四）小米"><span class="nav-number">22.</span> <span class="nav-text">（二十四）小米</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一面"><span class="nav-number">22.1.</span> <span class="nav-text">一面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（二十五）滴滴"><span class="nav-number">23.</span> <span class="nav-text">（二十五）滴滴</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#非分布式系统中的线程"><span class="nav-number">23.1.</span> <span class="nav-text">非分布式系统中的线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式系统中的线程"><span class="nav-number">23.2.</span> <span class="nav-text">分布式系统中的线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点"><span class="nav-number">23.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点"><span class="nav-number">23.4.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟地址（VA）如何转换成物理地址（PA）空间"><span class="nav-number">23.5.</span> <span class="nav-text">虚拟地址（VA）如何转换成物理地址（PA）空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（二十六）网易"><span class="nav-number">24.</span> <span class="nav-text">（二十六）网易</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-MVC举例-其他设计模式-工厂模式-适配器模式-策略模式"><span class="nav-number">24.1.</span> <span class="nav-text">1. MVC举例 其他设计模式:工厂模式  适配器模式  策略模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一-简单工厂模式-工厂方法模式-抽象工厂模式"><span class="nav-number">24.1.1.</span> <span class="nav-text">(一)简单工厂模式  工厂方法模式   抽象工厂模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（二）适配器模式"><span class="nav-number">24.1.2.</span> <span class="nav-text">（二）适配器模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（三）策略模式"><span class="nav-number">24.1.3.</span> <span class="nav-text">（三）策略模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-activity生命周期"><span class="nav-number">24.2.</span> <span class="nav-text">2. activity生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-15个android通用流行框架"><span class="nav-number">24.3.</span> <span class="nav-text">3.15个android通用流行框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-c-和java的区别"><span class="nav-number">24.4.</span> <span class="nav-text">c&#x2F;c++和java的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（二十七）知识点"><span class="nav-number">25.</span> <span class="nav-text">（二十七）知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-vector源码初始设置值"><span class="nav-number">25.1.</span> <span class="nav-text">1. vector源码初始设置值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-linux内存管理"><span class="nav-number">25.2.</span> <span class="nav-text">2. linux内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-内置类型和复合类型"><span class="nav-number">25.3.</span> <span class="nav-text">3. 内置类型和复合类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-c-模板和java泛型有什么区别"><span class="nav-number">25.4.</span> <span class="nav-text">4. c++模板和java泛型有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-布隆过滤器"><span class="nav-number">25.5.</span> <span class="nav-text">5.布隆过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-NoSQL和SQL的区别"><span class="nav-number">25.6.</span> <span class="nav-text">6.NoSQL和SQL的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-为什么要分堆和栈"><span class="nav-number">25.7.</span> <span class="nav-text">7. 为什么要分堆和栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-c-线程中的几种锁"><span class="nav-number">25.8.</span> <span class="nav-text">8. c++线程中的几种锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-git-log"><span class="nav-number">25.9.</span> <span class="nav-text">9. git log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-kill进程是进程通信：linux内核发送SIGKILL信号给进程"><span class="nav-number">25.10.</span> <span class="nav-text">10. kill进程是进程通信：linux内核发送SIGKILL信号给进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-windows消息驱动机制和时间驱动机制"><span class="nav-number">25.11.</span> <span class="nav-text">11. windows消息驱动机制和时间驱动机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-Linux设备驱动机制"><span class="nav-number">25.12.</span> <span class="nav-text">12. Linux设备驱动机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-字节二面编程题：1、求36进制的和-2、判断树是否对称"><span class="nav-number">25.13.</span> <span class="nav-text">10. 字节二面编程题：1、求36进制的和 2、判断树是否对称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-堆排序是原地算法，空间复杂度O-1-。"><span class="nav-number">25.14.</span> <span class="nav-text">11. 堆排序是原地算法，空间复杂度O(1)。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-常见数据结构的查找、插入、删除时间复杂度"><span class="nav-number">25.15.</span> <span class="nav-text">12. 常见数据结构的查找、插入、删除时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-使用递归函数需要注意防止栈溢出-。"><span class="nav-number">25.16.</span> <span class="nav-text">13. 使用递归函数需要注意防止栈溢出**。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-递归时间复杂度"><span class="nav-number">25.17.</span> <span class="nav-text">14. 递归时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-struct和class的区别"><span class="nav-number">25.18.</span> <span class="nav-text">15. struct和class的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-两种通用的遍历树的策略"><span class="nav-number">25.19.</span> <span class="nav-text">16. 两种通用的遍历树的策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-std-funtion和std-bind参考"><span class="nav-number">25.20.</span> <span class="nav-text">17. std::funtion和std::bind参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-函数对象：定义了调用操作符（）的类对象。"><span class="nav-number">25.21.</span> <span class="nav-text">18. 函数对象：定义了调用操作符（）的类对象。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-解决hash冲突的三种方法"><span class="nav-number">25.22.</span> <span class="nav-text">19. 解决hash冲突的三种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-文件描述符、打开文件描述符表、文件表、inode节点"><span class="nav-number">25.23.</span> <span class="nav-text">20. 文件描述符、打开文件描述符表、文件表、inode节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-查找路由器地址"><span class="nav-number">25.24.</span> <span class="nav-text">21. 查找路由器地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-const-static-inline默认内部链接（内部链接的符号不能在别的编译单元中使用），若要实现共享，则要定义于头文件；函数和变量默认外部链接（外部链接的符号在整个程序范围内都是可以使用的，这就要求其他编译单元不能导出相同的符号（不然就会报duplicated-external-symbols）"><span class="nav-number">25.25.</span> <span class="nav-text">22. const&#x2F;static&#x2F;inline默认内部链接（内部链接的符号不能在别的编译单元中使用），若要实现共享，则要定义于头文件；函数和变量默认外部链接（外部链接的符号在整个程序范围内都是可以使用的，这就要求其他编译单元不能导出相同的符号（不然就会报duplicated external symbols）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-read-write-fsync和fread-fwrite-fflush都是对文件进行操作，那她们有什么区别呢"><span class="nav-number">25.26.</span> <span class="nav-text">23. read&#x2F;write&#x2F;fsync和fread&#x2F;fwrite&#x2F;fflush都是对文件进行操作，那她们有什么区别呢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-TCP协议保证数据传输可靠性的主要方式"><span class="nav-number">25.27.</span> <span class="nav-text">24.  TCP协议保证数据传输可靠性的主要方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-Linux-虚拟内存和物理内存的理解"><span class="nav-number">25.28.</span> <span class="nav-text">25. Linux 虚拟内存和物理内存的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-Socket通信"><span class="nav-number">25.29.</span> <span class="nav-text">26.Socket通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-索引使用原则"><span class="nav-number">25.30.</span> <span class="nav-text">27.索引使用原则</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">翟安然</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  
  
    <script src="/js/cursor/fireworks.js"></script>
  

</body>
</html>

