<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,面试,shell," />










<meta name="description" content="[TOC] （一）面向对象的三个基本特征：封装、继承、多态 继承   子类对象可以直接调用父类中的成员函数 子类对象可以直接赋值给父类对象。 子类对象可以直接初始化父类对象。 父类引用可以直接引用子类对象。 父类指针可以直接指向子类对象。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试要点记录">
<meta property="og:url" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="翟安然&#39;s Blog">
<meta property="og:description" content="[TOC] （一）面向对象的三个基本特征：封装、继承、多态 继承   子类对象可以直接调用父类中的成员函数 子类对象可以直接赋值给父类对象。 子类对象可以直接初始化父类对象。 父类引用可以直接引用子类对象。 父类指针可以直接指向子类对象。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/seekgseekp.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/https.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/qiuck_sort.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/struct.png">
<meta property="article:published_time" content="2020-03-24T13:59:01.000Z">
<meta property="article:modified_time" content="2020-06-11T15:24:32.032Z">
<meta property="article:author" content="翟安然">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/seekgseekp.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/24/面试要点记录/"/>





  <title>面试要点记录 | 翟安然's Blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">翟安然's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="翟安然">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="翟安然's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试要点记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-24T21:59:01+08:00">
                2020-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h4 id="（一）面向对象的三个基本特征：封装、继承、多态"><a href="#（一）面向对象的三个基本特征：封装、继承、多态" class="headerlink" title="（一）面向对象的三个基本特征：封装、继承、多态"></a>（一）面向对象的三个基本特征：封装、继承、多态</h4><ol>
<li>继承</li>
</ol>
<ul>
<li>子类对象可以直接调用父类中的成员函数</li>
<li>子类对象可以直接赋值给父类对象。</li>
<li>子类对象可以直接初始化父类对象。</li>
<li>父类引用可以直接引用子类对象。</li>
<li>父类指针可以直接指向子类对象。</li>
</ul>
<a id="more"></a>

<ul>
<li>子类初始化一定会先初始化父类，析构顺序相反。</li>
<li>虚继承对构造函数的影响：<a href="https://blog.csdn.net/dqjyong/article/details/8028888?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">指南</a>。构造函数的调用可能内带大量的隐藏码，因为编译器会对构造函数进行扩充，一般而言编译器所作的扩充规则如下：</li>
</ul>
<p>（1）记录在成员初始化列表中的数据成员的初始化操作会被放到构造函数本身中，<strong>按照数据成员声明的顺序</strong></p>
<p>（2）如果有一个数据成员没有出现在初始化列表中，但是它有一个默认构造函数，那么这个默认构造函数会被调用</p>
<p>（3）在那之前，如果有虚函数表，会调整虚函数表指针</p>
<p>（4）在那之前，会对上一层基类的构造函数进行调用</p>
<p>（5）在那之前，所有虚基类的构造函数必须被调用，按照声明的继承顺序从左往右，从最深到最浅的顺序</p>
<ol start="2">
<li>多态</li>
</ol>
<ul>
<li>多态发生的三个必要条件：<ol>
<li>要有继承。</li>
<li>要有虚函数重写。</li>
<li>父类指针或引用 指向 子类对象。</li>
</ol>
</li>
<li>虚析构函数：在多态时，要调用析构函数时，注意在父类的析构成员函数前加virtual。</li>
<li>动态绑定必须使用指针或者引用，不能使用<code>.</code></li>
<li>虚函数表指针在内存中的分布:<a href="https://blog.csdn.net/li1914309758/article/details/79916414" target="_blank" rel="noopener">参考</a></li>
</ul>
<ol start="3">
<li>重载/重写（覆盖）/重定义（隐藏）</li>
</ol>
<ul>
<li>重载（overload）-编译时的多态性</li>
</ul>
<p>（1）重载只能通过不同的参数样式（参数类型、个数、顺序至少有一个不相同），不能通过访问权限、返回类型、抛出的异常进行重载。</p>
<ul>
<li>重写（override）-运行时的多态性</li>
</ul>
<p>（1）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p>
<p>（2）被定义为final的方法不能被重写。</p>
<ul>
<li>重定义（隐藏hiding）</li>
</ul>
<p>（1）隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base display()"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base show()"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>&#123; <span class="built_in">display</span>(); show(); &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base fun(string)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base fun(int)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;<span class="comment">//overload:两个fun函数在Base类的内部被重载  </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">function</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span>:</span><span class="keyword">public</span> Base  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"ClassA display()"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;<span class="comment">//override:基类中display为虚函数，且参数列表一直，故此处为重写  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"ClassA fun(int,int)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;<span class="comment">//redefining:fun函数在Base类中不为虚函数，故此处为重定义  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"ClassA show()"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;<span class="comment">//redefining:理由同上  </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;&#125;<span class="comment">//overload:注意这是重载而不是重写，因为参数列表不同，在编译时ClassA中其实还有个编译器自己偷偷加上的从Base继承来的int function()&#123;&#125;;  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    ClassA a;  </span><br><span class="line">    Base *base=&amp;a;  </span><br><span class="line">    base-&gt;exec();<span class="comment">//display()是ClassA的，因为覆盖了，show()是Base自己的  </span></span><br><span class="line">    a.exec();<span class="comment">//结果同上,子类对象可以直接调用父类中的成员函数  </span></span><br><span class="line">    a.show();<span class="comment">//show()是ClassA重定义的  </span></span><br><span class="line">    base-&gt;fun(<span class="number">1</span>);<span class="comment">//fun()是Base自己的，因为直接从对象base调用  </span></span><br><span class="line">    a.fun(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//fun()是ClassA重定义的  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="function">ClassA <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Base <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">ClassA <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Base <span class="title">show</span><span class="params">()</span><span class="comment">//父类中的成员函数直接调用自身的Base show()</span></span></span><br><span class="line"><span class="function">ClassA <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Base <span class="title">fun</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">ClassA <span class="title">fun</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::f(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::g(int) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::h(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base *pb = &amp;d;</span><br><span class="line">    Derived *pd = &amp;d;</span><br><span class="line">    <span class="comment">// Good : behavior depends solely on type of the object</span></span><br><span class="line">    pb-&gt;f(<span class="number">3.14f</span>); <span class="comment">//Derived::f(float) 3.14</span></span><br><span class="line">    pd-&gt;f(<span class="number">3.14f</span>); <span class="comment">//Derived::f(float) 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bad : behavior depends on type of the pointer</span></span><br><span class="line">    pb-&gt;g(<span class="number">3.14f</span>); <span class="comment">//Base::g(float) 3.14</span></span><br><span class="line">    pd-&gt;g(<span class="number">3.14f</span>); <span class="comment">//Derived::g(int) 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bad : behavior depends on type of the pointer</span></span><br><span class="line">    pb-&gt;h(<span class="number">3.14f</span>); <span class="comment">//Base::h(float) 3.14</span></span><br><span class="line">    pd-&gt;h(<span class="number">3.14f</span>); <span class="comment">//Derived::h(float) 3.14</span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数Derived::f(float)覆盖了Base::f(float)。</span></span><br><span class="line"><span class="comment">//函数Derived::g(int)隐藏了Base::g(float)，而不是重载。</span></span><br><span class="line"><span class="comment">//函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>三者</th>
<th>作用域</th>
<th>有无virtual</th>
<th>函数名</th>
<th>参数列表</th>
<th>返回类型</th>
</tr>
</thead>
<tbody><tr>
<td>重载</td>
<td>相同</td>
<td>可有可无</td>
<td>相同</td>
<td>不同</td>
<td>可同可不同</td>
</tr>
<tr>
<td>重写</td>
<td>不同</td>
<td>必有</td>
<td>相同</td>
<td>相同</td>
<td>相同（协变）</td>
</tr>
<tr>
<td>隐藏</td>
<td>不同</td>
<td>可有可无</td>
<td>相同</td>
<td>可同可不同</td>
<td>可同可不同</td>
</tr>
</tbody></table>
<h4 id="（二）bash-shell"><a href="#（二）bash-shell" class="headerlink" title="（二）bash shell"></a>（二）bash shell</h4><ul>
<li><p>bash是borne again shell的缩写，是shell的一种,Linux上默认采用的是bash。</p>
</li>
<li><p>Shell 是一个 C 语言编写的程序，一般都是放在<code>/bin</code>或者<code>/user/bin</code>目录下，当前 Linux 系统可用的 Shell 都记录在<code>/etc/shells</code>文件中。<code>/etc/shells</code>是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令查看它。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/shells <span class="comment">#通过 cat 命令来查看当前 Linux 系统的可用 Shell</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$SHELL</span> <span class="comment">#查看当前Linux默认的shell，输出 SHELL 环境变量</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$BASH_VERSION</span> <span class="comment">#查看shell版本</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置取消alias：<a href="http://c.biancheng.net/linux/alias.html" target="_blank" rel="noopener">指南</a></li>
<li>PHP即“<a href="https://baike.baidu.com/item/超文本" target="_blank" rel="noopener">超文本</a><a href="https://baike.baidu.com/item/预处理器" target="_blank" rel="noopener">预处理器</a>”，是一种通用<a href="https://baike.baidu.com/item/开源/246339" target="_blank" rel="noopener">开源</a><a href="https://baike.baidu.com/item/脚本语言/1379708" target="_blank" rel="noopener">脚本语言</a>。PHP是一种在服务器端执行的嵌入HTML文档的脚本语言。PHP 独特的语法混合了C、Java、Perl 以及 PHP 自创新的语法，它可以比 CGI 或者 Perl 更快速的执行动态网页，主要适用于<a href="https://baike.baidu.com/item/Web/150564" target="_blank" rel="noopener">Web</a>开发领域。</li>
</ul>
<h4 id="（三）图"><a href="#（三）图" class="headerlink" title="（三）图"></a>（三）图</h4><ol>
<li>拓扑排序</li>
</ol>
<ul>
<li>一个有向无环图可以有<strong>一个或多个</strong>拓扑排序序列。</li>
<li>判断有向图是否有环的两种方法：(1)拓扑排序 (2)DFS</li>
</ul>
<ol start="2">
<li><p>五大常用算法</p>
<ol>
<li>分冶法</li>
</ol>
<p>分治法所能解决的问题一般具有以下几个特征：</p>
<p>  1) 该问题的规模缩小到一定的程度就可以容易地解决</p>
<p>  2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p>
<p>  3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p>
<p>  4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</p>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p>
<p><strong>第二条特征是应用分治法的前提</strong>它也是大多数问题可以满足的，此特征反映了递归思想的应用；</p>
<p><strong>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征</strong>，如果<strong>具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法</strong>。</p>
<p><strong>第四条特征涉及到分治法的效率</strong>，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但<strong>一般用动态规划法较好</strong>。可用分冶法求解的一些经典问题：二分查找；快速排序。</p>
<ol start="2">
<li><p>动态规划</p>
<p>(1)  最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
<p>(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>(3) 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。</p>
</li>
</ol>
<p>递归常常用于分冶算法和动态规划算法中。</p>
<ol start="3">
<li>贪心算法</li>
</ol>
<p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。</p>
<p>从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的地求得更好的解。当达到算法中的某一步不能再继续前进时，算法停止。该算法存在问题：</p>
<ul>
<li><p>不能保证求得的最后解是最佳的；</p>
</li>
<li><p>不能用来求最大或最小解问题；</p>
</li>
<li><p>只能求满足某些约束条件的可行解的范围。</p>
</li>
</ul>
<p><strong>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</strong>贪心算法和动态规划的区别：</p>
<ul>
<li><p>贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解则不作保留；动态规划：全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有的局部最优解 。求一个问题的最优解相当于遍历所有的子集来找最优解，但是这样解随着解空间的维度成指数增长，动态规划其实就是一种遍历，但是他是带备忘录的遍历，我前面算到的子问题，到这儿我不在计算，我直接调用之前保存的值，这样就节省了大量的时间。</p>
</li>
<li><p>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常自顶向下的方式进行。</p>
</li>
<li><p>根据以上两条可以知道，贪心不能保证求得的最后解是最佳的，一般复杂度低；而动态规划本质是穷举法，可以保证结果是最佳的，复杂度高。</p>
</li>
</ul>
<ol start="4">
<li>回溯法</li>
</ol>
<p>在包含问题的所有解的解空间树中，按照<strong>深度优先搜索的策略</strong>，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>
<p>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p>
<p>而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>
<ol start="5">
<li>分支界限法</li>
</ol>
<p><strong>回溯法以深度优先的方式搜索解空间树T</strong>，而<strong>分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T</strong>。</p>
<p> 分支限界法的<strong>搜索策略是</strong>：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</p>
</li>
</ol>
<ol start="3">
<li>最小生成树-Prim算法和Kruskal算法</li>
</ol>
<p>a. 最小生成树</p>
<p>生成树是连通图的<strong><em>\</em>最小连通子图**</strong>。所谓最小是指：若在树中任意增加一条边，则将出现一个回路；若去掉一条边，将会使之变成非连通图。按照该定义，<strong>n个顶点的连通网络的生成树有n个顶点，n-1条边</strong>。生成树各边的权值总和称为生成树的权，<strong><em>\</em>权最小的生成树称为最小生成树**</strong>。常见的构造最小生成树的方法有Prim算法和Kruskal算法。</p>
<p>b. Prim算法：选取与当前节点连接的权值最小边</p>
<p>c. Kruskal算法：所有边按权值从小到大排序，依次选取不使最小生成树存在回路的最小权值边</p>
<ol start="4">
<li>最短路径-Dijkstra算法和Floyd算法：<a href="https://www.jianshu.com/p/92e46d990d17" target="_blank" rel="noopener">具体代码参考</a></li>
</ol>
<p>a. Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。注意该算法要求图中不存在负权边。</p>
<p>主要思想：通过“边”来松弛v1顶点到其余各个顶点的路程。</p>
<p>b. Floyd算法</p>
<p><strong>Floyd-Warshall算法</strong>（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd算法是一个经典的动态规划算法。</p>
<h4 id="（四）IO库"><a href="#（四）IO库" class="headerlink" title="（四）IO库"></a>（四）IO库</h4><ol>
<li><p>当操作符改变流的格式状态时，通常改变后的状态对所以后续IO都生效。setw类似endl不改变输出流的内部状态，只决定下一个输出的大小。</p>
</li>
<li><p>操作符hex(0x)、oct(0)、dec只影响整型运算对象，浮点型的表示形式不受影响。使用nouppercase、noshoubase和dec来重置流状态。</p>
</li>
<li><p><code>showbase</code>:当打印整型值时显示进制</p>
<p><code>ios::internal</code>:数值的符号位在域宽内左对齐,数值右对齐,中间由填充字符填充 </p>
<p><code>setfill()</code>：允许一个字符替代默认的字符填补空白</p>
<p><code>setbase</code>：将整数设置为b进制</p>
</li>
<li><p><code>cout.setf()</code>的作用是通过设置格式标志来控制输出形式；<code>cin&gt;&gt;noskipws</code>设置<code>cin</code>读取空白符;</p>
<p><code>cin&gt;&gt;skipws</code>将<code>cin</code>恢复到默认状态，丢弃空白符</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf ( <span class="built_in">std</span>::ios::hex, <span class="built_in">std</span>::ios::basefield );<span class="comment">//set hex as the basefield</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf ( <span class="built_in">std</span>::ios::showbase );      <span class="comment">//activate showbase</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">100</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//输出0x100</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.unsetf ( <span class="built_in">std</span>::ios::showbase );   <span class="comment">//deactivate showbase</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">100</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//输出100</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>未格式化输出中<code>is.get()</code>将is的下一个字节作为int返回，头文件cstdio定义了一个名为EOF的const，用来检测返回的值是否是文件末尾，而不必记忆表示文件尾的实际数值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;<span class="comment">//使用一个int,而不是char来保存get()的返回值,否则循环可能永远不会停止，循环也可能会在遇见'\377'的字符提前终止（-1转换为一个singed char会得到'\377'）</span></span><br><span class="line"><span class="comment">//循环读取并输出输入中的所有数据</span></span><br><span class="line"><span class="keyword">while</span>((ch=<span class="built_in">cin</span>.<span class="built_in">get</span>())!=EOF)</span><br><span class="line">    <span class="built_in">cout</span>.<span class="built_in">put</span>(ch);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>istream和ostream类通常不支持随机访问，只有fstream、sstream支持。</li>
</ol>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/seekgseekp.png" alt="随机访问标记"></p>
<h4 id="（五）搜狗"><a href="#（五）搜狗" class="headerlink" title="（五）搜狗"></a>（五）搜狗</h4><ol>
<li>STL : std::map/std::set std::unordered_map/std::unordered_set结构 </li>
</ol>
<p>std::map:红黑树，自动排序，稳定查找插入删除时间复杂度O(lgn)，空间占用高，因为红黑树每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间</p>
<p>std::unordered_map:哈希表，无序，快速查找插入删除，insert/find/erase的平均时间复杂度是O(1)，但是最坏复杂度是O(N)，相比于map空间占用更高，哈希表建立比较耗费时间，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表地址顺序从前往后依次遍历的</p>
<p>存储小对象，内存消耗依次是：vector &lt;&lt;map &lt;&lt;unordered_map;当存储的对象增大时，vector的优势变得并不明显。因为随着对象增大，用于存储对象的空间所占的比例越来越大。因此单从内存消耗的角度来看，当存储的是小对象时，vector占很大的优势。但是，当存储的对象本身大小增大时，它的优势变得不再那么明显。</p>
<p>hash表：（1）插入删除接近常量，大o表示法最快的方式（2）哈希表查询也快,但是底层存储结构是数组，一旦创建无法改变大小（3）哈希表无法用来有序遍历</p>
<ol start="2">
<li>顺序容器</li>
</ol>
<p>vector:可变大小数组，支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢，vector插入insert删除erase时间复杂度均是O(n)</p>
<p>deque:双端队列，支持快速随机访问。在头尾部位置插入/删除速度很快</p>
<p>list:双向链表。支持双向顺序访问，在链表任何位置进行插入/删除操作速度都很快</p>
<p>forward_list:单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快</p>
<p>array:固定大小数组，支持快速随机访问。不能添加或删除元素</p>
<p>string:与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快</p>
<p>除固定大小的array外，其他容器都提供高效、灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器大小。string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入和删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。而且添加一个元素有时可能还需要分配额外的存储空间。在这种情况下，每个元素必须都移动到新的存储空间中。</p>
<p>list和forward_list两个容器添加和删除操作都很快，但是不支持元素的随机访问，为了访问一个元素，只能遍历整个容器，与vector、deque、array相比，这两个容器的额外内存开销很大。</p>
<ol start="3">
<li>指针大小由当前CPU运行模式的寻址位数决定</li>
</ol>
<p>32位处理器上32位操作系统的32位编译器，指针大小4字节。<br>32位处理器上32位操作系统的16位编译器，指针大小2字节。<br>32位处理器上16位操作系统的16位编译器，指针大小2字节。<br>16位处理器上16位操作系统的16位编译器，指针大小2字节。</p>
<p>这从结果看起来指针的大小和编译器有关？？</p>
<p>　　实际不是这样的，有这样的结果是因为以上几种情况，处理器当前运行模式的寻址位数是不一样的，如下：</p>
<p>　Intel 32位处理器32位运行模式，逻辑寻址位数32，指针也就是32位，即4个字节<br>　Intel 32位处理器16位虚拟机运行模式，逻辑寻址位数16，指针也就是16位，即2个字节</p>
<p>编译器的作用是根据目标硬件（即CPU）的特性将源程序编译为可在该硬件上运行的目标文件。如果一个编译器支持某32位的CPU，那么它就可以将源程序编译为可以在该CPU上运行的目标文件。该源程序中指针大小也会被编译器根据该CPU的寻址位数（如32位）编译选择为4字节。</p>
<ul>
<li>sizeof和strlen的区别 </li>
</ul>
<p>❀第一个例子：<br>char* ss = “0123456789”;<br>1、sizeof(ss)的结果是4,ss是指向字符串常量的字符指针<br>2、sizeof(<em>ss)的结果是1，</em>ss是第一个字符 </p>
<p>❀第二个例子：<br>char ss[] = “01233456789”;<br>1、sizeof(ss)结果是11，ss是数组，计算到’\0’的位置，因此是10+1<br>2、sizeof(<em>ss)结果是1，</em>ss是第一个字符 </p>
<p>❀第三个例子<br>char ss[100] = “0123456789”;<br>1、sizeof(ss)的结果是100，ss表示在内存中预分配的大小：100*1<br>2、strlen(ss)的结果是10，它的内部实现是用一个循环计算字符串的长度，直到’\0’为止。 </p>
<p>❀第四个例子<br>int ss[100] = {0,1,2,3,4,5,6,7,8,9};<br>1、sizeof(ss)的结果是400，ss表示在内存中的大小，为100<em>4<br>2、strlen(ss)错误，strlen的参数只能是char</em>，且必须是以’\0’结尾的。</p>
<ol start="4">
<li>访问一个网页的全过程：<a href="https://blog.csdn.net/u012862311/article/details/78753232" target="_blank" rel="noopener">参考</a></li>
</ol>
<ul>
<li><p>域名解析成IP地址（搜索浏览器自身缓存，没有的话向DNS服务器发出解析请求）；</p>
</li>
<li><p>与目的主机进行TCP连接（<a href="[https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/5111559](https://baike.baidu.com/item/三次握手/5111559)">三次握手</a>）；</p>
</li>
<li><p>发送与收取数据（浏览器与目的主机开始HTTP访问过程）；</p>
</li>
<li><p>与目的主机断开TCP连接（<a href="https://blog.csdn.net/O9A0MA/article/details/90731748" target="_blank" rel="noopener">TCP四次挥手</a>）；</p>
</li>
</ul>
<ol start="5">
<li>OSI模型：应用层（HTTP） 表示层（加密   SSL握手协议） 会话层（建立和维持会话，并能使会话获得同步   SSL记录协议）  传输层（TCP/UDP端到端 段Segment 数据报文）  网络层 (IP数据包Packet)  数据链路层(逻辑链路控制子层（LLC）媒体访问控制子层（MAC）数据帧Frame)   物理层(物理介质Bit)</li>
</ol>
<p><strong>消息（message）：</strong>是指起始点和目的地都在网络层以上（经常在<strong>应用层</strong>）的信息单元。</p>
<p>TCP/UDP五层模型：应用层  传输层  网络层  数据链路层  物理层</p>
<ol start="5">
<li>编程内存的基本构成（堆、存储区别）</li>
</ol>
<p><strong>1、内存</strong></p>
<p>（1）静态内存（静态分配）：发生在程序编译和链接阶段，存在于程序的整个生命周期，内存大小固定，不占用CPU资源</p>
<ul>
<li>数据区</li>
</ul>
<p>1）全局/静态存储区</p>
<p>（i）.bss段：存放未初始化的全局变量和static静态变量</p>
<p>（ii）.data段（全局初始化区）：存放初始化的全局变量</p>
<p>2）常量存储区 </p>
<ul>
<li>代码区（.txt段）：存放程序代码</li>
</ul>
<p>注意：</p>
<p>​    代码区：存放函数体的二进制代码，虚函数存放在代码区。</p>
<p>​    常量存储区：常量字符串就是放在这里的。 程序结束后由系统释放。虚函数表在常量存储区。</p>
<p>​    函数指针指向Code区，是程序运行的指令代码，数据指针指向Data,Heap,Stack    区，是程序依赖以运行的各种数据。</p>
<p>​    在文件作用域声明inline函数默认为static存储类型,const常量默认为static存储，    如果加上extern，则为外部存储类型</p>
<p>（2）动态内存（动态分配）：发生在程序调入和执行阶段，根据程序的需要分配和释放，其大小可变，占用CPU资源</p>
<ul>
<li><p>堆：<strong>链表结构，程序通过调用malloc和new分配，调用free和delete释放；堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，链表的遍历方向是由低地址向高地址</strong>。堆的大小受限于计算机系统中有效的虚拟内存4G。由此可见，堆获得的空间比较灵活，也比较大。<strong>堆中的存储内容一般是在堆的头部用一个字节存放堆的大小</strong>。堆中的具体内容有程序员安排。</p>
</li>
<li><p>栈：<strong>线性结构，由编译器自动分配与释放，速度较快，是一块连续的内存的区域</strong>，存储函数（包括main函数）的方法调用、函数参数、内部局部变量、返回地址和CPU系统提供的两个特殊的寄存器用于标识位于系统栈顶端的栈帧（(1)ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈地上面-个栈帧的栈顶。(2) EBP：基址指针寄存器(extended base pointer)-其内存放着一个指针，该指针永远指向系统栈展上面一个栈帧的底部），存储地址由高地址向低地址，栈顶的地址和栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，提示Stack Overflow，出现溢出现象。栈中的存储内容<strong>在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址</strong>，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。函数退出时，其占用内存被收回；进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。</p>
</li>
<li><p>堆栈的区别：</p>
<p>  1、管理方式不同（堆手动分配new/delete；栈编译器自动分配和释放）<br>  2、空间大小不同（堆32位系统可达4G;栈Linux 10M,Windows 1M）<br>  3、能否产生碎片不同（堆能；栈不能）<br>  4、生长方向不同（堆从低地址到高地址；栈从高地址到低地址）<br>  5、分配方式不同（堆动态分配；栈动静分配都可以，栈的动态使用alloc分配）<br>  6、分配效率不同（堆效率低；栈效率高）</p>
</li>
<li><p>堆栈数据的写入跟读出不需要提供地址，而是根据写入的顺序决定读出的顺序。通用寄存器、主存储器、输入输出设备存储数据时均需要编址。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp </span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;  <span class="comment">//a存储在全局初始化区 ，静态内存，0存储在常量区随程序结束而释放</span></span><br><span class="line"><span class="keyword">char</span> *p1;  <span class="comment">//全局未初始化区 ，静态内存</span></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">4</span>);  <span class="comment">//p存储在全局初始化区，静态内存，分配得来的4存储在堆区</span></span><br><span class="line">main() </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> b;  <span class="comment">//栈 ，编译时</span></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">"abc"</span>;  <span class="comment">//栈 ，运行时赋值</span></span><br><span class="line"><span class="keyword">char</span> *p2; <span class="comment">// 栈 </span></span><br><span class="line"><span class="keyword">char</span> *p3 = <span class="string">"123456"</span>;  <span class="comment">//"123456\0"在常量区（不同于数组数据可存储在数组里），编译时就确定下来，静态内存，p3在栈上。 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>； <span class="comment">//全局（静态）初始化区 </span></span><br><span class="line">p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); </span><br><span class="line">p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>); </span><br><span class="line"><span class="comment">//分配得来的10和20字节的区域就在堆区。 </span></span><br><span class="line"><span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>);  <span class="comment">//"123456\0"放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 </span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">char</span>* p = <span class="string">"Hello World1"</span>;</span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">"Hello World2"</span>;</span><br><span class="line">p[<span class="number">2</span>] = <span class="string">'A'</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">char</span>* p1 = <span class="string">"Hello World1"</span>; </span><br><span class="line"><span class="comment">//这个程序是有错误的，错误发生在p[2] = 'A'这行代码处，为什么呢，是变量p和变量数组a都存在于栈区的（任何临时变量都是处于栈区的，包括在main（）函数中定义的变量）。但是，数据“Hello World1”和数据“Hello World2”是存储于不同的区域的。因为数据“Hello World2”存在于数组中，所以，此数据存储于栈区，对它修改是没有任何问题的。因为指针变量p仅仅能够存储某个存储空间的地址，数据“Hello World1”为字符串常量，所以存储在静态存储区。虽然通过p[2]可以访问到静态存储区中的第三个数据单元，即字符‘l’所在的存储的单元。但是因为数据“Hello World1”为字符串常量，不可以改变，所以在程序运行时，会报告内存错误。并且，如果此时对p和p1输出的时候会发现p和p1里面保存的地址是完全相同的。换句话说，在数据区只保留一份相同的数据。</span></span><br></pre></td></tr></table></figure>

<p><strong>2、内存申请函数</strong></p>
<ul>
<li>malloc calloc realloc的区别</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">realloc</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">unsigned</span> newsize)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> numElements, <span class="keyword">size_t</span> sizeOfElement)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> * __cdecl  <span class="title">alloca</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="built_in">free</span>将<span class="built_in">malloc</span>申请的内存最终需要通过该函数进行释放. </span><br><span class="line">sbrk则是增加数据段的大小;</span><br></pre></td></tr></table></figure>

<p>都在stdlib.h函数库内，它们的返回值都是请求系统分配的地址,如果请求失败就返回NULL.<br>  (1)函数malloc()<br>    在内存的动态存储区中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度，返回该区域的首地址。由于没有初始化内存的内容，所以调用malloc后一般调用函数memset来初始化这部分内存空间。<br>  (2)函数calloc()<br>    与malloc相似,参数sizeOfElement为申请地址的单位元素长度,numElements为元素个数，即在内存中申请numElements*sizeOfElement字节大小的连续地址空间，返回该区域的首地址。初始化所分配的内存空间，设置为0。</p>
<p><strong>malloc() 函数和calloc ()函数的主要区别是前者不能初始化所分配的内存空间，而后者能</strong>。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是 0；反之，如果这部分内存空间曾经被分配、释放和重新分配，则其中可能遗留各种各样的数据。也就是说，<strong>使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常运行，但经过一段时间后(内存空间已被重新分配)可能会出现问题</strong>。  calloc() 函数会将所分配的内存空间中的每一位都初始化为零，也就是说，如果你是为字符类型或整数类型的元素分配内存，那么这些元素将保证会被初始化为零；如果你是<strong>为指针类型的元素分配内存，那么这些元素通常(但无法保证)会被初始化为空指针</strong>；如果你是为实数类型的元素分配内存，那么这些元素可能(只在某些计算机中)会被初始化为浮点型的零。</p>
<p>  (3)函数realloc()<br>给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度.如果在该存储区后有足够的空间可供扩充，则可在原存储区位置上向高地址方向扩充，并返回传送给它的同样的指针值。如果在原存储区后没有足够的空间，则realloc分配另一个足够大的存储区，将现存的512个元素数组的内容复制到新分配的存储区。因为这种存储区可能会移动位置，所以不应当使用任何指针指在该区中。注意，realloc的最后一个参数是存储区的newsize(新长度)，不是新、旧长度之差。作为一个特例，若ptr是一个空指针，则realloc的功能与malloc相同，用于分配一个指定长度newsize的存储区。</p>
<p>（4）alloca()是在栈(stack)上申请空间的，而栈内存一般可以由编译器自动释放。既然是在栈内申请内存，这就决定了其固有的局限性。其一是不适用于那些比创建它们的函数生命周期更长的结构；其二是不具可移植性，而且在没有传统堆栈的机器上很难高效地实现。这是因为当它的返回值直接传入另一个函数时会带来问题。这就决定了alloca()不宜使用在需要广泛移植的程序中，这也是很多人不太提倡使用alloca()的一个原因。</p>
<ul>
<li>malloc和free的操作原则</li>
</ul>
<blockquote>
<p>1) 配对使用，配对使用，避免内存泄漏和多重释放（C语言提供了malloc和free两个系统函数，完成对堆内存的申请和释放。而C++则提供了两个关键字new和delete）。</p>
<p>2) 尽量在同一层上使用，不要像上面那种，malloc在函数中，而free在函数外。最好在同一调用层上使用这两个函数。</p>
<p>3) malloc分配的内存一定要初始化。free后的指针一定要设置为NULL。 </p>
<p>注意：new/delete是关键字，效率高于malloc和free。<br>new/delete 主要是用在类对象的申请和释放。申请的时候会调用构造器完成初始化，释放的时候，会调用析构器完成内存清理。</p>
</blockquote>
<p><strong>3、new和malloc的区别</strong></p>
<ul>
<li><p>属性</p>
<p>new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持。</p>
</li>
<li><p>参数</p>
<p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p>
</li>
<li><p>返回类型</p>
<p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p>
</li>
<li><p>自定义类型</p>
</li>
</ul>
<p>new做两件事：分配内存和调用类的构造函数，new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为什么有了malloc还要设计new</span></span><br><span class="line"><span class="keyword">delete</span>：调用类的析构函数和释放内存。<span class="keyword">delete</span>先调用析构函数，然后调用<span class="keyword">operator</span> <span class="keyword">delete</span>函数释放内存（通常底层使用<span class="built_in">free</span>实现）。</span><br><span class="line"></span><br><span class="line">而<span class="built_in">malloc</span>和<span class="built_in">free</span>只是分配和释放内存。<span class="built_in">malloc</span>/<span class="built_in">free</span>是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>重载</p>
<p>  C++允许重载new/delete操作符，malloc不允许重载。</p>
</li>
<li><p><strong>内存区域</strong></p>
</li>
</ul>
<p>　　new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</p>
<p><strong>4、delete和free的区别</strong></p>
<ol>
<li><p><strong>new/delete是关键字，而free/malloc是库函数，需要头文件支持</strong>free对应的是malloc；delete对应的是new；free用来释放malloc出来动态内存，delete用来释放new出来的动态内存空间。</p>
</li>
<li><p><strong>无论释放几个空间大小，free只传递指针，多个对象时delete需加[]</strong>。数组的时候int* <em>p=(int</em>)malloc(10*sizeof(int)) 释放的时候 free(p)即可；这是因为编译器对malloc做了一些特殊的处理，以保证可以正确释放内存。而当int *p=new int[10]释放的时候应为delete []p，注意[]的作用说明释放的是一个数组的内存，如果delete p则只是释放的p[0]，其余9个int的内存没有释放；这是因为当指明为[]的时候，编译器实际上是做了一个循环来释放这个数组的所有内存。</p>
</li>
<li><p>在类和对象的时候会有很大区别。在使用malloc和free来处理动态内存的时候，仅仅是释放了这个对象所占的内存，而不会调用这个对象的析构函数；使用new和delete就可以既释放对象的内存的同时，调用这个对象的析构函数。<strong>delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）</strong>。</p>
</li>
</ol>
<p><strong>共同之处：</strong></p>
<p>它们都是只把指针所指向的内存释放掉了，并没有把指针本身干掉。在free和delete之后，都需要把指向清理内存的指针置为空，即p=NULL，否则指针指向的内存空间虽然释放了，但是指针p的值还是记录的那块地址，该地址对应的内存是垃圾，p就成了“野指针”。同样会使人认为p是个合法的指针，如果程序较长，我们通常在使用一个指针前会检查p！=NULL，这样就起不到作用了。此时如果再释放p指向的空间，编译器就会报错，因为释放一个已经被释放过的空间是不合法的。而将其置为NULL之后再重复释放就不会产生问题，因为delete一个0指针是安全的。</p>
<p><strong>指针和动态申请的内存空间总结如下：</strong></p>
<p><strong>1.</strong>   <strong>指针消亡了，并不表示它指示的动态内存会自动释放；</strong></p>
<p><strong>2.</strong>   <strong>动态内存释放掉了，如果这个内存是一个动态对象，则并不表示一定会调用这个对象的析构函数；</strong></p>
<p><strong>3. 动态内存释放掉了，并且调用了析构函数，并不表示指针会消亡或者自动变成了NULL。</strong></p>
<p><strong>PS:</strong></p>
<p><strong>在C++中，内存区分为6个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区、代码区</strong>；</p>
<p><strong>在C中，C内存区分为5个区堆、栈、全局/静态存储区、常量存储区、代码区</strong></p>
<p>为什么栈生长方向是从高地址到低地址？<strong>最大程度地共用剩余的地址空间，达到利用率的最大化</strong>。如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。</p>
<ul>
<li><p>分配失败</p>
<p>  new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p>
</li>
<li><p>内存泄漏</p>
<p>  内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc确不可以。</p>
</li>
</ul>
<ol start="6">
<li><p>快速排序  堆排序</p>
</li>
<li><p>给你100个数找出最大的前五十个</p>
</li>
</ol>
<ul>
<li>partition 时间复杂度O(n)</li>
<li>最小堆 时间复杂度O(nlgk)  (海量数据)</li>
<li>mutiset 时间复杂度O(n)空间复杂度O(n)</li>
</ul>
<ol start="8">
<li>笔试题：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">提示：优先写源码，源码有难度可以写伪代码 或 思路。</span><br><span class="line">要求：c或c++, 尽量使得时间复杂度较低，写出完整代码。</span><br><span class="line">题目：查找元素element在非降序正整数数组a中的最左下标位置,数组大小为<span class="built_in">size</span>.</span><br><span class="line">例子：元素<span class="number">2</span>在数组a[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">21</span>]的最左位置为<span class="number">2.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchRange</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"><span class="keyword">int</span> middle=(right-left)/<span class="number">2</span>+left;</span><br><span class="line"><span class="keyword">if</span>(a[middle]==target)&#123;</span><br><span class="line">middle-=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(a[middle]==target)midlle--;</span><br><span class="line"><span class="keyword">return</span> middle+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[middle]&lt;target)</span><br><span class="line">left=middle+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right=middle<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_pos</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> element)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">size</span>==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">int</span> leftIndex=searchBoundEqual(a,<span class="number">0</span>,<span class="built_in">size</span><span class="number">-1</span>,element);</span><br><span class="line">      <span class="keyword">if</span>(leftIndex==<span class="built_in">size</span>||a[leftIndex]!=target)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">return</span> leftIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">find</span>(a,a+<span class="built_in">size</span>,target);</span><br></pre></td></tr></table></figure>

<h4 id="（六）手写代码"><a href="#（六）手写代码" class="headerlink" title="（六）手写代码"></a>（六）手写代码</h4><p>一个数组中有多个整数， 其中有两个重复的数字，如何找出来，考虑一下时间复杂度和空间复杂度<br> 给两个字符串A和B，找出A对于B的最长前缀。<br> 单链表逆序<br> 一个链表的连续区间和最大值，及其对应区<br> 数组中，连续和最大的区间<br> 判断一个链表是否有环，并确定环的位置，如何确定两个链表是否有相同的部分<br> 写个小程序，一个数组，长100，里边乱序分布数字1-100，在数组中随机挑选一个位置的数字，将其替换为-1，如何判断，被替换掉的数字是多少？<br> 跳台阶，一次跳1个，也可以跳2个，问，n个台阶有多少种跳法</p>
<p>dfs bfs dp迷宫</p>
<p>最小圆覆盖</p>
<p>1）任意选取距离最远两点p1、p2，以p1p2做直径画圆；</p>
<p>2）如果所有点都在圆内，则该圆即为包括所有点的最小圆；否则选取圆外一点距离圆心最远点pi,寻找覆盖pi和集合Di-1的最小圆<code>Di=MiniDiskWithPoints({p1，p2，p3......pi-1}，pi)</code>，循环第（2）步直到Di包括所有点，即得到最小包围圆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function MiniDiskWithPoints（P，q）</span><br><span class="line">Input：由平面上n个点构成的一个集合P，以及另外一个点q</span><br><span class="line">Output：在满足“边界穿过q”的前提下，P的最小包围圆</span><br><span class="line">    <span class="number">1.</span>令D1为对应于&#123;p1，q&#125;的最小包围圆</span><br><span class="line">    <span class="number">2.f</span><span class="keyword">or</span>   j ← <span class="number">2</span> to n</span><br><span class="line">    <span class="number">3.</span>   <span class="keyword">do</span> <span class="keyword">if</span>    pj ∈Dj<span class="number">-1</span></span><br><span class="line">    <span class="number">4.</span>      then    Dj ← Dj<span class="number">-1</span></span><br><span class="line">    <span class="number">5.</span>      <span class="keyword">else</span>    Dj ← MiniDiskWithPoints&#123;&#123;p1，p2,p3......pj<span class="number">-1</span>&#125;，pj，pi&#125;</span><br><span class="line">    <span class="number">6.</span><span class="keyword">return</span>    Dn</span><br><span class="line">Function MiniDiskWithPoints（P，q1，q2）</span><br><span class="line">Input：由平面上n个点构成的一个集合P，以及另外两个点q1，q2</span><br><span class="line">Output：在满足“边界穿过q1，q2”的前提下，P的最小包围圆</span><br><span class="line"><span class="number">1.</span>       令D0为对应于q1，q2的最小包围圆</span><br><span class="line"><span class="number">2.</span>       <span class="keyword">for</span>   k ← <span class="number">1</span> to n</span><br><span class="line"><span class="number">3.</span>            <span class="keyword">do</span> <span class="keyword">if</span>    pk∈Dk<span class="number">-1</span></span><br><span class="line"><span class="number">4.</span>                    then    Dk ← Dk<span class="number">-1</span></span><br><span class="line"><span class="number">5.</span>                    <span class="keyword">else</span>    Dk ← q1，q2和pk确定的圆</span><br><span class="line"><span class="number">6.</span>        <span class="keyword">return</span>    Dn</span><br></pre></td></tr></table></figure>

<p>给定一个无序数组，求这个数组变为有序后相邻元素之差的最大值是多少，要求时间复杂度是O(n)</p>
<ul>
<li><p>方法一：排序，计算。时间复杂度O(nlgn)，空间复杂度O(1)</p>
</li>
<li><p>方法二：std::multiset，计算。时间复杂度O(n),空间复杂度O(n)</p>
</li>
<li><p>方法三：<a href="https://blog.csdn.net/weixin_38426554/article/details/95785743" target="_blank" rel="noopener">桶排序</a>。时间复杂度O(n),空间复杂度O(n)</p>
</li>
</ul>
<p>算法题给定一个长字符串zesfjjk和一个短字符串xsfjx，求短字符串在长字符串中出现的最长部分是什么？sfj</p>
<p><a href="https://blog.csdn.net/hackbuteer1/article/details/6686931" target="_blank" rel="noopener">最长公共子字符串</a></p>
<h4 id="（七）SAP"><a href="#（七）SAP" class="headerlink" title="（七）SAP"></a>（七）SAP</h4><ol>
<li>linux命令</li>
</ol>
<p>查找  vi  保存  修改权限</p>
<ol start="2">
<li>C语言和c++的区别</li>
</ol>
<ul>
<li>c++兼容c。区块（blocks）、语句（statements）、预处理器（preprocessors）、内置数据类型（build-in data types）、数组（arrays）、指针（pointers）等统统来源于c。</li>
<li>c仅支持面向过程，c++还支持面向对象：包含封装、继承、多态三大特性和虚函数、虚函数表指针、虚基类表指针等。</li>
<li>c++包含泛型编程、模板元编程。</li>
<li>c++包含STL。</li>
</ul>
<h4 id="（八）进程间的通信方式（IPC-inter-Process-Communication）"><a href="#（八）进程间的通信方式（IPC-inter-Process-Communication）" class="headerlink" title="（八）进程间的通信方式（IPC,inter-Process Communication）"></a>（八）进程间的通信方式（IPC,inter-Process Communication）</h4><p>同一主机中两个进程间的通信由操作系统决定，不同主机间的通信进程通过网络交换报文进行。</p>
<ol>
<li><p>信号：用于通知进程某个事件已经发生</p>
</li>
<li><p>管道：读写操作符合先进先出原则，对于两端的进程而言就是文件，向管道中写入数据时,linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。</p>
</li>
</ol>
<ul>
<li><p>无名管道pipe:半双工的通信方式，数据单向流动，只能在具有亲缘关系的进程间使用，从结构上看，无名管道没有文件路径名，不占用文件目录项，因此文件目录结构中的链表不适用于这种文件，它只是存在于打开文件结构中的一个临时文件，依附于进程临时存在。</p>
</li>
<li><p>命名管道FIFO:半双工，数据单向流动，允许无亲缘关系进程间的通信，FIFO是一种永久性的机制，它具有普通的UNIX系统文件名。在系统下可利用mkfifo命令建立永久的管道，除非刻意删除它，否则它将一直保持在系统中。</p>
</li>
<li><p><strong>联系</strong>：</p>
</li>
</ul>
<p>1) 通信数据只存在于内存缓冲页面中；</p>
<p>2) 都是半双工通信；</p>
<ul>
<li><strong>区别</strong>：</li>
</ul>
<p>(1)无名管道是无名的，有名管道是有名的；</p>
<p>(2)无名管道只能用于父子进程或兄弟进程之间的通信，而有名管道可用于任意两进程之间通信；</p>
<p>(3)无名管道是无形的，即无名管道的 inode 结构不是在磁盘上存储的，而是临时生成的，而有名管道的 inode 结点在磁盘上。</p>
<ol start="3">
<li>消息队列：消息的链表存放在内核中并由消息队列标识符标识，克服了信号传递信息少，管道只能承载无格式字节流以及缓冲器大小受限等缺点，但只有在内核重启时才能删除一个消息队列，内核重启也就是系统重启。</li>
<li>共享内存：最快的IPC方式，映射一段能被其他进程所访问的内存。往往与其他通信机制如信号两两配合使用，来实现进程间的同步和通信。</li>
<li>信号量Semaphore:信号量是一个计数器，可以用来控制多个进程对共享资源的访问。常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>套接字Socket:套接字也是一种进程间通信机制，包括IPC 套接字（即 Unix 套接字）给予进程在相同设备（主机）上基于通道的通信能力；而网络套接字给予进程运行在不同主机的能力，因此也带来了网络通信的能力。IPC 套接字依赖于本地系统内核的支持来进行通信。网络套接字需要底层协议的支持，例如 TCP（传输控制协议）或 UDP（用户数据报协议），包括流套接字（TCP/IP）和数据报套接字（UDP/IP），利用三元组（<strong>ip地址，协议，端口</strong>）构成套接字；<a href="https://baike.baidu.com/item/传输层/4329536" target="_blank" rel="noopener">传输层</a>实现<a href="https://baike.baidu.com/item/端到端/8851783" target="_blank" rel="noopener">端到端</a>的通信，传输层连接的端点叫做套接字。</li>
</ol>
<h5 id="进程创建fork和vfork"><a href="#进程创建fork和vfork" class="headerlink" title="进程创建fork和vfork"></a>进程创建fork和vfork</h5><ul>
<li><p>进程识别信息：表示哪台主机上的哪一个进程</p>
<ul>
<li>主机名称或地址：网络中的哪一个主机。因特网中，用IP地址标识（32位，全球唯一）。</li>
<li>进程的标识：主机中的哪一个进程。因特网中，采用端口号标识。<strong>创建一个新的网络应用程序时，必须分配一个新的端口号。不得重复</strong>。</li>
</ul>
</li>
<li><p>fork后操作系统会复制一个与父进程完全相同的子进程，两个进程共享代码空间，但数据空间相互独立，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别作不同的工作，也就是分岔了。这也是fork为什么叫fork的原因至于那一个最先运行，可能与操作系统（调度算法）有关，而且这个问题在实际应用中并不重要，如果需要父子进程协同，可以通过原语的办法解决。</p>
</li>
<li><h5 id="fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别："><a href="#fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别：" class="headerlink" title="fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别："></a>fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别：</h5><ol>
<li>fork  （）：子进程拷贝父进程的数据段，代码段<br>vfork （ ）：子进程与父进程共享数据段，<strong>子进程中对父进程变量的修改，会影响父进程</strong></li>
<li>fork （）父子进程的执行次序不确定<br>vfork 保证子进程先运行，在调用<code>exec()</code> 或<code>_exit()</code> 之前与父进程数据是共享的,在它调用<code>exec()</code>或<code>_exit()</code>之后父进程才可能被调度运行。</li>
<li>若vfork （）调用exec 或<code>_exit()</code> 之前子进程依赖于父进程的进一步动作，会导致死锁。</li>
</ol>
</li>
</ul>
<h5 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h5><p>​         （1）进程是资源分配和调度的一个独立单元，而线程是CPU调度和分派的基本单元<br>​          （2）一个进程至少包括一个线程，并且同一个进程的所有线程共享整个进程的资源，因此线程执行时一般都要进行同步和互斥<br>​          （3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束<br>​          （4）线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的<br>​          （5）进程间通信IPC需要特别的方法，线程间可以直接读写进程数据段（如全局变量）来进行通信。</p>
<h5 id="线程有什么是共享的什么是私有的"><a href="#线程有什么是共享的什么是私有的" class="headerlink" title="线程有什么是共享的什么是私有的"></a>线程有什么是共享的什么是私有的</h5><p>线程共享的环境包括：</p>
<p>  1.进程代码段 </p>
<p>  2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯) </p>
<p>  3.进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p>
<p>线程独立的资源包括：</p>
<p>1.线程ID</p>
<p>2.寄存器组的值</p>
<p>由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。</p>
<p>3.线程的堆栈</p>
<p>堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。</p>
<p>4.线程的错误返回码</p>
<p>由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。</p>
<p>5.线程的信号屏蔽码</p>
<p>6.线程的优先级</p>
<p>注：线程有自己的私有属性线程控制块TCB，进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志。</p>
<h5 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h5><ul>
<li><p>就绪状态：当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态就称为就绪状态；</p>
</li>
<li><p>执行状态：当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态；</p>
</li>
<li><p>阻塞状态：正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而进入阻塞状态。引起进程阻塞的事件有很多种，例如，等待I/O完成、申请缓冲区不能满足、等待信号等。</p>
</li>
<li><p>进程三种状态间的转换  </p>
</li>
</ul>
<blockquote>
<p>执行–&gt;就绪：时间片完；</p>
<p>就绪–&gt;执行：被调度；</p>
<p>执行–&gt;阻塞：等待事件，io请求；</p>
<p>阻塞-&gt;就绪：io完成</p>
</blockquote>
<p>一个进程在运行期间，不断地从一种状态转换到另一种状态，它可以多次处于就绪状态和执行状态，也可以多次处于阻塞状态。<br>A. 就绪—&gt;执行<br>处于就绪状态的进程，当进程调度程序为之分配好了处理机后，该进程便由就绪状态转换为执行状态；<br>B. 执行—&gt;就绪<br>处于执行状态的进程在其执行过程中，因分配给它的一个时间片已经用完而不得不让出处理机，于是进程从执行状态转换为就绪状态；<br>C. 执行—&gt;阻塞<br>正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态；<br>D. 阻塞—&gt;就绪<br>处于阻塞状态的进程，若其等待的事件已经发生，于是进程便从阻塞状态转变为就绪状态。</p>
<ul>
<li>线程同步</li>
</ul>
<p>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。</p>
<p>内核模式下的方法有：事件，信号量，互斥量。</p>
<p>1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。<br>2、互斥量:为协调共同对一个共享资源的单独访问而设计的。<br>3、信号量:为控制一个具有有限数量用户资源而设计。<br>4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。</p>
<ul>
<li>线程间通信：由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）。</li>
<li>进程间的通信则不同，它的数据空间的独立性决定了它的通信相对比较复杂，需要通过操作系统。以前进程间的通信只能是单机版的，现在操作系统都继承了基于套接字（socket）的进程间的通信机制。这样进程间的通信就不局限于单台计算机了，也可以实现不同操作系统间的网络通信，eg.windows和Linux操作系统通过Socket进行进程间通信。</li>
<li>windows进程通信</li>
</ul>
<p><em>标准的Windows</em>进程间通信方法有三种：匿名管道、命名管道（又叫<em>FIFO</em>，命名管道可以控制读消息的长度，一个命名管道可以有多个实例，具体通信还是一对一）、邮槽（<em>MailSlot</em>）。共享内存也可用于windows进程通信，但因为其实是<em>Windows</em>“内存映射文件”的一个特殊用法，所以不算作标准的windows进程间通信方法。</p>
<table>
<thead>
<tr>
<th align="center">对比点</th>
<th align="center">匿名管道</th>
<th align="center">命名管道</th>
<th align="center">邮槽</th>
<th></th>
<th align="center">共享内存</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">消息格式</td>
<td align="center">字符</td>
<td align="center">二进制</td>
<td align="center">数据包</td>
<td></td>
<td align="center">-</td>
<td></td>
</tr>
<tr>
<td align="center">工作模式</td>
<td align="center">半双工</td>
<td align="center">全双工</td>
<td align="center">单向</td>
<td></td>
<td align="center">双向</td>
<td></td>
</tr>
<tr>
<td align="center">访问模式</td>
<td align="center">只能在一台机器上</td>
<td align="center">可以跨网络</td>
<td align="center">可以跨网络</td>
<td></td>
<td align="center">只能在一台机器上</td>
<td></td>
</tr>
<tr>
<td align="center">通信模式</td>
<td align="center">一对一，父子进程用</td>
<td align="center">一对多，不同进程均可用</td>
<td align="center">广播机制</td>
<td></td>
<td align="center">-</td>
<td></td>
</tr>
</tbody></table>
<h5 id="windows命名管道和Linux命名管道的区别"><a href="#windows命名管道和Linux命名管道的区别" class="headerlink" title="windows命名管道和Linux命名管道的区别"></a>windows命名管道和Linux命名管道的区别</h5><table>
<thead>
<tr>
<th align="center">对比点</th>
<th align="center">Linux命名管道</th>
<th align="center">Windows命名管道</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">消息格式</td>
<td align="center">字节流</td>
<td align="center">二进制</td>
<td align="center">windows更牛</td>
</tr>
<tr>
<td align="center">工作模式</td>
<td align="center">半双工</td>
<td align="center">全双工</td>
<td align="center">windows更牛</td>
</tr>
<tr>
<td align="center">访问模式</td>
<td align="center">只能在一台机器上</td>
<td align="center">可以跨网络</td>
<td align="center">windows更牛</td>
</tr>
</tbody></table>
<ul>
<li>windows线程通信</li>
</ul>
<p>windows下，一个典型的线程拥有自己的堆栈、寄存器（包括程序计数器PC，用于指向下一条应该执行的指令在内存中的位置），而代码段、数据段、打开文件这些进程级资源是同一进程内多个线程所共享的。因此同一进程的不同线程可以很方便的通过全局变量（数据段）进行通信，使用多线程相对于多进程来说有很多优点：</p>
<ul>
<li>① 无需跨进程边界；</li>
<li>② 程序逻辑和控制方式简单；</li>
<li>③ 所有线程可以直接共享内存和变量等；</li>
<li>④ 线程方式消耗的总资源比进程方式好；</li>
</ul>
<h5 id="windows多线程通信的方法主要有三种："><a href="#windows多线程通信的方法主要有三种：" class="headerlink" title="windows多线程通信的方法主要有三种："></a>windows多线程通信的方法主要有三种：</h5><p><strong>1.全局变量</strong></p>
<p>由于同一进程下的线程之间共享数据空间。当需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，来告诉编译器这个全局变量是“易变”（更直接的讲是“直接存取原始内存地址”，更明确的说是不要编辑器去读缓存中的数据，而是直接从内存中获取变量的值）的，让编译器不要对这个变量进行优化。</p>
<p><strong>2.Message消息机制</strong><br>常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，<br>PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。</p>
<p><strong>3.CEvent对象</strong></p>
<p>CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。</p>
<ul>
<li>Linux线程通信</li>
</ul>
<p>线程间无需特别的手段进行通信，因为线程间可以共享数据结构，也就是一个全局变量可以被两个线程同时使用。不过要注意的是线程间需要做好同步，一般用mutex。</p>
<h5 id="死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？"><a href="#死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？" class="headerlink" title="死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？"></a>死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？</h5><p>​         （1）相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态<br>​          （2）系统资源不足、相互竞争资源、请求资源顺序不当<br>​          （3）互斥、不可剥夺、循环等待、请求与保持<br>​          （4）因为互斥是不可改变的，所以只能破坏其他三个条件中的一个来解除死锁，方法：</p>
<ul>
<li><p>破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中。</p>
</li>
<li><p>破坏”请求与保持条件“：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。</p>
</li>
<li><p>破坏“循环等待”条件：资源有序分配（将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程）</p>
</li>
</ul>
<h4 id="（九）SQL"><a href="#（九）SQL" class="headerlink" title="（九）SQL"></a>（九）SQL</h4><ol>
<li>一致性哈希？渐进性哈希？</li>
</ol>
<p>一致性哈希是一种特殊的哈希算法，目的是解决分布式缓存的问题。在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式<a href="https://baike.baidu.com/item/哈希表/5981869" target="_blank" rel="noopener">哈希表</a>( Distributed Hash Table，DHT) 中存在的动态伸缩等问题。</p>
<p>  首先，对存储节点的哈希值进行计算，其将存储空间抽象为一个环，将存储节点配置到环上。环上所有的节点都有一个值。其次，对数据进行哈希计算，按顺时针方向将其映射到离其最近的节点上去。当有节点出现故障离线时，按照算法的映射方法，受影响的仅仅为环上故障节点开始逆时针方向至下一个节点之间区间的数据对象，而这些对象本身就是映射到故障节点之上的。当有节点增加时，比如，在节点A和B之间重新添加一个节点H，受影响的也仅仅是节点H逆时针遍历直到B之间的数据对象，将这些重新映射到H上即可，因此，当有节点出现变动时，不会使得整个存储空间上的数据都进行重新映射，解决了简单哈希算法增删节点，重新映射所有数据带来的效率低下的问题。</p>
<p>渐进性哈希</p>
<p>  当hash表满员时（或负载因子高于阈值时）会进行rehash,也就是重新调整空间大小，并拷贝原来的数据。这里rehash就是优化效率的关键。例如假设有1w个元素，rehash时要拷贝1w元素到新的空间，这样势必会成为很大的负担。<br>  redis的数据库使用字典来作为底层实现的，对数据库的增删查改操作也是构建在对字典的操作之上。redis的字典使用hash表作为底层实现。</p>
<p>  redis作为一个广泛使用的内存数据库，时间和空间效率都是至关重要的。（redis的根本就是一个大的hashmap，所以对hashmap的优化十分重视）</p>
<p>  redis采用渐进式rehash来解决这个问题。</p>
<p>  何为渐进式rehash？就是把拷贝节点数据的过程平摊到后续的操作中，而不是一次性拷贝。所谓平摊到后续的操作中，就是对节点操作，例如再次插入，查找，删除，修改时都会进行拷贝。</p>
<ol start="2">
<li>友元函数注意事项</li>
</ol>
<p>1）必须在类的说明中说明友元函数，说明时以关键字friend开头，后跟友元函数的函数原型，友元函数的说明可以出现在类的任何地方，包括在private和public部分；<br>2）注意友元函数不是类的成员函数，所以友元函数的实现和普通函数一样，在实现时不用”::”指示属于哪个类，只有成员函数才使用”::”作用域符号；<br>3）友元函数不能直接访问类的成员，只能访问对象成员，<br>4）友元函数可以访问对象的私有成员，但普通函数不行；<br>5）调用友元函数时，在实际参数中需要指出要访问的对象，<br>6）友元的声明只能出现在类定义的内部（最好在类定义开始或者结束前的位置集中声明友元），仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，必须在友元声明之外再转名对函数进行一次声明。每个类负责控制自己的友元类或友元函数，友元关系不存在传递性。类与类之间的友元关系不能继承.</p>
<ol start="3">
<li>模板</li>
</ol>
<p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>
<p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>
<h4 id="（十）计算机网络"><a href="#（十）计算机网络" class="headerlink" title="（十）计算机网络"></a>（十）计算机网络</h4><h5 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h5><ul>
<li>http是超文本传输协议，信息是明文传输，无连接无状态；https则是具有安全性的ssl加密传输协议。</li>
<li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 根证书，一般免费证书较少，因而需要一定费用。</li>
<li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li>
<li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li>
<li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li>
</ul>
<h5 id="客户端在使用HTTPS方式与Web服务器通信步骤"><a href="#客户端在使用HTTPS方式与Web服务器通信步骤" class="headerlink" title="客户端在使用HTTPS方式与Web服务器通信步骤"></a>客户端在使用HTTPS方式与Web服务器通信步骤</h5><p>　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p>
<p>　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p>
<p>　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p>
<p>　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p>
<p>　　（5）Web服务器利用自己的私钥解密出会话密钥。</p>
<p>　　（6）Web服务器利用会话密钥加密与客户端之间的通信。</p>
<p><img src="%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/https.png" alt="https与web服务器通信步骤"></p>
<h5 id="怎么理解http协议的无连接无状态"><a href="#怎么理解http协议的无连接无状态" class="headerlink" title="怎么理解http协议的无连接无状态"></a>怎么理解http协议的无连接无状态</h5><p>HTTP协议又称超文本传输协议；是OSI模型中的第七层应用程中协议；具有以下特点：<br> <strong>1、支持客户/服务器模式;<br> 2、简单快速;<br> 3、灵活;<br> 4、无连接;<br> 5、无状态；</strong></p>
<p>注意：<strong>HTTP不是字面意义上的没有连接</strong>，事实上，这个定义也符合HTTP短连接的定义，但<strong>无连接强调的是HTTP的特性，短连接可理解为一种实现</strong>。而HTTP真正的连接，根据计算机网络体系的协议栈可知，是通过传输层的TCP协议实现的，下层向上层提供了可靠的连接，上层屏蔽了下层的具体实现，所有的操作均在可靠的连接基础之上。HTTP使用TCP的目的是为了保证数据传输的可靠性和完整性。简单来说就是：</p>
<ul>
<li><p>TCP的面向连接是基于网络底层的数据传输。</p>
</li>
<li><p>HTTP的无连接是基于应用层面的沟通交互。</p>
<p><strong>无连接：</strong>指的是每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接；这种方式有利于节省传输时间；然后随着互联网的发展，一台服务器同一时间处理的请求越来越多，如果依然采用原来的方式，将会在建立和断开连接上花费大部分时间。为了避免这一劣势，针对http无连接，人们设计了非持久连接和持久连接。实际上关于http协议非持久连接和持久连接是针对tcp协议的。</p>
</li>
<li><p>非持久连接：请求一个HTTP请求/响应需要的总时间为客户端发出建立连接和发生请求报文+服务器传输HTML文件的时间。</p>
</li>
<li><p>持久连接：服务器在发送响应后，保持该TCP连接打开。在相同的客户机与服务器之间的后续请求和响应报文通过相同的连接进行传送。不需要再次建立tcp连接 ，但是由于所有的连接都是串行的，当某一个请求阻塞时就会导致同一条连接的后续请求被阻塞。为了解决这一问题：提出了pipellining的概念；客户端发起一次请求时不必等待响应便直接发起第二个请求；服务端按照请求的顺序一次返回结果；<br><strong>SPDY和HTTP/2:multiplexing：</strong>多路复用技术出现；能够让多个请求和响应的传输完全混杂在一起进行；通过streamID来互相区别；</p>
</li>
</ul>
<p> PS:HTTP借助于底层的TCP虚拟连接，HTTP协议本身无需连接；就好比A和B打电话，A和B是借助于底层的简化先连接交换信息；但是A和B本身无需连接；</p>
<p> <strong>无状态：</strong>是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。言外之意是说http协议没法保存客户机信息，也就没法区分每次请求的不同之处。关于http无状态阻碍了交互式应用程序的实现。比如记录用户浏览哪些网页、判断用户是否拥有权限访问等。于是，两种用于保持HTTP状态的技术就应运而生了，一个是Cookie，而另一个则是Session。</p>
<p>HTTPS协议，它比HTTP协议相比多了以下优势:</p>
<ul>
<li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li>
<li>数据完整性：内容传输经过完整性校验</li>
<li>身份认证：第三方无法伪造服务端（客户端）身份</li>
</ul>
<p>数字证书认证机构的业务流程：</p>
<p>服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;</p>
<p>CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</p>
<p>如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，<strong>采用 CA的私钥对信息摘要进行加密</strong>，密文即签名;</p>
<p>客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;</p>
<p>客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，<strong>利用对应 CA的公钥解密签名数据</strong>，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。</p>
<p>客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。因为没有CA私钥，黑客无法伪造CA证书。</p>
<h5 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h5><p> 1、Cookie和Session都是会话技术，Session是运行在服务器端，用来跟踪用户的状态，数据可以保存在集群、数据库、文件中；Cookie是运行在客户端，用来记录用户的一些信息，也是实现Session的一种方式。</p>
<p>  2、Cookie有大小限制以及浏览器存储cookie的个数也有限制，Session是没有大小限制和存储个数与服务器的内存大小有关。</p>
<p>  3、Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。</p>
<p>  4、有效期不同。cookie长期有效；Session有效时间短，假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。</p>
<ol start="4">
<li>共享session</li>
</ol>
<ul>
<li>基于数据库的Session共享</li>
<li>基于NFS共享文件系统</li>
<li>基于memcached 的session，如何保证 memcached 本身的高可用性？</li>
<li>基于cookie 进行session共享</li>
<li>基于resin/tomcat web容器本身的session复制机制</li>
<li>基于TT/Redis 或 jbosscache 进行 session 共享。</li>
</ul>
<h5 id="http状态码分类"><a href="#http状态码分类" class="headerlink" title="http状态码分类"></a>http状态码分类</h5><table>
<thead>
<tr>
<th>分类</th>
<th>分类描述</th>
</tr>
</thead>
<tbody><tr>
<td>1**</td>
<td>信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2**</td>
<td>成功，操作被成功接收并处理</td>
</tr>
<tr>
<td>3**</td>
<td>重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4**</td>
<td>客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td>服务端错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<p>  200，请求成功  </p>
<p>  301，资源（网页等）被永久转移到其它URL  </p>
<p>  302，资源临时移动  </p>
<p>  403，forbidden，服务器理解请求客户端的请求，但是拒绝执行此请求。请求资源被拒绝，通常原因是服务器上某些文件或目录设置了权限，客户端权限不够 </p>
<p>  404，not found，用户输入错误的链接，该链接指向的网页不存在。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 </p>
<p>  500，internal server error 服务器内部错误（比如浏览器代理除了问题，ip，端口不对等）该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。 </p>
<p>  502，Bad Gateway，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应  </p>
<p>  503，服务器超载或停机维护  </p>
<p>  504，Gateway Timeout网关超时服务器作为网关或代理，未及时从上游服务器接收请求</p>
<h5 id="http请求报文和响应报文格式"><a href="#http请求报文和响应报文格式" class="headerlink" title="http请求报文和响应报文格式"></a>http请求报文和响应报文格式</h5><ul>
<li><p><strong>客户端发送一个HTTP请求到服务器的请求消息包括请求行（request line）、请求头部（header）、空行和请求数据四个部分</strong></p>
</li>
<li><p><strong>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文</strong></p>
</li>
<li><p>URL由4部分组成：协议、主机、端口、路径;一般语法格式为(带方括号[]的为可选项,<a href="https://baike.baidu.com/item/URL格式/10056474" target="_blank" rel="noopener">参考</a>)：</p>
<p>protocol :// hostname[:port] / path / [;parameters] [?query] [#fragment]</p>
</li>
</ul>
<h5 id="get和post的区别：参考"><a href="#get和post的区别：参考" class="headerlink" title="get和post的区别：参考"></a>get和post的区别：<a href="https://blog.csdn.net/qq_38182125/article/details/89071899" target="_blank" rel="noopener">参考</a></h5><p><strong>它们的本质都是 TCP 链接，并无区别，在网络环境好的情况下发送时间也几乎一样。但是由于 HTTP 的规定以及浏览器/服务器的限制，导致它们在应用过程中可能会有所不同</strong>。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">get</th>
<th align="center">post</th>
</tr>
</thead>
<tbody><tr>
<td align="center">后退按钮/刷新</td>
<td align="center">无害</td>
<td align="center">数据会被重新提交（浏览器会告知用户数据会被重新提交）</td>
</tr>
<tr>
<td align="center">书签</td>
<td align="center">可收藏为书签</td>
<td align="center">不可收藏为书签</td>
</tr>
<tr>
<td align="center">缓存</td>
<td align="center">浏览器自动缓存</td>
<td align="center">不能被缓存</td>
</tr>
<tr>
<td align="center">历史</td>
<td align="center">参数能保留在浏览器历史中</td>
<td align="center">参数不会保存在浏览器历史中</td>
</tr>
<tr>
<td align="center">对数据长度的限制</td>
<td align="center">数据在URL中，因此URL长度受限（最大长度2048个字符，不同浏览器和服务器限制不同）</td>
<td align="center">没有限制</td>
</tr>
<tr>
<td align="center">对数据类型的限制</td>
<td align="center">只允许ASCLL字符</td>
<td align="center">没有限制，也允许二进制数据。</td>
</tr>
<tr>
<td align="center">安全性</td>
<td align="center">安全性较差，因为所发送数据是URL的一部分，发送密码或者其他敏感信息时绝不要使用get</td>
<td align="center">更安全，因为参数不会被保存在浏览历史或web服务器</td>
</tr>
<tr>
<td align="center">可见性</td>
<td align="center">数据在URL中对所有人可见</td>
<td align="center">数据不会显示在URL中</td>
</tr>
<tr>
<td align="center">TCP数据包</td>
<td align="center">一个，把头部和数据一并发出去</td>
<td align="center">两个，浏览器先发送请求行和请求头，服务器响应100 continue,浏览器再发送data，服务器响应200 ok (返回数据)</td>
</tr>
</tbody></table>
<h5 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h5><ul>
<li>TCP 面向连接，建立连接进行三次握手，一对一传输；UDP 面向无连接，不会建立连接，一对一、一对多、多对一传输，可以应用于广播</li>
<li>UDP程序结构较简单，包头8字节；TCP包头20字节，还有一个可选项长度不确定</li>
<li>TCP 是面向字节流的，UDP 是基于数据报的</li>
<li>TCP 保证数据正确性，有流量控制、拥塞控制、累计确认和超时重传机制；UDP 可能丢包，没有流量控制和拥塞控制</li>
<li>TCP 保证数据顺序，UDP 不保证</li>
</ul>
<h4 id="（十一）百度"><a href="#（十一）百度" class="headerlink" title="（十一）百度"></a>（十一）百度</h4><ol>
<li><a href="https://blog.csdn.net/vivian187/article/details/93043070" target="_blank" rel="noopener">c++中构造函数或析构函数定义为protected</a></li>
</ol>
<p>通常将拷贝构造函数和operator=(赋值操作符重载)声明成private，但是没有实现体。这个的目的是禁止一个类的外部用户对这个类的对象进行复制动作。</p>
<ol start="2">
<li>c++设计模式：<a href="https://blog.csdn.net/wuzhekai1985/category_9260796.html" target="_blank" rel="noopener">参考</a></li>
</ol>
<p>（1）工厂模式</p>
<ul>
<li>简单工厂模式：switch</li>
<li>工厂方法模式：一个工厂抽象接口和多个具体生成对象的工厂。比简单工厂模式多的一点优点就是遵循了开放-封闭原则，使得模式的灵活性更强</li>
<li>抽象工厂模式：客户端要使用时必须知道是哪一个工厂并且是哪一组的产品抽象类。每一个工厂子类负责产生一族产品，而子类的一种方法产生一种类型的产品。在客户端看来只有AbstractProductA和AbstractProductB两种产品，使用的时候也是直接使用这两种产品。而通过工厂来识别是属于哪一族产品。</li>
</ul>
<p>工厂模式和简单工厂模式要求产品子类必须要是同一类型的，拥有共同的方法，这就限制了产品子类的扩展。于是为了更加方便的扩展，抽象工厂模式就将同一类的产品子类归为一类，让他们继承同一个抽象子类，我们可以把他们一起视作一组，然后好几组产品构成一族。</p>
<p>（2）策略模式</p>
<ul>
<li>直接通过参数指定，传入一个特定算法的指针（暴露了算法）</li>
<li>直接通过参数指定，只不过不是传入指针，而是一个标签（switch和简单工厂结合）</li>
<li>模板实现</li>
</ul>
<p>（3）适配器模式：系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要适应于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。</p>
<p>（4）单例模式：由于构造函数是私有的，因此无法通过构造函数实例化，可以通过调用静态成员函数GetInstance在类内部构造实例。用户访问唯一实例的方法只有GetInstance()成员函数。GetInstance()使用懒惰初始化，也就是说它的返回值是当这个函数首次被访问时被创建的。这是一种防弹设计——所有GetInstance()之后的调用都返回相同实例的指针。单例模式通过类本身来管理其唯一实例，唯一的实例是类的一个普通对象，但设计这个类时，让它只能创建一个实例并提供对此实例的全局访问。唯一实例类Singleton在静态成员函数中隐藏创建实例的操作。习惯上把这个成员函数叫做Instance()，它的返回值是唯一实例的指针。<a href="https://blog.csdn.net/hackbuteer1/article/details/7460019" target="_blank" rel="noopener">参考</a></p>
<p>（5）原型模式：拷贝构造函数</p>
<p>（6）模板方法模式：定义操作的骨架，依次调用子类实现的函数</p>
<p>（7）建造者模式（直接传入特定类型对象作为参数）</p>
<ol start="3">
<li>最长回文子串</li>
<li>数组中未出现最小正整数</li>
<li>内存管理</li>
<li>udp为什么会丢包？如何减少丢包？</li>
</ol>
<p>1、接收端处理时间过长（接收端采用多线程回调机制或尽量简化处理数据包到重新回到监听状态的中间过程）</p>
<p>2、发送包过大，超过接受者缓存（使用setsocketopt修改接收端缓冲区大小）</p>
<p>3、发送包的频率过高（发送端sleep）</p>
<p>4、网络不稳定或拥塞（改善网络环境或实现丢包处理）</p>
<ol start="7">
<li>TCP/UDP传输的应用  TCP流量控制  拥塞机制：慢启动  拥塞避免  快重传  快恢复</li>
<li>非递归快排</li>
</ol>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/qiuck_sort.png" alt="快速排序递归排序非递归排序"></p>
<ol start="9">
<li>封装、继承、多态的目的 </li>
</ol>
<p>封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用，派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性。</p>
<p>最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种方法的目的了。</p>
<ol start="10">
<li>磁盘的随机读写和顺序读写</li>
</ol>
<p>顺序读写：文件指针只能从头移动到尾，SAS机械硬盘主要是看顺序读写性能</p>
<p>随机读写：文件指针可以根据需要随意移动，寻道时间和旋转延迟，SSD固态盘主要看随机读写性能</p>
<ol start="11">
<li>对称密钥加密和非对称密钥加密的区别</li>
</ol>
<p>对称密钥：又称私钥加密，即<strong>信息的发送方和接收方用一个密钥去加密和解密数据</strong>。它的最大优势是加/解密速度快，适合于对大数据量进行加密，但密钥管理困难，安全性低。</p>
<p>非对称密钥加密系统：又称公钥密钥加密，它<strong>需要使用一对密钥来分别完成加密和解密操作</strong>，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。公钥机制灵活，安全性高，但加密和解密速度却比对称密钥加密慢得多。</p>
<ol start="12">
<li><p>垃圾回收机制</p>
</li>
<li><p>Linux操作系统的主要组成部分：内核，shell,文件系统，应用程序</p>
</li>
</ol>
<ul>
<li>文件系统索引结构B+树</li>
</ul>
<ol start="14">
<li>IO  cache 用法</li>
</ol>
<p><strong>Buffer</strong>（缓冲区）是系统两端处理<strong>速度平衡</strong>（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到<strong>流量整形</strong>的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。<br><strong>Cache</strong>（缓存）则是系统两端处理<strong>速度不匹配</strong>时的一种<strong>折衷策略</strong>。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。</p>
<p>常规文件系统操作（调用read/fread/write等类函数）中，函数的调用过程：</p>
<ul>
<li><p><strong>读文件</strong><br>1、进程调用库函数向内核发起读文件请求；</p>
<p>2、内核通过检查进程的文件描述符定位到虚拟文件系统的已打开文件列表表项；</p>
<p>3、调用该文件可用的系统调用函数read()</p>
<p>3、read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode；</p>
<p>4、在inode中，通过文件内容偏移量计算出要读取的页；</p>
<p>5、通过inode找到文件对应的address_space；</p>
<p>6、在address_space中访问该文件的页缓存树，查找对应的页缓存结点：</p>
<p>（1）如果页缓存命中，那么直接返回文件内容；</p>
<p>（2）如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第6步查找页缓存；</p>
<p>7、文件内容读取成功。</p>
<p><strong>写文件</strong><br>前5步和读文件一致，在address_space中查询对应页的页缓存是否存在：</p>
<p>6、如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。</p>
<p>7、如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。</p>
<p>8、一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：</p>
<p>（1）手动调用sync()或者fsync()系统调用把脏页写回</p>
<p>（2）pdflush进程会定时把脏页写回到磁盘</p>
<p>同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。</p>
</li>
</ul>
<p>将磁盘上的数据缓存在内存中，加速文件的读写。实际上，在一般情况下，read/write是只跟缓存打交道的。read就直接从缓存读数据。如果要读的数据还不在缓存中，则触发一次读盘操作，然后等待磁盘上的数据被更新到磁盘高速缓存中；write也是直接写到缓存里去，然后就不用管了。后续内核会负责将数据写回磁盘。为了实现这样的缓存，每个文件的inode内嵌了一个address_space结构，通过inode-&gt;i_mapping来访问。address_space结构中维护了一棵radix树，用于磁盘高速缓存的内存页面就挂在这棵树上。而既然磁盘高速缓存是跟文件的inode关联上的，则打开这个文件的每个进程都共用同一份缓存。</p>
<ol start="15">
<li><p>bitmap   磁盘一亿个数查询target，内存4g</p>
</li>
<li><p>linux创建管道命令</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo [options] NAME  #创建有名管道</span><br></pre></td></tr></table></figure>

<ol start="17">
<li>git命令行</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;name&gt;  <span class="comment">#创建分支</span></span><br><span class="line">git merge &lt;name&gt;   <span class="comment">#合并分支</span></span><br></pre></td></tr></table></figure>

<ol start="18">
<li>动态链接库和静态链接库的区别:<a href="https://www.cnblogs.com/cyyljw/p/10949660.html" target="_blank" rel="noopener">参考</a></li>
</ol>
<p>（一）静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，lib中的指令都全部被直接包含在最终生成的exe文件中了（链接器从静态链接库获取所有被引用函数的二进制代码和库一起放到可执行文件中）。但是若使用dll动态链接库，该dll不必被包含在最终的exe文件中，它允许可执行模块（dll或exe文件）仅包含在运行时定位dll函数的可执行代码的所需信息，执行文件执行时可以动态地引用和卸载这个与exe独立的dll文件。如果某个目标文件需要的函数在参与链接的目标文件中找不到的话，链接器就报错了。目标文件中有两个重要的接口来提供这些信息：一个是符号表，另外一个是重定位表。</p>
<p>（二）静态链接库不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。 </p>
<p>（三）动态链接库基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，<strong>当程序在运行到指定的代码时，去执行共享内存中已经加载的动态库可执行代码</strong>，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件,也就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果在当前工程中有多处对dll文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但是如果有多处对lib文件中同一个函数的调用，那么执行时，该函数将在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝。</p>
<p><strong>静态链接的优点</strong> </p>
<p>   (1) 代码装载速度快，执行速度略比动态链接库快，在程序发布的时候就不需要的依赖库（不需要带着库一块发布），程序可以独立执行； </p>
<p>   (2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 </p>
<p>  <strong>动态链接的优点</strong> </p>
<p>   (1) DLL 节省内存，减少页面交换，节省磁盘空间，多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝；</p>
<p>   (2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；</p>
<p>   (3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；</p>
<p>   (4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。</p>
<p>  <strong>静态链接和动态链接的不足之处</strong></p>
<p>   (1) 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；如果静态库有更新的话，所有可执行文件都得重新链接才能用上新的静态库，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统死掉</p>
<p>   (2) 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。但是由于是运行时加载，可能会影响程序的前期执行性能。</p>
<ol start="20">
<li>从源程序到执行程序的过程:<a href="https://blog.csdn.net/zhoudonghao4381/article/details/80811906" target="_blank" rel="noopener">参考</a></li>
</ol>
<ul>
<li>预编译</li>
<li>编译：<strong>把预编译之后生成的xxx.i或xxx.ii文件，进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成和优化，生成相应的汇编代码文件。</strong></li>
<li>汇编：<strong>将汇编代码转变成机器可以执行的指令(机器码文件)</strong>，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)，还有<strong>一个问题——变量a和数组arr的地址还没有确定</strong>。</li>
<li>链接：静态链接和动态链接，生成可执行文件</li>
</ul>
<ol start="21">
<li>mysql怎么创建索引 （索引是一种高效获取数据库数据的数据结构） ？为什么说B+树比B树更适合实际应用中<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="noopener">操作系统</a>的文件索引和<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">数据库</a>索引？</li>
</ol>
<ul>
<li><p>MySQL 提供了三种创建索引的方法：</p>
<p>（1）使用 CREATE INDEX 语句</p>
<p>（2）ALTER TABLE</p>
<p>（3）CREATE TABLE</p>
</li>
</ul>
<ol start="22">
<li>为什么B+树（有序数组+平衡多叉树）比B树（有序数组链表+平衡多叉树）更适合文件索引系统？<a href="https://blog.csdn.net/weixin_30531261/article/details/79312676" target="_blank" rel="noopener">扩展</a></li>
</ol>
<p>（1）B+树空间利用率更高，因为B+树的内部节点只是作为索引使用，而不像B树那样每个节点都需要存储硬盘指针。</p>
<p>（2）增删文件（节点）时，效率更高，因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</p>
<h4 id="（十二）网易"><a href="#（十二）网易" class="headerlink" title="（十二）网易"></a>（十二）网易</h4><ol>
<li>海量数据找到最小的k个数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大堆，时间复杂度O(nlgk),空间复杂度O(k)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;&gt; inSet;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLeastNumbers</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;data,inSet&amp; leastNumbers,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">1</span> || data.<span class="built_in">size</span>()&lt;k)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;itn&gt;::const_iterator iter=data.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(;iter!=data.<span class="built_in">end</span>();++iter)&#123;</span><br><span class="line">        <span class="keyword">if</span>(leastNumbers.<span class="built_in">size</span>()&lt;k)</span><br><span class="line">            leastNumbers.insert(*iter);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(*iter&lt;*leastNumbers.<span class="built_in">begin</span>())&#123;</span><br><span class="line">                leastNumbers.erase(leastNumbers.<span class="built_in">begin</span>());</span><br><span class="line">            	leastNumbers.insert(*iter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当我们可以修改输入数组时，可用partition函数，时间复杂度为O(n)</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>重载一个运算符原则：</p>
<p>1.不能改变运算符的初始意义。</p>
<p>2.不能改变运算符的参数数目。如重载运算符+时只用一个操作数是错误的。</p>
<p>3.运算符函数不能包括缺省的参数。</p>
<p>4.绝大部分C++运算符都可以重载，除以下的例外：</p>
<p><code>.   ::   .*  ?</code></p>
<p>5．除赋值运算符外，其它运算符函数都可以由派生类继承。</p>
<p>6.运算符重载不改变运算符的优先级和结合性，也不改变运算符的语法结构，即单目、双目运算符只能重载为单目、双目运算符。</p>
<p>7.运算符的重载实际上是函数的重载。编译程序对运算符重载的选择，遵循函数重载的选择原则。当遇到不很明显的运算符时，编译程序将去寻找参数匹配的运算符函数。</p>
<p>8.运算符重载可使程序更简洁，使表达式更直观，增强可读性。但使用不宜过多。</p>
<p>9.重载运算符含义必须清楚.</p>
</li>
</ol>
<p>   <strong>重载的形式:成员函数形式 和 友元函数形式</strong></p>
<p>   (1) 一般情况下，单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数。<br>   (2) 以下双目运算符不能重载为类的友元函数：=、()、[]、-&gt;。<br>   (3) 类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。<br>   (4) 若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好。<br>   (5) 若运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则只能选用友元函数。<br>   (6) 当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一　个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部　类型的对象，该运算符函数必须作为一个友元函数来实现。<br>   (7) 当需要重载运算符具有可交换性时，选择重载为友元函数。</p>
<ol start="3">
<li><p>HTTP1.0和HTTP1.1的区别</p>
<p>HTTP1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。</p>
<p>在 HTTP1.1 中,一个连接可用于一次或多次请求/响应交换,尽管连接可能由于各种原因被关闭。HTTP 1.1只能持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延时。</p>
</li>
<li><p>二叉树的高度和节点数</p>
<p>具有n个结点的完全二叉树的高度为log(n+1)向上取整，或者(logn)向下取整+1</p>
<p>高度为h完全二叉树最后一层有n+1-2^(h-1)个结点;完全二叉树第k层至多有2^（k-1）个结点<br>满二叉树深度为h，则有2^h-1个结点；第k层的节点数目为2^（k-1）</p>
</li>
</ol>
<h4 id="（十三）腾讯"><a href="#（十三）腾讯" class="headerlink" title="（十三）腾讯"></a>（十三）腾讯</h4><ol>
<li>static变量？ static函数为什么只能用static变量？</li>
</ol>
<p>（1）静态成员变量：</p>
<ul>
<li>静态成员变量属于整个类所有，生命期不依赖于任何对象，为程序的生命周期</li>
<li>可以通过类名直接访问公有静态成员变量，也可以通过对象名访问公有静态成员变量</li>
<li>静态成员变量是静态存储的，所以必须对它进行初始化</li>
<li>静态成员变量在类外单独分配空间</li>
<li>静态成员变量在程序内部位于全局/静态存储区</li>
</ul>
<p>（2）静态成员函数:</p>
<ul>
<li>类内使用static修饰的特殊成员函数</li>
<li>属于整个类所有，没有this指针（这就是它仅能访问类的静态数据和静态成员函数的原因）</li>
<li>只能直接访问静态成员变量和静态成员函数，调用这个函数不会访问或者修改任何对象非static数据成员</li>
<li>可以通过类名直接访问类的公有静态成员函数，也可以通过对象名访问类的公有静态成员函数</li>
<li>不能将静态成员函数定义为虚函数</li>
</ul>
<p>其实很好理解，类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，函数地址类型是个“nonmember 函数指针”。static 并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。静态数据成员在&lt;定义或说明&gt;时前面加关键字 static。 静态成员初始化与一般数据成员初始化不同：</p>
<p>　　初始化在类体外进行，而前面不加 static，以免与一般静态变量或对象相混淆；初始化时不加该成员的访问权限控制符 private、public；初始化时使用作用域运算符来标明它所属类；所以我们得出静态数据成员初始化的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;&#x3D;&lt;值&gt;</span><br></pre></td></tr></table></figure>

<p>　　(9) 为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p>
<p>设置静态成员的目的，是为了将和某些类紧密相关的全局变量和全局函数写到类里面，形式上成为一个整体。使用 sizeof 运算符计算对象所占用的存储空间时，不会将静态成员变量计算在内。对上面的 CRectangle 类来说，sizeof(CRectangle) 的值是 8。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> nTotalArea;  <span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> nTotalNumber;  <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTotal</span> <span class="params">()</span></span>;  <span class="comment">//静态成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>主键索引和非主键索引的区别？</li>
</ol>
<p>非主键索引的叶子节点存放的是<strong>主键的值</strong>，而主键索引的叶子节点存放的是<strong>整行数据</strong>，其中非主键索引也被称为<strong>二级索引</strong>，而主键索引也被称为<strong>聚簇索引</strong>。</p>
<ol start="3">
<li>孤儿进程  僵尸进程</li>
</ol>
<p><strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p>
<p><strong>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</strong>假如它的父进程没有安装SIGCHLD信号处理函数来处理子进程（也即使wait或者waitpid等待儿子结束），又没有显示忽略该信号，那子进程就会一直保持僵尸状态。只有在父进程结束之后，才由init进程接管子进程，为他收尸（好凄惨啊），这个时候才能说子进程才真正的消失在Linux内核中。</p>
<p><strong>僵尸进程的避免</strong></p>
<p>⒈父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。</p>
<p>⒉ 如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler，因为子进程结束后， 父进程会收到该信号，可以在handler中调用wait回收。</p>
<p>⒊ 如果<a href="https://baike.baidu.com/item/父进程" target="_blank" rel="noopener">父进程</a>不关心子进程什么时候结束，那么可以用signal（SIGCHLD,SIG_IGN） 通知<a href="https://baike.baidu.com/item/内核" target="_blank" rel="noopener">内核</a>，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收， 并不再给父进程发送信号。</p>
<p>⒋ 还有一些技巧，就是fork两次，父进程fork一个子进程，然后继续工作，子进程fork一 个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做。</p>
<ol start="4">
<li><p>链表的选择排序</p>
</li>
<li><p>二叉树的最长路径和</p>
</li>
<li><p>数独</p>
</li>
<li><p>迷宫</p>
</li>
<li><p>printf函数是从右向左计算入栈，输出顺序从左往右；函数调用参数的时候，从右往左依次执行所有会改变变量数值的式子，遇到后置自增的式子则直接把此时的变量代入，得到该自增式的值。全部执行完成后再从左往右依次把改变后的变量值代入各个除后置自增式以外的所有式子，此时这些式子的值是最终要代入函数的参数。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by anranzhai on 2020/4/17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>, (i++) - (--j), j = (i += <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>, i, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>,(k++,k++),k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>,l,(l++,l++));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a=<span class="number">11</span>, a++, a++);</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a, a + <span class="number">1</span>, a = <span class="number">3</span>);</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a++, a++, a = <span class="number">3</span>);</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a = <span class="number">11</span>, a = <span class="number">22</span>, a = <span class="number">33</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>, ++b,++b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>, ++b,b++);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v&#123;<span class="string">'a'</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(vec)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(v)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s=<span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span></span><br><span class="line"><span class="number">6</span>  <span class="number">4</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2</span></span><br><span class="line"><span class="number">11</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">11</span> <span class="number">11</span> <span class="number">11</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">i++=<span class="number">1</span>;<span class="comment">//错误，后置源码定义函数返回const int右值</span></span><br><span class="line">++i=<span class="number">1</span>;<span class="comment">//正确,前置源码定义函数返回int&amp;左值</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>sizeof</p>
</li>
<li><pre><code class="c++"><span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>,(k++,k++),k); <span class="comment">//为什么带括号？</span>
&lt;!--￼<span class="number">16</span>--&gt;


</code></pre>
</li>
</ol>
<h4 id="（十五）快手"><a href="#（十五）快手" class="headerlink" title="（十五）快手"></a>（十五）快手</h4><ol>
<li><p>容器的选择：<a href="https://blog.csdn.net/gogokongyin/article/details/51178378" target="_blank" rel="noopener">vector/deque/list的差别</a></p>
<p>1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector<br>2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list<br>3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。</p>
</li>
<li><p>vector自定义类的要求</p>
</li>
</ol>
<p>自定义的类必须有默认构造函数，因为vector会调用默认构造函数来初始化元素的对象。编译器隐式声明默认构造函数的条件：</p>
<p>· 该类没有显式声明任何构造函数。</p>
<p>· 数据成员中没有const和reference。–因为要初始化（？？这点目前不是很理解）</p>
<p>满足则隐式生成默认构造函数。这里强调“任何”，是指即使用户自定义了复制构造函数或一个需要多个参数的构造函数，默认构造函数也不会被隐式声明了。在定义一个类时要保证有默认的构造函数。同时要求：<br>   1、Copy构造函数：<a href="https://www.jianshu.com/p/025ae7b51ca8" target="_blank" rel="noopener">原理</a><br>   2、赋值=操作符<br>   3、能够销毁对象的析构函数<br>  另外：<br>   1、可用的缺省构造函数，序列型容器必须，用于初始化元素<br>   2、==操作符定义，用于判断相等<br>   3、&lt;操作符定义，关联型容器必须，用于缺省排序</p>
<ol start="3">
<li>程序状态字PSW(Program Status Word)</li>
</ol>
<p>指在电脑中，一段包含被<a href="https://baike.so.com/doc/5354536-5590000.html" target="_blank" rel="noopener">操作系统</a>和潜在<a href="https://baike.so.com/doc/2368908-2504815.html" target="_blank" rel="noopener">硬件</a>使用的程序状态信息的<a href="https://baike.so.com/doc/176561-186541.html" target="_blank" rel="noopener">内存</a>或<a href="https://baike.so.com/doc/2368908-2504815.html" target="_blank" rel="noopener">硬件</a>区域。一般用一个专门的寄存器来指示处理器状态。在计算机系统中，表明系统运行状态的部件是<strong>程序状态字</strong>。</p>
<p>程序状态字PSW(Program Status Word)包括的状态位有<strong>进位标志位(CF)</strong>、<strong>结果为零标志位(ZF)</strong>、<strong>符号标志位(SF)</strong>、<strong>溢出标志位(OF)</strong>、<strong>陷阱标志位(TF)</strong>、<strong>中断使能(中断屏蔽)标志位(IF)</strong>、<strong>虚拟中断标志位(VIF)</strong>、<strong>虚拟中断待决标志位(VIP)</strong>、<strong>I0特权级别(IOPL)</strong>。</p>
<ol start="4">
<li>类型变量所占字节数</li>
</ol>
<table>
<thead>
<tr>
<th>算术类型</th>
<th>32</th>
<th>64</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>char</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>char*</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>8</td>
</tr>
</tbody></table>
<p>指针类型存储的是所指向变量的地址，所以32位机器只需要32bit，而64位机器需要64bit。数据类型占内存的位数实际上与操作系统的位数和编译器（不同编译器支持的位数可能有所不同）都有关，具体某种数据类型占字节数需要编译器根据操作系统位数间进行协调好后分配内存大小。</p>
<h4 id="（十六）华为"><a href="#（十六）华为" class="headerlink" title="（十六）华为"></a>（十六）华为</h4><ol>
<li>字符串分隔符分隔和定义比较函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> s,<span class="keyword">int</span> n):name(s),cnt(n)&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"><span class="comment">//直接在类内重载&lt;运算符</span></span><br><span class="line"><span class="comment">//    bool operator&lt; (const Person&amp; two) const&#123;//一定要加const</span></span><br><span class="line"><span class="comment">//        if(cnt==two.cnt)&#123;</span></span><br><span class="line"><span class="comment">//            if(name.find(two.name)||two.name.find(name))</span></span><br><span class="line"><span class="comment">//                return name.length()&lt;two.name.length();</span></span><br><span class="line"><span class="comment">//            else</span></span><br><span class="line"><span class="comment">//                return name&lt;two.name;</span></span><br><span class="line"><span class="comment">//        &#125; else</span></span><br><span class="line"><span class="comment">//            return cnt&gt;two.cnt;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类外设计比较函数类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Isshort</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//一定要加public，不然编译不过去</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; one,<span class="keyword">const</span> Person&amp; two)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(one.cnt==two.cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(one.name.<span class="built_in">find</span>(two.name)||two.name.<span class="built_in">find</span>(one.name))</span><br><span class="line">                <span class="keyword">return</span> one.name.length()&lt;two.name.length();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> one.name&lt;two.name;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> one.cnt&gt;two.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getStar</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &amp;str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; people;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> per:str)&#123;</span><br><span class="line">        people.emplace_back(per.first,per.second);</span><br><span class="line">    &#125;</span><br><span class="line">   sort(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>(),Isshort());</span><br><span class="line"><span class="comment">//在函数上直接添加lamda表达式</span></span><br><span class="line"><span class="comment">//       [](const Person &amp;one,const Person&amp; p)&#123;</span></span><br><span class="line"><span class="comment">//        if(one.cnt==p.cnt)&#123;</span></span><br><span class="line"><span class="comment">//            if(one.name.find(p.name)||p.name.find(one.name))</span></span><br><span class="line"><span class="comment">//                return one.name.length()&lt;p.name.length();</span></span><br><span class="line"><span class="comment">//            else</span></span><br><span class="line"><span class="comment">//                return one.name&lt;p.name;</span></span><br><span class="line"><span class="comment">//        &#125; else</span></span><br><span class="line"><span class="comment">//            return one.cnt&gt;p.cnt;</span></span><br><span class="line"><span class="comment">//    &#125;);</span></span><br><span class="line">    <span class="keyword">return</span> (*people.cbegin()).name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; str;</span><br><span class="line"><span class="comment">//这样输入无法正常停止，遇见'.'或者换行符'\n'或者结束符'EOF'才能停止</span></span><br><span class="line"><span class="comment">//    while(getline(cin,s,','))&#123;</span></span><br><span class="line"><span class="comment">//        if(s=="\n")</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line"><span class="comment">//        if(s[0]&lt;'A'||s[0]&gt;'Z')&#123;</span></span><br><span class="line"><span class="comment">//            cout&lt;&lt;00001&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        for(int i=1;i&lt;s.size();i++)&#123;</span></span><br><span class="line"><span class="comment">//            if(s[i]&lt;'a'||s[i]&gt;'z')&#123;</span></span><br><span class="line"><span class="comment">//                cout&lt;&lt;00001&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if(str.count(s))</span></span><br><span class="line"><span class="comment">//            str[s]++;</span></span><br><span class="line"><span class="comment">//        else</span></span><br><span class="line"><span class="comment">//            str[s]=1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="comment">//字符串分隔符的两种办法find和strtok</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* delim=<span class="keyword">new</span> <span class="keyword">char</span>(<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">char</span>* data=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(s.<span class="built_in">size</span>()* <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    copy(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),data);</span><br><span class="line">    <span class="keyword">char</span>* per=strtok(data,delim);</span><br><span class="line">    <span class="keyword">while</span>(per!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*per&lt;<span class="string">'A'</span>||*per&gt;<span class="string">'Z'</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">00001</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p=per+<span class="number">1</span>;*p!=<span class="string">'\0'</span>;p++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*p&lt;<span class="string">'a'</span>||*p&gt;<span class="string">'z'</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="number">00001</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str.count(per))</span><br><span class="line">            str[per]++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            str[per]=<span class="number">1</span>;</span><br><span class="line">        per=strtok(<span class="literal">NULL</span>,delim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    for(auto start=s.begin();start&lt;=s.end();)&#123;</span></span><br><span class="line"><span class="comment">//        auto it=find(start,s.end(),',');</span></span><br><span class="line"><span class="comment">//        auto per=s.substr(start-s.begin(),it-start);</span></span><br><span class="line"><span class="comment">//        if(per[0]&lt;'A'||per[0]&gt;'Z')&#123;</span></span><br><span class="line"><span class="comment">//            cout&lt;&lt;00001&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        for(int i=1;i&lt;per.size();i++)&#123;</span></span><br><span class="line"><span class="comment">//            if(per[i]&lt;'a'||per[i]&gt;'z')&#123;</span></span><br><span class="line"><span class="comment">//                cout&lt;&lt;00001&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if(str.count(per))</span></span><br><span class="line"><span class="comment">//            str[per]++;</span></span><br><span class="line"><span class="comment">//        else</span></span><br><span class="line"><span class="comment">//            str[per]=1;</span></span><br><span class="line"><span class="comment">//        start=it+1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:str)&#123;</span><br><span class="line">        sum+=p.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&lt;=<span class="number">0</span>||sum&gt;=<span class="number">100</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">00001</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> star=getStar(str);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; star&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（十七）阿里"><a href="#（十七）阿里" class="headerlink" title="（十七）阿里"></a>（十七）阿里</h4><ol>
<li>可以用数据结构红黑树/哈希表存储五万个数查询是否存在x</li>
<li>数据量众多，哈希表地址冲突怎么办 可以直接添加链表等</li>
<li>c++新特性</li>
<li>虚函数</li>
<li>数组和链表的区别  单向链表 双向链表</li>
<li>析构函数 private  堆栈</li>
<li>二叉树的建立  存储结构</li>
<li>如何用vector实现队列 <ul>
<li>deque的内存模型：指针数组+vector  </li>
<li>简易实现可以使用int值记录头和尾下标 </li>
</ul>
</li>
<li>static和const的区别</li>
</ol>
<ul>
<li>const定义的常量在超出其作用域之后其空间会被释放。存储在动态区，可以通过取址直接操作指向的内存的值，以绕过编译器对其只读的限制检查；而static定义的静态常量在函数执行后不会释放其存储空间。static修饰的变量作为程序运行时的静态变量，存储于内存的静态区，静态区的数据初始化工作由操作系统在加载完程序后执行main函数前进行。操作系统在加载完程序后，将常量区中存放的变量初值复制给静态变量，完成其初始化。static变量的内存只被分配一次，其值在下次调用时仍维持上次的值。</li>
<li>static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化；static关键字只能用于类定义体内部的声明中，定义时不能标示为static。</li>
<li>const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数，运行期间将不能再对const属性进行修改。</li>
</ul>
<p><strong>const成员函数主要目的是防止成员函数修改对象的内容。</strong>const成员函数不能修改成员变量的值，但可以访问成员变量。</p>
<p><strong>static成员函数主要目的是作为类作用域的全局函数。</strong>不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致：1、不能直接存取类的非静态成员变量，调用非静态成员函数2、不能被声明为virtual</p>
<p>*<em>static const 和 const static *</em>含义相同，有两种用法，一种是作为预编译声明，一种是作为类的静态常量属性。当作为预编译声明时，static const 属性必须在声明时即指定值，而且类型仅限基本数据类型，保证了程序的健壮性。const static常量存在于内存的常量区，有操作系统加载程序时，加载到内存的常量区。所以可以对其取址，但是不能对该区的内存进行写操作，因为这个区从操作系统级进行了只读限定，任何对该内存区的写操作会导致程序崩溃。</p>
<h4 id="（十八）华为"><a href="#（十八）华为" class="headerlink" title="（十八）华为"></a>（十八）华为</h4><ol>
<li>std::thread  线程的启动  线程库</li>
<li>MySQL内联和外联</li>
<li>给定一个字符串  找出出现频率最高的字符  频率相同比较index小的  输出第一个值</li>
<li>单例的安全性</li>
</ol>
<h4 id="（十九）腾讯测开"><a href="#（十九）腾讯测开" class="headerlink" title="（十九）腾讯测开"></a>（十九）腾讯测开</h4><ol>
<li>多态用法示例</li>
<li>测试用例举例(测试边界)</li>
<li>用两个栈实现单向队列</li>
<li>TCP与UDP区别总结：<br>1、TCP面向连接（要先通过三次握手建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付<br>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li>
<li>哈希算法</li>
<li>指针和引用的区别</li>
</ol>
<ul>
<li>指针可以为空，引用不可以为空，引用是对象的别名，定义一个引用的时候必须初始化。因此使用指针之前必须做判空操作，引用就不必，引用是类型安全的，而指针不是。</li>
<li>sizeof引用的大小是所指变量的大小；sizeof指针是指针本身的大小-四个字节。</li>
<li>指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名，引用不改变指向，指针可以，所以有常量指针没有常量引用。自增(++)操作对引用的操作是改变所指对象内容，对指针的操作是使指针指向下一个对象。</li>
<li>引用使用时无需解引用（*）,指针需要解引用。</li>
</ul>
<ol start="7">
<li>指针传递和引用传递的区别：<a href="https://blog.csdn.net/weixin_41256281/article/details/90545595" target="_blank" rel="noopener">参考</a></li>
</ol>
<table>
<thead>
<tr>
<th>传递方式</th>
<th>函数定义</th>
<th>函数调用</th>
<th>函数内对A修改</th>
</tr>
</thead>
<tbody><tr>
<td>值传递</td>
<td>fun(int a)</td>
<td>fun(x)</td>
<td>外部不变</td>
</tr>
<tr>
<td>指针传递</td>
<td>fun(int *a)</td>
<td>fun(&amp;x)</td>
<td>外部同步更改</td>
</tr>
<tr>
<td>引用传递(c++)</td>
<td>fun(int &amp;a)</td>
<td>fun(x)</td>
<td>外部同步更改</td>
</tr>
</tbody></table>
<ul>
<li>指针传递本质上是值传递，传递的是一个地址值。被调函数的形参作为被调函数的局部变量处理，会在栈中开辟内存空间存放由主调函数传进来的实参值，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行操作。如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。</li>
<li>引用传递，被调函数的形参也作为局部变量在栈中开辟内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。参数的处理是通过一个间接寻址的方式操作到主调函数中的相关变量。</li>
<li>从编译的角度讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后不会再更改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象则不能更改。</li>
<li>指针和引用的区别：</li>
</ul>
<p>（1）引用是别名，创建的同时必须被初始化，一旦被初始化就不能改变引用关系，不能为NULL；指针是变量，独立可变可空</p>
<p>（2）引用是间接寻址；指针是直接寻址</p>
<p>（3）引用有类型检查；指针无类型检查</p>
<h4 id="（二十）美团测开"><a href="#（二十）美团测开" class="headerlink" title="（二十）美团测开"></a>（二十）美团测开</h4><ol>
<li>函数指针和指针函数的区别</li>
</ol>
<ul>
<li>函数指针其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">声明格式：类型说明符 (*函数名) (参数)</span><br><span class="line">函数指针是需要把一个函数的地址赋值给它，有两种写法：</span><br><span class="line">fun = &amp;Function；</span><br><span class="line">fun = Function;</span><br><span class="line">取地址运算符&amp;不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。</span><br><span class="line">调用函数指针的方式也有两种：</span><br><span class="line">x = (*fun)();</span><br><span class="line">x = fun();</span><br></pre></td></tr></table></figure>

<ul>
<li>指针函数就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。</li>
</ul>
<ol start="2">
<li>屏幕适配</li>
</ol>
<ul>
<li>屏幕尺寸：手机对角线的物理尺寸 单位：英寸（inch），1英寸=2.54cm</li>
</ul>
<p>Android手机常见的尺寸有5寸、5.5寸、6寸，6.5寸等等</p>
<ul>
<li>屏幕分辨率：手机在横向、纵向上的像素点数总和</li>
</ul>
<p>一般描述成屏幕的“宽x高”=AxB 含义：屏幕在横向方向（宽度）上有A个像素点，在纵向方向（高）有B个像素点 例子：1080x1920，即宽度方向上有1080个像素点，在高度方向上有1920个像素点。单位：px（pixel），1px=1像素点</p>
<p>UI设计师的设计图会以px作为统一的计量单位</p>
<p>Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920</p>
<ul>
<li>屏幕像素密度:每英寸的像素点数 单位：dpi（dots per ich）</li>
</ul>
<p>假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpi=(横向分辨率^<span class="number">2</span>+纵向分辨率^<span class="number">2</span>)^(<span class="number">1</span>/<span class="number">2</span>)/屏幕尺寸</span><br></pre></td></tr></table></figure>

<ul>
<li>屏幕适配的解决方案：<a href="https://blog.csdn.net/coderinchina/article/details/94736938?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">参考</a></li>
</ul>
<p>1、自定义像素适配：(屏幕真实横纵分辨率/默认横纵分辨率)*所设置的横纵长=适配横纵长</p>
<p>2、百分比适配（添加依赖）</p>
<p>3、修改density实现屏幕适配</p>
<p>4、限定符适配</p>
<ol start="2">
<li>SQL语句</li>
<li>微信登录测试内容</li>
<li>为什么选测开</li>
<li>支付宝咻咻咻原理</li>
</ol>
<h4 id="（二十一）知识点"><a href="#（二十一）知识点" class="headerlink" title="（二十一）知识点"></a>（二十一）知识点</h4><ol start="2">
<li>linux内存管理</li>
</ol>
<ul>
<li>虚拟内存</li>
<li>物理内存：Linux内核管理物理内存是通过分页机制实现的</li>
</ul>
<ol start="3">
<li>内置类型和复合类型</li>
</ol>
<p>内置类型包括算术类型和空类型。算术类型分为整型和浮点型，其中整型包括字符型和布尔型。</p>
<p>复合类型主要包括：引用、指针、数组。</p>
<ol start="9">
<li>git log</li>
<li>kill进程是进程通信：linux内核发送SIGKILL信号给进程</li>
<li>windows消息驱动机制和时间驱动机制</li>
<li>Linux设备驱动机制</li>
</ol>
<ul>
<li>字符设备</li>
<li>块设备</li>
<li>网络设备</li>
</ul>
<ol start="10">
<li><p>同学分享的字节二面编程题：1、求36进制的和 2、判断树是否对称</p>
</li>
<li><p>堆排序是原地算法，空间复杂度O(1)。堆在逻辑上是特殊的完全二叉树，在存储结构上是顺序表。一般用数组实现。堆只分为大堆和小堆大堆：树的父亲节点必须比它的叶子节点大；小堆：树中父亲节点比它的叶子小，只有这两种特殊的情况下一个数组才能被称为堆。</p>
<ul>
<li>自底向上构建堆时间复杂度O（n）：从最后一个非叶子结点开始循环遍历直到根结点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span>; i != <span class="number">0</span>; i--)</span><br><span class="line">		sink(n, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自顶向下构建堆时间复杂度O（nlogn）：从根结点开始</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            swim(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见数据结构的查找、插入、删除时间复杂度</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">数据结构</th>
<th align="center">访问</th>
<th align="center">查找</th>
<th align="center">插入</th>
<th align="center">删除</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数组</td>
<td align="center">O(1)</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">有序数组</td>
<td align="center">O(1)</td>
<td align="center">O(logn)</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">链表</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">有序链表</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">二叉查找树</td>
<td align="center">O(logn)</td>
<td align="center">O(logn)</td>
<td align="center">O(logn)</td>
<td align="center">O(logn)</td>
</tr>
<tr>
<td align="center">哈希表</td>
<td align="center">—</td>
<td align="center">O(1)</td>
<td align="center">O(1)</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/struct.png" alt="常见数据结构插入查找删除复杂度"></p>
<ol start="13">
<li><p><strong>使用递归函数需要注意防止</strong>栈溢出<strong>。在计算机中，</strong>函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出<strong><code>fact(1000)</code>。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> n</span>==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<pre><code>**尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。**

上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，主要是要把每一步的乘积传入到递归函数中：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">fact_iter</span><span class="params">(n, <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">fact_iter</span><span class="params">(num, product)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> num </span>== <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br></pre></td></tr></table></figure>

**栈帧**
每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数的返回地址和局部变量。

栈帧也叫过程活动记录，是编译器用来实现过程/函数调用的一种数据结构。从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等。

栈是从高地址向低地址延伸的。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着所需要的各种信息。寄存器ebp指向当前的栈帧的底部（高地址），寄存器esp指向当前的栈帧的顶部（低地址）。

注意：EBP指向当前位于系统栈最上边一个栈帧的底部，而不是系统栈的底部。严格说来，“栈帧底部”和“栈底”是不同的概念;ESP所指的栈帧顶部和系统栈的顶部是同一个位置。</code></pre><ol start="14">
<li>递归时间复杂度</li>
</ol>
<p>master公式：</p>
<p>T [n] = aT[n/b] + f (n)（直接记为T [n] = aT[n/b] + T (N^d)）</p>
<p>其中 a &gt;= 1 and b &gt; 1 是常量，其表示的意义是n表示问题的规模，a表示递归的次数也就是生成的子问题数，b表示每次递归是原来的1/b之一个规模，f（n）表示分解和合并所要花费的时间之和。</p>
<p>解法：<br>①当d&lt;logb a时，时间复杂度为O(n^(logb a))<br>②当d=logb a时，时间复杂度为O((n^d)*logn)<br>③当d&gt;logb a时，时间复杂度为O(n^d)</p>
<ol start="15">
<li>struct和class的区别</li>
</ol>
<ul>
<li><p>默认成员访问说明符：struct-public;class-private</p>
</li>
<li><p>默认派生访问说明符:   struct-public;class-private</p>
</li>
<li><p>构造函数不同：（1）结构体不能包含显示地无参数构造函数，在自定义构造函数中必须为所有成员赋值。结构体成员将自动初始化为它们的默认值。（2）结构体不能包含以下形式的初始值设定类：base(argument-list)</p>
</li>
<li><p>结构体不允许声明析构函数；类可以</p>
</li>
<li><p>对于结构体中的实例字段成员，不能在声明时赋值初始化</p>
</li>
<li><p>声明了结构体类型后，可以使用new运算符创建构造对象，也可以不使用new关键字。如果不使用new,那么在初始化所有字段之前，字段将保持未赋值状态且对象不可用（结构体可以像类一样通过new 构造函数()来创建实例，也可以声明实例之后再赋值，例如：Person xiaoming; <a href="http://xiaoming.name/" target="_blank" rel="noopener">xiaoming.name</a> = “xiaoming”;）</p>
</li>
<li><p>struct是值类型，栈中创建（栈资源却很有限，因此struct常用来处理作为基类型对待的小对象）；class是引用类型，堆中创建</p>
</li>
<li><p>class能用于表示模板类型；struct不能</p>
<p>注意：<strong>struct能包含成员函数；struct能继承；struct能实现多态</strong></p>
</li>
</ul>
<ol start="16">
<li>两种通用的遍历树的策略</li>
</ol>
<ul>
<li>深度优先搜索（DFS）</li>
</ul>
<p>采用深度作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回根到达另一个分支。深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为前序遍历，中序遍历和后序遍历。</p>
<ul>
<li>宽度优先搜索（BFS）</li>
</ul>
<p>按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。</p>
<ol start="17">
<li>std::funtion和std::bind<a href="https://blog.csdn.net/qq_38410730/article/details/103637778" target="_blank" rel="noopener">参考</a></li>
<li>函数对象：定义了调用操作符（）的类对象。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sort</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;str2)</span> <span class="keyword">const</span>  <span class="comment">//带两个参数</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> str1 &gt; str2;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">然后我们可以用这个类作为参数来初始化<span class="built_in">set</span>容器：</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, Sort&gt; myset;  <span class="comment">//带比较函数的set构造函数,并用函数对象Sort初始化</span></span><br><span class="line">myset.insert(<span class="string">"A"</span>);  </span><br><span class="line">myset.insert(<span class="string">"B"</span>);  </span><br><span class="line"><span class="comment">//输出为：B，A。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upper</span> </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Upper(<span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">0</span>):m_min(<span class="built_in">min</span>)&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">const</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value &gt;= m_min;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">int</span> m_min;  </span><br><span class="line">&#125;;  </span><br><span class="line">从而这样调用 find_if 函数：</span><br><span class="line"></span><br><span class="line">find_if( dest.<span class="built_in">begin</span>(), dest.<span class="built_in">end</span>(), Upper(<span class="number">10</span>) );</span><br><span class="line"></span><br><span class="line">首先生成类 Upper 的对象，并用 <span class="number">10</span> 初始化，调用find_if 时将用该函数对象进行判断。</span><br></pre></td></tr></table></figure>

<ol start="19">
<li>解决hash冲突的三种方法</li>
</ol>
<p>哈希函数的构造方法很多，常用的有直接定址法、数字分析法、平方取中法、折叠法、除留余数法、随机数法等，一般常用除留余数法。</p>
<ul>
<li>开放地址法：线性探测、二次探测</li>
<li>链地址法：又称拉链法，将所有具有相同哈希地址的而不同关键字的元素连接到同一个单链表中。如果选定的哈希表长度为m，则可以将哈希表定义为一个有m个头指针组成的指针数组。</li>
<li>再散列法：有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。</li>
<li>建立公共溢出去：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表</li>
</ul>
<ol start="20">
<li>文件描述符表、文件描述符、打开文件表、inode节点</li>
</ol>
<p>不同进程打开现存文件或新建文件时，内核会返回一个<strong>文件描述符</strong>（file descriptor），它是个非负整数。在所有进程的PCB（Process Control Block）中均会保存一份<strong>文件描述符表</strong>（可以理解为一个数组），文件描述符就是这个表的索引（数组下标），每个表项都有一个指向已打开文件的指针（数组的内容），具体是指向文件表中该文件对应的表格项。</p>
<p>在Linux系统中，已打开的文件形成<strong>打开文件表</strong>（open file table），存放在内核空间中，并由系统里的所有进程共享。该表中每个表格保存了一个打开文件的全部信息，如下所示：</p>
<ul>
<li>当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）；</li>
<li>打开文件时所使用的状态标识（即，open()的flags参数）；<br>文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）；</li>
<li>与信号驱动相关的设置；</li>
<li>对该文件<strong>i-node</strong>对象的引用；</li>
<li>文件类型（例如：常规文件、套接字或FIFO）和访问权限；</li>
<li>一个指针，指向该文件所持有的锁列表；</li>
<li>文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳；</li>
</ul>
<p>文件描述符是一个POSIX标准下的概念，为系统调用接口，常见于Linux系统。Windows也是声称遵循POSIX标准的，所以Windows也有文件描述符等概念，但不常用。文件描述符的分配规则： 从当前未被分配的最小整数处分匹配，特别的有：标准输入（stdin）的文件描述符是 0；标准输出（stdout）的文件描述符是 1；标准错误（stderr）的文件描述符是 2。</p>
<p>注意：</p>
<ul>
<li>同一个进程的不同文件描述符可以指向同一个文件；</li>
<li>不同进程可以拥有相同的文件描述符；</li>
<li>不同进程的同一个文件描述符可以指向不同的文件（一般也是这样，除了 0、1、2 这三个特殊的文件）；</li>
<li>不同进程的不同文件描述符也可以指向同一个文件。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          
            <a href="/tags/shell/" rel="tag"># shell</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/" rel="next" title="C++易混点">
                <i class="fa fa-chevron-left"></i> C++易混点
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/25/Git%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" rel="prev" title="Git操作注意事项">
                Git操作注意事项 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">翟安然</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#（一）面向对象的三个基本特征：封装、继承、多态"><span class="nav-number">1.</span> <span class="nav-text">（一）面向对象的三个基本特征：封装、继承、多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（二）bash-shell"><span class="nav-number">2.</span> <span class="nav-text">（二）bash shell</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（三）图"><span class="nav-number">3.</span> <span class="nav-text">（三）图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（四）IO库"><span class="nav-number">4.</span> <span class="nav-text">（四）IO库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（五）搜狗"><span class="nav-number">5.</span> <span class="nav-text">（五）搜狗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（六）手写代码"><span class="nav-number">6.</span> <span class="nav-text">（六）手写代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（七）SAP"><span class="nav-number">7.</span> <span class="nav-text">（七）SAP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（八）进程间的通信方式（IPC-inter-Process-Communication）"><span class="nav-number">8.</span> <span class="nav-text">（八）进程间的通信方式（IPC,inter-Process Communication）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程创建fork和vfork"><span class="nav-number">8.1.</span> <span class="nav-text">进程创建fork和vfork</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别："><span class="nav-number">8.2.</span> <span class="nav-text">fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程和线程的区别"><span class="nav-number">8.3.</span> <span class="nav-text">进程和线程的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程有什么是共享的什么是私有的"><span class="nav-number">8.4.</span> <span class="nav-text">线程有什么是共享的什么是私有的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程的三种基本状态"><span class="nav-number">8.5.</span> <span class="nav-text">进程的三种基本状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#windows命名管道和Linux命名管道的区别"><span class="nav-number">8.6.</span> <span class="nav-text">windows命名管道和Linux命名管道的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#windows多线程通信的方法主要有三种："><span class="nav-number">8.7.</span> <span class="nav-text">windows多线程通信的方法主要有三种：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？"><span class="nav-number">8.8.</span> <span class="nav-text">死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（九）SQL"><span class="nav-number">9.</span> <span class="nav-text">（九）SQL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（十）计算机网络"><span class="nav-number">10.</span> <span class="nav-text">（十）计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP-与-HTTPS-区别"><span class="nav-number">10.1.</span> <span class="nav-text">HTTP 与 HTTPS 区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#客户端在使用HTTPS方式与Web服务器通信步骤"><span class="nav-number">10.2.</span> <span class="nav-text">客户端在使用HTTPS方式与Web服务器通信步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#怎么理解http协议的无连接无状态"><span class="nav-number">10.3.</span> <span class="nav-text">怎么理解http协议的无连接无状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cookie和session的区别"><span class="nav-number">10.4.</span> <span class="nav-text">cookie和session的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#http状态码分类"><span class="nav-number">10.5.</span> <span class="nav-text">http状态码分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#http请求报文和响应报文格式"><span class="nav-number">10.6.</span> <span class="nav-text">http请求报文和响应报文格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#get和post的区别：参考"><span class="nav-number">10.7.</span> <span class="nav-text">get和post的区别：参考</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP和UDP的区别"><span class="nav-number">10.8.</span> <span class="nav-text">TCP和UDP的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（十一）百度"><span class="nav-number">11.</span> <span class="nav-text">（十一）百度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（十二）网易"><span class="nav-number">12.</span> <span class="nav-text">（十二）网易</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（十三）腾讯"><span class="nav-number">13.</span> <span class="nav-text">（十三）腾讯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（十五）快手"><span class="nav-number">14.</span> <span class="nav-text">（十五）快手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（十六）华为"><span class="nav-number">15.</span> <span class="nav-text">（十六）华为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（十七）阿里"><span class="nav-number">16.</span> <span class="nav-text">（十七）阿里</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（十八）华为"><span class="nav-number">17.</span> <span class="nav-text">（十八）华为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（十九）腾讯测开"><span class="nav-number">18.</span> <span class="nav-text">（十九）腾讯测开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（二十）美团测开"><span class="nav-number">19.</span> <span class="nav-text">（二十）美团测开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（二十一）知识点"><span class="nav-number">20.</span> <span class="nav-text">（二十一）知识点</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">翟安然</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  
  
    <script src="/js/cursor/fireworks.js"></script>
  

</body>
</html>

