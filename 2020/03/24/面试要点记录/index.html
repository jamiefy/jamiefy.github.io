<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,面试,shell," />










<meta name="description" content="（一）面向对象的三个基本特征：封装、继承、多态 继承   子类对象可以直接调用父类中的成员函数 子类对象可以直接赋值给父类对象。 子类对象可以直接初始化父类对象。 父类引用可以直接引用子类对象。 父类指针可以直接指向子类对象。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试要点记录">
<meta property="og:url" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="翟安然&#39;s Blog">
<meta property="og:description" content="（一）面向对象的三个基本特征：封装、继承、多态 继承   子类对象可以直接调用父类中的成员函数 子类对象可以直接赋值给父类对象。 子类对象可以直接初始化父类对象。 父类引用可以直接引用子类对象。 父类指针可以直接指向子类对象。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/seekgseekp.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95%5Clinux32%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95%5Chttps.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95%5Cqiuck_sort.png">
<meta property="article:published_time" content="2020-03-24T13:59:01.000Z">
<meta property="article:modified_time" content="2020-04-06T11:04:26.007Z">
<meta property="article:author" content="翟安然">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/seekgseekp.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/24/面试要点记录/"/>





  <title>面试要点记录 | 翟安然's Blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">翟安然's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="翟安然">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="翟安然's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试要点记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-24T21:59:01+08:00">
                2020-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="（一）面向对象的三个基本特征：封装、继承、多态"><a href="#（一）面向对象的三个基本特征：封装、继承、多态" class="headerlink" title="（一）面向对象的三个基本特征：封装、继承、多态"></a>（一）面向对象的三个基本特征：封装、继承、多态</h4><ol>
<li>继承</li>
</ol>
<ul>
<li>子类对象可以直接调用父类中的成员函数</li>
<li>子类对象可以直接赋值给父类对象。</li>
<li>子类对象可以直接初始化父类对象。</li>
<li>父类引用可以直接引用子类对象。</li>
<li>父类指针可以直接指向子类对象。</li>
</ul>
<a id="more"></a>

<ul>
<li>子类初始化一定会先初始化父类，析构顺序相反。</li>
<li>虚继承对构造函数的影响：<a href="https://blog.csdn.net/dqjyong/article/details/8028888?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">指南</a>。构造函数的调用可能内带大量的隐藏码，因为编译器会对构造函数进行扩充，一般而言编译器所作的扩充规则如下：</li>
</ul>
<p>（1）记录在成员初始化列表中的数据成员的初始化操作会被放到构造函数本身中，按照数据成员声明的顺序</p>
<p>（2）如果有一个数据成员没有出现在初始化列表中，但是它有一个默认构造函数，那么这个默认构造函数会被调用</p>
<p>（3）在那之前，如果有虚函数表，会调整虚函数表指针</p>
<p>（4）在那之前，会对上一层基类的构造函数进行调用</p>
<p>（5）在那之前，所有虚基类的构造函数必须被调用，按照声明的继承顺序从左往右，从最深到最浅的顺序</p>
<ol start="2">
<li>多态</li>
</ol>
<ul>
<li>多态发生的三个必要条件：<ol>
<li>要有继承。</li>
<li>要有虚函数重写。</li>
<li>父类指针或引用 指向 子类对象。</li>
</ol>
</li>
<li>虚析构函数：在多态时，要调用析构函数时，注意在父类的析构成员函数前加virtual。</li>
</ul>
<ol start="3">
<li>重载/重写（覆盖）/重定义（隐藏）</li>
</ol>
<ul>
<li>重载（overload）-编译时的多态性</li>
</ul>
<p>（1）重载只能通过不同的参数样式（参数类型、个数、顺序至少有一个不相同），不能通过访问权限、返回类型、抛出的异常进行重载。</p>
<ul>
<li>重写（override）-运行时的多态性</li>
</ul>
<p>（1）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p>
<p>（2）被定义为final的方法不能被重写。</p>
<ul>
<li>重定义（隐藏hiding）</li>
</ul>
<p>（1）隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base display()"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base show()"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>&#123; <span class="built_in">display</span>(); show(); &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base fun(string)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base fun(int)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;<span class="comment">//overload:两个fun函数在Base类的内部被重载  </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">function</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span>:</span><span class="keyword">public</span> Base  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"ClassA display()"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;<span class="comment">//override:基类中display为虚函数，且参数列表一直，故此处为重写  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"ClassA fun(int,int)"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;<span class="comment">//redefining:fun函数在Base类中不为虚函数，故此处为重定义  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"ClassA show()"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;<span class="comment">//redefining:理由同上  </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;&#125;<span class="comment">//overload:注意这是重载而不是重写，因为参数列表不同，在编译时ClassA中其实还有个编译器自己偷偷加上的从Base继承来的int function()&#123;&#125;;  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    ClassA a;  </span><br><span class="line">    Base *base=&amp;a;  </span><br><span class="line">    base-&gt;exec();<span class="comment">//display()是ClassA的，因为覆盖了，show()是Base自己的  </span></span><br><span class="line">    a.exec();<span class="comment">//结果同上,子类对象可以直接调用父类中的成员函数  </span></span><br><span class="line">    a.show();<span class="comment">//show()是ClassA重定义的  </span></span><br><span class="line">    base-&gt;fun(<span class="number">1</span>);<span class="comment">//fun()是Base自己的，因为直接从对象base调用  </span></span><br><span class="line">    a.fun(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//fun()是ClassA重定义的  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="function">ClassA <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Base <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">ClassA <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Base <span class="title">show</span><span class="params">()</span><span class="comment">//父类中的成员函数直接调用自身的Base show()</span></span></span><br><span class="line"><span class="function">ClassA <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Base <span class="title">fun</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">ClassA <span class="title">fun</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::f(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::g(int) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::h(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base *pb = &amp;d;</span><br><span class="line">    Derived *pd = &amp;d;</span><br><span class="line">    <span class="comment">// Good : behavior depends solely on type of the object</span></span><br><span class="line">    pb-&gt;f(<span class="number">3.14f</span>); <span class="comment">//Derived::f(float) 3.14</span></span><br><span class="line">    pd-&gt;f(<span class="number">3.14f</span>); <span class="comment">//Derived::f(float) 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bad : behavior depends on type of the pointer</span></span><br><span class="line">    pb-&gt;g(<span class="number">3.14f</span>); <span class="comment">//Base::g(float) 3.14</span></span><br><span class="line">    pd-&gt;g(<span class="number">3.14f</span>); <span class="comment">//Derived::g(int) 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bad : behavior depends on type of the pointer</span></span><br><span class="line">    pb-&gt;h(<span class="number">3.14f</span>); <span class="comment">//Base::h(float) 3.14</span></span><br><span class="line">    pd-&gt;h(<span class="number">3.14f</span>); <span class="comment">//Derived::h(float) 3.14</span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数Derived::f(float)覆盖了Base::f(float)。</span></span><br><span class="line"><span class="comment">//函数Derived::g(int)隐藏了Base::g(float)，而不是重载。</span></span><br><span class="line"><span class="comment">//函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>三者</th>
<th>作用域</th>
<th>有无virtual</th>
<th>函数名</th>
<th>参数列表</th>
<th>返回类型</th>
</tr>
</thead>
<tbody><tr>
<td>重载</td>
<td>相同</td>
<td>可有可无</td>
<td>相同</td>
<td>不同</td>
<td>可同可不同</td>
</tr>
<tr>
<td>重写</td>
<td>不同</td>
<td>必有</td>
<td>相同</td>
<td>相同</td>
<td>相同（协变）</td>
</tr>
<tr>
<td>隐藏</td>
<td>不同</td>
<td>可有可无</td>
<td>相同</td>
<td>可同可不同</td>
<td>可同可不同</td>
</tr>
</tbody></table>
<h4 id="（二）bash-shell"><a href="#（二）bash-shell" class="headerlink" title="（二）bash shell"></a>（二）bash shell</h4><ul>
<li><p>bash是borne again shell的缩写，是shell的一种,Linux上默认采用的是bash。</p>
</li>
<li><p>Shell 是一个 C 语言编写的程序，一般都是放在<code>/bin</code>或者<code>/user/bin</code>目录下，当前 Linux 系统可用的 Shell 都记录在<code>/etc/shells</code>文件中。<code>/etc/shells</code>是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令查看它。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/shells <span class="comment">#通过 cat 命令来查看当前 Linux 系统的可用 Shell</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$SHELL</span> <span class="comment">#查看当前Linux默认的shell，输出 SHELL 环境变量</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$BASH_VERSION</span> <span class="comment">#查看shell版本</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置取消alias：<a href="http://c.biancheng.net/linux/alias.html" target="_blank" rel="noopener">指南</a></li>
<li>PHP即“<a href="https://baike.baidu.com/item/超文本" target="_blank" rel="noopener">超文本</a><a href="https://baike.baidu.com/item/预处理器" target="_blank" rel="noopener">预处理器</a>”，是一种通用<a href="https://baike.baidu.com/item/开源/246339" target="_blank" rel="noopener">开源</a><a href="https://baike.baidu.com/item/脚本语言/1379708" target="_blank" rel="noopener">脚本语言</a>。PHP是一种在服务器端执行的嵌入HTML文档的脚本语言。PHP 独特的语法混合了C、Java、Perl 以及 PHP 自创新的语法，它可以比 CGI 或者 Perl 更快速的执行动态网页，主要适用于<a href="https://baike.baidu.com/item/Web/150564" target="_blank" rel="noopener">Web</a>开发领域。</li>
</ul>
<h4 id="（三）图"><a href="#（三）图" class="headerlink" title="（三）图"></a>（三）图</h4><ol>
<li>拓扑排序</li>
</ol>
<ul>
<li>一个有向无环图可以有<strong>一个或多个</strong>拓扑排序序列。</li>
<li>判断有向图是否有环的两种方法：(1)拓扑排序 (2)DFS</li>
</ul>
<ol start="2">
<li><p>五大常用算法</p>
<ol>
<li>分冶法</li>
</ol>
<p>分治法所能解决的问题一般具有以下几个特征：</p>
<p>  1) 该问题的规模缩小到一定的程度就可以容易地解决</p>
<p>  2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p>
<p>  3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p>
<p>  4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</p>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p>
<p><strong>第二条特征是应用分治法的前提</strong>它也是大多数问题可以满足的，此特征反映了递归思想的应用；</p>
<p><strong>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征</strong>，如果<strong>具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法</strong>。</p>
<p><strong>第四条特征涉及到分治法的效率</strong>，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但<strong>一般用动态规划法较好</strong>。可用分冶法求解的一些经典问题：二分查找；快速排序。</p>
<ol start="2">
<li><p>动态规划</p>
<p>(1)  最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
<p>(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>(3) 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。</p>
</li>
</ol>
<p>递归常常用于分冶算法和动态规划算法中。</p>
<ol start="3">
<li>贪心算法</li>
</ol>
<p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。</p>
<p>从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的地求得更好的解。当达到算法中的某一步不能再继续前进时，算法停止。该算法存在问题：</p>
<ul>
<li><p>不能保证求得的最后解是最佳的；</p>
</li>
<li><p>不能用来求最大或最小解问题；</p>
</li>
<li><p>只能求满足某些约束条件的可行解的范围。</p>
</li>
</ul>
<p><strong>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</strong>贪心算法和动态规划的区别：</p>
<ul>
<li><p>贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解则不作保留；动态规划：全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有的局部最优解 。求一个问题的最优解相当于遍历所有的子集来找最优解，但是这样解随着解空间的维度成指数增长，动态规划其实就是一种遍历，但是他是带备忘录的遍历，我前面算到的子问题，到这儿我不在计算，我直接调用之前保存的值，这样就节省了大量的时间。</p>
</li>
<li><p>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常自顶向下的方式进行。</p>
</li>
<li><p>根据以上两条可以知道，贪心不能保证求得的最后解是最佳的，一般复杂度低；而动态规划本质是穷举法，可以保证结果是最佳的，复杂度高。</p>
</li>
</ul>
<ol start="4">
<li>回溯法</li>
</ol>
<p>在包含问题的所有解的解空间树中，按照<strong>深度优先搜索的策略</strong>，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>
<p>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p>
<p>而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>
<ol start="5">
<li>分支界限法</li>
</ol>
<p><strong>回溯法以深度优先的方式搜索解空间树T</strong>，而<strong>分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T</strong>。</p>
<p> 分支限界法的<strong>搜索策略是</strong>：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</p>
</li>
</ol>
<ol start="3">
<li>最小生成树-Prim算法和Kruskal算法</li>
</ol>
<p>a. 最小生成树</p>
<p>生成树是连通图的<strong><em>\</em>最小连通子图**</strong>。所谓最小是指：若在树中任意增加一条边，则将出现一个回路；若去掉一条边，将会使之变成非连通图。按照该定义，<strong>n个顶点的连通网络的生成树有n个顶点，n-1条边</strong>。生成树各边的权值总和称为生成树的权，<strong><em>\</em>权最小的生成树称为最小生成树**</strong>。常见的构造最小生成树的方法有Prim算法和Kruskal算法。</p>
<p>b. Prim算法：选取与当前节点连接的权值最小边</p>
<p>c. Kruskal算法：所有边按权值从小到大排序，依次选取不使最小生成树存在回路的最小权值边</p>
<ol start="4">
<li>最短路径-Dijkstra算法和Floyd算法：<a href="https://www.jianshu.com/p/92e46d990d17" target="_blank" rel="noopener">具体代码参考</a></li>
</ol>
<p>a. Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。注意该算法要求图中不存在负权边。</p>
<p>主要思想：通过“边”来松弛v1顶点到其余各个顶点的路程。</p>
<p>b. Floyd算法</p>
<p><strong>Floyd-Warshall算法</strong>（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd算法是一个经典的动态规划算法。</p>
<h4 id="（四）IO库"><a href="#（四）IO库" class="headerlink" title="（四）IO库"></a>（四）IO库</h4><ol>
<li><p>当操作符改变流的格式状态时，通常改变后的状态对所以后续IO都生效。setw类似endl不改变输出流的内部状态，只决定下一个输出的大小。</p>
</li>
<li><p>操作符hex(0x)、oct(0)、dec只影响整型运算对象，浮点型的表示形式不受影响。使用nouppercase、noshoubase和dec来重置流状态。</p>
</li>
<li><p><code>showbase</code>:当打印整型值时显示进制</p>
<p><code>ios::internal</code>:数值的符号位在域宽内左对齐,数值右对齐,中间由填充字符填充 </p>
<p><code>setfill()</code>：允许一个字符替代默认的字符填补空白</p>
<p><code>setbase</code>：将整数设置为b进制</p>
</li>
<li><p><code>cout.setf()</code>的作用是通过设置格式标志来控制输出形式；<code>cin&gt;&gt;noskipws</code>设置<code>cin</code>读取空白符;</p>
<p><code>cin&gt;&gt;skipws</code>将<code>cin</code>恢复到默认状态，丢弃空白符</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf ( <span class="built_in">std</span>::ios::hex, <span class="built_in">std</span>::ios::basefield );<span class="comment">//set hex as the basefield</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf ( <span class="built_in">std</span>::ios::showbase );      <span class="comment">//activate showbase</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">100</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//输出0x100</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.unsetf ( <span class="built_in">std</span>::ios::showbase );   <span class="comment">//deactivate showbase</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">100</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//输出100</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>未格式化输出中<code>is.get()</code>将is的下一个字节作为int返回，头文件cstdio定义了一个名为EOF的const，用来检测返回的值是否是文件末尾，而不必记忆表示文件尾的实际数值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;<span class="comment">//使用一个int,而不是char来保存get()的返回值,否则循环可能永远不会停止，循环也可能会在遇见'\377'的字符提前终止（-1转换为一个singed char会得到'\377'）</span></span><br><span class="line"><span class="comment">//循环读取并输出输入中的所有数据</span></span><br><span class="line"><span class="keyword">while</span>((ch=<span class="built_in">cin</span>.<span class="built_in">get</span>())!=EOF)</span><br><span class="line">    <span class="built_in">cout</span>.<span class="built_in">put</span>(ch);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>istream和ostream类通常不支持随机访问，只有fstream、sstream支持。</li>
</ol>
<p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/seekgseekp.png" alt="随机访问标记"></p>
<h4 id="（五）搜狗"><a href="#（五）搜狗" class="headerlink" title="（五）搜狗"></a>（五）搜狗</h4><ol>
<li>STL : std::map/std::set std::unordered_map/std::unordered_set结构 </li>
</ol>
<p>std::map:红黑树，自动排序，稳定查找插入删除时间复杂度O(lgn)，空间占用低，(但是因为红黑树每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间）</p>
<p>std::unordered_map:哈希表，无序，快速查找插入删除，insert/find/erase的平均时间复杂度是O(1)，但是最坏复杂度是O(N)，空间占用高，哈希表建立比较耗费时间，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表地址顺序从前往后依次遍历的</p>
<p>存储小对象，内存消耗从小到大依次是：vector &gt;&gt; map &gt;&gt; unordered_map;当存储的对象增大时，vector的优势变得并不明显。因为随着对象增大，用于存储对象的空间所占的比例越来越大。因此单从内存消耗的角度来看，当存储的是小对象时，vector占很大的优势。但是，当存储的对象本身大小增大时，它的优势变得不再那么明显。</p>
<ol start="2">
<li>顺序容器</li>
</ol>
<p>vector:可变大小数组，支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢，vector插入insert删除erase时间复杂度均是O(n)</p>
<p>deque:双端队列，支持快速随机访问。在头尾部位置插入/删除速度很快</p>
<p>list:双向链表。支持双向顺序访问，在链表任何位置进行插入/删除操作速度都很快</p>
<p>forward_list:单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快</p>
<p>array:固定大小数组，支持快速随机访问。不能添加或删除元素</p>
<p>string:与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快</p>
<p>除固定大小的array外，其他容器都提供高效、灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器大小。string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入和删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。而且添加一个元素有时可能还需要分配额外的存储空间。在这种情况下，每个元素必须都移动到新的存储空间中。</p>
<p>list和forward_list两个容器添加和删除操作都很快，但是不支持元素的随机访问，为了访问一个元素，只能遍历整个容器，与vector、deque、array相比，这两个容器的额外内存开销很大。</p>
<ol start="3">
<li>指针大小由当前CPU运行模式的寻址位数决定</li>
</ol>
<p>32位处理器上32位操作系统的32位编译器，指针大小4字节。<br>32位处理器上32位操作系统的16位编译器，指针大小2字节。<br>32位处理器上16位操作系统的16位编译器，指针大小2字节。<br>16位处理器上16位操作系统的16位编译器，指针大小2字节。</p>
<p>这从结果看起来指针的大小和编译器有关？？</p>
<p>　　实际不是这样的，有这样的结果是因为以上几种情况，处理器当前运行模式的寻址位数是不一样的，如下：</p>
<p>　Intel 32位处理器32位运行模式，逻辑寻址位数32，指针也就是32位，即4个字节<br>　Intel 32位处理器16位虚拟机运行模式，逻辑寻址位数16，指针也就是16位，即2个字节</p>
<p>编译器的作用是根据目标硬件（即CPU）的特性将源程序编译为可在该硬件上运行的目标文件。如果一个编译器支持某32位的CPU，那么它就可以将源程序编译为可以在该CPU上运行的目标文件。该源程序中指针大小也会被编译器根据该CPU的寻址位数（如32位）编译选择为4字节。</p>
<ol start="4">
<li>访问一个网页的全过程：<a href="https://blog.csdn.net/u012862311/article/details/78753232" target="_blank" rel="noopener">参考</a></li>
</ol>
<ul>
<li><p>域名解析成IP地址（搜索浏览器自身缓存，没有的话向DNS服务器发出解析请求）；</p>
</li>
<li><p>与目的主机进行TCP连接（<a href="[https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/5111559](https://baike.baidu.com/item/三次握手/5111559)">三次握手</a>）；</p>
</li>
<li><p>发送与收取数据（浏览器与目的主机开始HTTP访问过程）；</p>
</li>
<li><p>与目的主机断开TCP连接（<a href="https://blog.csdn.net/O9A0MA/article/details/90731748" target="_blank" rel="noopener">TCP四次挥手</a>）；</p>
</li>
</ul>
<ol start="5">
<li>OSI模型：应用层（HTTP） 表示层（SSL握手协议：加密） 会话层（SSL记录协议）  传输层（TCP/UDP端到端 段Segment 数据报文）  网络层 (IP数据包Packet)  数据链路层(逻辑链路控制子层（LLC）媒体访问控制子层（MAC）数据帧Frame)   物理层(物理介质Bit)</li>
</ol>
<p><strong>消息（message）：</strong>是指起始点和目的地都在网络层以上（经常在<strong>应用层</strong>）的信息单元。</p>
<p>TCP/UDP五层模型：应用层  传输层  网络层  数据链路层  物理层</p>
<ol start="5">
<li>编程内存的基本构成（堆、存储区别）</li>
</ol>
<p><strong>1、内存</strong></p>
<p>（1）静态内存（静态分配）：发生在程序编译和链接阶段，存在于程序的整个生命周期，内存大小固定，不占用CPU资源</p>
<ul>
<li>.bss段：存放未初始化的全局变量和static静态变量</li>
<li>.data段（全局初始化区）：存放初始化的全局变量</li>
<li>常量存储区</li>
<li>.txt段（代码区）：存放程序代码</li>
</ul>
<p>注意：</p>
<p>​    代码区：存放函数体的二进制代码</p>
<p>​    常量存储区：常量字符串就是放在这里的。 程序结束后由系统释放</p>
<p>​    函数指针指向Code区，是程序运行的指令代码，数据指针指向Data,Heap,Stack    区，是程序依赖以运行的各种数据</p>
<p>​    在文件作用域声明inline函数默认为static存储类型,const常量默认为static存储，    如果加上extern，则为外部存储类型</p>
<p>（2）动态内存（动态分配）：发生在程序调入和执行阶段，根据程序的需要分配和释放，其大小可变，占用CPU资源</p>
<ul>
<li><p>堆：<strong>链表结构，程序通过调用malloc和new分配，调用free和delete释放；堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址</strong>。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。<strong>堆中的存储内容一般是在堆的头部用一个字节存放堆的大小</strong>。堆中的具体内容有程序员安排。</p>
</li>
<li><p>栈：<strong>线性结构，由编译器分配与释放</strong>（当我们要通过某种手段在堆内存上分配一段空间后，我们需要一个变量作为左值来接受这块内存，这个作为左值的变量就是分配在栈空间的）；<strong>函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放</strong>，函数退出时，其占用内存被收回；进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。一个堆栈可以通过“基地址”和“栈顶”地址来描述。<strong>栈是向低地址扩展的数据结构，是一块连续的内存的区域</strong>。栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。<strong>栈中的存储内容</strong>在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是<strong>函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量</strong>。注意静态变量是不入栈的。当本次函数调用结束后，<strong>局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址</strong>，也就是主函数中的下一条指令，程序由该点继续运行。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp </span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;  <span class="comment">//a存储在全局初始化区 ，静态内存，0存储在常量区随程序结束而释放</span></span><br><span class="line"><span class="keyword">char</span> *p1;  <span class="comment">//全局未初始化区 ，静态内存</span></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">4</span>);  <span class="comment">//p存储在全局初始化区，静态内存，分配得来的4存储在堆区</span></span><br><span class="line">main() </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> b;  <span class="comment">//栈 </span></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">"abc"</span>;  <span class="comment">//栈 </span></span><br><span class="line"><span class="keyword">char</span> *p2; <span class="comment">// 栈 </span></span><br><span class="line"><span class="keyword">char</span> *p3 = <span class="string">"123456"</span>;  <span class="comment">//"123456\0"在常量区（不同于数组数据可存储在数组里），静态内存，p3在栈上。 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>； <span class="comment">//全局（静态）初始化区 </span></span><br><span class="line">p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); </span><br><span class="line">p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>); </span><br><span class="line"><span class="comment">//分配得来的10和20字节的区域就在堆区。 </span></span><br><span class="line"><span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>);  <span class="comment">//"123456\0"放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 </span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">char</span>* p = <span class="string">"Hello World1"</span>;</span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">"Hello World2"</span>;</span><br><span class="line">p[<span class="number">2</span>] = <span class="string">'A'</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">char</span>* p1 = <span class="string">"Hello World1"</span>; </span><br><span class="line"><span class="comment">//这个程序是有错误的，错误发生在p[2] = 'A'这行代码处，为什么呢，是变量p和变量数组a都存在于栈区的（任何临时变量都是处于栈区的，包括在main（）函数中定义的变量）。但是，数据“Hello World1”和数据“Hello World2”是存储于不同的区域的。因为数据“Hello World2”存在于数组中，所以，此数据存储于栈区，对它修改是没有任何问题的。因为指针变量p仅仅能够存储某个存储空间的地址，数据“Hello World1”为字符串常量，所以存储在静态存储区。虽然通过p[2]可以访问到静态存储区中的第三个数据单元，即字符‘l’所在的存储的单元。但是因为数据“Hello World1”为字符串常量，不可以改变，所以在程序运行时，会报告内存错误。并且，如果此时对p和p1输出的时候会发现p和p1里面保存的地址是完全相同的。换句话说，在数据区只保留一份相同的数据。</span></span><br></pre></td></tr></table></figure>

<p><strong>2、malloc</strong></p>
<ul>
<li>malloc calloc realloc的区别</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">realloc</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">unsigned</span> newsize)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> numElements, <span class="keyword">size_t</span> sizeOfElement)</span></span>;</span><br></pre></td></tr></table></figure>

<p>都在stdlib.h函数库内，它们的返回值都是请求系统分配的地址,如果请求失败就返回NULL.<br>  (1)函数malloc()<br>    在内存的动态存储区中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度，返回该区域的首地址.<br>  (2)函数calloc()<br>    与malloc相似,参数sizeOfElement为申请地址的单位元素长度,numElements为元素个数，即在内存中申请numElements*sizeOfElement字节大小的连续地址空间.<br>  (3)函数realloc()<br>给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度.如果在该存储区后有足够的空间可供扩充，则可在原存储区位置上向高地址方向扩充，并返回传送给它的同样的指针值。如果在原存储区后没有足够的空间，则realloc分配另一个足够大的存储区，将现存的512个元素数组的内容复制到新分配的存储区。因为这种存储区可能会移动位置，所以不应当使用任何指针指在该区中。注意，realloc的最后一个参数是存储区的newsize(新长度)，不是新、旧长度之差。作为一个特例，若ptr是一个空指针，则realloc的功能与malloc相同，用于分配一个指定长度newsize的存储区。</p>
<ul>
<li>malloc和free的操作原则</li>
</ul>
<blockquote>
<p>1) 配对使用，配对使用，避免内存泄漏和多重释放（C语言提供了malloc和free两个系统函数，完成对堆内存的申请和释放。而C++则提供了两个关键字new和delete）。</p>
<p>2) 尽量在同一层上使用，不要像上面那种，malloc在函数中，而free在函数外。最好在同一调用层上使用这两个函数。</p>
<p>3) malloc分配的内存一定要初始化。free后的指针一定要设置为NULL。 </p>
<p>注意：</p>
<p>new/delete是关键字，效率高于malloc和free。<br>new/delete 主要是用在类对象的申请和释放。申请的时候会调用构造器完成初始化，释放的时候，会调用析构器完成内存清理。</p>
</blockquote>
<p><strong>3、new和malloc的区别</strong></p>
<ul>
<li><p>属性</p>
<p>new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持。</p>
</li>
<li><p>参数</p>
<p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p>
</li>
<li><p>返回类型</p>
<p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p>
</li>
<li><p>自定义类型</p>
</li>
</ul>
<p>new做两件事：分配内存和调用类的构造函数，new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。</p>
<pre><code>delete：调用类的析构函数和释放内存。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。

而malloc和free只是分配和释放内存。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</code></pre><ul>
<li><p>重载</p>
<p>  C++允许重载new/delete操作符，malloc不允许重载。</p>
</li>
<li><p><strong>内存区域</strong></p>
</li>
</ul>
<p>　　new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</p>
<p><strong>PS:</strong></p>
<p> 在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区；</p>
<p>在C中，C内存区分为4个区堆、栈、全局/静态存储区、常量存储区</p>
<ul>
<li><p>分配失败</p>
<p>  new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p>
</li>
<li><p>内存泄漏</p>
<p>  内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc确不可以。</p>
</li>
</ul>
<ol start="6">
<li><p>快速排序  堆排序</p>
</li>
<li><p>给你100个数找出最大的前五十个</p>
</li>
</ol>
<ul>
<li>partition 时间复杂度O(n)</li>
<li>最大堆 时间复杂度O(nlgk)  (海量数据)</li>
<li>mutiset 时间复杂度O(n)空间复杂度O(n)</li>
</ul>
<ol start="8">
<li>笔试题：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">提示：优先写源码，源码有难度可以写伪代码 或 思路。</span><br><span class="line">要求：c或c++, 尽量使得时间复杂度较低，写出完整代码。</span><br><span class="line">题目：查找元素element在非降序正整数数组a中的最左下标位置,数组大小为<span class="built_in">size</span>.</span><br><span class="line">例子：元素<span class="number">2</span>在数组a[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">21</span>]的最左位置为<span class="number">2.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchRange</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"><span class="keyword">int</span> middle=(right-left)/<span class="number">2</span>+left;</span><br><span class="line"><span class="keyword">if</span>(a[middle]==target)&#123;</span><br><span class="line">middle-=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(a[middle]==target)midlle--;</span><br><span class="line"><span class="keyword">return</span> middle+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[middle]&lt;target)</span><br><span class="line">left=middle+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right=middle<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_pos</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> element)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">size</span>==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">int</span> leftIndex=searchBoundEqual(a,<span class="number">0</span>,<span class="built_in">size</span><span class="number">-1</span>,element);</span><br><span class="line">      <span class="keyword">if</span>(leftIndex==<span class="built_in">size</span>||a[leftIndex]!=target)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">return</span> leftIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">find</span>(a,a+<span class="built_in">size</span>,target);</span><br></pre></td></tr></table></figure>

<h4 id="（六）手写代码"><a href="#（六）手写代码" class="headerlink" title="（六）手写代码"></a>（六）手写代码</h4><p>一个数组中有多个整数， 其中有两个重复的数字，如何找出来，考虑一下时间复杂度和空间复杂度<br> 给两个字符串A和B，找出A对于B的最长前缀。<br> 单链表逆序<br> 一个链表的连续区间和最大值，及其对应区<br> 数组中，连续和最大的区间<br> 判断一个链表是否有环，并确定环的位置，如何确定两个链表是否有相同的部分<br> 写个小程序，一个数组，长100，里边乱序分布数字1-100，在数组中随机挑选一个位置的数字，将其替换为-1，如何判断，被替换掉的数字是多少？<br> 跳台阶，一次跳1个，也可以跳2个，问，n个台阶有多少种跳法</p>
<p>dfs bfs dp迷宫</p>
<p>最小圆覆盖</p>
<p>1）任意选取距离最远两点p1、p2，以p1p2做直径画圆；</p>
<p>2）如果所有点都在圆内，则该圆即为包括所有点的最小圆；否则选取圆外一点距离圆心最远点pi,寻找覆盖pi和集合Di-1的最小圆<code>Di=MiniDiskWithPoints({p1，p2，p3......pi-1}，pi)</code>，循环第（2）步直到Di包括所有点，即得到最小包围圆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function MiniDiskWithPoints（P，q）</span><br><span class="line">Input：由平面上n个点构成的一个集合P，以及另外一个点q</span><br><span class="line">Output：在满足“边界穿过q”的前提下，P的最小包围圆</span><br><span class="line">    <span class="number">1.</span>令D1为对应于&#123;p1，q&#125;的最小包围圆</span><br><span class="line">    <span class="number">2.f</span><span class="keyword">or</span>   j ← <span class="number">2</span> to n</span><br><span class="line">    <span class="number">3.</span>   <span class="keyword">do</span> <span class="keyword">if</span>    pj ∈Dj<span class="number">-1</span></span><br><span class="line">    <span class="number">4.</span>      then    Dj ← Dj<span class="number">-1</span></span><br><span class="line">    <span class="number">5.</span>      <span class="keyword">else</span>    Dj ← MiniDiskWithPoints&#123;&#123;p1，p2,p3......pj<span class="number">-1</span>&#125;，pj，pi&#125;</span><br><span class="line">    <span class="number">6.</span><span class="keyword">return</span>    Dn</span><br><span class="line">Function MiniDiskWithPoints（P，q1，q2）</span><br><span class="line">Input：由平面上n个点构成的一个集合P，以及另外两个点q1，q2</span><br><span class="line">Output：在满足“边界穿过q1，q2”的前提下，P的最小包围圆</span><br><span class="line"><span class="number">1.</span>       令D0为对应于q1，q2的最小包围圆</span><br><span class="line"><span class="number">2.</span>       <span class="keyword">for</span>   k ← <span class="number">1</span> to n</span><br><span class="line"><span class="number">3.</span>            <span class="keyword">do</span> <span class="keyword">if</span>    pk∈Dk<span class="number">-1</span></span><br><span class="line"><span class="number">4.</span>                    then    Dk ← Dk<span class="number">-1</span></span><br><span class="line"><span class="number">5.</span>                    <span class="keyword">else</span>    Dk ← q1，q2和pk确定的圆</span><br><span class="line"><span class="number">6.</span>        <span class="keyword">return</span>    Dn</span><br></pre></td></tr></table></figure>

<p>给定一个无序数组，求这个数组变为有序后相邻元素之差的最大值是多少，要求时间复杂度是O(n)</p>
<ul>
<li><p>方法一：排序，计算。时间复杂度O(nlgn)，空间复杂度O(1)</p>
</li>
<li><p>方法二：std::multiset，计算。时间复杂度O(n),空间复杂度O(n)</p>
</li>
<li><p>方法三：<a href="https://blog.csdn.net/weixin_38426554/article/details/95785743" target="_blank" rel="noopener">桶排序</a>。时间复杂度O(n),空间复杂度O(n)</p>
</li>
</ul>
<p>算法题给定一个长字符串zesfjjk和一个短字符串xsfjx，求短字符串在长字符串中出现的最长部分是什么？sfj</p>
<p><a href="https://blog.csdn.net/hackbuteer1/article/details/6686931" target="_blank" rel="noopener">最长公共子字符串</a></p>
<h4 id="（七）SAP"><a href="#（七）SAP" class="headerlink" title="（七）SAP"></a>（七）SAP</h4><ol>
<li>linux命令</li>
</ol>
<p>查找  vi  保存  修改权限</p>
<ol start="2">
<li>C语言和c++的区别</li>
</ol>
<ul>
<li>c++兼容c。区块（blocks）、语句（statements）、预处理器（preprocessors）、内置数据类型（build-in data types）、数组（arrays）、指针（pointers）等统统来源于c。</li>
<li>c仅支持面向过程，c++还支持面向对象：包含封装、继承、多态三大特性和虚函数、虚函数表指针、虚基类表指针等。</li>
<li>c++包含泛型编程、模板元编程。</li>
<li>c++包含STL。</li>
</ul>
<h4 id="（八）进程间的通信方式（IPC-inter-Process-Communication）"><a href="#（八）进程间的通信方式（IPC-inter-Process-Communication）" class="headerlink" title="（八）进程间的通信方式（IPC,inter-Process Communication）"></a>（八）进程间的通信方式（IPC,inter-Process Communication）</h4><p>同一主机中两个进程间的通信由操作系统决定，不同主机间的通信进程通过网络交换报文进行。</p>
<ol>
<li><p>信号：用于通知进程某个事件已经发生</p>
</li>
<li><p>管道：读写操作符合先进先出原则，对于两端的进程而言就是文件，向管道中写入数据时,linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。</p>
</li>
</ol>
<ul>
<li><p>无名管道pipe:半双工的通信方式，数据单向流动，只能在具有亲缘关系的进程间使用，从结构上看，无名管道没有文件路径名，不占用文件目录项，因此文件目录结构中的链表不适用于这种文件，它只是存在于打开文件结构中的一个临时文件，依附于进程临时存在。</p>
</li>
<li><p>命名管道FIFO:半双工，数据单向流动，允许无亲缘关系进程间的通信，FIFO是一种永久性的机制，它具有普通的UNIX系统文件名。在系统下可利用MKNOD命令建立永久的管道，除非刻意删除它，否则它将一直保持在系统中。</p>
</li>
<li><p><strong>联系</strong>：</p>
</li>
</ul>
<p>1) 通信数据只存在于内存缓冲页面中；</p>
<p>2) 都是半双工通信；</p>
<ul>
<li><strong>区别</strong>：</li>
</ul>
<ol>
<li><p>无名管道是无名的，有名管道是有名的；</p>
</li>
<li><p>无名管道只能用于父子进程或兄弟进程之间的通信，而有名管道可用于任意两进程之间通信；</p>
</li>
<li><p>无名管道是无形的，即无名管道的 inode 结构不是在磁盘上存储的，而是临时生成的，而有名管道的 inode 结点在磁盘上。</p>
</li>
<li><p>消息队列：消息的链表存放在内核中并由消息队列标识符标识，克服了信号传递信息少，管道只能承载无格式字节流以及缓冲器大小受限等缺点，但只有在内核重启时才能删除一个消息队列，内核重启也就是系统重启。</p>
</li>
<li><p>共享内存：最快的IPC方式，映射一段能被其他进程所访问的内存。往往与其他通信机制如信号两两配合使用，来实现进程间的同步和通信。</p>
</li>
<li><p>信号量Semaphore:信号量是一个计数器，可以用来控制多个进程对共享资源的访问。常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
</li>
<li><p>套接字Socket:套接字也是一种进程间通信机制，包括IPC 套接字（即 Unix 套接字）给予进程在相同设备（主机）上基于通道的通信能力；而网络套接字给予进程运行在不同主机的能力，因此也带来了网络通信的能力。IPC 套接字依赖于本地系统内核的支持来进行通信。网络套接字需要底层协议的支持，例如 TCP（传输控制协议）或 UDP（用户数据报协议），包括流套接字（TCP/IP）和数据报套接字（UDP/IP），利用三元组（<strong>ip地址，协议，端口</strong>）构成套接字；<a href="https://baike.baidu.com/item/传输层/4329536" target="_blank" rel="noopener">传输层</a>实现<a href="https://baike.baidu.com/item/端到端/8851783" target="_blank" rel="noopener">端到端</a>的通信，传输层连接的端点叫做套接字。</p>
</li>
<li><p>进程和线程</p>
</li>
</ol>
<ul>
<li><p>进程识别信息：表示哪台主机上的哪一个进程</p>
<ul>
<li>主机名称或地址：网络中的哪一个主机。因特网中，用IP地址标识（32位，全球唯一）。</li>
<li>进程的标识：主机中的哪一个进程。因特网中，采用端口号标识。<strong>创建一个新的网络应用程序时，必须分配一个新的端口号。不得重复</strong>。</li>
</ul>
</li>
<li><p>fork后操作系统会复制一个与父进程完全相同的子进程，两个进程共享代码空间，但数据空间相互独立，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别作不同的工作，也就是分岔了。这也是fork为什么叫fork的原因至于那一个最先运行，可能与操作系统（调度算法）有关，而且这个问题在实际应用中并不重要，如果需要父子进程协同，可以通过原语的办法解决。</p>
</li>
<li><p>fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别：</p>
<ol>
<li>fork  （）：子进程拷贝父进程的数据段，代码段<br>vfork （ ）：子进程与父进程共享数据段，<strong>子进程中对父进程变量的修改，会影响父进程</strong></li>
<li>fork （）父子进程的执行次序不确定<br>vfork 保证子进程先运行，在调用<code>exec()</code> 或<code>_exit()</code> 之前与父进程数据是共享的,在它调用<code>exec()</code>或<code>_exit()</code>之后父进程才可能被调度运行。</li>
<li>若vfork （）调用exec 或<code>_exit()</code> 之前子进程依赖于父进程的进一步动作，会导致死锁。</li>
</ol>
</li>
<li><p>进程和线程的区别</p>
<p>​         （1）进程是资源分配和调度的一个独立单元，而线程是CPU调度和分派的基本单元<br>​          （2）一个进程至少包括一个线程，并且同一个进程的所有线程共享整个进程的资源，因此线程执行时一般都要进行同步和互斥<br>​          （3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束<br>​          （4）线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的<br>​          （5）进程间通信IPC需要特别的方法，线程间可以直接读写进程数据段（如全局变量）来进行通信。</p>
</li>
<li><p>线程有什么是共享的什么是私有的</p>
</li>
</ul>
<p>线程共享的环境包括：</p>
<p>  1.进程代码段 </p>
<p>  2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯) </p>
<p>  3.进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p>
<p>线程独立的资源包括：</p>
<p>1.线程ID</p>
<p>2.寄存器组的值</p>
<p>由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。</p>
<p>3.线程的堆栈</p>
<p>堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。</p>
<p>4.线程的错误返回码</p>
<p>由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。</p>
<p>5.线程的信号屏蔽码</p>
<p>6.线程的优先级</p>
<p>注：线程有自己的私有属性线程控制块TCB，进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志。</p>
<ul>
<li>线程同步</li>
</ul>
<p>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。</p>
<p>内核模式下的方法有：事件，信号量，互斥量。</p>
<p>1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。<br>2、互斥量:为协调共同对一个共享资源的单独访问而设计的。<br>3、信号量:为控制一个具有有限数量用户资源而设计。<br>4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。</p>
<ul>
<li><p>进程的几种状态？</p>
<p>（1）run（运行状态）：正在运行的进程或在等待队列中等待的进程，等待的进程只要一得到cpu就可以运行<br> （2）Sleep（可中断休眠状态）：相当于阻塞或在等待的状态<br> （3）D（不可中断休眠状态）：在磁盘上的进程<br> （4）T（停止状态）：这种状态无法直观的看见，因为是进程停止后就释放了资源，所以不会留在linux中<br> （5）Z（僵尸状态）：子进程先于父进程结束，但父进程没有调用wait或waitpid来回收子进程的资源，所以子进程就成了僵尸进程，如果父进程结束后仍然没有回收子进程的资源，那么1号进程将回收</p>
</li>
<li><p>线程间通信：由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）。</p>
</li>
<li><p>进程间的通信则不同，它的数据空间的独立性决定了它的通信相对比较复杂，需要通过操作系统。以前进程间的通信只能是单机版的，现在操作系统都继承了基于套接字（socket）的进程间的通信机制。这样进程间的通信就不局限于单台计算机了，也可以实现不同操作系统间的网络通信，eg.windows和Linux操作系统通过Socket进行进程间通信。</p>
</li>
<li><p>windows进程通信</p>
</li>
</ul>
<p><em>标准的Windows</em>进程间通信方法有三种：匿名管道、命名管道（又叫<em>FIFO</em>，命名管道可以控制读消息的长度，一个命名管道可以有多个实例，具体通信还是一对一）、邮槽（<em>MailSlot</em>）。共享内存也可用于windows进程通信，但因为其实是<em>Windows</em>“内存映射文件”的一个特殊用法，所以不算作标准的windows进程间通信方法。</p>
<table>
<thead>
<tr>
<th align="center">对比点</th>
<th align="center">匿名管道</th>
<th align="center">命名管道</th>
<th align="center">邮槽</th>
<th></th>
<th align="center">共享内存</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">消息格式</td>
<td align="center">字符</td>
<td align="center">二进制</td>
<td align="center">数据包</td>
<td></td>
<td align="center">-</td>
<td></td>
</tr>
<tr>
<td align="center">工作模式</td>
<td align="center">半双工</td>
<td align="center">全双工</td>
<td align="center">单向</td>
<td></td>
<td align="center">双向</td>
<td></td>
</tr>
<tr>
<td align="center">访问模式</td>
<td align="center">只能在一台机器上</td>
<td align="center">可以跨网络</td>
<td align="center">可以跨网络</td>
<td></td>
<td align="center">只能在一台机器上</td>
<td></td>
</tr>
<tr>
<td align="center">通信模式</td>
<td align="center">一对一，父子进程用</td>
<td align="center">一对多，不同进程均可用</td>
<td align="center">广播机制</td>
<td></td>
<td align="center">-</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>windows命名管道和Linux命名管道的区别</li>
</ul>
<table>
<thead>
<tr>
<th align="center">对比点</th>
<th align="center">Linux命名管道</th>
<th align="center">Windows命名管道</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">消息格式</td>
<td align="center">字节流</td>
<td align="center">二进制</td>
<td align="center">windows更牛</td>
</tr>
<tr>
<td align="center">工作模式</td>
<td align="center">半双工</td>
<td align="center">全双工</td>
<td align="center">windows更牛</td>
</tr>
<tr>
<td align="center">访问模式</td>
<td align="center">只能在一台机器上</td>
<td align="center">可以跨网络</td>
<td align="center">windows更牛</td>
</tr>
</tbody></table>
<ul>
<li>windows线程通信</li>
</ul>
<p>windows下，一个典型的线程拥有自己的堆栈、寄存器（包括程序计数器PC，用于指向下一条应该执行的指令在内存中的位置），而代码段、数据段、打开文件这些进程级资源是同一进程内多个线程所共享的。因此同一进程的不同线程可以很方便的通过全局变量（数据段）进行通信，使用多线程相对于多进程来说有很多优点：</p>
<ul>
<li>① 无需跨进程边界；</li>
<li>② 程序逻辑和控制方式简单；</li>
<li>③ 所有线程可以直接共享内存和变量等；</li>
<li>④ 线程方式消耗的总资源比进程方式好；</li>
</ul>
<p>windows多线程通信的方法主要有三种：</p>
<p><strong>1.全局变量</strong></p>
<p>由于同一进程下的线程之间共享数据空间。当需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，来告诉编译器这个全局变量是“易变”（更直接的讲是“直接存取原始内存地址”，更明确的说是不要编辑器去读缓存中的数据，而是直接从内存中获取变量的值）的，让编译器不要对这个变量进行优化。</p>
<p><strong>2.Message消息机制</strong><br>常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，<br>PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。</p>
<p><strong>3.CEvent对象</strong></p>
<p>CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。</p>
<ul>
<li>Linux线程通信</li>
</ul>
<p>线程间无需特别的手段进行通信，因为线程间可以共享数据结构，也就是一个全局变量可以被两个线程同时使用。不过要注意的是线程间需要做好同步，一般用mutex。</p>
<ol start="22">
<li>死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？<pre><code>（1）相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态
 （2）系统资源不足、相互竞争资源、请求资源顺序不当
 （3）互斥、不可抢占、循环等待、请求与保持
 （4）因为互斥是不可改变的，所以只能破坏其他三个条件中的一个来解除死锁，方法：剥夺资源、杀死其中一个线程</code></pre></li>
</ol>
<h4 id="（九）Windows内存管理方式：段存储、页存储、段页存储"><a href="#（九）Windows内存管理方式：段存储、页存储、段页存储" class="headerlink" title="（九）Windows内存管理方式：段存储、页存储、段页存储"></a>（九）Windows内存管理方式：段存储、页存储、段页存储</h4><ol>
<li>什么是虚拟内存？</li>
</ol>
<p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还可以通过覆盖或者把处于不活动状态的程序以及它们的数据全部交换到外部磁盘存储器上临时存储。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。</p>
<p>对于32位的Linux操作系统，系统为每个进程分配4G的虚拟内存。<img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95%5Clinux32%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt="如图"></p>
<p>虚拟内存中，允许将一个作业分多次调入内存。釆用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：</p>
<ul>
<li>请求分页存储管理。</li>
<li>请求分段存储管理。</li>
<li>请求段页式存储管理。 </li>
</ul>
<p>不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面： </p>
<ul>
<li><p>一定容量的内存和外存。 </p>
</li>
<li><p>页表机制（或段表机制），作为主要的数据结构。 </p>
</li>
<li><p>中断机制，当用户程序要访问的部分尚未调入内存，则产生中断。 </p>
</li>
<li><p>地址变换机制，逻辑地址到物理地址的变换。</p>
</li>
</ul>
<ol start="2">
<li>一致性哈希？渐进性哈希？</li>
</ol>
<p>一致性哈希是一种特殊的哈希算法，目的是解决分布式缓存的问题。在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式<a href="https://baike.baidu.com/item/哈希表/5981869" target="_blank" rel="noopener">哈希表</a>( Distributed Hash Table，DHT) 中存在的动态伸缩等问题。</p>
<p>  首先，对存储节点的哈希值进行计算，其将存储空间抽象为一个环，将存储节点配置到环上。环上所有的节点都有一个值。其次，对数据进行哈希计算，按顺时针方向将其映射到离其最近的节点上去。当有节点出现故障离线时，按照算法的映射方法，受影响的仅仅为环上故障节点开始逆时针方向至下一个节点之间区间的数据对象，而这些对象本身就是映射到故障节点之上的。当有节点增加时，比如，在节点A和B之间重新添加一个节点H，受影响的也仅仅是节点H逆时针遍历直到B之间的数据对象，将这些重新映射到H上即可，因此，当有节点出现变动时，不会使得整个存储空间上的数据都进行重新映射，解决了简单哈希算法增删节点，重新映射所有数据带来的效率低下的问题。</p>
<p>渐进性哈希</p>
<p>  当hash表满员时（或负载因子高于阈值时）会进行rehash,也就是重新调整空间大小，并拷贝原来的数据。这里rehash就是优化效率的关键。例如假设有1w个元素，rehash时要拷贝1w元素到新的空间，这样势必会成为很大的负担。<br>  redis的数据库使用字典来作为底层实现的，对数据库的增删查改操作也是构建在对字典的操作之上。redis的字典使用hash表作为底层实现。</p>
<p>  redis作为一个广泛使用的内存数据库，时间和空间效率都是至关重要的。（redis的根本就是一个大的hashmap，所以对hashmap的优化十分重视）</p>
<p>  redis采用渐进式rehash来解决这个问题。</p>
<p>  何为渐进式rehash？就是把拷贝节点数据的过程平摊到后续的操作中，而不是一次性拷贝。所谓平摊到后续的操作中，就是对节点操作，例如再次插入，查找，删除，修改时都会进行拷贝。</p>
<ol start="3">
<li>友元函数注意事项</li>
</ol>
<p>1）必须在类的说明中说明友元函数，说明时以关键字friend开头，后跟友元函数的函数原型，友元函数的说明可以出现在类的任何地方，包括在private和public部分；<br>2）注意友元函数不是类的成员函数，所以友元函数的实现和普通函数一样，在实现时不用”::”指示属于哪个类，只有成员函数才使用”::”作用域符号；<br>3）友元函数不能直接访问类的成员，只能访问对象成员，<br>4）友元函数可以访问对象的私有成员，但普通函数不行；<br>5）调用友元函数时，在实际参数中需要指出要访问的对象，<br>6）友元的声明只能出现在类定义的内部（最好在类定义开始或者结束前的位置集中声明友元），仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，必须在友元声明之外再转名对函数进行一次声明。每个类负责控制自己的友元类或友元函数，友元关系不存在传递性。类与类之间的友元关系不能继承.</p>
<ol start="4">
<li>模板</li>
</ol>
<p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>
<p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>
<h4 id="（十）计算机网络"><a href="#（十）计算机网络" class="headerlink" title="（十）计算机网络"></a>（十）计算机网络</h4><ol>
<li>HTTP 与 HTTPS 区别</li>
</ol>
<ul>
<li>http是超文本传输协议，信息是明文传输，未加密；https则是具有安全性的ssl加密传输协议。</li>
<li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 根证书，一般免费证书较少，因而需要一定费用。</li>
<li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li>
<li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li>
<li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li>
</ul>
<ol start="2">
<li>客户端在使用HTTPS方式与Web服务器通信步骤</li>
</ol>
<p>　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p>
<p>　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p>
<p>　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p>
<p>　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p>
<p>　　（5）Web服务器利用自己的私钥解密出会话密钥。</p>
<p>　　（6）Web服务器利用会话密钥加密与客户端之间的通信。</p>
<p><img src="%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95%5Chttps.png" alt="https与web服务器通信步骤"></p>
<ol start="33">
<li>怎么理解http协议的无连接无状态</li>
</ol>
<p>HTTP协议又称超文本传输协议；是OSI模型中的第七层应用程中协议；具有以下特点：<br> <strong>1、支持客户/服务器模式;<br> 2、简单快速;<br> 3、灵活;<br> 4、无连接;<br> 5、无状态；</strong><br> <strong>无连接：</strong>指的是每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接；这种方式有利于节省传输时间；然后随着互联网的发展，一台服务器同一时间处理的请求越来越多，如果依然采用原来的方式，将会在建立和断开连接上花费大部分时间。为了避免这一劣势，针对http无连接，人们设计了非持久连接和持久连接。实际上关于http协议非持久连接和持久连接是针对tcp协议的。</p>
<ul>
<li><p>非持久连接：请求一个HTTP请求/响应需要的总时间为客户端发出建立连接和发生请求报文+服务器传输HTML文件的时间。</p>
</li>
<li><p>持久连接：服务器在发送响应后，保持该TCP连接打开。在相同的客户机与服务器之间的后续请求和响应报文通过相同的连接进行传送。不需要再次建立tcp连接 ，但是由于所有的连接都是串行的，当某一个请求阻塞时就会导致同一条连接的后续请求被阻塞。为了解决这一问题：提出了pipellining的概念；客户端发起一次请求时不必等待响应便直接发起第二个请求；服务端按照请求的顺序一次返回结果；<br><strong>SPDY和HTTP/2:multiplexing：</strong>多路复用技术出现；能够让多个请求和响应的传输完全混杂在一起进行；通过streamID来互相区别；</p>
</li>
</ul>
<p> PS:HTTP借助于底层的TCP虚拟连接，HTTP协议本身无需连接；就好比A和B打电话，A和B是借助于底层的简化先连接交换信息；但是A和B本身无需连接；</p>
<p> <strong>无状态：</strong>是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。言外之意是说http协议没法保存客户机信息，也就没法区分每次请求的不同之处。关于http无状态阻碍了交互式应用程序的实现。比如记录用户浏览哪些网页、判断用户是否拥有权限访问等。于是，两种用于保持HTTP状态的技术就应运而生了，一个是Cookie，而另一个则是Session。</p>
<ol start="3">
<li><p>cookie和session的区别</p>
<p>1、Cookie和Session都是会话技术，Session是运行在服务器端，用来跟踪用户的状态，数据可以保存在集群、数据库、文件中；Cookie是运行在客户端，用来记录用户的一些信息，也是实现Session的一种方式。</p>
<p>2、Cookie有大小限制以及浏览器存储cookie的个数也有限制，Session是没有大小限制和存储个数与服务器的内存大小有关。</p>
<p>3、Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。</p>
<p>4、Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p>
</li>
<li><p>共享session</p>
</li>
</ol>
<ul>
<li>基于数据库的Session共享</li>
<li>基于NFS共享文件系统</li>
<li>基于memcached 的session，如何保证 memcached 本身的高可用性？</li>
<li>基于cookie 进行session共享</li>
<li>基于resin/tomcat web容器本身的session复制机制</li>
<li>基于TT/Redis 或 jbosscache 进行 session 共享。</li>
</ul>
<ol start="5">
<li>http状态码分类</li>
</ol>
<table>
<thead>
<tr>
<th>分类</th>
<th>分类描述</th>
</tr>
</thead>
<tbody><tr>
<td>1**</td>
<td>信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2**</td>
<td>成功，操作被成功接收并处理</td>
</tr>
<tr>
<td>3**</td>
<td>重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4**</td>
<td>客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td>服务端错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<ol start="6">
<li>http</li>
</ol>
<ul>
<li><p><strong>客户端发送一个HTTP请求到服务器的请求消息包括请求行（request line）、请求头部（header）、空行和请求数据四个部分</strong></p>
</li>
<li><p><strong>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文</strong></p>
</li>
<li><p>URL由4部分组成：协议、主机、端口、路径;一般语法格式为(带方括号[]的为可选项,<a href="https://baike.baidu.com/item/URL格式/10056474" target="_blank" rel="noopener">参考</a>)：</p>
<p>protocol :// hostname[:port] / path / [;parameters] [?query] [#fragment]</p>
</li>
</ul>
<ol start="7">
<li>get和post的区别](<a href="https://blog.csdn.net/qq_38182125/article/details/89071899" target="_blank" rel="noopener">https://blog.csdn.net/qq_38182125/article/details/89071899</a>)</li>
</ol>
<h4 id="（十一）百度"><a href="#（十一）百度" class="headerlink" title="（十一）百度"></a>（十一）百度</h4><ol>
<li><p>TCP/UDP传输的应用  TCP/UDP拥塞机制  拥塞窗口</p>
</li>
<li><p>多继承  续继承 多态的目的 </p>
</li>
<li><p>gooletest</p>
</li>
<li><p>栈的大小  10MB</p>
</li>
<li><p>linux管道 grep</p>
</li>
<li><p><img src="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95%5Cqiuck_sort.png" alt="快速排序递归排序非递归排序"></p>
</li>
<li><p>无序数组 寻找不在该数组范围内的最小正整数</p>
</li>
<li><p>最长回文子</p>
</li>
<li><p>垃圾回收机制</p>
</li>
<li><p>重点网络  和  linux</p>
</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          
            <a href="/tags/shell/" rel="tag"># shell</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/" rel="next" title="C++易混点">
                <i class="fa fa-chevron-left"></i> C++易混点
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/25/Git%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" rel="prev" title="Git操作注意事项">
                Git操作注意事项 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">翟安然</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#（一）面向对象的三个基本特征：封装、继承、多态"><span class="nav-number">1.</span> <span class="nav-text">（一）面向对象的三个基本特征：封装、继承、多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（二）bash-shell"><span class="nav-number">2.</span> <span class="nav-text">（二）bash shell</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（三）图"><span class="nav-number">3.</span> <span class="nav-text">（三）图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（四）IO库"><span class="nav-number">4.</span> <span class="nav-text">（四）IO库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（五）搜狗"><span class="nav-number">5.</span> <span class="nav-text">（五）搜狗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（六）手写代码"><span class="nav-number">6.</span> <span class="nav-text">（六）手写代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（七）SAP"><span class="nav-number">7.</span> <span class="nav-text">（七）SAP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（八）进程间的通信方式（IPC-inter-Process-Communication）"><span class="nav-number">8.</span> <span class="nav-text">（八）进程间的通信方式（IPC,inter-Process Communication）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（九）Windows内存管理方式：段存储、页存储、段页存储"><span class="nav-number">9.</span> <span class="nav-text">（九）Windows内存管理方式：段存储、页存储、段页存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（十）计算机网络"><span class="nav-number">10.</span> <span class="nav-text">（十）计算机网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（十一）百度"><span class="nav-number">11.</span> <span class="nav-text">（十一）百度</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">翟安然</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  
  
    <script src="/js/cursor/fireworks.js"></script>
  

</body>
</html>

