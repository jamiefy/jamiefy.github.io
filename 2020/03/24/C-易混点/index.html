<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++," />










<meta name="description" content="（一）虚函数表指针、虚基类表指针 非虚继承时，不需要额外增加虚函数表指针。单继承：一个虚函数表，一个虚表指针；多继承：子类的虚表指针数&#x3D;父类数。  虚继承时：无论是单虚继承还是多虚继承，需要有一个虚基类表来记录虚继承关系，所以此时子类有且仅有一个虚基类表指针；多虚继承时子类可能持有多个虚函数表：如果子类没有构造函数和析构函数，且子类中的虚函数都是在父类中出现的虚函数，这个时候不需要增加任何虚表指针">
<meta property="og:type" content="article">
<meta property="og:title" content="C++易混点">
<meta property="og:url" content="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/index.html">
<meta property="og:site_name" content="翟安然&#39;s Blog">
<meta property="og:description" content="（一）虚函数表指针、虚基类表指针 非虚继承时，不需要额外增加虚函数表指针。单继承：一个虚函数表，一个虚表指针；多继承：子类的虚表指针数&#x3D;父类数。  虚继承时：无论是单虚继承还是多虚继承，需要有一个虚基类表来记录虚继承关系，所以此时子类有且仅有一个虚基类表指针；多虚继承时子类可能持有多个虚函数表：如果子类没有构造函数和析构函数，且子类中的虚函数都是在父类中出现的虚函数，这个时候不需要增加任何虚表指针">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/C-%E6%98%93%E6%B7%B7%E7%82%B9%5Csort.png">
<meta property="article:published_time" content="2020-03-24T06:44:02.000Z">
<meta property="article:modified_time" content="2020-06-11T15:59:38.198Z">
<meta property="article:author" content="翟安然">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/C-%E6%98%93%E6%B7%B7%E7%82%B9%5Csort.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/24/C-易混点/"/>





  <title>C++易混点 | 翟安然's Blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">翟安然's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="翟安然">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="翟安然's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++易混点</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-24T14:44:02+08:00">
                2020-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="（一）虚函数表指针、虚基类表指针"><a href="#（一）虚函数表指针、虚基类表指针" class="headerlink" title="（一）虚函数表指针、虚基类表指针"></a>（一）虚函数表指针、虚基类表指针</h4><ul>
<li><p>非虚继承时，不需要额外增加虚函数表指针。单继承：一个虚函数表，一个虚表指针；多继承：子类的虚表指针数=父类数。</p>
</li>
<li><p>虚继承时：无论是单虚继承还是多虚继承，需要有一个虚基类表来记录虚继承关系，所以此时子类有且仅有一个虚基类表指针；多虚继承时子类可能持有多个虚函数表：如果子类没有构造函数和析构函数，且子类中的虚函数都是在父类中出现的虚函数，这个时候不需要增加任何虚表指针，只需要像多继承那个持有父类个数的虚函数表指针来标识即可。</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li>如果子类中含有构造函数或者析构函数或二者都有，则在子类中只要出现一个父类中的虚函数则需要增加一个虚函数表指针来标识此类的虚函数表；无论是否含有构造函数或者虚构函数，只要继承都是虚继承且出现了父类中没有出现的虚函数，则在子类中需要再增加一个虚函数表指针；如果其中有一个是非虚继承，则按照最省空间的原则，不需要增加虚函数表指针，因为这个时候可以和非虚基类共享一个虚函数表指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统指针占四字节 64位系统指针占8字节，本题按32位系统</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::fun2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::d_fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive2::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive2::d_fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive3</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d3;</span><br><span class="line"><span class="keyword">int</span> add;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive3::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive3::d_fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive4</span> :</span> <span class="keyword">public</span> Derive2, <span class="keyword">public</span> Derive3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d4;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive4::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive4::d_fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive5</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive5::d_fun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//输出结果为：pstr1为虚函数表指针，vpstr为虚基类表指针</span></span><br><span class="line"><span class="keyword">sizeof</span>(Base1):<span class="number">8</span>  <span class="comment">//sizeof(int) + sizeof(pstr) = 4+4</span></span><br><span class="line"><span class="keyword">sizeof</span>(Base2):<span class="number">8</span>  <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive1):<span class="number">12</span> <span class="comment">//sizeof(int) + sizeof(pstr)  + sizeof(int)= 4+4+4</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive2):<span class="number">20</span>  <span class="comment">//sizeof(int) + sizeof(Base1的pstr)  +sizeof(Derive2的pstr) + sizeof(vpstr)+ sizeof(int)= 4+4+4+4+4</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive3):<span class="number">24</span>  <span class="comment">//sizeof(int) + sizeof(int) + sizeof(Base1的pstr)  +sizeof(Derive2的pstr) + sizeof(vpstr)+ sizeof(int)= 4+4+4+4+4+4</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive4):<span class="number">44</span>  <span class="comment">//sizeof(Derive2) + sizeof(Derive3) + sizeof(int)</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive5):<span class="number">16</span>  <span class="comment">//sizeof(Base1) + sizeof(Base2)</span></span><br></pre></td></tr></table></figure>

<h4 id="（二）万能头文件"><a href="#（二）万能头文件" class="headerlink" title="（二）万能头文件"></a>（二）万能头文件</h4><p>基本上所有的代码只要用了这个头文件就不再写其他头文件了。</p>
<p>#include&lt;bits/stdc++.h&gt;包含了目前c++所包含的所有头文件。</p>
<h4 id="（三）加速c"><a href="#（三）加速c" class="headerlink" title="（三）加速c++"></a>（三）加速c++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> _ = []()&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>​        <code>iostream</code>默认是与<code>stdio</code>关联在一起的，以使两者同步，因此消耗了<code>iostream</code>不少性能。C++中的<code>std :: cin</code>和<code>std :: cout</code>为了兼容C，保证在代码中同时出现<code>std :: cin</code>和<code>scanf</code>或<code>std :: cout</code>和<code>printf</code>时输出不发生混乱，所以C++用一个流缓冲区来同步C的标准流。通过<code>std :: ios_base :: sync_with_stdio</code>函数设置为<code>false</code>后可以解除这种同步，让<code>std :: cin</code>和<code>std :: cout</code>不再经过缓冲区，<code>iostream</code>的性能就会提高了很多倍。因此，当解除同步之后，注意不要与<code>scanf</code>和<code>printf</code>混用以免出现问题</p>
<p>​        <code>tie</code>是将两个<code>stream</code>绑定的函数，空参数的话返回当前的输出流指针。<code>std :: cin</code>默认是与<code>std :: cout</code>绑定的，所以每次操作的时候都要调用<code>flush</code>，这样增加了IO的负担，通过<code>tie(nullptr)</code>来解除<code>std :: cin</code>和<code>std :: cout</code>之间的绑定，进一步加快执行效率。</p>
<h4 id="（四）运算符优先级"><a href="#（四）运算符优先级" class="headerlink" title="（四）运算符优先级"></a>（四）运算符优先级</h4><ul>
<li>！= 优于 &amp; 。</li>
</ul>
<h4 id="（五）c-11新特性：参考"><a href="#（五）c-11新特性：参考" class="headerlink" title="（五）c++11新特性：参考"></a>（五）c++11新特性：<a href="https://blog.csdn.net/qq_34139994/article/details/94590736?ops_request_misc=%7B%22request%5Fid%22%3A%22158562057919195162527066%22%2C%22scm%22%3A%2220140713.130056874..%22%7D&request_id=158562057919195162527066&biz_id=0&utm_source=distribute.pc_search_result.none-task" target="_blank" rel="noopener">参考</a></h4><p><strong>1、nullptr关键字</strong></p>
<p>解决二义性问题，专门用来区分空指针和0。</p>
<p><strong>2、auto关键字</strong></p>
<p>用于从初始化表达式中推断出变量的数据类型。</p>
<ul>
<li>auto定义变量时必须初始化（类似引用）</li>
<li>auto作为函数返回值时，只能用于定义函数，不能用于声明函数</li>
<li>不允许使用auto定义函数参数</li>
<li>不允许使用auto定义struct/class的成员变量</li>
<li>不允许使用auto定义数组</li>
<li>不允许使用auto作为模板参数传递</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>;             <span class="comment">// i 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> arr = <span class="keyword">new</span> <span class="keyword">auto</span>(<span class="number">10</span>) <span class="comment">// arr 被推导为 int *</span></span><br></pre></td></tr></table></figure>

<p><strong>3、decltype 关键字</strong><br>decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。编译器分析表达式并得到它的类型，却不实际计算表达式的值。<strong>如果给变量加上了一层括号，编译器会把它当作一个表达式，得到的则是引用类型</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> j = <span class="number">5.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(i) a;		<span class="comment">// a的类型是int</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) b = i;  	<span class="comment">// b的类型是int&amp;，必须为其初始化，否则会编译报错</span></span><br><span class="line"><span class="keyword">decltype</span>(i+j) c; 	<span class="comment">// c的类型是int+float =&gt; float</span></span><br></pre></td></tr></table></figure>



<p><strong>4、新式函数声明</strong><br>C++11 引入了一个叫做拖尾返回类型（trailing return type），利用 auto 关键字将返回类型后置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T x, U y) -&gt; decltype(x+y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5、基于范围的 for 循环</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : arr) &#123;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6、Lambda表达式</strong></p>
<p>如果mutable,exception,attribute,return type四者只要一种出现，小括号()不可省略，均不出现则可省略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[capture] (parameters) opt-&gt; <span class="keyword">return</span>-type &#123;</span><br><span class="line">  body</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">noreturnfun</span><span class="params">()</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;<span class="comment">//函数不会返回。</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> capture是捕获列表； </span><br><span class="line">    <span class="number">1</span>).[]不捕获任何变量</span><br><span class="line">    <span class="number">2</span>).[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）</span><br><span class="line">    <span class="number">3</span>).[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)</span><br><span class="line">    <span class="number">4</span>).[=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量</span><br><span class="line">    <span class="number">5</span>).[bar]按值捕获bar变量，同时不捕获其他变量</span><br><span class="line">    <span class="number">6</span>).[<span class="keyword">this</span>]捕获当前类中的<span class="keyword">this</span>指针，让lambda表达式拥有和当前类成员函数同样的访问权限</span><br><span class="line">    如果已经使用了&amp;或者=，就默认添加此选项。捕获<span class="keyword">this</span>的目的是可以在lamda中使用当前类的成员函数和成员变量</span><br><span class="line"><span class="number">2.</span> parameters是参数表；(选填) </span><br><span class="line"><span class="number">3.</span> opt是函数选项；可以填<span class="keyword">mutable</span>,exception,attribute（选填） </span><br><span class="line">    <span class="number">1</span>).<span class="keyword">mutable</span>说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-<span class="keyword">const</span>方法</span><br><span class="line">    <span class="number">2</span>).exception说明lambda表达式是否抛出异常以及何种异常</span><br><span class="line">    <span class="number">3</span>).attribute用来声明属性，GCC使用__attribute__关键字来描述函数，变量和数据类型的属性，用于编译器对源代码的优化。</span><br><span class="line">attribute语法格式为：</span><br><span class="line">_attribute_ ((attribute-<span class="built_in">list</span>))</span><br><span class="line"><span class="number">4.</span> <span class="keyword">return</span>-type是返回值类型（拖尾返回类型）(选填) </span><br><span class="line"><span class="number">5.</span> body是函数体</span><br></pre></td></tr></table></figure>

<p><strong>7、std::function/std::bind封装可执行对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Test.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; fun, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = fun(a, b);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum:"</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"add"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestAdd::Add"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    test.Add(add, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    TestAdd testAdd;</span><br><span class="line">    test.Add(<span class="built_in">std</span>::bind(&amp;TestAdd::Add, testAdd, <span class="built_in">std</span>::placeholders::_1, <span class="built_in">std</span>::placeholders::_2), <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">add</span><br><span class="line">sum:<span class="number">3</span></span><br><span class="line">TestAdd::Add</span><br><span class="line">sum:<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"><span class="built_in">std</span>::bind第一个参数为对象函数指针，表示函数相对于类的首地址的偏移量；</span><br><span class="line">testAdd为对象指针；</span><br><span class="line"><span class="built_in">std</span>::placeholders::_1和<span class="built_in">std</span>::placeholders::_2为参数占位符，表示<span class="built_in">std</span>::bind封装的可执行对象可以接受两个参数。</span><br><span class="line">我们的Test函数在函数指针和类对象函数中，两种情况下都完美运行。</span><br></pre></td></tr></table></figure>

<p><strong>8、初始化列表</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Magic(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Magic magic = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>9、STL容器</strong></p>
<ul>
<li>std::array&lt;类型，容量&gt;，相对于数组增加了迭代器</li>
<li>std::forward_list单向链表，链表在对数据进行插入和删除是比顺序存储的线性表有优势，因此在插入和删除操作频繁的应用场景中，使用list和forward_list比使用array、vector和deque效率要高很多。</li>
<li>std::unordered_map与std::map用法基本差不多，但STL在内部实现上有很大不同，std::map使用的数据结构为红黑树，而std::unordered_map内部是哈希表的实现方式，哈希map理论上查找效率为O(1)。但在存储效率上，哈希map需要增加哈希表的内存开销。</li>
<li>std::unordered_set的数据存储结构也是哈希表的方式结构，除此之外，std::unordered_set在插入时不会自动排序，这都是std::set表现不同的地方。</li>
</ul>
<p><strong>10、多线程</strong></p>
<ul>
<li>std::thread为C++11的线程类，使用方法和boost接口一样非常方便，同时得益于C++11的可变参数的设计风格，C++11的std::thread还解决了boost::thread中构成参数限制的问题：如果线程需要绑定的函数有参数则需要使用boost::bind。比如想使用 boost::thread创建一个线程来执行函数：void f(int i)，如果这样写：boost::thread thrd(f)是不对的，因为thread构造函数声明接受的是一个没有参数且返回类型为void的型别，而且不提供参数i的值f也无法运行，这时就可以写：boost::thread thrd(boost::bind(f,1))。涉及到有参函数的绑定问题基本上都是boost::thread、boost::function、boost::bind结合起来使用。</li>
<li>std::atomic为C++11封装的原子数据类型，在多线程中用户不必对其添加互斥资源锁的类型，其内部已自己加了锁。</li>
<li>C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到被唤醒再从新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。</li>
</ul>
<p><strong>11、智能指针内存管理</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> make_shared&lt;Foo&gt;(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Foo&gt; p=factory(arg);</span><br><span class="line">    <span class="comment">//使用p</span></span><br><span class="line">&#125;<span class="comment">//p离开了作用域，它指向的内存会被自动释放掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Foo&gt; p=factory(arg);</span><br><span class="line">    <span class="comment">//使用p</span></span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//当我们返回p时，引用计数进行了递增操作</span></span><br><span class="line">&#125;<span class="comment">//p离开了作用域，它指向的内存不会被自动释放掉</span></span><br></pre></td></tr></table></figure>

<p>C++11新增了std::shared_ptr（共享）、std::weak_ptr（弱引用，指向管理的对象，不会增加引用计数）、std::unique_str(独占)等类型的智能指针，用于解决内存管理的问题，更容易安全的使用动态内存。</p>
<p><strong>12、右值引用于std::move</strong></p>
<p>右值引用 (Rvalue Referene) 是 C++ 新标准 中引入的新特性 , 它实现了移动语义 (Move Sementics) 和完美转发 (Perfect Forwarding)。它的主要目的有两个方面：</p>
<p>1）消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</p>
<p>2）能够更简洁明确地定义泛型函数。</p>
<ul>
<li>左值持久；右值短暂</li>
</ul>
<p>左值：非临时对象，要么是字面常量，要么是在表达式求值过程中创建的临时对象<br>右值：临时的对象，</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/88584015" target="_blank" rel="noopener">右值引用的转移语义和完美转发</a></li>
</ul>
<p><strong>13、模板增强</strong></p>
<ul>
<li>外部模板扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化。</li>
<li>类型别名模板</li>
</ul>
<p>在传统 C++中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> NewType = SuckType&lt;<span class="keyword">int</span>, T, <span class="number">1</span>&gt;;    <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">typedef</span> SuckType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, U, <span class="number">1</span>&gt; NewType; <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>默认模板参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>, <span class="keyword">typename</span> U = <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> add(T x, U y) -&gt; <span class="keyword">decltype</span>(x+y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>14、构造函数</strong></p>
<ul>
<li>委托构造</li>
</ul>
<p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">int</span> value2;</span><br><span class="line">    Base() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> value) : Base() &#123;  <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>继承构造</li>
</ul>
<p>在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  A(<span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">  A(<span class="keyword">double</span> d,<span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">  A(<span class="keyword">float</span> f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c)&#123;&#125;</span><br><span class="line">  <span class="comment">//...等等系列的构造函数版本</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A</span><br><span class="line">&#123;</span><br><span class="line">  B(<span class="keyword">int</span> i):A(i)&#123;&#125;</span><br><span class="line">  B(<span class="keyword">double</span> d,<span class="keyword">int</span> i):A(d,i)&#123;&#125;</span><br><span class="line">  B(folat f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c):A(f,i,e)&#123;&#125;</span><br><span class="line">  <span class="comment">//......等等好多个和基类构造函数对应的构造函数</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//c++11的继承构造</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  A(<span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">  A(<span class="keyword">double</span> d,<span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">  A(<span class="keyword">float</span> f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c)&#123;&#125;</span><br><span class="line">  <span class="comment">//...等等系列的构造函数版本</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> A::A;</span><br><span class="line">  <span class="comment">//关于基类各构造函数的继承一句话搞定</span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>



<p><strong>15、虚函数的 override 和 final 指示符</strong></p>
<ul>
<li>override，表示函数应当重写基类中的虚函数</li>
<li>final，表示派生类不应当重写这个虚函数</li>
</ul>
<p><strong>16、static_assert() 静态断言</strong></p>
<ul>
<li>C提供的assert()只能在运行时断言</li>
<li>C++11/14 提供的static_assert()可以在编译期断言</li>
</ul>
<h4 id="（六）十大经典排序算法：参考"><a href="#（六）十大经典排序算法：参考" class="headerlink" title="（六）十大经典排序算法：参考"></a>（六）十大经典排序算法：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">参考</a></h4><p><img src="/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/C-%E6%98%93%E6%B7%B7%E7%82%B9%5Csort.png" alt="排序算法分类"></p>
<ol>
<li>冒泡排序</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="comment">//注意限制条件j&lt;len-1-i</span></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">                                swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>快速排序</li>
<li>插入排序</li>
<li>选择排序</li>
<li>堆排序</li>
<li>归并排序</li>
</ol>
<ul>
<li>自顶向下</li>
<li>自底向上：注意底层达不到整数倍length的数据部分</li>
</ul>
<h4 id="（七）重点知识点"><a href="#（七）重点知识点" class="headerlink" title="（七）重点知识点"></a>（七）重点知识点</h4><ol>
<li><h5 id="printf-从右向左计算，从左向右输出，符合栈模型"><a href="#printf-从右向左计算，从左向右输出，符合栈模型" class="headerlink" title="printf 从右向左计算，从左向右输出，符合栈模型"></a>printf 从右向左计算，从左向右输出，符合栈模型</h5></li>
<li><h5 id="类中变量赋值顺序是变量声明顺序，所以赋值时先执行a-b-，再执行b-i-1-。a赋值为随机数"><a href="#类中变量赋值顺序是变量声明顺序，所以赋值时先执行a-b-，再执行b-i-1-。a赋值为随机数" class="headerlink" title="类中变量赋值顺序是变量声明顺序，所以赋值时先执行a(b)，再执行b(i+1)。a赋值为随机数"></a>类中变量赋值顺序是变量声明顺序，所以赋值时先执行a(b)，再执行b(i+1)。a赋值为随机数</h5></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base1</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>: <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    base1 ( <span class="keyword">int</span> i ) : b(i+<span class="number">1</span>),a(b)&#123;&#125;</span><br><span class="line">    base1():b(<span class="number">0</span>),a(b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_a</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_b</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">base1 <span class="title">obj1</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj1.get_a()&lt;&lt;<span class="built_in">endl</span>&lt;&lt;obj1.get_b()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5></li>
</ol>
<p>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。Static修饰的成员函数，在代码区分配内存。</p>
<ol start="4">
<li><h5 id="C-多态分为静态多态和动态多态"><a href="#C-多态分为静态多态和动态多态" class="headerlink" title="C++多态分为静态多态和动态多态"></a>C++多态分为静态多态和动态多态</h5></li>
</ol>
<p>静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。</p>
<ol start="5">
<li><h5 id="C-里面‘-’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。"><a href="#C-里面‘-’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。" class="headerlink" title="C++里面‘/’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。"></a>C++里面‘/’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。</h5></li>
<li><h5 id="派生访问说明符"><a href="#派生访问说明符" class="headerlink" title="派生访问说明符"></a>派生访问说明符</h5></li>
</ol>
<ul>
<li>public继承</li>
</ul>
<p>公有继承时，对基类的公有成员和保护成员的访问属性不变，<strong>派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员</strong>。派生类的对象只能访问派生类的公有成员（包括继承的公有成员），不能访问派生类和继承基类的保护成员和私有成员。</p>
<ul>
<li>protected继承</li>
</ul>
<p>保护继承中，基类的公有成员和保护成员被派生类继承后变成保护成员，<strong>派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员</strong>。派生类的对象只能访问派生类的公有成员，不能访问继承基类的公有成员、保护成员和私有成员。</p>
<ul>
<li>private继承</li>
</ul>
<p>私有继承时，基类的公有成员和保护成员都被派生类继承下来之后变成私有成员，<strong>派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员</strong>。派生类的对象只能访问派生类的公有成员，不能访问继承基类的公有成员、保护成员和私有成员。</p>
<ol start="7">
<li><h5 id="C-枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别"><a href="#C-枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别" class="headerlink" title="C++枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别"></a>C++枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别</h5></li>
</ol>
<ul>
<li>限定作用域的枚举类型的一般形式和不限范围的枚举类型不同</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非限定作用域</span></span><br><span class="line"><span class="keyword">enum</span> color&#123;</span><br><span class="line">    red,</span><br><span class="line">    green,</span><br><span class="line">    blue</span><br><span class="line">&#125;;</span><br><span class="line">color b=green;</span><br><span class="line"><span class="keyword">int</span> c=blue; <span class="comment">//正确</span></span><br><span class="line"><span class="comment">//限定作用域</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">color</span>:</span><span class="keyword">char</span></span><br><span class="line">&#123;</span><br><span class="line">    red,</span><br><span class="line">    green,</span><br><span class="line">    blue</span><br><span class="line">&#125;;</span><br><span class="line">color a=color::green;</span><br><span class="line"><span class="keyword">char</span> d=color:blue; <span class="comment">//错误，限定作用域的枚举类型不能用于初始化int类型的实体</span></span><br></pre></td></tr></table></figure>

<ul>
<li>限定作用域的枚举类型不能再作用域外访问枚举成员,必须显示地访问枚举成员，限定作用域的枚举型别带来的名字空间污染降低；不限范围的枚举型别可以</li>
<li>从限定作用域枚举型别到任何其他型别都不存在隐式转换路径（可实施强制型别转换）；不限范围的枚举型别可以</li>
<li>限定作用域的枚举型别和不限范围的枚举型别都支持底层型别指定。限定作用域的枚举型别的默认底层型别是int，而不限范围的枚举型别没有默认底层型别。</li>
<li>限定作用域的枚举型别总是可以进行前置声明，而不限范围的枚举型别却只有在指定了默认底层型别的前提下才可以进行前置声明。</li>
</ul>
<ol start="8">
<li><h5 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h5></li>
</ol>
<p>类型转换函数的语法格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1) type 可以是内置类型、类类型以及由 typedef 定义的类型别名，任何可作为函数返回类型的类型（void 除外）都能够被支持。一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的。</p>
<p>2) 类型转换函数一般不会更改被转换的对象，所以通常被定义为 const 成员。</p>
<p>3) 类型转换函数可以被继承，可以是虚函数。</p>
<p>4) 一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性。</p>
<p>5) 转换函数必须是成员函数，它的声明不能指定返回类型和参数列表。</p>
<ul>
<li>通常一个参数的构造函数在non-explicit的情况下同样能实现类型转换</li>
</ul>
<ol start="9">
<li><h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5></li>
</ol>
<ul>
<li>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。三种类型的内存泄漏：</li>
</ul>
<p>（1）堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过<code>malloc</code>,<code>realloc</code>,<code>new</code>等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</p>
<p>（2）系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 <code>Bitmap</code>,<code>handle</code> ,<code>SOCKET</code>等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p>
<p>（3）没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是<code>virtual</code>，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p>
<ul>
<li>安全的代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>（1）delete 一次以后，p成了野指针，但是它作为地址的值还是有效的，还可以访问它以前指向的内存，不过那片内存被重新格式化了；<br>（2）指针非空时，delete运算只释放指针所指的地址空间，不会判断空间是否被占用，delete结束后不会将指针赋值为空，释放后别的指针变量也可以得到这片空间，<strong>该空间的值并不一定是NULL，所以delete后不能用是否为NULL来判断</strong>。用 if(p) 语句不能判断它指向的内存是否有效（此时它指向的内存无效，p本身有效）；<br>（3）delete 一次以后，不能再次delete，否则会报错；<br>（4）如果p指向的空间再次被new函数分配，即使是分配给别的指针，即使分配大小与原来不一样，此时如果误用p指针，仍然可以修改内存的值和从该处取出数值，甚至可以重新被delete，p的作用与新分配的指针一样；</p>
<p>对同一非空指针delete多次，只有第一次delete被正确执行，之后的delete全部发生异常。对空指针delete多次可以正常执行。良好的习惯是，delete运算后手动将指针赋值为空。</p>
<ul>
<li>野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）,野指针的成因：</li>
</ul>
<p>1、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的默认值是随机的，它会乱指一气。<br>2、指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。<br>3、指针操作超越了变量的作用范围。这种情况让人防不胜防。</p>
<ul>
<li>悬空指针指指针正常初始化，曾指向过一个正常的对象，但是对象销毁了，该指针未置空，就成了悬空指针。例如指针p1、p2均指向对象a，delete p1后p2就是悬空指针，p1是野指针。</li>
</ul>
<ol start="10">
<li><h5 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h5></li>
</ol>
<p>在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，结构体变量所占空间的大小必定是最宽数据类型大小的整数倍。如有需要会在最后一个成员末尾填充若干字节使得所占空间大小是最宽数据类型大小的整数倍。内存对齐的原因：</p>
<ol>
<li><p>某些平台只能在特定的地址处访问特定类型的数据；</p>
</li>
<li><p>提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量</p>
</li>
<li><h5 id="大端小端"><a href="#大端小端" class="headerlink" title="大端小端"></a>大端小端</h5></li>
</ol>
<ul>
<li><p><strong>大端模式（Big_endian）</strong>：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。</p>
</li>
<li><p><strong>小端模式</strong>（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。</p>
</li>
<li><p><strong>口诀</strong>：大相反（低位存高位），小相同（低位存低位）。</p>
</li>
<li><p>联合体变量共享同一空间，可以通过联合体来判断大端小端。联合体同样存在内存对齐，所以联合长度至少可以容纳最大的成员。但是当最大成员大小不是<strong>最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍。</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkcpu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> w</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		<span class="keyword">char</span> b;</span><br><span class="line">	&#125;c;</span><br><span class="line">	c.a = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> (c.b == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(checkcpu() == <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"这是小端\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"这是大端\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li><h5 id="为什么析构函数可以virtual，构造函数不能呢？"><a href="#为什么析构函数可以virtual，构造函数不能呢？" class="headerlink" title="为什么析构函数可以virtual，构造函数不能呢？"></a>为什么析构函数可以virtual，构造函数不能呢？</h5></li>
</ol>
<ul>
<li><p>在公有继承中，基类的虚构函数如果不声明成为虚函数，delete p调用的是声明类型(即基类)的析构函数，所以只能销毁基类对象而无法销毁派生类对象，会发生销毁不完全的情况，那么销毁派生类时有可能造成资源泄漏。当基类的析构函数声明为虚函数，那么派生类的析构函数也是虚函数，此时调用delete p时发生动态绑定，运行时会根据实际类型调用该对象的虚函数。并不是要把所有类的析构函数都写成虚函数。只有当一个类是基类(即希望被继承)的时候才需要声明成虚函数，因为虚函数的作用是实现多态，而多态是建立在继承的基础上。单一类不能把析构函数写成虚函数，因为会产生额外的开销，比如虚表的创建和虚指针的定义。</p>
</li>
<li><p>（1）虚函数采用一种虚调用的办法。虚调用是一种可以在只有部分信息的情况下工作的机制，特别运行我们调用一个只知道接口而不知道其准确对象类型的函数。但是构造函数本身就是要初始化实例，要创建一个对象，构造函数肯定要知道对象的准确类型，因此构造函数不能为虚。</p>
<p>（2）虚函数对应虚函数表，虚函数表存储在对象的内存空间，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。</p>
<p>（3）虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p>
<p>（4）构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。</p>
<p>（5）当一个构造函数被调用时，它做的首要的事情之一是初始化它的V P T R。因此，它只能知道它是“当前”类的，而完全忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码- -既不是为基类，也不是为它的派生类（因为类不知道谁继承它）。所以它使用的V P T R必须是对于这个类的V TA B L E。而且，只要它是最后的构造函数调用，那么在这个对象的生命期内， V P T R将保持被初始化为指向这个V TA B L E, 但如果接着还有一个更晚派生的构造函数被调用，这个构造函数又将设置V P T R指向它的 V TA B L E，等直到最后的构造函数结束。V P T R的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类顺序的另一个理由。但是，当这一系列构造函数调用正发生时，每个构造函数都已经设置V P T R指向它自己的 V TA B L E。如果函数调用使用虚机制，它将只产生通过它自己的V TA B L E的调用，而不是最后的V TA B L E（所有构造函数被调用后才会有最后的V TA B L E）。</p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/24/MySQL/" rel="next" title="MySQL">
                <i class="fa fa-chevron-left"></i> MySQL
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/" rel="prev" title="面试要点记录">
                面试要点记录 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">翟安然</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#（一）虚函数表指针、虚基类表指针"><span class="nav-number">1.</span> <span class="nav-text">（一）虚函数表指针、虚基类表指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（二）万能头文件"><span class="nav-number">2.</span> <span class="nav-text">（二）万能头文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（三）加速c"><span class="nav-number">3.</span> <span class="nav-text">（三）加速c++</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（四）运算符优先级"><span class="nav-number">4.</span> <span class="nav-text">（四）运算符优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（五）c-11新特性：参考"><span class="nav-number">5.</span> <span class="nav-text">（五）c++11新特性：参考</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（六）十大经典排序算法：参考"><span class="nav-number">6.</span> <span class="nav-text">（六）十大经典排序算法：参考</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（七）重点知识点"><span class="nav-number">7.</span> <span class="nav-text">（七）重点知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#printf-从右向左计算，从左向右输出，符合栈模型"><span class="nav-number">7.1.</span> <span class="nav-text">printf 从右向左计算，从左向右输出，符合栈模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类中变量赋值顺序是变量声明顺序，所以赋值时先执行a-b-，再执行b-i-1-。a赋值为随机数"><span class="nav-number">7.2.</span> <span class="nav-text">类中变量赋值顺序是变量声明顺序，所以赋值时先执行a(b)，再执行b(i+1)。a赋值为随机数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#static"><span class="nav-number">7.3.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-多态分为静态多态和动态多态"><span class="nav-number">7.4.</span> <span class="nav-text">C++多态分为静态多态和动态多态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-里面‘-’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。"><span class="nav-number">7.5.</span> <span class="nav-text">C++里面‘&#x2F;’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#派生访问说明符"><span class="nav-number">7.6.</span> <span class="nav-text">派生访问说明符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别"><span class="nav-number">7.7.</span> <span class="nav-text">C++枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类型转换函数"><span class="nav-number">7.8.</span> <span class="nav-text">类型转换函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内存泄漏"><span class="nav-number">7.9.</span> <span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sizeof"><span class="nav-number">7.10.</span> <span class="nav-text">sizeof</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#大端小端"><span class="nav-number">7.11.</span> <span class="nav-text">大端小端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么析构函数可以virtual，构造函数不能呢？"><span class="nav-number">7.12.</span> <span class="nav-text">为什么析构函数可以virtual，构造函数不能呢？</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">翟安然</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  
  
    <script src="/js/cursor/fireworks.js"></script>
  

</body>
</html>

