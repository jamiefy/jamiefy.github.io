<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++," />










<meta name="description" content="（一）虚函数表指针、虚基类表指针 （二）万能头文件 （三）加速c++ （四）运算符优先级 （五）c++11新特性：参考 auto_ptr(C++11已经舍弃) unique_ptr（替换auto_ptr）   （六）十大经典排序算法：参考 （七）重点知识点 c++中的内存泄漏的原因   （八）友元函数 （九）外部排序 字符数组初始化 如何只能做堆上创建对象 只能在栈上创建对象 C++ s">
<meta property="og:type" content="article">
<meta property="og:title" content="C++易混点">
<meta property="og:url" content="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/index.html">
<meta property="og:site_name" content="翟安然&#39;s Blog">
<meta property="og:description" content="（一）虚函数表指针、虚基类表指针 （二）万能头文件 （三）加速c++ （四）运算符优先级 （五）c++11新特性：参考 auto_ptr(C++11已经舍弃) unique_ptr（替换auto_ptr）   （六）十大经典排序算法：参考 （七）重点知识点 c++中的内存泄漏的原因   （八）友元函数 （九）外部排序 字符数组初始化 如何只能做堆上创建对象 只能在栈上创建对象 C++ s">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/C-%E6%98%93%E6%B7%B7%E7%82%B9%5Csort.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/unicode%E5%88%97%E8%A1%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/vector%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png">
<meta property="article:published_time" content="2020-03-24T06:44:02.000Z">
<meta property="article:modified_time" content="2021-04-15T13:49:18.765Z">
<meta property="article:author" content="翟安然">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/C-%E6%98%93%E6%B7%B7%E7%82%B9%5Csort.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/24/C-易混点/"/>





  <title>C++易混点 | 翟安然's Blog</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">翟安然's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="翟安然">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="翟安然's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++易混点</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-24T14:44:02+08:00">
                2020-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

<ul>
<li><a href="#一虚函数表指针-虚基类表指针">（一）虚函数表指针、虚基类表指针</a></li>
<li><a href="#二万能头文件">（二）万能头文件</a></li>
<li><a href="#三加速c">（三）加速c++</a></li>
<li><a href="#四运算符优先级">（四）运算符优先级</a></li>
<li><a href="#五c11新特性参考httpsblogcsdnnetqq_34139994articledetails94590736ops_request_misc7b22request5fid223a22158562057919195162527066222c22scm223a2220140713130056874227drequest_id158562057919195162527066biz_id0utm_sourcedistributepc_search_resultnone-task">（五）c++11新特性：参考</a><ul>
<li><a href="#auto_ptrc11已经舍弃">auto_ptr(C++11已经舍弃)</a></li>
<li><a href="#unique_ptr替换auto_ptr">unique_ptr（替换auto_ptr）</a></li>
</ul>
</li>
<li><a href="#六十大经典排序算法参考httpswwwcnblogscomonepixelarticles7674659html">（六）十大经典排序算法：参考</a></li>
<li><a href="#七重点知识点">（七）重点知识点</a><ul>
<li><a href="#c中的内存泄漏的原因">c++中的内存泄漏的原因</a></li>
</ul>
</li>
<li><a href="#八友元函数">（八）友元函数</a></li>
<li><a href="#九外部排序">（九）外部排序</a></li>
<li><a href="#字符数组初始化">字符数组初始化</a></li>
<li><a href="#如何只能做堆上创建对象">如何只能做堆上创建对象</a></li>
<li><a href="#只能在栈上创建对象">只能在栈上创建对象</a></li>
<li><a href="#c-static-const-和-static-const-类型成员变量声明以及初始化httpswwwrunoobcomw3cnotecpp-static-consthtml">C++ static、const 和 static const 类型成员变量声明以及初始化</a><a id="more"></a></li>
<li><a href="#c方式编译的c文件决定不能出现重载函数httpswwwcnblogscomyogurshinep3913073html">c方式编译的c++文件决定不能出现重载函数</a></li>
<li><a href="#内存对齐的作用">内存对齐的作用</a></li>
<li><a href="#c设计一个类只能在堆上创建对象-只能在栈上创建对象-只能创建一个对象">C++设计一个类：只能在堆上创建对象、只能在栈上创建对象、只能创建一个对象</a><ul>
<li><a href="#一-只能在堆上创建对象">一、只能在堆上创建对象</a></li>
<li><a href="#二-只能在栈上创建对象">二、只能在栈上创建对象</a></li>
<li><a href="#三-只能创建一个对象">三、只能创建一个对象</a></li>
</ul>
</li>
<li><a href="#字符串编码方式">字符串编码方式</a><ul>
<li><a href="#unicode">Unicode</a></li>
<li><a href="#ascll码">ASCLL码</a></li>
</ul>
</li>
<li><a href="#volatile">volatile</a><ul>
<li><a href="#总结">总结</a></li>
<li><a href="#乱序执行与编译器重排序优化的比较编辑">乱序执行与编译器重排序优化的比较编辑</a></li>
<li><a href="#编译器屏障-compiler-barrior">编译器屏障 Compiler Barrior</a></li>
<li><a href="#cpu屏障-cpu-barrior">CPU屏障 CPU Barrior</a></li>
</ul>
</li>
<li><a href="#线程资源的回收">线程资源的回收</a></li>
<li><a href="#vector内存分配">vector内存分配</a><ul>
<li><a href="#reserve和resize的区别">reserve和resize的区别</a></li>
<li><a href="#vector扩容的两种方式">vector扩容的两种方式</a></li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->


<h2 id="（一）虚函数表指针、虚基类表指针"><a href="#（一）虚函数表指针、虚基类表指针" class="headerlink" title="（一）虚函数表指针、虚基类表指针"></a>（一）虚函数表指针、虚基类表指针</h2><ul>
<li><p>非虚继承时，不需要额外增加虚函数表指针。单继承：一个虚函数表，一个虚表指针；多继承：子类的虚表指针数=父类数。</p>
</li>
<li><p>虚继承时：无论是单虚继承还是多虚继承，需要有一个虚基类表来记录虚继承关系，所以此时子类有且仅有一个虚基类表指针；多虚继承时子类可能持有多个虚函数表：如果子类没有构造函数和析构函数，且子类中的虚函数都是在父类中出现的虚函数，这个时候不需要增加任何虚表指针，只需要像多继承那个持有父类个数的虚函数表指针来标识即可。</p>
</li>
</ul>
<ul>
<li>如果子类中含有构造函数或者析构函数或二者都有，则在子类中只要出现一个父类中的虚函数则需要增加一个虚函数表指针来标识此类的虚函数表；无论是否含有构造函数或者虚构函数，只要继承都是虚继承且出现了父类中没有出现的虚函数，则在子类中需要再增加一个虚函数表指针；如果其中有一个是非虚继承，则按照最省空间的原则，不需要增加虚函数表指针，因为这个时候可以和非虚基类共享一个虚函数表指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统指针占四字节 64位系统指针占8字节，本题按32位系统</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::fun2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::d_fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive2::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive2::d_fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive3</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d3;</span><br><span class="line"><span class="keyword">int</span> add;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive3::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive3::d_fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive4</span> :</span> <span class="keyword">public</span> Derive2, <span class="keyword">public</span> Derive3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d4;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive4::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive4::d_fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive5</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive5::d_fun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//输出结果为：pstr1为虚函数表指针，vpstr为虚基类表指针</span></span><br><span class="line"><span class="keyword">sizeof</span>(Base1):<span class="number">8</span>  <span class="comment">//sizeof(int) + sizeof(pstr) = 4+4</span></span><br><span class="line"><span class="keyword">sizeof</span>(Base2):<span class="number">8</span>  <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive1):<span class="number">12</span> <span class="comment">//sizeof(int) + sizeof(pstr)  + sizeof(int)= 4+4+4</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive2):<span class="number">20</span>  <span class="comment">//sizeof(int) + sizeof(Base1的pstr)  +sizeof(Derive2的pstr) + sizeof(vpstr)+ sizeof(int)= 4+4+4+4+4</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive3):<span class="number">24</span>  <span class="comment">//sizeof(int) + sizeof(int) + sizeof(Base1的pstr)  +sizeof(Derive2的pstr) + sizeof(vpstr)+ sizeof(int)= 4+4+4+4+4+4</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive4):<span class="number">44</span>  <span class="comment">//sizeof(Derive2) + sizeof(Derive3) + sizeof(int)</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive5):<span class="number">16</span>  <span class="comment">//sizeof(Base1) + sizeof(Base2)</span></span><br></pre></td></tr></table></figure>

<h2 id="（二）万能头文件"><a href="#（二）万能头文件" class="headerlink" title="（二）万能头文件"></a>（二）万能头文件</h2><p>基本上所有的代码只要用了这个头文件就不再写其他头文件了。</p>
<p>#include&lt;bits/stdc++.h&gt;包含了目前c++所包含的所有头文件。</p>
<h2 id="（三）加速c"><a href="#（三）加速c" class="headerlink" title="（三）加速c++"></a>（三）加速c++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> _ = []()&#123;</span><br><span class="line">    <span class="built_in">std</span> :: ios_base :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>​        <code>iostream</code>默认是与<code>stdio</code>关联在一起的，以使两者同步，因此消耗了<code>iostream</code>不少性能。C++中的<code>std :: cin</code>和<code>std :: cout</code>为了兼容C，保证在代码中同时出现<code>std :: cin</code>和<code>scanf</code>或<code>std :: cout</code>和<code>printf</code>时输出不发生混乱，所以C++用一个流缓冲区来同步C的标准流。通过<code>std :: ios_base :: sync_with_stdio</code>函数设置为<code>false</code>后可以解除这种同步，让<code>std :: cin</code>和<code>std :: cout</code>不再经过缓冲区，<code>iostream</code>的性能就会提高了很多倍。因此，当解除同步之后，注意不要与<code>scanf</code>和<code>printf</code>混用以免出现问题</p>
<p>​        <code>tie</code>是将两个<code>stream</code>绑定的函数，空参数的话返回当前的输出流指针。<code>std :: cin</code>默认是与<code>std :: cout</code>绑定的，所以每次操作的时候都要调用<code>flush</code>，这样增加了IO的负担，通过<code>tie(nullptr)</code>来解除<code>std :: cin</code>和<code>std :: cout</code>之间的绑定，进一步加快执行效率。</p>
<h2 id="（四）运算符优先级"><a href="#（四）运算符优先级" class="headerlink" title="（四）运算符优先级"></a>（四）运算符优先级</h2><ul>
<li>！= 优于 &amp; 。</li>
</ul>
<h2 id="（五）c-11新特性：参考"><a href="#（五）c-11新特性：参考" class="headerlink" title="（五）c++11新特性：参考"></a>（五）c++11新特性：<a href="https://blog.csdn.net/qq_34139994/article/details/94590736?ops_request_misc=%7B%22request%5Fid%22%3A%22158562057919195162527066%22%2C%22scm%22%3A%2220140713.130056874..%22%7D&request_id=158562057919195162527066&biz_id=0&utm_source=distribute.pc_search_result.none-task" target="_blank" rel="noopener">参考</a></h2><p><strong>1、nullptr关键字</strong></p>
<p>解决二义性问题，专门用来区分空指针和0。</p>
<p><strong>2、auto关键字</strong></p>
<p>用于从初始化表达式中推断出变量的数据类型。</p>
<ul>
<li>auto定义变量时必须初始化（类似引用）</li>
<li>auto作为函数返回值时，只能用于定义函数，不能用于声明函数</li>
<li>不允许使用auto定义函数参数</li>
<li>不允许使用auto定义struct/class的成员变量</li>
<li>不允许使用auto定义数组</li>
<li>不允许使用auto作为模板参数传递</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>;             <span class="comment">// i 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> arr = <span class="keyword">new</span> <span class="keyword">auto</span>(<span class="number">10</span>) <span class="comment">// arr 被推导为 int *</span></span><br></pre></td></tr></table></figure>

<p><strong>3、decltype 关键字</strong><br>decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。编译器分析表达式并得到它的类型，却不实际计算表达式的值。<strong>如果给变量加上了一层括号，编译器会把它当作一个表达式，得到的则是引用类型</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> j = <span class="number">5.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(i) a;		<span class="comment">// a的类型是int</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) b = i;  	<span class="comment">// b的类型是int&amp;，必须为其初始化，否则会编译报错</span></span><br><span class="line"><span class="keyword">decltype</span>(i+j) c; 	<span class="comment">// c的类型是int+float =&gt; float</span></span><br></pre></td></tr></table></figure>



<p><strong>4、新式函数声明</strong><br>C++11 引入了一个叫做拖尾返回类型（trailing return type），利用 auto 关键字将返回类型后置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T x, U y) -&gt; decltype(x+y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5、基于范围的 for 循环</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : arr) &#123;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6、Lambda表达式</strong></p>
<p>如果mutable,exception,attribute,return type四者只要一种出现，小括号()不可省略，均不出现则可省略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[capture] (parameters) opt-&gt; <span class="keyword">return</span> type &#123;</span><br><span class="line">  body</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">noreturnfun</span><span class="params">()</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;<span class="comment">//函数不会返回。</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> capture是捕获列表； </span><br><span class="line">    <span class="number">1</span>).[]不捕获任何变量</span><br><span class="line">    <span class="number">2</span>).[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）</span><br><span class="line">    <span class="number">3</span>).[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)</span><br><span class="line">    <span class="number">4</span>).[=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量</span><br><span class="line">    <span class="number">5</span>).[bar]按值捕获bar变量，同时不捕获其他变量</span><br><span class="line">    <span class="number">6</span>).[<span class="keyword">this</span>]捕获当前类中的<span class="keyword">this</span>指针，让lambda表达式拥有和当前类成员函数同样的访问权限</span><br><span class="line">    如果已经使用了&amp;或者=，就默认添加此选项。捕获<span class="keyword">this</span>的目的是可以在lamda中使用当前类的成员函数和成员变量</span><br><span class="line"><span class="number">2.</span> parameters是参数表；(选填) </span><br><span class="line"><span class="number">3.</span> opt是函数选项；可以填<span class="keyword">mutable</span>,exception,attribute（选填） </span><br><span class="line">    <span class="number">1</span>).<span class="keyword">mutable</span>说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-<span class="keyword">const</span>方法</span><br><span class="line">    <span class="number">2</span>).exception说明lambda表达式是否抛出异常以及何种异常</span><br><span class="line">    <span class="number">3</span>).attribute用来声明属性，GCC使用__attribute__关键字来描述函数，变量和数据类型的属性，用于编译器对源代码的优化。</span><br><span class="line">attribute语法格式为：</span><br><span class="line">_attribute_ ((attribute-<span class="built_in">list</span>))</span><br><span class="line"><span class="number">4.</span> <span class="keyword">return</span>-type是返回值类型（拖尾返回类型）(选填) </span><br><span class="line"><span class="number">5.</span> body是函数体</span><br></pre></td></tr></table></figure>

<p><strong>7、std::function/std::bind封装可执行对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Test.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; fun, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = fun(a, b);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum:"</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"add"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestAdd::Add"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    test.Add(add, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    TestAdd testAdd;</span><br><span class="line">    test.Add(<span class="built_in">std</span>::bind(&amp;TestAdd::Add, testAdd, <span class="built_in">std</span>::placeholders::_1, <span class="built_in">std</span>::placeholders::_2), <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">add</span><br><span class="line">sum:<span class="number">3</span></span><br><span class="line">TestAdd::Add</span><br><span class="line">sum:<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"><span class="built_in">std</span>::bind第一个参数为对象函数指针，表示函数相对于类的首地址的偏移量；</span><br><span class="line">testAdd为对象指针；</span><br><span class="line"><span class="built_in">std</span>::placeholders::_1和<span class="built_in">std</span>::placeholders::_2为参数占位符，表示<span class="built_in">std</span>::bind封装的可执行对象可以接受两个参数。</span><br><span class="line">我们的Test函数在函数指针和类对象函数中，两种情况下都完美运行。</span><br></pre></td></tr></table></figure>

<p><strong>8、初始化列表</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Magic(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Magic magic = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>9、STL容器</strong></p>
<ul>
<li>std::array&lt;类型，容量&gt;，相对于数组增加了迭代器</li>
<li>std::forward_list单向链表，链表在对数据进行插入和删除是比顺序存储的线性表有优势，因此在插入和删除操作频繁的应用场景中，使用list和forward_list比使用array、vector和deque效率要高很多。</li>
<li>std::unordered_map与std::map用法基本差不多，但STL在内部实现上有很大不同，std::map使用的数据结构为红黑树，而std::unordered_map内部是哈希表的实现方式，哈希map理论上查找效率为O(1)。但在存储效率上，哈希map需要增加哈希表的内存开销。</li>
<li>std::unordered_set的数据存储结构也是哈希表的方式结构，除此之外，std::unordered_set在插入时不会自动排序，这都是std::set表现不同的地方。</li>
</ul>
<p>迭代器失效分三种情况考虑，也是非三种数据结构考虑，分别为数组型，链表型，树型数据结构。</p>
<p>数组型数据结构：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(<em>iter)(或erase(</em>iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);</p>
<p>链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).</p>
<p>树形数据结构： 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。</p>
<p>注意：经过erase(iter)之后的迭代器完全失效，该迭代器iter不能参与任何运算，包括iter++,*ite</p>
<p><strong>10、多线程</strong></p>
<ul>
<li>std::thread为C++11的线程类，使用方法和boost接口一样非常方便，同时得益于C++11的可变参数的设计风格，C++11的std::thread还解决了boost::thread中构成参数限制的问题：如果线程需要绑定的函数有参数则需要使用boost::bind。比如想使用 boost::thread创建一个线程来执行函数：void f(int i)，如果这样写：boost::thread thrd(f)是不对的，因为thread构造函数声明接受的是一个没有参数且返回类型为void的型别，而且不提供参数i的值f也无法运行，这时就可以写：boost::thread thrd(boost::bind(f,1))。涉及到有参函数的绑定问题基本上都是boost::thread、boost::function、boost::bind结合起来使用。</li>
<li>std::atomic为C++11封装的原子数据类型，在多线程中用户不必对其添加互斥资源锁的类型，其内部已自己加了锁。</li>
<li>C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到被唤醒再从新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。</li>
</ul>
<p><strong>11、智能指针内存管理</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> make_shared&lt;Foo&gt;(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Foo&gt; p=factory(arg);</span><br><span class="line">    <span class="comment">//使用p</span></span><br><span class="line">&#125;<span class="comment">//p离开了作用域，它指向的内存会被自动释放掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Foo&gt; p=factory(arg);</span><br><span class="line">    <span class="comment">//使用p</span></span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//当我们返回p时，引用计数进行了递增操作</span></span><br><span class="line">&#125;<span class="comment">//p离开了作用域，它指向的内存不会被自动释放掉</span></span><br></pre></td></tr></table></figure>

<p>C++11新增了std::shared_ptr（共享引用控制块（共享强引用计数），当强引用计数为0时销毁共享对象）、std::weak_ptr（弱引用，指向管理的对象，不会增加强引用计数）、std::unique_tr(独占)等类型的智能指针，用于解决内存管理的问题，更容易安全的使用动态内存。</p>
<p>weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator*和-&gt;,不影响对象的生命周期，它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。</p>
<h3 id="auto-ptr-C-11已经舍弃"><a href="#auto-ptr-C-11已经舍弃" class="headerlink" title="auto_ptr(C++11已经舍弃)"></a>auto_ptr(C++11已经舍弃)</h3><p>由new expression获得的对象，在auto_ptr对象销毁时，他所管理的对象也会自动被delete掉。</p>
<p>auto_ptr<string> p1(new string(“This is a string”));<br>auto_ptr<string> p2;<br>p2 = p1;<br>上述语句中，如果p1和p2是常规指针，则两个指针将指向同一个string对象。这是不能接受的，因为程序将试图删除同一个对象两次。<br>要避免这种问题，方法有多种：</string></string></p>
<p>定义赋值运算符，使之执行深拷贝。这样两个指针将指向不同的对象，其中一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。<br>建立所有权概念。对于特定的对象，只能有一个指针可拥有，这样所拥有对象的智能指针的析构函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和unique_ptr的策略。<br>跟踪引用对象的智能指针数。这称为引用计数。例如：赋值时，计数加1，指针过期时，计数减1。当减为0时才调用delete。这就是sheared_ptr采用的策略。<br><strong>为什么要弃用auto_ptr?</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    auto_ptr&lt;string&gt; p1(new string(&quot;This is a string&quot;));</span><br><span class="line">    auto_ptr&lt;string&gt; p2 &#x3D; p1;  &#x2F;&#x2F;p1将所有权转让给p2，此时p1不再引用该字符串从而变成空指针。</span><br><span class="line">    cout &lt;&lt; *p1 &lt;&lt; endl;       &#x2F;&#x2F;报错，此时p1已经没有所指向的内存的所有权。</span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用shared_ptr时运行正常，因为shared_ptr采用引用计数，p1和p2都指向同一块内存，在释放空间时因为事先要判断引用计数值的大小因此不会出现多次删除一个对象的错误。<br>使用unique_ptr时编译出错，与auto_ptr不同的是，使用unique_ptr时，程序不会等到运行阶段崩溃，而在编译时出现错误。<br><strong>舍弃auto_ptr的原因：避免因潜在的内存问题导致程序崩溃</strong></p>
<h3 id="unique-ptr（替换auto-ptr）"><a href="#unique-ptr（替换auto-ptr）" class="headerlink" title="unique_ptr（替换auto_ptr）"></a>unique_ptr（替换auto_ptr）</h3><p>unique_ptr比auto_ptr更加安全，因为auto_ptr有拷贝语义，拷贝后原对象变得无效，再次访问原对象时会导致程序崩溃；unique_ptr禁止了拷贝语义，但提供了移动语义，即可以使用move()进行控制权限的转移。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; p1(new string(&quot;This is a string&quot;));</span><br><span class="line">unique_ptr&lt;string&gt; p2(p1);      &#x2F;&#x2F;编译出错，已禁止拷贝</span><br><span class="line">unique_ptr&lt;string&gt; p3 &#x3D; p1;     &#x2F;&#x2F;编译出错，已禁止拷贝</span><br><span class="line">unique_ptr&lt;string&gt; p4 &#x3D; std :: move(p1);  &#x2F;&#x2F;控制权限转移</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt;string&gt; p1(new string(&quot;This is a string&quot;));</span><br><span class="line">auto_ptr&lt;string&gt; p2(p1);  &#x2F;&#x2F;编译通过，运行出错</span><br><span class="line">auto_ptr&lt;string&gt; p3 &#x3D; p1; &#x2F;&#x2F;编译通过，运行出错</span><br><span class="line">如果unique_ptr是个临时右值，编译器允许拷贝语义。</span><br><span class="line">unique_ptr&lt;string&gt; demo(string *s)</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;string&gt; temp(new string(s));</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique_ptr&lt;string&gt; ps;</span><br><span class="line">ps &#x3D; demo(&quot;This is a string&quot;);</span><br><span class="line">demo()返回一个临时unique_ptr，然后ps接管了临时对象所管理的资源，而返回时临时的unique_ptr被销毁，也就是说没有机会使用unique_ptr来访问无效的数据。相对于auto_ptr任何情况下都允许拷贝语义，这正是unique_ptr更加灵活的地方。</span><br></pre></td></tr></table></figure>
<p><strong>扩展auto_ptr不能完成的功能</strong>：</p>
<p>unique_ptr可放在容器中，弥补了auto_ptr不能作为容器元素的缺点。<br>管理动态数组<br>自定义资源删除操作。</p>
<p><strong>12、右值引用于std::move</strong></p>
<p>右值引用 (Rvalue Referene) 是 C++ 新标准 中引入的新特性 , 它实现了移动语义 (Move Sementics) 和完美转发 (Perfect Forwarding)。它的主要目的有两个方面：</p>
<p>1）消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</p>
<p>2）能够更简洁明确地定义泛型函数。</p>
<ul>
<li>左值持久；右值短暂</li>
</ul>
<p>左值：非临时对象，要么是字面常量，要么是在表达式求值过程中创建的临时对象<br>右值：临时的对象，</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/88584015" target="_blank" rel="noopener">右值引用的转移语义和完美转发</a></li>
</ul>
<p><strong>13、模板增强</strong></p>
<ul>
<li>外部模板扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化。</li>
<li>类型别名模板</li>
</ul>
<p>在传统 C++中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> NewType = SuckType&lt;<span class="keyword">int</span>, T, <span class="number">1</span>&gt;;    <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">typedef</span> SuckType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, U, <span class="number">1</span>&gt; NewType; <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>默认模板参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>, <span class="keyword">typename</span> U = <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> add(T x, U y) -&gt; <span class="keyword">decltype</span>(x+y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>14、构造函数</strong></p>
<ul>
<li>委托构造</li>
</ul>
<p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">int</span> value2;</span><br><span class="line">    Base() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> value) : Base() &#123;  <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>继承构造</li>
</ul>
<p>在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  A(<span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">  A(<span class="keyword">double</span> d,<span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">  A(<span class="keyword">float</span> f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c)&#123;&#125;</span><br><span class="line">  <span class="comment">//...等等系列的构造函数版本</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A</span><br><span class="line">&#123;</span><br><span class="line">  B(<span class="keyword">int</span> i):A(i)&#123;&#125;</span><br><span class="line">  B(<span class="keyword">double</span> d,<span class="keyword">int</span> i):A(d,i)&#123;&#125;</span><br><span class="line">  B(folat f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c):A(f,i,e)&#123;&#125;</span><br><span class="line">  <span class="comment">//......等等好多个和基类构造函数对应的构造函数</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//c++11的继承构造</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  A(<span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">  A(<span class="keyword">double</span> d,<span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">  A(<span class="keyword">float</span> f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c)&#123;&#125;</span><br><span class="line">  <span class="comment">//...等等系列的构造函数版本</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> A::A;</span><br><span class="line">  <span class="comment">//关于基类各构造函数的继承一句话搞定</span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>



<p><strong>15、虚函数的 override 和 final 指示符</strong></p>
<ul>
<li>override，表示函数应当重写基类中的虚函数</li>
<li>final，表示派生类不应当重写这个虚函数</li>
</ul>
<p><strong>16、static_assert() 静态断言</strong></p>
<ul>
<li>C提供的assert()只能在运行时断言</li>
<li>C++11/14 提供的static_assert()可以在编译期断言</li>
</ul>
<h2 id="（六）十大经典排序算法：参考"><a href="#（六）十大经典排序算法：参考" class="headerlink" title="（六）十大经典排序算法：参考"></a>（六）十大经典排序算法：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">参考</a></h2><p><img src="/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/C-%E6%98%93%E6%B7%B7%E7%82%B9%5Csort.png" alt="排序算法分类"></p>
<ol>
<li>冒泡排序</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="comment">//注意限制条件j&lt;len-1-i</span></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">                                swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>快速排序</li>
<li><a href="https://www.cnblogs.com/hardyyao/p/9903278.html" target="_blank" rel="noopener">插入排序</a></li>
<li>选择排序</li>
<li>堆排序</li>
<li>归并排序</li>
</ol>
<ul>
<li>自顶向下</li>
<li>自底向上：注意底层达不到整数倍length的数据部分</li>
</ul>
<h2 id="（七）重点知识点"><a href="#（七）重点知识点" class="headerlink" title="（七）重点知识点"></a>（七）重点知识点</h2><ol>
<li><h5 id="printf-从右向左计算，从左向右输出，符合栈模型"><a href="#printf-从右向左计算，从左向右输出，符合栈模型" class="headerlink" title="printf 从右向左计算，从左向右输出，符合栈模型"></a>printf 从右向左计算，从左向右输出，符合栈模型</h5></li>
<li><h5 id="类中变量赋值顺序是变量声明顺序，所以赋值时先执行a-b-，再执行b-i-1-。a赋值为随机数"><a href="#类中变量赋值顺序是变量声明顺序，所以赋值时先执行a-b-，再执行b-i-1-。a赋值为随机数" class="headerlink" title="类中变量赋值顺序是变量声明顺序，所以赋值时先执行a(b)，再执行b(i+1)。a赋值为随机数"></a>类中变量赋值顺序是变量声明顺序，所以赋值时先执行a(b)，再执行b(i+1)。a赋值为随机数</h5></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base1</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>: <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    base1 ( <span class="keyword">int</span> i ) : b(i+<span class="number">1</span>),a(b)&#123;&#125;</span><br><span class="line">    base1():b(<span class="number">0</span>),a(b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_a</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_b</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">base1 <span class="title">obj1</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj1.get_a()&lt;&lt;<span class="built_in">endl</span>&lt;&lt;obj1.get_b()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5></li>
</ol>
<p>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。Static修饰的成员函数，在代码区分配内存。</p>
<ol start="4">
<li><h5 id="C-多态分为静态多态和动态多态"><a href="#C-多态分为静态多态和动态多态" class="headerlink" title="C++多态分为静态多态和动态多态"></a>C++多态分为静态多态和动态多态</h5></li>
</ol>
<p>静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。</p>
<ol start="5">
<li><h5 id="C-里面‘-’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。"><a href="#C-里面‘-’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。" class="headerlink" title="C++里面‘/’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。"></a>C++里面‘/’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。</h5></li>
<li><h5 id="派生访问说明符"><a href="#派生访问说明符" class="headerlink" title="派生访问说明符"></a>派生访问说明符</h5></li>
</ol>
<ul>
<li>public继承</li>
</ul>
<p>公有继承时，对基类的公有成员和保护成员的访问属性不变，<strong>派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员</strong>。派生类的对象只能访问派生类的公有成员（包括继承的公有成员），不能访问派生类和继承基类的保护成员和私有成员。</p>
<ul>
<li>protected继承</li>
</ul>
<p>保护继承中，基类的公有成员和保护成员被派生类继承后变成保护成员，<strong>派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员</strong>。派生类的对象只能访问派生类的公有成员，不能访问继承基类的公有成员、保护成员和私有成员。</p>
<ul>
<li>private继承</li>
</ul>
<p>私有继承时，基类的公有成员和保护成员都被派生类继承下来之后变成私有成员，<strong>派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员</strong>。派生类的对象只能访问派生类的公有成员，不能访问继承基类的公有成员、保护成员和私有成员。</p>
<ol start="7">
<li><h5 id="C-枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别"><a href="#C-枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别" class="headerlink" title="C++枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别"></a>C++枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别</h5></li>
</ol>
<ul>
<li>限定作用域的枚举类型的一般形式和不限范围的枚举类型不同</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非限定作用域</span></span><br><span class="line"><span class="keyword">enum</span> color&#123;</span><br><span class="line">    red,</span><br><span class="line">    green,</span><br><span class="line">    blue</span><br><span class="line">&#125;;</span><br><span class="line">color b=green;</span><br><span class="line"><span class="keyword">int</span> c=blue; <span class="comment">//正确</span></span><br><span class="line"><span class="comment">//限定作用域</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">color</span>:</span><span class="keyword">char</span></span><br><span class="line">&#123;</span><br><span class="line">    red,</span><br><span class="line">    green,</span><br><span class="line">    blue</span><br><span class="line">&#125;;</span><br><span class="line">color a=color::green;</span><br><span class="line"><span class="keyword">char</span> d=color:blue; <span class="comment">//错误，限定作用域的枚举类型不能用于初始化int类型的实体</span></span><br></pre></td></tr></table></figure>

<ul>
<li>限定作用域的枚举类型不能再作用域外访问枚举成员,必须显示地访问枚举成员，限定作用域的枚举型别带来的名字空间污染降低；不限范围的枚举型别可以</li>
<li>从限定作用域枚举型别到任何其他型别都不存在隐式转换路径（可实施强制型别转换）；不限范围的枚举型别可以</li>
<li>限定作用域的枚举型别和不限范围的枚举型别都支持底层型别指定。限定作用域的枚举型别的默认底层型别是int，而不限范围的枚举型别没有默认底层型别。</li>
<li>限定作用域的枚举型别总是可以进行前置声明，而不限范围的枚举型别却只有在指定了默认底层型别的前提下才可以进行前置声明。</li>
</ul>
<ol start="8">
<li><h5 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h5></li>
</ol>
<p>类型转换函数的语法格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1) type 可以是内置类型、类类型以及由 typedef 定义的类型别名，任何可作为函数返回类型的类型（void 除外）都能够被支持。一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的。</p>
<p>2) 类型转换函数一般不会更改被转换的对象，所以通常被定义为 const 成员。</p>
<p>3) 类型转换函数可以被继承，可以是虚函数。</p>
<p>4) 一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性。</p>
<p>5) 转换函数必须是成员函数，它的声明不能指定返回类型和参数列表。</p>
<ul>
<li>通常一个参数的构造函数在non-explicit的情况下同样能实现类型转换</li>
</ul>
<ol start="9">
<li><h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a><a href="https://www.cnblogs.com/liushui-sky/p/7727865.html" target="_blank" rel="noopener">内存泄漏</a></h5></li>
</ol>
<ul>
<li>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。三种类型的内存泄漏：</li>
</ul>
<p>（1）堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过<code>malloc</code>,<code>realloc</code>,<code>new</code>等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</p>
<p>（2）系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 <code>Bitmap</code>,<code>handle</code> ,<code>SOCKET</code>等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p>
<p>（3）没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是<code>virtual</code>，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露。</p>
<h3 id="c-中的内存泄漏的原因"><a href="#c-中的内存泄漏的原因" class="headerlink" title="c++中的内存泄漏的原因"></a>c++中的内存泄漏的原因</h3><ol>
<li>在类的构造函数和析构函数中没有匹配的调用new和delete函数</li>
</ol>
<p>两种情况下会出现这种内存泄露：一是在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存</p>
<ol start="2">
<li><p>没有正确地清除嵌套的对象指针</p>
</li>
<li><p>在释放对象数组时在delete中没有使用方括号</p>
</li>
</ol>
<p>方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄露。</p>
<p>释放单个对象、单个基本数据类型的变量或者是基本数据类型的数组不需要大小参数，释放定义了析构函数的对象数组才需要大小参数。</p>
<ol start="4">
<li>指向对象的指针数组不等同于对象数组</li>
</ol>
<p>对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间</p>
<p>指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。</p>
<ol start="5">
<li>缺少拷贝构造函数</li>
</ol>
<p>两次释放相同的内存是一种错误的做法，同时可能会造成堆的奔溃。</p>
<p>按值传递会调用（拷贝）构造函数，引用传递不会调用。</p>
<p>在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。</p>
<p>所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符</p>
<p> C++中构造函数，拷贝构造函数和赋值函数的区别和实现参见：<a href="http://www.cnblogs.com/liushui-sky/p/7728902.html" target="_blank" rel="noopener">http://www.cnblogs.com/liushui-sky/p/7728902.html</a></p>
<ol start="6">
<li>缺少重载赋值运算符</li>
</ol>
<p>这种问题跟上述问题类似，也是逐个成员拷贝的方式复制对象，如果这个类的大小是可变的，那么结果就是造成内存泄露，如下图<br><img src="/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt></p>
<ol start="7">
<li>关于nonmodifying运算符重载的常见迷思</li>
</ol>
<p>a. 返回栈上对象的引用或者指针（也即返回局部对象的引用或者指针）。导致最后返回的是一个空引用或者空指针，因此变成野指针</p>
<p>b. 返回内部静态对象的引用。</p>
<p>c. 返回一个泄露内存的动态分配的对象。导致内存泄露，并且无法回收</p>
<p>解决这一类问题的办法是重载运算符函数的返回值不是类型的引用，二应该是类型的返回值，即不是 int&amp;而是int</p>
<ol start="8">
<li>没有将基类的析构函数定义为虚函数</li>
</ol>
<p>当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露</p>
<p>9.析构的时候void*，导致析构函数没有调用</p>
<p>10.构造的时候浅拷贝，释放的时候调用了两遍delete</p>
<p>11.野指针：指向被释放的或者访问受限内存的指针。</p>
<p>造成野指针的原因：</p>
<p>指针变量没有被初始化（如果值不定，可以初始化为NULL）<br>指针被free或者delete后，没有置为NULL, free和delete只是把指针所指向的内存给释放掉，并没有把指针本身干掉，此时指针指向的是“垃圾”内存。释放后的指针应该被置为NULL.<br>指针操作超越了变量的作用范围，比如返回指向栈内存的指针就是野指针。</p>
<p><strong>解决办法</strong>：</p>
<p>（1）shared_ptr共享的智能指针：</p>
<p>shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。在最后一个shared_ptr析构的时候，内存才会被释放。</p>
<p>注意事项：<br>1.不要用一个原始指针初始化多个shared_ptr。<br>2.不要再函数实参中创建shared_ptr，在调用函数之前先定义以及初始化它。<br>3.不要将this指针作为shared_ptr返回出来。<br>4.要避免循环引用。</p>
<p>（2）unique_ptr独占的智能指针：</p>
<p>&lt;1&gt;Unique_ptr是一个独占的智能指针，他不允许其他的智能指针共享其内部的指针，不允许通过赋值将一个unique_ptr赋值给另外一个 unique_ptr。</p>
<p>&lt;2&gt;unique_ptr不允许复制，但可以通过函数返回给其他的unique_ptr，还可以通过std::move来转移到其他的unique_ptr，这样它本身就不再 拥有原来指针的所有权了。</p>
<p>&lt;3&gt;如果希望只有一个智能指针管理资源或管理数组就用unique_ptr，如果希望多个智能指针管理同一个资源就用shared_ptr。</p>
<p>(3)weak_ptr弱引用的智能指针：<br>弱引用的智能指针weak_ptr是用来监视shared_ptr的，不会使引用计数加一，它不管理shared_ptr内部的指针，主要是为了监视shared_ptr的生命 周期，更像是shared_ptr的一个助手。 weak_ptr没有重载运算符*和-&gt;，因为它不共享指针，不能操作资源，主要是为了通过shared_ptr获得资源的监测权，它的构造不会增加引用计数，它的析构不会减少引用计数，纯粹只是作为一个旁观者来监视shared_ptr中关连的资源是否存在。 weak_ptr还可以用来返回this指针和解决循环引用的问题。</p>
<ul>
<li>安全的代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>（1）delete 一次以后，p成了野指针，但是它作为地址的值还是有效的，还可以访问它以前指向的内存，不过那片内存被重新格式化了；<br>（2）指针非空时，delete运算只释放指针所指的地址空间，不会判断空间是否被占用，delete结束后不会将指针赋值为空，释放后别的指针变量也可以得到这片空间，<strong>该空间的值并不一定是NULL，所以delete后不能用是否为NULL来判断</strong>。用 if(p) 语句不能判断它指向的内存是否有效（此时它指向的内存无效，p本身有效）；<br>（3）delete 一次以后，不能再次delete，否则会报错；<br>（4）如果p指向的空间再次被new函数分配，即使是分配给别的指针，即使分配大小与原来不一样，此时如果误用p指针，仍然可以修改内存的值和从该处取出数值，甚至可以重新被delete，p的作用与新分配的指针一样；对同一非空指针delete多次，只有第一次delete被正确执行，之后的delete全部发生异常。对空指针delete多次可以正常执行。良好的习惯是，delete运算后手动将指针赋值为空。</p>
<ul>
<li>野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）,野指针的成因：</li>
</ul>
<p>1、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的默认值是随机的，它会乱指一气。<br>2、指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。<br>3、指针操作超越了变量的作用范围。这种情况让人防不胜防。</p>
<ul>
<li>悬空指针指指针正常初始化，曾指向过一个正常的对象，但是对象销毁了，该指针未置空，就成了悬空指针。例如指针p1、p2均指向对象a，delete p1后p2就是悬空指针，p1是野指针。</li>
</ul>
<ol start="10">
<li><h5 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h5></li>
</ol>
<p>在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，结构体变量所占空间的大小必定是最宽数据类型大小的整数倍。如有需要会在最后一个成员末尾填充若干字节使得所占空间大小是最宽数据类型大小的整数倍。内存对齐的原因：</p>
<ol>
<li><p>某些平台只能在特定的地址处访问特定类型的数据；</p>
</li>
<li><p>提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量</p>
</li>
<li><h5 id="大端小端"><a href="#大端小端" class="headerlink" title="大端小端"></a>大端小端</h5></li>
</ol>
<ul>
<li><p><strong>大端模式（Big_endian）</strong>：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。</p>
</li>
<li><p><strong>小端模式</strong>（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。</p>
</li>
<li><p><strong>口诀</strong>：大相反（低位存高位），小相同（低位存低位）。</p>
</li>
<li><p>联合体变量共享同一空间，可以通过联合体来判断大端小端。联合体同样存在内存对齐，所以联合长度至少可以容纳最大的成员。但是当最大成员大小不是<strong>最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍。</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkcpu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> w</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		<span class="keyword">char</span> b;</span><br><span class="line">	&#125;c;</span><br><span class="line">	c.a = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> (c.b == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(checkcpu() == <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"这是小端\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"这是大端\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li><h5 id="为什么析构函数可以virtual，构造函数不能呢？"><a href="#为什么析构函数可以virtual，构造函数不能呢？" class="headerlink" title="为什么析构函数可以virtual，构造函数不能呢？"></a>为什么析构函数可以virtual，构造函数不能呢？</h5></li>
</ol>
<ul>
<li><p>在公有继承中，基类的虚构函数如果不声明成为虚函数，delete p调用的是声明类型(即基类)的析构函数，所以只能销毁基类对象而无法销毁派生类对象，会发生销毁不完全的情况，那么销毁派生类时有可能造成资源泄漏。当基类的析构函数声明为虚函数，那么派生类的析构函数也是虚函数，此时调用delete p时发生动态绑定，运行时会根据实际类型调用该对象的虚函数。并不是要把所有类的析构函数都写成虚函数。只有当一个类是基类(即希望被继承)的时候才需要声明成虚函数，因为虚函数的作用是实现多态，而多态是建立在继承的基础上。单一类不能把析构函数写成虚函数，因为会产生额外的开销，比如虚表的创建和虚指针的定义。</p>
</li>
<li><p>（1）虚函数采用一种虚调用的办法。虚调用是一种可以在只有部分信息的情况下工作的机制，特别运行我们调用一个只知道接口而不知道其准确对象类型的函数。但是构造函数本身就是要初始化实例，要创建一个对象，构造函数肯定要知道对象的准确类型，因此构造函数不能为虚。</p>
<p>（2）虚函数对应虚函数表，虚函数表存储在对象的内存空间，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。</p>
<p>（3）虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p>
<p>（4）构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。</p>
<p>（5）当一个构造函数被调用时，它做的首要的事情之一是初始化它的V P T R。因此，它只能知道它是“当前”类的，而完全忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码- -既不是为基类，也不是为它的派生类（因为类不知道谁继承它）。所以它使用的V P T R必须是对于这个类的V TA B L E。而且，只要它是最后的构造函数调用，那么在这个对象的生命期内， V P T R将保持被初始化为指向这个V TA B L E, 但如果接着还有一个更晚派生的构造函数被调用，这个构造函数又将设置V P T R指向它的 V TA B L E，等直到最后的构造函数结束。V P T R的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类（most-derived）顺序的另一个理由。但是，当这一系列构造函数调用正发生时，每个构造函数都已经设置V P T R指向它自己的 V TA B L E。如果函数调用使用虚机制，它将只产生通过它自己的V TA B L E的调用，而不是最后的V TA B L E（所有构造函数被调用后才会有最后的V TA B L E）。</p>
</li>
</ul>
<h2 id="（八）友元函数"><a href="#（八）友元函数" class="headerlink" title="（八）友元函数"></a>（八）友元函数</h2><p>1）必须在类的说明中说明友元函数，说明时以关键字friend开头，后跟友元函数的函数原型，友元函数的说明可以出现在类的任何地方，包括在private和public部分；<br>2）注意友元函数不是类的成员函数，所以友元函数的实现和普通函数一样，在实现时不用”::”指示属于哪个类，只有成员函数才使用”::”作用域符号；<br>3）友元函数不能直接访问类的成员，只能访问对象成员，<br>4）友元函数可以访问对象的私有成员，但普通函数不行；<br>5）调用友元函数时，在实际参数中需要指出要访问的对象，<br>6）友元的声明只能出现在类定义的内部（最好在类定义开始或者结束前的位置集中声明友元），仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，必须在友元声明之外再对函数进行一次声明。每个类负责控制自己的友元类或友元函数，友元关系不存在传递性。类与类之间的友元关系不能继承.</p>
<h2 id="（九）外部排序"><a href="#（九）外部排序" class="headerlink" title="（九）外部排序"></a>（九）外部排序</h2><p>详见<a href="https://www.cnblogs.com/haimishasha/p/10898715.html#autoid-4-1-0" target="_blank" rel="noopener">外部排序算法总结</a></p>
<h2 id="字符数组初始化"><a href="#字符数组初始化" class="headerlink" title="字符数组初始化"></a>字符数组初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//char *strcpy(char *dest, const char *src)</span></span><br><span class="line"><span class="comment">//void *memset(void *str, int c, size_t n)</span></span><br><span class="line"><span class="comment">//void *memcpy(void *str1, const void *str2, size_t n)</span></span><br><span class="line"><span class="comment">//遇到char s[15]这条语句时, 编译程序会在内存的某处留</span></span><br><span class="line"><span class="comment">//出连续15个字节的区域, 并将第一个字节的地址赋给s。</span></span><br><span class="line"><span class="comment">//当遇到strcpy时, 首先在目标文件的某处建立一个"I am a students\0" 的字符串,不加'\0'编译器会自动补全，其中\0表示字符串终止, 终止符是编译时自动加上的, 然后一个字符一个字符地复制到s所指的内存区域。因此定义字符串数组时, 其元素个数至少应该比字符串的长度多1。</span></span><br><span class="line"><span class="comment">//注意:</span></span><br><span class="line"><span class="comment">//1. 字符串数组不能用"="直接赋值, 即s="Good News!"是不合法的。所以应分</span></span><br><span class="line"><span class="comment">//清字符串数组和字符串指针的不同赋值方法。</span></span><br><span class="line"><span class="keyword">char</span> st[<span class="number">15</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(st,<span class="string">"I am a students"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* st=<span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(st,<span class="string">"I am a students"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* st=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">15</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(st,<span class="string">"I am a students"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* st=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(st,<span class="string">"I am a students"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反转字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseWord</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">begin</span>,<span class="keyword">char</span>* <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">begin</span>&lt;<span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp=*<span class="built_in">begin</span>;</span><br><span class="line">        *<span class="built_in">begin</span>=*<span class="built_in">end</span>;</span><br><span class="line">        *<span class="built_in">end</span>=tmp;</span><br><span class="line">        <span class="built_in">begin</span>++;</span><br><span class="line">        <span class="built_in">end</span>--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">begin</span>=str;</span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">end</span>=str;</span><br><span class="line">    <span class="keyword">while</span>(*<span class="built_in">begin</span>!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*<span class="built_in">begin</span>==<span class="string">' '</span>)&#123;</span><br><span class="line">            <span class="built_in">begin</span>++;</span><br><span class="line">            <span class="built_in">end</span>++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*<span class="built_in">end</span>==<span class="string">' '</span>|| *<span class="built_in">end</span>==<span class="string">'\0'</span>)&#123;</span><br><span class="line">            reverseWord(<span class="built_in">begin</span>,--<span class="built_in">end</span>);</span><br><span class="line">            <span class="built_in">begin</span>=++<span class="built_in">end</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="built_in">end</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    reverseWord(str,str+n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    char* st=(char*)malloc(14);</span></span><br><span class="line"><span class="comment">//    strcpy(st,"I am a students");</span></span><br><span class="line"><span class="comment">//    char* st=new char[15];</span></span><br><span class="line"><span class="comment">//    memcpy(st,"I am a students",15);</span></span><br><span class="line"><span class="comment">//    char st[]="I am a students";</span></span><br><span class="line"><span class="comment">//    char st[16]="I am a students";</span></span><br><span class="line">    <span class="keyword">char</span> st[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(st,<span class="string">"I am a students"</span>,<span class="number">15</span>);</span><br><span class="line">    reverse(st);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;st&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str1[]=&#123;<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">strlen</span>(str1)&lt;&lt;<span class="string">"   str1="</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈方向从右向左，str2[]没有长度规定，所以输出的时候连带str1也输出了出来</span></span><br><span class="line">    <span class="keyword">char</span> str2[]=&#123;<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">strlen</span>(str2)&lt;&lt;<span class="string">"   str2="</span>&lt;&lt;str2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str3[<span class="number">3</span>]=&#123;<span class="string">'5'</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">strlen</span>(str3)&lt;&lt;<span class="string">"   str3="</span>&lt;&lt;str3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str4[<span class="number">4</span>]=<span class="string">"abc"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">strlen</span>(str4)&lt;&lt;<span class="string">"   str4="</span>&lt;&lt;str4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">students a am I</span><br><span class="line"><span class="number">3</span>   str1=<span class="number">123</span></span><br><span class="line"><span class="number">9</span>   str2=<span class="number">123456123</span></span><br><span class="line"><span class="number">1</span>   str3=<span class="number">5</span></span><br><span class="line"><span class="number">3</span>   str4=abc</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">//循环变量</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> *p = str;</span><br><span class="line">    <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));  <span class="comment">//只能写sizeof(str), 不能写sizeof(p)</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\x20"</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">根据<span class="built_in">memset</span>函数的不同，输出结果也不同，分为以下几种情况：</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));  <span class="comment">//地址的大小都是4字节</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(*p));  <span class="comment">//*p表示的是一个字符变量, 只有一字节</span></span><br><span class="line"><span class="number">0</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="number">10</span>);  <span class="comment">//直接写10也行, 但不专业</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h2 id="如何只能做堆上创建对象"><a href="#如何只能做堆上创建对象" class="headerlink" title="如何只能做堆上创建对象"></a>如何只能做堆上创建对象</h2><p>在C++中，类的创建分为两种。一种是静态创建，即直接创建对象；另一种是动态创建对象，即通过 <strong>new</strong> 创建，如 T *t = new T。要想正确回答上题，就必须知道这两种创建方式的区别。</p>
<p><strong>1 静态创建</strong></p>
<p>由编译器在栈中为对象分配内存，通过移动栈顶指针获得合适大小的空间，然后<strong>调用对象的构造函数生成</strong>对象。</p>
<p><strong>2 动态创建</strong></p>
<p>通过new在堆中创建对象。这个过程分为两步：首先在堆中找到合适大小的空间并分配，然后<strong>调用对象的构造函数</strong>生成对象。</p>
<p>因为两者都需要调用对象的构造函数，所以通过将<strong>构造函数私有化</strong>的做法是行不通的。那么还有其他办法吗？这是就需要了解静态创建的另一个特点了。</p>
<p><strong>编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。</strong></p>
<p>所以我们只需要将析构函数私有化就可以组织直接创建对象了。由于栈的创建和释放都需要由系统完成的，所以若是无法调用构造或者析构函数，自然会报错。</p>
<p>当然为了我们能够正确释放动态创建的对象，我们必须提供一个公有函数，该函数的唯一功能就是<strong>删除对象本身</strong>。</p>
<p> 测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	~test()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"test destroy"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//test p;//编译器报错test::~test()不可访问</span></span><br><span class="line">	test *p = <span class="keyword">new</span> test;</span><br><span class="line">	p-&gt;destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="只能在栈上创建对象"><a href="#只能在栈上创建对象" class="headerlink" title="只能在栈上创建对象"></a>只能在栈上创建对象</h2><p>既然可以做到只在堆上创建对象，同样的我们可以只在栈上创建对象。</p>
<p>其实理解了这个理念，不难想到我们只需要<strong>让new操作符无法使用即可，</strong>要做到这件事，我们可以将<strong>new操作符重载并设置为私有访问</strong>即可。</p>
<p>重载new的同时最好重载delete</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"test destroy"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//test *A = new test;</span></span><br><span class="line">	<span class="comment">//编译器报错函数test::operator new 不可访问</span></span><br><span class="line">	test A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-static、const-和-static-const-类型成员变量声明以及初始化"><a href="#C-static、const-和-static-const-类型成员变量声明以及初始化" class="headerlink" title="C++ static、const 和 static const 类型成员变量声明以及初始化"></a><a href="https://www.runoob.com/w3cnote/cpp-static-const.html" target="_blank" rel="noopener">C++ static、const 和 static const 类型成员变量声明以及初始化</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test():a(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">enum</span> &#123;size1=<span class="number">100</span>,size2=<span class="number">200</span>&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;<span class="comment">//只能在构造函数初始化列表中初始化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b;<span class="comment">//在类的实现文件中定义并初始化</span></span><br><span class="line">    conststatic <span class="keyword">int</span> c;<span class="comment">//与 static const int c;相同。</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Test::b=<span class="number">0</span>;<span class="comment">//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。</span></span><br><span class="line">cosnt intTest::c=<span class="number">0</span>;<span class="comment">//注意：给静态成员变量赋值时，不需要加static修饰符，但要加cosnt。</span></span><br></pre></td></tr></table></figure>

<h2 id="c方式编译的c-文件决定不能出现重载函数"><a href="#c方式编译的c-文件决定不能出现重载函数" class="headerlink" title="c方式编译的c++文件决定不能出现重载函数"></a><a href="https://www.cnblogs.com/Yogurshine/p/3913073.html" target="_blank" rel="noopener">c方式编译的c++文件决定不能出现重载函数</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用c方式编译的代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></span><br></pre></td></tr></table></figure>

<p>对于一份.c文件，采用gcc编译时候没有定义__cplusplus，宏判断不起作用，且自是用c语言的方式编译，采用g++编译定义了_cplusplus，经过上面宏判断，所以还是会以c语言的方式编译。注意，extern “C”是g++才具有的关键字，gcc并没有，所以如果用gcc编译而不加以宏判断直接使用extern “C”那么就会出现语法错误。<br>用c方式去编译c++文件，还要注意重载函数。c方式编译的c++文件决定不能出现重载函数。</p>
<h2 id="内存对齐的作用"><a href="#内存对齐的作用" class="headerlink" title="内存对齐的作用"></a>内存对齐的作用</h2><p>1.为了更好的跨平台，原因：某些硬件只能从特定的内存地址中读取特定类型的数据，然而每个数据的所占的字节数不同，需要统一对齐，那样才会比较方便读取，所以为啥C++比较好跨平台的原因也就是这样。<br>2.加快CPU访问性能，加快的原因是假如一个int或者double类型的数据占4字节的情况下，然后她的起始字节数假设是从1开始，cpu读取的话，就得先1-4 4-8 然后提出1.5-8 再把2-5的字节数放进寄存器，那样效率大大降低，但是对于现在的cpu来说，这种应该不算什么。<br>总结：基本上如今的机器，需要内存对齐的原因，主要是因为更好的跨平台</p>
<p><strong>内存对齐的规则：</strong></p>
<p>1、 对于结构的各个成员，第一个成员位于偏移为0的位置，以后每个数据成员的偏移量必须是min(#pragma pack()指定的数，这个数据成员的自身长度) 的倍数。</p>
<p>2、 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p>
<h2 id="C-设计一个类：只能在堆上创建对象、只能在栈上创建对象、只能创建一个对象"><a href="#C-设计一个类：只能在堆上创建对象、只能在栈上创建对象、只能创建一个对象" class="headerlink" title="C++设计一个类：只能在堆上创建对象、只能在栈上创建对象、只能创建一个对象"></a>C++设计一个类：只能在堆上创建对象、只能在栈上创建对象、只能创建一个对象</h2><p>在C++中，创建类的对象有两种方法，一种是静态建立，A a; 另一种是动态建立，调用new 操作符。</p>
<h3 id="一、只能在堆上创建对象"><a href="#一、只能在堆上创建对象" class="headerlink" title="一、只能在堆上创建对象"></a>一、只能在堆上创建对象</h3><ul>
<li>就是动态建立类的对象，使用new操作符来完成。</li>
<li>做法一：将该类的构造函数和析构函数权限设为protected，(可以让该类可以被继承)，然后定义两个static 函数来调用new ，delete 来创建和销毁对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    A()</span><br><span class="line">    &#123;&#125;;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    static A* Create()</span><br><span class="line">    &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void Destory(A* p)</span><br><span class="line">    &#123;</span><br><span class="line">        delete p;</span><br><span class="line">        p &#x3D; NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>做法二：<br>对象建立在栈上面时，是由编译器分配空间的，调用构造函数来构造栈对象，当对象使用完之后，编译器会调用析构函数来释放栈对象所占的空间，编译器管理了对象的整个生命周期，编译器为对象分配空间的时候，只要是非静态的函数都会检查，包括析构函数，但是此时析构函数不可访问，编译器无法调用类的析构函数来释放内存，那么编译器将无法在栈上为对象分配内存。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;A a;&#x2F;&#x2F;栈上创建</span><br><span class="line">    A* p &#x3D; new A;&#x2F;&#x2F;堆上创建</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、只能在栈上创建对象"><a href="#二、只能在栈上创建对象" class="headerlink" title="二、只能在栈上创建对象"></a>二、只能在栈上创建对象</h3><ul>
<li>只能在栈上创建的对象的话，就是不能调用new 操作符，所以可以将operator new 和operator delete 设置为私有的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    void* operator new(size_t)&#123;&#125;;</span><br><span class="line">    void operator delete(void*)&#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    AA()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;AA()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~AA()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~AA()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="三、只能创建一个对象"><a href="#三、只能创建一个对象" class="headerlink" title="三、只能创建一个对象"></a>三、只能创建一个对象</h3><ul>
<li>在类中创建一个静态变量Count，用来限制可创建的实例的数量。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> singleclass* <span class="title">getsingleclass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> singleclass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    singleclass()&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字符串编码方式"><a href="#字符串编码方式" class="headerlink" title="字符串编码方式"></a>字符串编码方式</h2><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte）。一个字节能表示的最大的整数就是255（2^8-1=255），而ASCII编码，占用0 - 127用来表示大小写英文字母、数字和一些符号，这个编码表被称为<a href="https://baike.baidu.com/item/ASCII编码/3712529" target="_blank" rel="noopener">ASCII编码</a>，比如大写字母A的编码是65，小写字母z的编码是122。</p>
<p>如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了<a href="https://baike.baidu.com/item/GB2312/483170" target="_blank" rel="noopener">GB2312</a>编码，用来把中文编进去。</p>
<p>类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>
<p>Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。</p>
<p>在Unicode中：汉字“字”对应的数字是23383（十进制），十六进制表示为5B57。在Unicode中，我们有很多方式将数字23383表示成程序中的数据，包括：<a href="https://baike.baidu.com/item/UTF-8" target="_blank" rel="noopener">UTF-8</a>、<a href="https://baike.baidu.com/item/UTF-16" target="_blank" rel="noopener">UTF-16</a>、<a href="https://baike.baidu.com/item/UTF-32" target="_blank" rel="noopener">UTF-32</a>。UTF是“Unicode Transformation Format”的缩写，可以翻译成Unicode字符集转换格式，即怎样将Unicode定义的数字转换成程序数据。</p>
<p><img src="/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/unicode%E5%88%97%E8%A1%A8.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点,这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s=<span class="string">"\u00234\67"</span>;<span class="comment">//   0023是16进制对应#；4；\67是8进制对应7</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s;<span class="comment">//   #47</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ASCLL码"><a href="#ASCLL码" class="headerlink" title="ASCLL码"></a>ASCLL码</h3><p>所有的<a href="https://baike.baidu.com/item/ASCII码" target="_blank" rel="noopener">ASCII码</a>都可以用“\”加数字（一般是8进制数字）来表示。而C中定义了一些字母前加”&quot;来表示常见的那些不能显示的ASCII<a href="https://baike.baidu.com/item/字符" target="_blank" rel="noopener">字符</a>，如\0,\t,\n等，就称为转义字符，因为后面的<a href="https://baike.baidu.com/item/字符/4768913" target="_blank" rel="noopener">字符</a>，都不是它本来的ASCII字符意思了。</p>
<ol>
<li>所有的转义字符和所对应的意义：</li>
</ol>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>响铃(BEL)</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>\</td>
<td>代表一个反斜线字符’’&#39;</td>
<td>092</td>
</tr>
<tr>
<td>&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>空字符(NUL)</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>1到3位八进制数所代表的任意字符</td>
<td>三位八进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>十六进制所代表的任意字符</td>
<td>十六进制</td>
</tr>
</tbody></table>
<p><em>注意：</em></p>
<p><em>1. 区分，斜杠：”/“ 与 反斜杠：”&quot; ,此处不可互换</em></p>
<p><em>2. \xhh 十六进制转义不限制字符个数 ‘\x000000000000F’ == ‘\xF’ [3]</em> </p>
<ol start="2">
<li>字符型常量：</li>
</ol>
<p>C语言中字符型常量所表示的值是int型所能包含的值。我们可以用ASCII<a href="https://baike.baidu.com/item/表达式" target="_blank" rel="noopener">表达式</a>来表示一个字符型常量，或者用单引号内加<a href="https://baike.baidu.com/item/反斜杠" target="_blank" rel="noopener">反斜杠</a>表示转义字符。</p>
<p>‘A’, ‘\x2f’, ‘\013’;</p>
<p>其中：\x表示后面的字符是<a href="https://baike.baidu.com/item/十六进制数" target="_blank" rel="noopener">十六进制数</a>，\0表示后面的字符是八进制数。例如十进制的17用十六进制表示就是</p>
<p>‘\x11’,用八进制表示就是‘\021’;</p>
<p>上面我们见到的\x,\n,\a等等都是叫转义字符，它告诉<a href="https://baike.baidu.com/item/编译器" target="_blank" rel="noopener">编译器</a>需要用特殊的方式进行处理。</p>
<p>转义字符以<code>\</code>或者<code>\x</code>开头，以<code>\</code>开头表示后跟八进制形式的编码值，以<code>\x</code>开头表示后跟十六进制形式的编码值。对于转义字符来说，只能使用八进制或者十六进制。</p>
<p>字符 1、2、3、a、b、c 对应的 ASCII 码的八进制形式分别是 61、62、63、141、142、143，十六进制形式分别是 31、32、33、61、62、63。下面的例子演示了转义字符的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char a = '\61';  //字符1</span><br><span class="line"><span class="keyword">char</span> b = <span class="string">'\141'</span>;  <span class="comment">//字符a</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'\x31'</span>;  <span class="comment">//字符1</span></span><br><span class="line"><span class="keyword">char</span> d = <span class="string">'\x61'</span>;  <span class="comment">//字符a</span></span><br><span class="line"><span class="keyword">char</span> *str1 = <span class="string">"\x31\x32\x33\x61\x62\x63"</span>;  <span class="comment">//字符串"123abc"</span></span><br><span class="line"><span class="keyword">char</span> *str2 = <span class="string">"\61\62\63\141\142\143"</span>;  <span class="comment">//字符串"123abc"</span></span><br><span class="line"><span class="keyword">char</span> *str3 = <span class="string">"The string is: \61\62\63\x61\x62\x63"</span>  <span class="comment">//混用八进制和十六进制形式</span></span><br></pre></td></tr></table></figure>

<p>转义字符既可以用于单个字符，也可以用于字符串，并且一个字符串中可以同时使用八进制形式和十六进制形式。</p>
<p>一个完整的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"\x68\164\164\x70://c.biancheng.\x6e\145\x74"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a></p>
<p>转义字符的初衷是用于 ASCII 编码，所以它的取值范围有限：</p>
<ul>
<li>八进制形式的转义字符最多后跟三个数字，也即<code>\ddd</code>，最大取值是<code>\177</code>；</li>
<li>十六进制形式的转义字符最多后跟两个数字，也即<code>\xdd</code>，最大取值是<code>\7f</code>。</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>编译器优化常用的方法有：将内存变量缓存到寄存器；调整指令顺序充分利用CPU指令流水线，常见的是重新排序读写指令。对常规内存进行优化的时候，这些优化是透明的，而且效率很好。由硬件重新排序引起的问题的解决办法是在从硬件（或者其他处理器）的角度看必须以特定顺序执行的操作之间设置内存屏障（memory barrier）.<br>用volatile关键字禁止做这些优化，volatile的字面含义是易变的，告诉编译器（GCC）:<br>1）不要将该段内嵌汇编指令与前面的指令重新排序；也就是在执行内嵌汇编代码之前，它前面的指令都执行完毕<br>2）不要将变量缓存到寄存器，因为这段代码可能会用到内存变量，而这些内存变量会以不可预知的方式发生改变，因此GCC插入必要的代码先将缓存到寄存器的变量值写回内存，如果后面又访问这些变量，需要重新访问内存。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.volatile关键字的两层含义</p>
<p> 一旦一个变量（类成员变量、类的静态成员变量）被volatile修饰之后，就具备了两层含义：<br>  ①保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其它线程来说是立即可见的。<br>  ②禁止进行指令重排序</p>
<p>2.volatile保证原子性吗？</p>
<p> volatile关键字保证了操作的可见性，不能保证对变量的任何操作都是原子性的。</p>
<p>3.volatile保证有序性吗？</p>
<p> volatile在一定程度上保证有序性。<br> volatile关键字禁止指令重排序有两层意思：<br>  ①当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行<br>  ②在进行指令优化时，不能将在对volatile变量访问的语句放在其后面进行，也不能把volatile变量后面的语句放到其前面执行。</p>
<p>4.volatile原理和实现机制</p>
<p> 观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码实现，加入volatile关键字时，会多出一个lock前缀指令：<br> lock前缀指令实际上相当于一个内存屏障（也称内存栅栏），内存屏障提供3个功能：<br>  ①它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>  ②它会强制将对缓存的修改操作立即写入主存；<br>  ③如果是写操作，它会导致其它CPU中对应的缓存行失效</p>
<p><strong>补充</strong>：<br>第一：使用volatile关键字会强制将修改的值立即写入主存；<br>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；<br>第三：由于线程1的工作内存中缓存变量的缓存行无效，所以线程1再次读取变量的值时会去主存读取。<br>最重要的是：</p>
<p>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。<br>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</p>
<p><strong>volatile为什么不能保证原子性</strong>:<br>volatile方式的i++，总共是四个步骤：i++实际为load、Increment、store、Memory Barriers 四个操作。内存屏障是线程安全的,但是内存屏障之前的指令并不是.在某一时刻线程1将i的值load取出来，放置到cpu缓存中，然后再将此值放置到寄存器A中，然后A中的值自增1（寄存器A中保存的是中间值，没有直接修改i，因此其他线程并不会获取到这个自增1的值）。如果在此时线程2也执行同样的操作，获取值i==10,自增1变为11，然后马上刷入主内存。此时由于线程2修改了i的值，实时的线程1中的i==10的值缓存失效，重新从主内存中读取，变为11。接下来线程1恢复。将自增过后的A寄存器值11赋值给cpu缓存i。这样就出现了线程安全问题。</p>
<p>线程安全性问题可以总结为： 可见性 、 原子性 、 有序性 .</p>
<p>如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。</p>
<h3 id="乱序执行与编译器重排序优化的比较编辑"><a href="#乱序执行与编译器重排序优化的比较编辑" class="headerlink" title="乱序执行与编译器重排序优化的比较编辑"></a>乱序执行与编译器重排序优化的比较编辑</h3><p>C与C++语言中，volatile关键字意图允许内存映射的I/O操作。这要求编译器对此的数据读写按照程序中的先后顺序执行，不能对volatile内存的读写重排序。因此关键字volatile并不保证是一个内存屏障。<br>对于Visual Studio 2003，编译器保证对volatile的操作是有序的，但是不能保证处理器的乱序执行。因此，可以使用InterlockedCompareExchange或InterlockedExchange函数。<br>对于Visual Studio 2005及以后版本，编译器对volatile变量的读操作使用acquire semantics，对写操作使用release semantics。</p>
<h3 id="编译器屏障-Compiler-Barrior"><a href="#编译器屏障-Compiler-Barrior" class="headerlink" title="编译器屏障 Compiler Barrior"></a>编译器屏障 Compiler Barrior</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* The &quot;volatile&quot; is due to gcc bugs *&#x2F;</span><br><span class="line">#define barrier() __asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;) </span><br><span class="line">阻止编译器重排，保证编译程序时在优化屏障之前的指令不会在优化屏障之后执行。</span><br></pre></td></tr></table></figure>
<h3 id="CPU屏障-CPU-Barrior"><a href="#CPU屏障-CPU-Barrior" class="headerlink" title="CPU屏障 CPU Barrior"></a>CPU屏障 CPU Barrior</h3><p>CPU级别内存屏障其作用有两个：</p>
<p>防止指令之间的重排序<br>保证数据的可见性<br>指令重排中Load和Store两种操作会有Load-Store、Store-Load、Load-Load、Store-Store这四种可能的乱序结果。</p>
<p>Intel为此提供三种内存屏障指令：</p>
<p>sfence ，实现Store Barrior 会将store buffer中缓存的修改刷入L1 cache中，使得其他cpu核可以观察到这些修改，而且之后的写操作不会被调度到之前，即sfence之前的写操作一定在sfence完成且全局可见；<br>lfence ，实现Load Barrior 会将invalidate queue失效，强制读取入L1 cache中，而且lfence之后的读操作不会被调度到之前，即lfence之前的读操作一定在lfence完成（并未规定全局可见）；<br>mfence ，实现Full Barrior 同时刷新store buffer和invalidate queue，保证了mfence前后的读写操作的顺序，同时要求mfence之后写操作结果全局可见之前，mfence之前写操作结果全局可见；<br>lock 用来修饰当前指令操作的内存只能由当前CPU使用，若指令不操作内存仍然由用，因为这个修饰会让指令操作本身原子化，而且自带Full Barrior效果；还有指令比如IO操作的指令、exch等原子交换的指令，任何带有lock前缀的指令以及CPUID等指令都有内存屏障的作用。<br>X86-64下仅支持一种指令重排：Store-Load ，即读操作可能会重排到写操作前面，同时不同线程的写操作并没有保证全局可见序，例子见《Intel® 64 and IA-32 Architectures Software Developer’s Manual》手册8.6.1、8.2.3.7节。要注意的是这个问题只能用mfence解决，不能靠组合lfence和sfence解决。（用sfence+lfence组合仅可以解决重排问题，但不能解决全局可见性问题，简单理解不如视为sfence和lfence本身也能乱序重排）</p>
<p>X86-64一般情况根本不会需要使用lfence与sfence这两个指令，除非操作Write-Through内存或使用 non-temporal 指令（NT指令，属于SSE指令集），比如movntdq, movnti, maskmovq，这些指令也使用Write-Through内存策略，通常使用在图形学或视频处理，Linux编程里就需要使用GNC提供的专门的函数（例子见参考资料13：Memory part 5: What programmers can do）。</p>
<p>下面是GNU中的三种内存屏障定义方法，结合了编译器屏障和三种CPU屏障指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define lfence() __asm__ __volatile__(&quot;lfence&quot;: : :&quot;memory&quot;) </span><br><span class="line">#define sfence() __asm__ __volatile__(&quot;sfence&quot;: : :&quot;memory&quot;) </span><br><span class="line">#define mfence() __asm__ __volatile__(&quot;mfence&quot;: : :&quot;memory&quot;)</span><br></pre></td></tr></table></figure>
<p>代码中仍然使用lfence()与sfence()这两个内存屏障应该也是一种长远的考虑。按照Interface写代码是最保险的，万一Intel以后出一个采用弱一致模型的CPU，遗留代码出问题就不好了。目前在X86下面视为编译器屏障即可。</p>
<h2 id="线程资源的回收"><a href="#线程资源的回收" class="headerlink" title="线程资源的回收"></a>线程资源的回收</h2><p>线程有joinable和unjoinable两种状态，如果线程是joinable状态，当子线程的主函数终止时（自己退出或调用pthread_exit退出）不会释放线程所占用内用资源，这种线程被称为“僵尸线程”。创建线程时默认属性连接的joinable,即是非分离的。可以pthread_join获取线程返回值后，通过pthread_cancel取消线程，回收线程资源。</p>
<h2 id="vector内存分配"><a href="#vector内存分配" class="headerlink" title="vector内存分配"></a>vector内存分配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; test;</span><br><span class="line">    std::cout &lt;&lt; test.capacity()&lt;&lt;&quot;  size:&quot; &lt;&lt; test.size()&lt;&lt; std::endl;</span><br><span class="line">    test.resize(10);</span><br><span class="line">    std::cout &lt;&lt; test.capacity()&lt;&lt;&quot;  size:&quot; &lt;&lt; test.size()&lt;&lt; std::endl;</span><br><span class="line">    test.reserve(20);</span><br><span class="line">    std::cout &lt;&lt; test.capacity() &lt;&lt;&quot;  size:&quot;&lt;&lt; test.size()&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    test.push_back(2);</span><br><span class="line">    for(auto&amp; v:test)&#123;</span><br><span class="line">        cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    std::cout &lt;&lt; test.capacity() &lt;&lt;&quot;  size:&quot;&lt;&lt; test.size()&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    test.push_back(2);</span><br><span class="line">    for(auto&amp; v:test)&#123;</span><br><span class="line">        cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    std::cout &lt;&lt; test.capacity() &lt;&lt;&quot;  size:&quot;&lt;&lt; test.size()&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0;i&lt;8;i++)</span><br><span class="line">        test.push_back(2);</span><br><span class="line">    for(auto&amp; v:test)&#123;</span><br><span class="line">        cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    std::cout &lt;&lt; test.capacity() &lt;&lt;&quot;  size:&quot;&lt;&lt; test.size()&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    test.push_back(2);</span><br><span class="line">    for(auto&amp; v:test)&#123;</span><br><span class="line">        cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    std::cout &lt;&lt; test.capacity() &lt;&lt;&quot;  size:&quot;&lt;&lt; test.size()&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0;i&lt;20;i++)</span><br><span class="line">        test.push_back(2);</span><br><span class="line">    for(auto&amp; v:test)&#123;</span><br><span class="line">        cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    std::cout &lt;&lt; test.capacity() &lt;&lt;&quot;  size:&quot;&lt;&lt; test.size()&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    test.reserve(90);</span><br><span class="line">    std::cout &lt;&lt; test.capacity() &lt;&lt;&quot;  size:&quot;&lt;&lt; test.size()&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    test.resize(100);</span><br><span class="line">    std::cout &lt;&lt; test.capacity() &lt;&lt;&quot;  size:&quot;&lt;&lt; test.size()&lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/vector%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png" alt></p>
<h3 id="reserve和resize的区别"><a href="#reserve和resize的区别" class="headerlink" title="reserve和resize的区别"></a>reserve和resize的区别</h3><p>void reserve (size_type n);<br>reserver函数用来给vector预分配存储区大小，即capacity的值 ，但是没有给这段内存进行初始化。reserve 的参数n是推荐预分配内存的大小，实际分配的可能等于或大于这个值，即n大于capacity的值，就会reallocate内存 capacity的值会大于或者等于n 。这样，当调用push_back函数使得size 超过原来的默认分配的capacity值时 避免了内存重分配开销。</p>
<p>需要注意的是：reserve 函数分配出来的内存空间，只是表示vector可以利用这部分内存，但vector不能有效地访问这些内存空间，访问的时候就会出现越界现象，导致程序崩溃。</p>
<p>void resize (size_type n);<br>void resize (size_type n, value_type val);<br>resize函数重新分配大小，改变容器的大小，并且创建对象</p>
<p>当n小于当前size()值时候，vector首先会减少size()值 保存前n个元素，然后将超出n的元素删除(remove and destroy)</p>
<p>当n大于当前size()值时候，vector会插入相应数量的元素 使得size()值达到n，并对这些元素进行初始化，如果调用上面的第二个resize函数，指定val，vector会用val来初始化这些新插入的元素</p>
<p>当n大于capacity()值的时候，会自动分配重新分配内存存储空间。</p>
<h3 id="vector扩容的两种方式"><a href="#vector扩容的两种方式" class="headerlink" title="vector扩容的两种方式"></a>vector扩容的两种方式</h3><ol>
<li>当元素添加数目大于当前capacity时VS2015扩容1.5倍，mingw 和 GCC扩容2倍 <a href="https://www.cnblogs.com/-citywall123/p/12846941.html" target="_blank" rel="noopener">最好1.5-2倍扩容的原因</a></li>
<li>reserve 和 resize</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/24/MySQL/" rel="next" title="MySQL">
                <i class="fa fa-chevron-left"></i> MySQL
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/" rel="prev" title="面试要点记录">
                面试要点记录 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">翟安然</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#（一）虚函数表指针、虚基类表指针"><span class="nav-number">1.</span> <span class="nav-text">（一）虚函数表指针、虚基类表指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（二）万能头文件"><span class="nav-number">2.</span> <span class="nav-text">（二）万能头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（三）加速c"><span class="nav-number">3.</span> <span class="nav-text">（三）加速c++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（四）运算符优先级"><span class="nav-number">4.</span> <span class="nav-text">（四）运算符优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（五）c-11新特性：参考"><span class="nav-number">5.</span> <span class="nav-text">（五）c++11新特性：参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#auto-ptr-C-11已经舍弃"><span class="nav-number">5.1.</span> <span class="nav-text">auto_ptr(C++11已经舍弃)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-ptr（替换auto-ptr）"><span class="nav-number">5.2.</span> <span class="nav-text">unique_ptr（替换auto_ptr）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（六）十大经典排序算法：参考"><span class="nav-number">6.</span> <span class="nav-text">（六）十大经典排序算法：参考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（七）重点知识点"><span class="nav-number">7.</span> <span class="nav-text">（七）重点知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#printf-从右向左计算，从左向右输出，符合栈模型"><span class="nav-number">7.0.0.1.</span> <span class="nav-text">printf 从右向左计算，从左向右输出，符合栈模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类中变量赋值顺序是变量声明顺序，所以赋值时先执行a-b-，再执行b-i-1-。a赋值为随机数"><span class="nav-number">7.0.0.2.</span> <span class="nav-text">类中变量赋值顺序是变量声明顺序，所以赋值时先执行a(b)，再执行b(i+1)。a赋值为随机数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#static"><span class="nav-number">7.0.0.3.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-多态分为静态多态和动态多态"><span class="nav-number">7.0.0.4.</span> <span class="nav-text">C++多态分为静态多态和动态多态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-里面‘-’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。"><span class="nav-number">7.0.0.5.</span> <span class="nav-text">C++里面‘&#x2F;’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#派生访问说明符"><span class="nav-number">7.0.0.6.</span> <span class="nav-text">派生访问说明符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别"><span class="nav-number">7.0.0.7.</span> <span class="nav-text">C++枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类型转换函数"><span class="nav-number">7.0.0.8.</span> <span class="nav-text">类型转换函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内存泄漏"><span class="nav-number">7.0.0.9.</span> <span class="nav-text">内存泄漏</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-中的内存泄漏的原因"><span class="nav-number">7.1.</span> <span class="nav-text">c++中的内存泄漏的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#sizeof"><span class="nav-number">7.1.0.1.</span> <span class="nav-text">sizeof</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#大端小端"><span class="nav-number">7.1.0.2.</span> <span class="nav-text">大端小端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么析构函数可以virtual，构造函数不能呢？"><span class="nav-number">7.1.0.3.</span> <span class="nav-text">为什么析构函数可以virtual，构造函数不能呢？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（八）友元函数"><span class="nav-number">8.</span> <span class="nav-text">（八）友元函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（九）外部排序"><span class="nav-number">9.</span> <span class="nav-text">（九）外部排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符数组初始化"><span class="nav-number">10.</span> <span class="nav-text">字符数组初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何只能做堆上创建对象"><span class="nav-number">11.</span> <span class="nav-text">如何只能做堆上创建对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#只能在栈上创建对象"><span class="nav-number">12.</span> <span class="nav-text">只能在栈上创建对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-static、const-和-static-const-类型成员变量声明以及初始化"><span class="nav-number">13.</span> <span class="nav-text">C++ static、const 和 static const 类型成员变量声明以及初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c方式编译的c-文件决定不能出现重载函数"><span class="nav-number">14.</span> <span class="nav-text">c方式编译的c++文件决定不能出现重载函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存对齐的作用"><span class="nav-number">15.</span> <span class="nav-text">内存对齐的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-设计一个类：只能在堆上创建对象、只能在栈上创建对象、只能创建一个对象"><span class="nav-number">16.</span> <span class="nav-text">C++设计一个类：只能在堆上创建对象、只能在栈上创建对象、只能创建一个对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、只能在堆上创建对象"><span class="nav-number">16.1.</span> <span class="nav-text">一、只能在堆上创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、只能在栈上创建对象"><span class="nav-number">16.2.</span> <span class="nav-text">二、只能在栈上创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、只能创建一个对象"><span class="nav-number">16.3.</span> <span class="nav-text">三、只能创建一个对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串编码方式"><span class="nav-number">17.</span> <span class="nav-text">字符串编码方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Unicode"><span class="nav-number">17.1.</span> <span class="nav-text">Unicode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASCLL码"><span class="nav-number">17.2.</span> <span class="nav-text">ASCLL码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile"><span class="nav-number">18.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">18.1.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乱序执行与编译器重排序优化的比较编辑"><span class="nav-number">18.2.</span> <span class="nav-text">乱序执行与编译器重排序优化的比较编辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译器屏障-Compiler-Barrior"><span class="nav-number">18.3.</span> <span class="nav-text">编译器屏障 Compiler Barrior</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU屏障-CPU-Barrior"><span class="nav-number">18.4.</span> <span class="nav-text">CPU屏障 CPU Barrior</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程资源的回收"><span class="nav-number">19.</span> <span class="nav-text">线程资源的回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector内存分配"><span class="nav-number">20.</span> <span class="nav-text">vector内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#reserve和resize的区别"><span class="nav-number">20.1.</span> <span class="nav-text">reserve和resize的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector扩容的两种方式"><span class="nav-number">20.2.</span> <span class="nav-text">vector扩容的两种方式</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">翟安然</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  
  
    <script src="/js/cursor/fireworks.js"></script>
  

</body>
</html>

