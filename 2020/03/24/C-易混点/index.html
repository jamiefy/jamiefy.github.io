<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++," />










<meta name="description" content="（一）虚函数表指针、虚基类表指针 （二）万能头文件 （三）加速c++ （四）运算符优先级 （五）c++11新特性：参考 （六）十大经典排序算法：参考 （七）重点知识点 （八）友元函数 （九）外部排序 字符数组初始化 如何只能做堆上创建对象 只能在栈上创建对象 C++ static、const 和 static const 类型成员变量声明以及初始化 c方式编译的c++文件决定不能出现重载">
<meta property="og:type" content="article">
<meta property="og:title" content="C++易混点">
<meta property="og:url" content="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/index.html">
<meta property="og:site_name" content="翟安然&#39;s Blog">
<meta property="og:description" content="（一）虚函数表指针、虚基类表指针 （二）万能头文件 （三）加速c++ （四）运算符优先级 （五）c++11新特性：参考 （六）十大经典排序算法：参考 （七）重点知识点 （八）友元函数 （九）外部排序 字符数组初始化 如何只能做堆上创建对象 只能在栈上创建对象 C++ static、const 和 static const 类型成员变量声明以及初始化 c方式编译的c++文件决定不能出现重载">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/C-%E6%98%93%E6%B7%B7%E7%82%B9%5Csort.png">
<meta property="og:image" content="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/unicode%E5%88%97%E8%A1%A8.jpg">
<meta property="article:published_time" content="2020-03-24T06:44:02.000Z">
<meta property="article:modified_time" content="2020-09-19T04:41:32.000Z">
<meta property="article:author" content="翟安然">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/C-%E6%98%93%E6%B7%B7%E7%82%B9%5Csort.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/24/C-易混点/"/>





  <title>C++易混点 | 翟安然's Blog</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">翟安然's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="翟安然">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="翟安然's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++易混点</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-24T14:44:02+08:00">
                2020-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

<ul>
<li><a href="#一虚函数表指针-虚基类表指针">（一）虚函数表指针、虚基类表指针</a></li>
<li><a href="#二万能头文件">（二）万能头文件</a></li>
<li><a href="#三加速c">（三）加速c++</a></li>
<li><a href="#四运算符优先级">（四）运算符优先级</a></li>
<li><a href="#五c11新特性参考httpsblogcsdnnetqq_34139994articledetails94590736ops_request_misc7b22request5fid223a22158562057919195162527066222c22scm223a2220140713130056874227drequest_id158562057919195162527066biz_id0utm_sourcedistributepc_search_resultnone-task">（五）c++11新特性：参考</a></li>
<li><a href="#六十大经典排序算法参考httpswwwcnblogscomonepixelarticles7674659html">（六）十大经典排序算法：参考</a></li>
<li><a href="#七重点知识点">（七）重点知识点</a></li>
<li><a href="#八友元函数">（八）友元函数</a></li>
<li><a href="#九外部排序">（九）外部排序</a></li>
<li><a href="#字符数组初始化">字符数组初始化</a></li>
<li><a href="#如何只能做堆上创建对象">如何只能做堆上创建对象</a></li>
<li><a href="#只能在栈上创建对象">只能在栈上创建对象</a></li>
<li><a href="#c-static-const-和-static-const-类型成员变量声明以及初始化httpswwwrunoobcomw3cnotecpp-static-consthtml">C++ static、const 和 static const 类型成员变量声明以及初始化</a></li>
<li><a href="#c方式编译的c文件决定不能出现重载函数httpswwwcnblogscomyogurshinep3913073html">c方式编译的c++文件决定不能出现重载函数</a></li>
<li><a href="#内存对齐的作用">内存对齐的作用</a></li>
<li><a href="#c设计一个类只能在堆上创建对象-只能在栈上创建对象-只能创建一个对象">C++设计一个类：只能在堆上创建对象、只能在栈上创建对象、只能创建一个对象</a><ul>
<li><a href="#一-只能在堆上创建对象">一、只能在堆上创建对象</a></li>
<li><a href="#二-只能在栈上创建对象">二、只能在栈上创建对象</a></li>
<li><a href="#三-只能创建一个对象">三、只能创建一个对象</a></li>
</ul>
</li>
<li><a href="#字符串编码方式">字符串编码方式</a><ul>
<li><a href="#unicode">Unicode</a></li>
<li><a href="#ascll码">ASCLL码</a></li>
</ul>
</li>
<li><a href="#volatile">volatile</a></li>
</ul>
<!-- /code_chunk_output -->


<h2 id="（一）虚函数表指针、虚基类表指针"><a href="#（一）虚函数表指针、虚基类表指针" class="headerlink" title="（一）虚函数表指针、虚基类表指针"></a>（一）虚函数表指针、虚基类表指针</h2><ul>
<li><p>非虚继承时，不需要额外增加虚函数表指针。单继承：一个虚函数表，一个虚表指针；多继承：子类的虚表指针数=父类数。</p>
</li>
<li><p>虚继承时：无论是单虚继承还是多虚继承，需要有一个虚基类表来记录虚继承关系，所以此时子类有且仅有一个虚基类表指针；多虚继承时子类可能持有多个虚函数表：如果子类没有构造函数和析构函数，且子类中的虚函数都是在父类中出现的虚函数，这个时候不需要增加任何虚表指针，只需要像多继承那个持有父类个数的虚函数表指针来标识即可。</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li>如果子类中含有构造函数或者析构函数或二者都有，则在子类中只要出现一个父类中的虚函数则需要增加一个虚函数表指针来标识此类的虚函数表；无论是否含有构造函数或者虚构函数，只要继承都是虚继承且出现了父类中没有出现的虚函数，则在子类中需要再增加一个虚函数表指针；如果其中有一个是非虚继承，则按照最省空间的原则，不需要增加虚函数表指针，因为这个时候可以和非虚基类共享一个虚函数表指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统指针占四字节 64位系统指针占8字节，本题按32位系统</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::fun2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::d_fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive2::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive2::d_fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive3</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d3;</span><br><span class="line"><span class="keyword">int</span> add;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive3::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive3::d_fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive4</span> :</span> <span class="keyword">public</span> Derive2, <span class="keyword">public</span> Derive3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d4;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive4::fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive4::d_fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive5</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d_fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive5::d_fun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//输出结果为：pstr1为虚函数表指针，vpstr为虚基类表指针</span></span><br><span class="line"><span class="keyword">sizeof</span>(Base1):<span class="number">8</span>  <span class="comment">//sizeof(int) + sizeof(pstr) = 4+4</span></span><br><span class="line"><span class="keyword">sizeof</span>(Base2):<span class="number">8</span>  <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive1):<span class="number">12</span> <span class="comment">//sizeof(int) + sizeof(pstr)  + sizeof(int)= 4+4+4</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive2):<span class="number">20</span>  <span class="comment">//sizeof(int) + sizeof(Base1的pstr)  +sizeof(Derive2的pstr) + sizeof(vpstr)+ sizeof(int)= 4+4+4+4+4</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive3):<span class="number">24</span>  <span class="comment">//sizeof(int) + sizeof(int) + sizeof(Base1的pstr)  +sizeof(Derive2的pstr) + sizeof(vpstr)+ sizeof(int)= 4+4+4+4+4+4</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive4):<span class="number">44</span>  <span class="comment">//sizeof(Derive2) + sizeof(Derive3) + sizeof(int)</span></span><br><span class="line"><span class="keyword">sizeof</span>(Derive5):<span class="number">16</span>  <span class="comment">//sizeof(Base1) + sizeof(Base2)</span></span><br></pre></td></tr></table></figure>

<h2 id="（二）万能头文件"><a href="#（二）万能头文件" class="headerlink" title="（二）万能头文件"></a>（二）万能头文件</h2><p>基本上所有的代码只要用了这个头文件就不再写其他头文件了。</p>
<p>#include&lt;bits/stdc++.h&gt;包含了目前c++所包含的所有头文件。</p>
<h2 id="（三）加速c"><a href="#（三）加速c" class="headerlink" title="（三）加速c++"></a>（三）加速c++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> _ = []()&#123;</span><br><span class="line">    <span class="built_in">std</span> :: ios_base :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>​        <code>iostream</code>默认是与<code>stdio</code>关联在一起的，以使两者同步，因此消耗了<code>iostream</code>不少性能。C++中的<code>std :: cin</code>和<code>std :: cout</code>为了兼容C，保证在代码中同时出现<code>std :: cin</code>和<code>scanf</code>或<code>std :: cout</code>和<code>printf</code>时输出不发生混乱，所以C++用一个流缓冲区来同步C的标准流。通过<code>std :: ios_base :: sync_with_stdio</code>函数设置为<code>false</code>后可以解除这种同步，让<code>std :: cin</code>和<code>std :: cout</code>不再经过缓冲区，<code>iostream</code>的性能就会提高了很多倍。因此，当解除同步之后，注意不要与<code>scanf</code>和<code>printf</code>混用以免出现问题</p>
<p>​        <code>tie</code>是将两个<code>stream</code>绑定的函数，空参数的话返回当前的输出流指针。<code>std :: cin</code>默认是与<code>std :: cout</code>绑定的，所以每次操作的时候都要调用<code>flush</code>，这样增加了IO的负担，通过<code>tie(nullptr)</code>来解除<code>std :: cin</code>和<code>std :: cout</code>之间的绑定，进一步加快执行效率。</p>
<h2 id="（四）运算符优先级"><a href="#（四）运算符优先级" class="headerlink" title="（四）运算符优先级"></a>（四）运算符优先级</h2><ul>
<li>！= 优于 &amp; 。</li>
</ul>
<h2 id="（五）c-11新特性：参考"><a href="#（五）c-11新特性：参考" class="headerlink" title="（五）c++11新特性：参考"></a>（五）c++11新特性：<a href="https://blog.csdn.net/qq_34139994/article/details/94590736?ops_request_misc=%7B%22request%5Fid%22%3A%22158562057919195162527066%22%2C%22scm%22%3A%2220140713.130056874..%22%7D&request_id=158562057919195162527066&biz_id=0&utm_source=distribute.pc_search_result.none-task" target="_blank" rel="noopener">参考</a></h2><p><strong>1、nullptr关键字</strong></p>
<p>解决二义性问题，专门用来区分空指针和0。</p>
<p><strong>2、auto关键字</strong></p>
<p>用于从初始化表达式中推断出变量的数据类型。</p>
<ul>
<li>auto定义变量时必须初始化（类似引用）</li>
<li>auto作为函数返回值时，只能用于定义函数，不能用于声明函数</li>
<li>不允许使用auto定义函数参数</li>
<li>不允许使用auto定义struct/class的成员变量</li>
<li>不允许使用auto定义数组</li>
<li>不允许使用auto作为模板参数传递</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>;             <span class="comment">// i 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> arr = <span class="keyword">new</span> <span class="keyword">auto</span>(<span class="number">10</span>) <span class="comment">// arr 被推导为 int *</span></span><br></pre></td></tr></table></figure>

<p><strong>3、decltype 关键字</strong><br>decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。编译器分析表达式并得到它的类型，却不实际计算表达式的值。<strong>如果给变量加上了一层括号，编译器会把它当作一个表达式，得到的则是引用类型</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> j = <span class="number">5.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(i) a;		<span class="comment">// a的类型是int</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) b = i;  	<span class="comment">// b的类型是int&amp;，必须为其初始化，否则会编译报错</span></span><br><span class="line"><span class="keyword">decltype</span>(i+j) c; 	<span class="comment">// c的类型是int+float =&gt; float</span></span><br></pre></td></tr></table></figure>



<p><strong>4、新式函数声明</strong><br>C++11 引入了一个叫做拖尾返回类型（trailing return type），利用 auto 关键字将返回类型后置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T x, U y) -&gt; decltype(x+y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5、基于范围的 for 循环</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : arr) &#123;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6、Lambda表达式</strong></p>
<p>如果mutable,exception,attribute,return type四者只要一种出现，小括号()不可省略，均不出现则可省略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[capture] (parameters) opt-&gt; <span class="keyword">return</span> type &#123;</span><br><span class="line">  body</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">noreturnfun</span><span class="params">()</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;<span class="comment">//函数不会返回。</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> capture是捕获列表； </span><br><span class="line">    <span class="number">1</span>).[]不捕获任何变量</span><br><span class="line">    <span class="number">2</span>).[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）</span><br><span class="line">    <span class="number">3</span>).[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)</span><br><span class="line">    <span class="number">4</span>).[=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量</span><br><span class="line">    <span class="number">5</span>).[bar]按值捕获bar变量，同时不捕获其他变量</span><br><span class="line">    <span class="number">6</span>).[<span class="keyword">this</span>]捕获当前类中的<span class="keyword">this</span>指针，让lambda表达式拥有和当前类成员函数同样的访问权限</span><br><span class="line">    如果已经使用了&amp;或者=，就默认添加此选项。捕获<span class="keyword">this</span>的目的是可以在lamda中使用当前类的成员函数和成员变量</span><br><span class="line"><span class="number">2.</span> parameters是参数表；(选填) </span><br><span class="line"><span class="number">3.</span> opt是函数选项；可以填<span class="keyword">mutable</span>,exception,attribute（选填） </span><br><span class="line">    <span class="number">1</span>).<span class="keyword">mutable</span>说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-<span class="keyword">const</span>方法</span><br><span class="line">    <span class="number">2</span>).exception说明lambda表达式是否抛出异常以及何种异常</span><br><span class="line">    <span class="number">3</span>).attribute用来声明属性，GCC使用__attribute__关键字来描述函数，变量和数据类型的属性，用于编译器对源代码的优化。</span><br><span class="line">attribute语法格式为：</span><br><span class="line">_attribute_ ((attribute-<span class="built_in">list</span>))</span><br><span class="line"><span class="number">4.</span> <span class="keyword">return</span>-type是返回值类型（拖尾返回类型）(选填) </span><br><span class="line"><span class="number">5.</span> body是函数体</span><br></pre></td></tr></table></figure>

<p><strong>7、std::function/std::bind封装可执行对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Test.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; fun, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = fun(a, b);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum:"</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"add"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TestAdd::Add"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    test.Add(add, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    TestAdd testAdd;</span><br><span class="line">    test.Add(<span class="built_in">std</span>::bind(&amp;TestAdd::Add, testAdd, <span class="built_in">std</span>::placeholders::_1, <span class="built_in">std</span>::placeholders::_2), <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">add</span><br><span class="line">sum:<span class="number">3</span></span><br><span class="line">TestAdd::Add</span><br><span class="line">sum:<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"><span class="built_in">std</span>::bind第一个参数为对象函数指针，表示函数相对于类的首地址的偏移量；</span><br><span class="line">testAdd为对象指针；</span><br><span class="line"><span class="built_in">std</span>::placeholders::_1和<span class="built_in">std</span>::placeholders::_2为参数占位符，表示<span class="built_in">std</span>::bind封装的可执行对象可以接受两个参数。</span><br><span class="line">我们的Test函数在函数指针和类对象函数中，两种情况下都完美运行。</span><br></pre></td></tr></table></figure>

<p><strong>8、初始化列表</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Magic(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Magic magic = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>9、STL容器</strong></p>
<ul>
<li>std::array&lt;类型，容量&gt;，相对于数组增加了迭代器</li>
<li>std::forward_list单向链表，链表在对数据进行插入和删除是比顺序存储的线性表有优势，因此在插入和删除操作频繁的应用场景中，使用list和forward_list比使用array、vector和deque效率要高很多。</li>
<li>std::unordered_map与std::map用法基本差不多，但STL在内部实现上有很大不同，std::map使用的数据结构为红黑树，而std::unordered_map内部是哈希表的实现方式，哈希map理论上查找效率为O(1)。但在存储效率上，哈希map需要增加哈希表的内存开销。</li>
<li>std::unordered_set的数据存储结构也是哈希表的方式结构，除此之外，std::unordered_set在插入时不会自动排序，这都是std::set表现不同的地方。</li>
</ul>
<p>迭代器失效分三种情况考虑，也是非三种数据结构考虑，分别为数组型，链表型，树型数据结构。</p>
<p>数组型数据结构：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(<em>iter)(或erase(</em>iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);</p>
<p>链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).</p>
<p>树形数据结构： 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。</p>
<p>注意：经过erase(iter)之后的迭代器完全失效，该迭代器iter不能参与任何运算，包括iter++,*ite</p>
<p><strong>10、多线程</strong></p>
<ul>
<li>std::thread为C++11的线程类，使用方法和boost接口一样非常方便，同时得益于C++11的可变参数的设计风格，C++11的std::thread还解决了boost::thread中构成参数限制的问题：如果线程需要绑定的函数有参数则需要使用boost::bind。比如想使用 boost::thread创建一个线程来执行函数：void f(int i)，如果这样写：boost::thread thrd(f)是不对的，因为thread构造函数声明接受的是一个没有参数且返回类型为void的型别，而且不提供参数i的值f也无法运行，这时就可以写：boost::thread thrd(boost::bind(f,1))。涉及到有参函数的绑定问题基本上都是boost::thread、boost::function、boost::bind结合起来使用。</li>
<li>std::atomic为C++11封装的原子数据类型，在多线程中用户不必对其添加互斥资源锁的类型，其内部已自己加了锁。</li>
<li>C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到被唤醒再从新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。</li>
</ul>
<p><strong>11、智能指针内存管理</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> make_shared&lt;Foo&gt;(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Foo&gt; p=factory(arg);</span><br><span class="line">    <span class="comment">//使用p</span></span><br><span class="line">&#125;<span class="comment">//p离开了作用域，它指向的内存会被自动释放掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Foo&gt; p=factory(arg);</span><br><span class="line">    <span class="comment">//使用p</span></span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//当我们返回p时，引用计数进行了递增操作</span></span><br><span class="line">&#125;<span class="comment">//p离开了作用域，它指向的内存不会被自动释放掉</span></span><br></pre></td></tr></table></figure>

<p>C++11新增了std::shared_ptr（共享）、std::weak_ptr（弱引用，指向管理的对象，不会增加引用计数）、std::unique_tr(独占)等类型的智能指针，用于解决内存管理的问题，更容易安全的使用动态内存。</p>
<p><strong>12、右值引用于std::move</strong></p>
<p>右值引用 (Rvalue Referene) 是 C++ 新标准 中引入的新特性 , 它实现了移动语义 (Move Sementics) 和完美转发 (Perfect Forwarding)。它的主要目的有两个方面：</p>
<p>1）消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</p>
<p>2）能够更简洁明确地定义泛型函数。</p>
<ul>
<li>左值持久；右值短暂</li>
</ul>
<p>左值：非临时对象，要么是字面常量，要么是在表达式求值过程中创建的临时对象<br>右值：临时的对象，</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/88584015" target="_blank" rel="noopener">右值引用的转移语义和完美转发</a></li>
</ul>
<p><strong>13、模板增强</strong></p>
<ul>
<li>外部模板扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化。</li>
<li>类型别名模板</li>
</ul>
<p>在传统 C++中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> NewType = SuckType&lt;<span class="keyword">int</span>, T, <span class="number">1</span>&gt;;    <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">typedef</span> SuckType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, U, <span class="number">1</span>&gt; NewType; <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>默认模板参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>, <span class="keyword">typename</span> U = <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> add(T x, U y) -&gt; <span class="keyword">decltype</span>(x+y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>14、构造函数</strong></p>
<ul>
<li>委托构造</li>
</ul>
<p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">int</span> value2;</span><br><span class="line">    Base() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> value) : Base() &#123;  <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>继承构造</li>
</ul>
<p>在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  A(<span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">  A(<span class="keyword">double</span> d,<span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">  A(<span class="keyword">float</span> f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c)&#123;&#125;</span><br><span class="line">  <span class="comment">//...等等系列的构造函数版本</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A</span><br><span class="line">&#123;</span><br><span class="line">  B(<span class="keyword">int</span> i):A(i)&#123;&#125;</span><br><span class="line">  B(<span class="keyword">double</span> d,<span class="keyword">int</span> i):A(d,i)&#123;&#125;</span><br><span class="line">  B(folat f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c):A(f,i,e)&#123;&#125;</span><br><span class="line">  <span class="comment">//......等等好多个和基类构造函数对应的构造函数</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//c++11的继承构造</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  A(<span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">  A(<span class="keyword">double</span> d,<span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">  A(<span class="keyword">float</span> f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c)&#123;&#125;</span><br><span class="line">  <span class="comment">//...等等系列的构造函数版本</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> A::A;</span><br><span class="line">  <span class="comment">//关于基类各构造函数的继承一句话搞定</span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>



<p><strong>15、虚函数的 override 和 final 指示符</strong></p>
<ul>
<li>override，表示函数应当重写基类中的虚函数</li>
<li>final，表示派生类不应当重写这个虚函数</li>
</ul>
<p><strong>16、static_assert() 静态断言</strong></p>
<ul>
<li>C提供的assert()只能在运行时断言</li>
<li>C++11/14 提供的static_assert()可以在编译期断言</li>
</ul>
<h2 id="（六）十大经典排序算法：参考"><a href="#（六）十大经典排序算法：参考" class="headerlink" title="（六）十大经典排序算法：参考"></a>（六）十大经典排序算法：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">参考</a></h2><p><img src="/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/C-%E6%98%93%E6%B7%B7%E7%82%B9%5Csort.png" alt="排序算法分类"></p>
<ol>
<li>冒泡排序</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="comment">//注意限制条件j&lt;len-1-i</span></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">                                swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>快速排序</li>
<li><a href="https://www.cnblogs.com/hardyyao/p/9903278.html" target="_blank" rel="noopener">插入排序</a></li>
<li>选择排序</li>
<li>堆排序</li>
<li>归并排序</li>
</ol>
<ul>
<li>自顶向下</li>
<li>自底向上：注意底层达不到整数倍length的数据部分</li>
</ul>
<h2 id="（七）重点知识点"><a href="#（七）重点知识点" class="headerlink" title="（七）重点知识点"></a>（七）重点知识点</h2><ol>
<li><h5 id="printf-从右向左计算，从左向右输出，符合栈模型"><a href="#printf-从右向左计算，从左向右输出，符合栈模型" class="headerlink" title="printf 从右向左计算，从左向右输出，符合栈模型"></a>printf 从右向左计算，从左向右输出，符合栈模型</h5></li>
<li><h5 id="类中变量赋值顺序是变量声明顺序，所以赋值时先执行a-b-，再执行b-i-1-。a赋值为随机数"><a href="#类中变量赋值顺序是变量声明顺序，所以赋值时先执行a-b-，再执行b-i-1-。a赋值为随机数" class="headerlink" title="类中变量赋值顺序是变量声明顺序，所以赋值时先执行a(b)，再执行b(i+1)。a赋值为随机数"></a>类中变量赋值顺序是变量声明顺序，所以赋值时先执行a(b)，再执行b(i+1)。a赋值为随机数</h5></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base1</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>: <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    base1 ( <span class="keyword">int</span> i ) : b(i+<span class="number">1</span>),a(b)&#123;&#125;</span><br><span class="line">    base1():b(<span class="number">0</span>),a(b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_a</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_b</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">base1 <span class="title">obj1</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj1.get_a()&lt;&lt;<span class="built_in">endl</span>&lt;&lt;obj1.get_b()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5></li>
</ol>
<p>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。Static修饰的成员函数，在代码区分配内存。</p>
<ol start="4">
<li><h5 id="C-多态分为静态多态和动态多态"><a href="#C-多态分为静态多态和动态多态" class="headerlink" title="C++多态分为静态多态和动态多态"></a>C++多态分为静态多态和动态多态</h5></li>
</ol>
<p>静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。</p>
<ol start="5">
<li><h5 id="C-里面‘-’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。"><a href="#C-里面‘-’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。" class="headerlink" title="C++里面‘/’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。"></a>C++里面‘/’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。</h5></li>
<li><h5 id="派生访问说明符"><a href="#派生访问说明符" class="headerlink" title="派生访问说明符"></a>派生访问说明符</h5></li>
</ol>
<ul>
<li>public继承</li>
</ul>
<p>公有继承时，对基类的公有成员和保护成员的访问属性不变，<strong>派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员</strong>。派生类的对象只能访问派生类的公有成员（包括继承的公有成员），不能访问派生类和继承基类的保护成员和私有成员。</p>
<ul>
<li>protected继承</li>
</ul>
<p>保护继承中，基类的公有成员和保护成员被派生类继承后变成保护成员，<strong>派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员</strong>。派生类的对象只能访问派生类的公有成员，不能访问继承基类的公有成员、保护成员和私有成员。</p>
<ul>
<li>private继承</li>
</ul>
<p>私有继承时，基类的公有成员和保护成员都被派生类继承下来之后变成私有成员，<strong>派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员</strong>。派生类的对象只能访问派生类的公有成员，不能访问继承基类的公有成员、保护成员和私有成员。</p>
<ol start="7">
<li><h5 id="C-枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别"><a href="#C-枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别" class="headerlink" title="C++枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别"></a>C++枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别</h5></li>
</ol>
<ul>
<li>限定作用域的枚举类型的一般形式和不限范围的枚举类型不同</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非限定作用域</span></span><br><span class="line"><span class="keyword">enum</span> color&#123;</span><br><span class="line">    red,</span><br><span class="line">    green,</span><br><span class="line">    blue</span><br><span class="line">&#125;;</span><br><span class="line">color b=green;</span><br><span class="line"><span class="keyword">int</span> c=blue; <span class="comment">//正确</span></span><br><span class="line"><span class="comment">//限定作用域</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">color</span>:</span><span class="keyword">char</span></span><br><span class="line">&#123;</span><br><span class="line">    red,</span><br><span class="line">    green,</span><br><span class="line">    blue</span><br><span class="line">&#125;;</span><br><span class="line">color a=color::green;</span><br><span class="line"><span class="keyword">char</span> d=color:blue; <span class="comment">//错误，限定作用域的枚举类型不能用于初始化int类型的实体</span></span><br></pre></td></tr></table></figure>

<ul>
<li>限定作用域的枚举类型不能再作用域外访问枚举成员,必须显示地访问枚举成员，限定作用域的枚举型别带来的名字空间污染降低；不限范围的枚举型别可以</li>
<li>从限定作用域枚举型别到任何其他型别都不存在隐式转换路径（可实施强制型别转换）；不限范围的枚举型别可以</li>
<li>限定作用域的枚举型别和不限范围的枚举型别都支持底层型别指定。限定作用域的枚举型别的默认底层型别是int，而不限范围的枚举型别没有默认底层型别。</li>
<li>限定作用域的枚举型别总是可以进行前置声明，而不限范围的枚举型别却只有在指定了默认底层型别的前提下才可以进行前置声明。</li>
</ul>
<ol start="8">
<li><h5 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h5></li>
</ol>
<p>类型转换函数的语法格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1) type 可以是内置类型、类类型以及由 typedef 定义的类型别名，任何可作为函数返回类型的类型（void 除外）都能够被支持。一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的。</p>
<p>2) 类型转换函数一般不会更改被转换的对象，所以通常被定义为 const 成员。</p>
<p>3) 类型转换函数可以被继承，可以是虚函数。</p>
<p>4) 一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性。</p>
<p>5) 转换函数必须是成员函数，它的声明不能指定返回类型和参数列表。</p>
<ul>
<li>通常一个参数的构造函数在non-explicit的情况下同样能实现类型转换</li>
</ul>
<ol start="9">
<li><h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a><a href="https://www.cnblogs.com/liushui-sky/p/7727865.html" target="_blank" rel="noopener">内存泄漏</a></h5></li>
</ol>
<ul>
<li>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。三种类型的内存泄漏：</li>
</ul>
<p>（1）堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过<code>malloc</code>,<code>realloc</code>,<code>new</code>等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</p>
<p>（2）系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 <code>Bitmap</code>,<code>handle</code> ,<code>SOCKET</code>等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p>
<p>（3）没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是<code>virtual</code>，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露。</p>
<ul>
<li>安全的代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>（1）delete 一次以后，p成了野指针，但是它作为地址的值还是有效的，还可以访问它以前指向的内存，不过那片内存被重新格式化了；<br>（2）指针非空时，delete运算只释放指针所指的地址空间，不会判断空间是否被占用，delete结束后不会将指针赋值为空，释放后别的指针变量也可以得到这片空间，<strong>该空间的值并不一定是NULL，所以delete后不能用是否为NULL来判断</strong>。用 if(p) 语句不能判断它指向的内存是否有效（此时它指向的内存无效，p本身有效）；<br>（3）delete 一次以后，不能再次delete，否则会报错；<br>（4）如果p指向的空间再次被new函数分配，即使是分配给别的指针，即使分配大小与原来不一样，此时如果误用p指针，仍然可以修改内存的值和从该处取出数值，甚至可以重新被delete，p的作用与新分配的指针一样；对同一非空指针delete多次，只有第一次delete被正确执行，之后的delete全部发生异常。对空指针delete多次可以正常执行。良好的习惯是，delete运算后手动将指针赋值为空。</p>
<ul>
<li>野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）,野指针的成因：</li>
</ul>
<p>1、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的默认值是随机的，它会乱指一气。<br>2、指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。<br>3、指针操作超越了变量的作用范围。这种情况让人防不胜防。</p>
<ul>
<li>悬空指针指指针正常初始化，曾指向过一个正常的对象，但是对象销毁了，该指针未置空，就成了悬空指针。例如指针p1、p2均指向对象a，delete p1后p2就是悬空指针，p1是野指针。</li>
</ul>
<ol start="10">
<li><h5 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h5></li>
</ol>
<p>在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，结构体变量所占空间的大小必定是最宽数据类型大小的整数倍。如有需要会在最后一个成员末尾填充若干字节使得所占空间大小是最宽数据类型大小的整数倍。内存对齐的原因：</p>
<ol>
<li><p>某些平台只能在特定的地址处访问特定类型的数据；</p>
</li>
<li><p>提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量</p>
</li>
<li><h5 id="大端小端"><a href="#大端小端" class="headerlink" title="大端小端"></a>大端小端</h5></li>
</ol>
<ul>
<li><p><strong>大端模式（Big_endian）</strong>：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。</p>
</li>
<li><p><strong>小端模式</strong>（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。</p>
</li>
<li><p><strong>口诀</strong>：大相反（低位存高位），小相同（低位存低位）。</p>
</li>
<li><p>联合体变量共享同一空间，可以通过联合体来判断大端小端。联合体同样存在内存对齐，所以联合长度至少可以容纳最大的成员。但是当最大成员大小不是<strong>最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍。</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkcpu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> w</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		<span class="keyword">char</span> b;</span><br><span class="line">	&#125;c;</span><br><span class="line">	c.a = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> (c.b == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(checkcpu() == <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"这是小端\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"这是大端\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li><h5 id="为什么析构函数可以virtual，构造函数不能呢？"><a href="#为什么析构函数可以virtual，构造函数不能呢？" class="headerlink" title="为什么析构函数可以virtual，构造函数不能呢？"></a>为什么析构函数可以virtual，构造函数不能呢？</h5></li>
</ol>
<ul>
<li><p>在公有继承中，基类的虚构函数如果不声明成为虚函数，delete p调用的是声明类型(即基类)的析构函数，所以只能销毁基类对象而无法销毁派生类对象，会发生销毁不完全的情况，那么销毁派生类时有可能造成资源泄漏。当基类的析构函数声明为虚函数，那么派生类的析构函数也是虚函数，此时调用delete p时发生动态绑定，运行时会根据实际类型调用该对象的虚函数。并不是要把所有类的析构函数都写成虚函数。只有当一个类是基类(即希望被继承)的时候才需要声明成虚函数，因为虚函数的作用是实现多态，而多态是建立在继承的基础上。单一类不能把析构函数写成虚函数，因为会产生额外的开销，比如虚表的创建和虚指针的定义。</p>
</li>
<li><p>（1）虚函数采用一种虚调用的办法。虚调用是一种可以在只有部分信息的情况下工作的机制，特别运行我们调用一个只知道接口而不知道其准确对象类型的函数。但是构造函数本身就是要初始化实例，要创建一个对象，构造函数肯定要知道对象的准确类型，因此构造函数不能为虚。</p>
<p>（2）虚函数对应虚函数表，虚函数表存储在对象的内存空间，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。</p>
<p>（3）虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p>
<p>（4）构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。</p>
<p>（5）当一个构造函数被调用时，它做的首要的事情之一是初始化它的V P T R。因此，它只能知道它是“当前”类的，而完全忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码- -既不是为基类，也不是为它的派生类（因为类不知道谁继承它）。所以它使用的V P T R必须是对于这个类的V TA B L E。而且，只要它是最后的构造函数调用，那么在这个对象的生命期内， V P T R将保持被初始化为指向这个V TA B L E, 但如果接着还有一个更晚派生的构造函数被调用，这个构造函数又将设置V P T R指向它的 V TA B L E，等直到最后的构造函数结束。V P T R的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类（most-derived）顺序的另一个理由。但是，当这一系列构造函数调用正发生时，每个构造函数都已经设置V P T R指向它自己的 V TA B L E。如果函数调用使用虚机制，它将只产生通过它自己的V TA B L E的调用，而不是最后的V TA B L E（所有构造函数被调用后才会有最后的V TA B L E）。</p>
</li>
</ul>
<h2 id="（八）友元函数"><a href="#（八）友元函数" class="headerlink" title="（八）友元函数"></a>（八）友元函数</h2><p>1）必须在类的说明中说明友元函数，说明时以关键字friend开头，后跟友元函数的函数原型，友元函数的说明可以出现在类的任何地方，包括在private和public部分；<br>2）注意友元函数不是类的成员函数，所以友元函数的实现和普通函数一样，在实现时不用”::”指示属于哪个类，只有成员函数才使用”::”作用域符号；<br>3）友元函数不能直接访问类的成员，只能访问对象成员，<br>4）友元函数可以访问对象的私有成员，但普通函数不行；<br>5）调用友元函数时，在实际参数中需要指出要访问的对象，<br>6）友元的声明只能出现在类定义的内部（最好在类定义开始或者结束前的位置集中声明友元），仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，必须在友元声明之外再对函数进行一次声明。每个类负责控制自己的友元类或友元函数，友元关系不存在传递性。类与类之间的友元关系不能继承.</p>
<h2 id="（九）外部排序"><a href="#（九）外部排序" class="headerlink" title="（九）外部排序"></a>（九）外部排序</h2><p>详见<a href="https://www.cnblogs.com/haimishasha/p/10898715.html#autoid-4-1-0" target="_blank" rel="noopener">外部排序算法总结</a></p>
<h2 id="字符数组初始化"><a href="#字符数组初始化" class="headerlink" title="字符数组初始化"></a>字符数组初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//char *strcpy(char *dest, const char *src)</span></span><br><span class="line"><span class="comment">//void *memset(void *str, int c, size_t n)</span></span><br><span class="line"><span class="comment">//void *memcpy(void *str1, const void *str2, size_t n)</span></span><br><span class="line"><span class="comment">//遇到char s[15]这条语句时, 编译程序会在内存的某处留</span></span><br><span class="line"><span class="comment">//出连续15个字节的区域, 并将第一个字节的地址赋给s。</span></span><br><span class="line"><span class="comment">//当遇到strcpy时, 首先在目标文件的某处建立一个"I am a students\0" 的字符串,不加'\0'编译器会自动补全，其中\0表示字符串终止, 终止符是编译时自动加上的, 然后一个字符一个字符地复制到s所指的内存区域。因此定义字符串数组时, 其元素个数至少应该比字符串的长度多1。</span></span><br><span class="line"><span class="comment">//注意:</span></span><br><span class="line"><span class="comment">//1. 字符串数组不能用"="直接赋值, 即s="Good News!"是不合法的。所以应分</span></span><br><span class="line"><span class="comment">//清字符串数组和字符串指针的不同赋值方法。</span></span><br><span class="line"><span class="keyword">char</span> st[<span class="number">15</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(st,<span class="string">"I am a students"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* st=<span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(st,<span class="string">"I am a students"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* st=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">15</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(st,<span class="string">"I am a students"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* st=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(st,<span class="string">"I am a students"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反转字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseWord</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">begin</span>,<span class="keyword">char</span>* <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">begin</span>&lt;<span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp=*<span class="built_in">begin</span>;</span><br><span class="line">        *<span class="built_in">begin</span>=*<span class="built_in">end</span>;</span><br><span class="line">        *<span class="built_in">end</span>=tmp;</span><br><span class="line">        <span class="built_in">begin</span>++;</span><br><span class="line">        <span class="built_in">end</span>--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">begin</span>=str;</span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">end</span>=str;</span><br><span class="line">    <span class="keyword">while</span>(*<span class="built_in">begin</span>!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*<span class="built_in">begin</span>==<span class="string">' '</span>)&#123;</span><br><span class="line">            <span class="built_in">begin</span>++;</span><br><span class="line">            <span class="built_in">end</span>++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*<span class="built_in">end</span>==<span class="string">' '</span>|| *<span class="built_in">end</span>==<span class="string">'\0'</span>)&#123;</span><br><span class="line">            reverseWord(<span class="built_in">begin</span>,--<span class="built_in">end</span>);</span><br><span class="line">            <span class="built_in">begin</span>=++<span class="built_in">end</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="built_in">end</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    reverseWord(str,str+n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    char* st=(char*)malloc(14);</span></span><br><span class="line"><span class="comment">//    strcpy(st,"I am a students");</span></span><br><span class="line"><span class="comment">//    char* st=new char[15];</span></span><br><span class="line"><span class="comment">//    memcpy(st,"I am a students",15);</span></span><br><span class="line"><span class="comment">//    char st[]="I am a students";</span></span><br><span class="line"><span class="comment">//    char st[16]="I am a students";</span></span><br><span class="line">    <span class="keyword">char</span> st[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(st,<span class="string">"I am a students"</span>,<span class="number">15</span>);</span><br><span class="line">    reverse(st);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;st&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str1[]=&#123;<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">strlen</span>(str1)&lt;&lt;<span class="string">"   str1="</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈方向从右向左，str2[]没有长度规定，所以输出的时候连带str1也输出了出来</span></span><br><span class="line">    <span class="keyword">char</span> str2[]=&#123;<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">strlen</span>(str2)&lt;&lt;<span class="string">"   str2="</span>&lt;&lt;str2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str3[<span class="number">3</span>]=&#123;<span class="string">'5'</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">strlen</span>(str3)&lt;&lt;<span class="string">"   str3="</span>&lt;&lt;str3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str4[<span class="number">4</span>]=<span class="string">"abc"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">strlen</span>(str4)&lt;&lt;<span class="string">"   str4="</span>&lt;&lt;str4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">students a am I</span><br><span class="line"><span class="number">3</span>   str1=<span class="number">123</span></span><br><span class="line"><span class="number">9</span>   str2=<span class="number">123456123</span></span><br><span class="line"><span class="number">1</span>   str3=<span class="number">5</span></span><br><span class="line"><span class="number">3</span>   str4=abc</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">//循环变量</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> *p = str;</span><br><span class="line">    <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));  <span class="comment">//只能写sizeof(str), 不能写sizeof(p)</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\x20"</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">根据<span class="built_in">memset</span>函数的不同，输出结果也不同，分为以下几种情况：</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));  <span class="comment">//地址的大小都是4字节</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(*p));  <span class="comment">//*p表示的是一个字符变量, 只有一字节</span></span><br><span class="line"><span class="number">0</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span> <span class="number">-52</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="number">10</span>);  <span class="comment">//直接写10也行, 但不专业</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h2 id="如何只能做堆上创建对象"><a href="#如何只能做堆上创建对象" class="headerlink" title="如何只能做堆上创建对象"></a>如何只能做堆上创建对象</h2><p>在C++中，类的创建分为两种。一种是静态创建，即直接创建对象；另一种是动态创建对象，即通过 <strong>new</strong> 创建，如 T *t = new T。要想正确回答上题，就必须知道这两种创建方式的区别。</p>
<p><strong>1 静态创建</strong></p>
<p>由编译器在栈中为对象分配内存，通过移动栈顶指针获得合适大小的空间，然后<strong>调用对象的构造函数生成</strong>对象。</p>
<p><strong>2 动态创建</strong></p>
<p>通过new在堆中创建对象。这个过程分为两步：首先在堆中找到合适大小的空间并分配，然后<strong>调用对象的构造函数</strong>生成对象。</p>
<p>因为两者都需要调用对象的构造函数，所以通过将<strong>构造函数私有化</strong>的做法是行不通的。那么还有其他办法吗？这是就需要了解静态创建的另一个特点了。</p>
<p><strong>编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。</strong></p>
<p>所以我们只需要将析构函数私有化就可以组织直接创建对象了。由于栈的创建和释放都需要由系统完成的，所以若是无法调用构造或者析构函数，自然会报错。</p>
<p>当然为了我们能够正确释放动态创建的对象，我们必须提供一个公有函数，该函数的唯一功能就是<strong>删除对象本身</strong>。</p>
<p> 测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	~test()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"test destroy"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//test p;//编译器报错test::~test()不可访问</span></span><br><span class="line">	test *p = <span class="keyword">new</span> test;</span><br><span class="line">	p-&gt;destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="只能在栈上创建对象"><a href="#只能在栈上创建对象" class="headerlink" title="只能在栈上创建对象"></a>只能在栈上创建对象</h2><p>既然可以做到只在堆上创建对象，同样的我们可以只在栈上创建对象。</p>
<p>其实理解了这个理念，不难想到我们只需要<strong>让new操作符无法使用即可，</strong>要做到这件事，我们可以将<strong>new操作符重载并设置为私有访问</strong>即可。</p>
<p>重载new的同时最好重载delete</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"test destroy"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//test *A = new test;</span></span><br><span class="line">	<span class="comment">//编译器报错函数test::operator new 不可访问</span></span><br><span class="line">	test A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-static、const-和-static-const-类型成员变量声明以及初始化"><a href="#C-static、const-和-static-const-类型成员变量声明以及初始化" class="headerlink" title="C++ static、const 和 static const 类型成员变量声明以及初始化"></a><a href="https://www.runoob.com/w3cnote/cpp-static-const.html" target="_blank" rel="noopener">C++ static、const 和 static const 类型成员变量声明以及初始化</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test():a(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">enum</span> &#123;size1=<span class="number">100</span>,size2=<span class="number">200</span>&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;<span class="comment">//只能在构造函数初始化列表中初始化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b;<span class="comment">//在类的实现文件中定义并初始化</span></span><br><span class="line">    conststatic <span class="keyword">int</span> c;<span class="comment">//与 static const int c;相同。</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Test::b=<span class="number">0</span>;<span class="comment">//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。</span></span><br><span class="line">cosnt intTest::c=<span class="number">0</span>;<span class="comment">//注意：给静态成员变量赋值时，不需要加static修饰符，但要加cosnt。</span></span><br></pre></td></tr></table></figure>

<h2 id="c方式编译的c-文件决定不能出现重载函数"><a href="#c方式编译的c-文件决定不能出现重载函数" class="headerlink" title="c方式编译的c++文件决定不能出现重载函数"></a><a href="https://www.cnblogs.com/Yogurshine/p/3913073.html" target="_blank" rel="noopener">c方式编译的c++文件决定不能出现重载函数</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用c方式编译的代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></span><br></pre></td></tr></table></figure>

<p>对于一份.c文件，采用gcc编译时候没有定义__cplusplus，宏判断不起作用，且自是用c语言的方式编译，采用g++编译定义了_cplusplus，经过上面宏判断，所以还是会以c语言的方式编译。注意，extern “C”是g++才具有的关键字，gcc并没有，所以如果用gcc编译而不加以宏判断直接使用extern “C”那么就会出现语法错误。<br>用c方式去编译c++文件，还要注意重载函数。c方式编译的c++文件决定不能出现重载函数。</p>
<h2 id="内存对齐的作用"><a href="#内存对齐的作用" class="headerlink" title="内存对齐的作用"></a>内存对齐的作用</h2><p>1.为了更好的跨平台，原因：某些硬件只能从特定的内存地址中读取特定类型的数据，然而每个数据的所占的字节数不同，需要统一对齐，那样才会比较方便读取，所以为啥C++比较好跨平台的原因也就是这样。<br>2.加快CPU访问性能，加快的原因是假如一个int或者double类型的数据占4字节的情况下，然后她的起始字节数假设是从1开始，cpu读取的话，就得先1-4 4-8 然后提出1.5-8 再把2-5的字节数放进寄存器，那样效率大大降低，但是对于现在的cpu来说，这种应该不算什么。<br>总结：基本上如今的机器，需要内存对齐的原因，主要是因为更好的跨平台</p>
<p><strong>内存对齐的规则：</strong></p>
<p>1、 对于结构的各个成员，第一个成员位于偏移为0的位置，以后每个数据成员的偏移量必须是min(#pragma pack()指定的数，这个数据成员的自身长度) 的倍数。</p>
<p>2、 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p>
<h2 id="C-设计一个类：只能在堆上创建对象、只能在栈上创建对象、只能创建一个对象"><a href="#C-设计一个类：只能在堆上创建对象、只能在栈上创建对象、只能创建一个对象" class="headerlink" title="C++设计一个类：只能在堆上创建对象、只能在栈上创建对象、只能创建一个对象"></a>C++设计一个类：只能在堆上创建对象、只能在栈上创建对象、只能创建一个对象</h2><p>在C++中，创建类的对象有两种方法，一种是静态建立，A a; 另一种是动态建立，调用new 操作符。</p>
<h3 id="一、只能在堆上创建对象"><a href="#一、只能在堆上创建对象" class="headerlink" title="一、只能在堆上创建对象"></a>一、只能在堆上创建对象</h3><ul>
<li>就是动态建立类的对象，使用new操作符来完成。</li>
<li>做法一：将该类的构造函数和析构函数权限设为protected，(可以让该类可以被继承)，然后定义两个static 函数来调用new ，delete 来创建和销毁对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    A()</span><br><span class="line">    &#123;&#125;;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    static A* Create()</span><br><span class="line">    &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void Destory(A* p)</span><br><span class="line">    &#123;</span><br><span class="line">        delete p;</span><br><span class="line">        p &#x3D; NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>做法二：<br>对象建立在栈上面时，是由编译器分配空间的，调用构造函数来构造栈对象，当对象使用完之后，编译器会调用析构函数来释放栈对象所占的空间，编译器管理了对象的整个生命周期，编译器为对象分配空间的时候，只要是非静态的函数都会检查，包括析构函数，但是此时析构函数不可访问，编译器无法调用类的析构函数来释放内存，那么编译器将无法在栈上为对象分配内存。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;A a;&#x2F;&#x2F;栈上创建</span><br><span class="line">    A* p &#x3D; new A;&#x2F;&#x2F;堆上创建</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、只能在栈上创建对象"><a href="#二、只能在栈上创建对象" class="headerlink" title="二、只能在栈上创建对象"></a>二、只能在栈上创建对象</h3><ul>
<li>只能在栈上创建的对象的话，就是不能调用new 操作符，所以可以将operator new 和operator delete 设置为私有的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    void* operator new(size_t)&#123;&#125;;</span><br><span class="line">    void operator delete(void*)&#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    AA()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;AA()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~AA()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~AA()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="三、只能创建一个对象"><a href="#三、只能创建一个对象" class="headerlink" title="三、只能创建一个对象"></a>三、只能创建一个对象</h3><ul>
<li>在类中创建一个静态变量Count，用来限制可创建的实例的数量。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> singleclass* <span class="title">getsingleclass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> singleclass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    singleclass()&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字符串编码方式"><a href="#字符串编码方式" class="headerlink" title="字符串编码方式"></a>字符串编码方式</h2><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte）。一个字节能表示的最大的整数就是255（2^8-1=255），而ASCII编码，占用0 - 127用来表示大小写英文字母、数字和一些符号，这个编码表被称为<a href="https://baike.baidu.com/item/ASCII编码/3712529" target="_blank" rel="noopener">ASCII编码</a>，比如大写字母A的编码是65，小写字母z的编码是122。</p>
<p>如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了<a href="https://baike.baidu.com/item/GB2312/483170" target="_blank" rel="noopener">GB2312</a>编码，用来把中文编进去。</p>
<p>类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>
<p>Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。</p>
<p>在Unicode中：汉字“字”对应的数字是23383（十进制），十六进制表示为5B57。在Unicode中，我们有很多方式将数字23383表示成程序中的数据，包括：<a href="https://baike.baidu.com/item/UTF-8" target="_blank" rel="noopener">UTF-8</a>、<a href="https://baike.baidu.com/item/UTF-16" target="_blank" rel="noopener">UTF-16</a>、<a href="https://baike.baidu.com/item/UTF-32" target="_blank" rel="noopener">UTF-32</a>。UTF是“Unicode Transformation Format”的缩写，可以翻译成Unicode字符集转换格式，即怎样将Unicode定义的数字转换成程序数据。</p>
<p><img src="/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/unicode%E5%88%97%E8%A1%A8.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点,这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s=<span class="string">"\u00234\67"</span>;<span class="comment">//   0023是16进制对应#；4；\67是8进制对应7</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s;<span class="comment">//   #47</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ASCLL码"><a href="#ASCLL码" class="headerlink" title="ASCLL码"></a>ASCLL码</h3><p>所有的<a href="https://baike.baidu.com/item/ASCII码" target="_blank" rel="noopener">ASCII码</a>都可以用“\”加数字（一般是8进制数字）来表示。而C中定义了一些字母前加”&quot;来表示常见的那些不能显示的ASCII<a href="https://baike.baidu.com/item/字符" target="_blank" rel="noopener">字符</a>，如\0,\t,\n等，就称为转义字符，因为后面的<a href="https://baike.baidu.com/item/字符/4768913" target="_blank" rel="noopener">字符</a>，都不是它本来的ASCII字符意思了。</p>
<ol>
<li>所有的转义字符和所对应的意义：</li>
</ol>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>响铃(BEL)</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>\</td>
<td>代表一个反斜线字符’’&#39;</td>
<td>092</td>
</tr>
<tr>
<td>&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>空字符(NUL)</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>1到3位八进制数所代表的任意字符</td>
<td>三位八进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>十六进制所代表的任意字符</td>
<td>十六进制</td>
</tr>
</tbody></table>
<p><em>注意：</em></p>
<p><em>1. 区分，斜杠：”/“ 与 反斜杠：”&quot; ,此处不可互换</em></p>
<p><em>2. \xhh 十六进制转义不限制字符个数 ‘\x000000000000F’ == ‘\xF’ [3]</em> </p>
<ol start="2">
<li>字符型常量：</li>
</ol>
<p>C语言中字符型常量所表示的值是int型所能包含的值。我们可以用ASCII<a href="https://baike.baidu.com/item/表达式" target="_blank" rel="noopener">表达式</a>来表示一个字符型常量，或者用单引号内加<a href="https://baike.baidu.com/item/反斜杠" target="_blank" rel="noopener">反斜杠</a>表示转义字符。</p>
<p>‘A’, ‘\x2f’, ‘\013’;</p>
<p>其中：\x表示后面的字符是<a href="https://baike.baidu.com/item/十六进制数" target="_blank" rel="noopener">十六进制数</a>，\0表示后面的字符是八进制数。例如十进制的17用十六进制表示就是</p>
<p>‘\x11’,用八进制表示就是‘\021’;</p>
<p>上面我们见到的\x,\n,\a等等都是叫转义字符，它告诉<a href="https://baike.baidu.com/item/编译器" target="_blank" rel="noopener">编译器</a>需要用特殊的方式进行处理。</p>
<p>转义字符以<code>\</code>或者<code>\x</code>开头，以<code>\</code>开头表示后跟八进制形式的编码值，以<code>\x</code>开头表示后跟十六进制形式的编码值。对于转义字符来说，只能使用八进制或者十六进制。</p>
<p>字符 1、2、3、a、b、c 对应的 ASCII 码的八进制形式分别是 61、62、63、141、142、143，十六进制形式分别是 31、32、33、61、62、63。下面的例子演示了转义字符的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char a = '\61';  //字符1</span><br><span class="line"><span class="keyword">char</span> b = <span class="string">'\141'</span>;  <span class="comment">//字符a</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'\x31'</span>;  <span class="comment">//字符1</span></span><br><span class="line"><span class="keyword">char</span> d = <span class="string">'\x61'</span>;  <span class="comment">//字符a</span></span><br><span class="line"><span class="keyword">char</span> *str1 = <span class="string">"\x31\x32\x33\x61\x62\x63"</span>;  <span class="comment">//字符串"123abc"</span></span><br><span class="line"><span class="keyword">char</span> *str2 = <span class="string">"\61\62\63\141\142\143"</span>;  <span class="comment">//字符串"123abc"</span></span><br><span class="line"><span class="keyword">char</span> *str3 = <span class="string">"The string is: \61\62\63\x61\x62\x63"</span>  <span class="comment">//混用八进制和十六进制形式</span></span><br></pre></td></tr></table></figure>

<p>转义字符既可以用于单个字符，也可以用于字符串，并且一个字符串中可以同时使用八进制形式和十六进制形式。</p>
<p>一个完整的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"\x68\164\164\x70://c.biancheng.\x6e\145\x74"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a></p>
<p>转义字符的初衷是用于 ASCII 编码，所以它的取值范围有限：</p>
<ul>
<li>八进制形式的转义字符最多后跟三个数字，也即<code>\ddd</code>，最大取值是<code>\177</code>；</li>
<li>十六进制形式的转义字符最多后跟两个数字，也即<code>\xdd</code>，最大取值是<code>\7f</code>。</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>编译器优化常用的方法有：将内存变量缓存到寄存器；调整指令顺序充分利用CPU指令流水线，常见的是重新排序读写指令。对常规内存进行优化的时候，这些优化是透明的，而且效率很好。由编译器优化或者硬件重新排序引起的问题的解决办法是在从硬件（或者其他处理器）的角度看必须以特定顺序执行的操作之间设置内存屏障（memory barrier）.<br>volatile总是与优化有关，编译器有一种技术叫做数据流分析，分析程序中的变量在哪里赋值、在哪里使用、在哪里失效，分析结果可以用于常量合并，常量传播等优化，进一步可以死代码消除。但有时这些优化不是程序所需要的，这时可以用volatile关键字禁止做这些优化，volatile的字面含义是易变的，告诉编译器（GCC）:<br>1）不要将该段内嵌汇编指令与前面的指令重新排序；也就是在执行内嵌汇编代码之前，它前面的指令都执行完毕<br>2）不要将变量缓存到寄存器，因为这段代码可能会用到内存变量，而这些内存变量会以不可预知的方式发生改变，因此GCC插入必要的代码先将缓存到寄存器的变量值写回内存，如果后面又访问这些变量，需要重新访问内存。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/24/MySQL/" rel="next" title="MySQL">
                <i class="fa fa-chevron-left"></i> MySQL
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/" rel="prev" title="面试要点记录">
                面试要点记录 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">翟安然</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#（一）虚函数表指针、虚基类表指针"><span class="nav-number">1.</span> <span class="nav-text">（一）虚函数表指针、虚基类表指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（二）万能头文件"><span class="nav-number">2.</span> <span class="nav-text">（二）万能头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（三）加速c"><span class="nav-number">3.</span> <span class="nav-text">（三）加速c++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（四）运算符优先级"><span class="nav-number">4.</span> <span class="nav-text">（四）运算符优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（五）c-11新特性：参考"><span class="nav-number">5.</span> <span class="nav-text">（五）c++11新特性：参考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（六）十大经典排序算法：参考"><span class="nav-number">6.</span> <span class="nav-text">（六）十大经典排序算法：参考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（七）重点知识点"><span class="nav-number">7.</span> <span class="nav-text">（七）重点知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#printf-从右向左计算，从左向右输出，符合栈模型"><span class="nav-number">7.0.0.1.</span> <span class="nav-text">printf 从右向左计算，从左向右输出，符合栈模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类中变量赋值顺序是变量声明顺序，所以赋值时先执行a-b-，再执行b-i-1-。a赋值为随机数"><span class="nav-number">7.0.0.2.</span> <span class="nav-text">类中变量赋值顺序是变量声明顺序，所以赋值时先执行a(b)，再执行b(i+1)。a赋值为随机数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#static"><span class="nav-number">7.0.0.3.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-多态分为静态多态和动态多态"><span class="nav-number">7.0.0.4.</span> <span class="nav-text">C++多态分为静态多态和动态多态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-里面‘-’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。"><span class="nav-number">7.0.0.5.</span> <span class="nav-text">C++里面‘&#x2F;’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#派生访问说明符"><span class="nav-number">7.0.0.6.</span> <span class="nav-text">派生访问说明符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别"><span class="nav-number">7.0.0.7.</span> <span class="nav-text">C++枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类型转换函数"><span class="nav-number">7.0.0.8.</span> <span class="nav-text">类型转换函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内存泄漏"><span class="nav-number">7.0.0.9.</span> <span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sizeof"><span class="nav-number">7.0.0.10.</span> <span class="nav-text">sizeof</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#大端小端"><span class="nav-number">7.0.0.11.</span> <span class="nav-text">大端小端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么析构函数可以virtual，构造函数不能呢？"><span class="nav-number">7.0.0.12.</span> <span class="nav-text">为什么析构函数可以virtual，构造函数不能呢？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（八）友元函数"><span class="nav-number">8.</span> <span class="nav-text">（八）友元函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（九）外部排序"><span class="nav-number">9.</span> <span class="nav-text">（九）外部排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符数组初始化"><span class="nav-number">10.</span> <span class="nav-text">字符数组初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何只能做堆上创建对象"><span class="nav-number">11.</span> <span class="nav-text">如何只能做堆上创建对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#只能在栈上创建对象"><span class="nav-number">12.</span> <span class="nav-text">只能在栈上创建对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-static、const-和-static-const-类型成员变量声明以及初始化"><span class="nav-number">13.</span> <span class="nav-text">C++ static、const 和 static const 类型成员变量声明以及初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c方式编译的c-文件决定不能出现重载函数"><span class="nav-number">14.</span> <span class="nav-text">c方式编译的c++文件决定不能出现重载函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存对齐的作用"><span class="nav-number">15.</span> <span class="nav-text">内存对齐的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-设计一个类：只能在堆上创建对象、只能在栈上创建对象、只能创建一个对象"><span class="nav-number">16.</span> <span class="nav-text">C++设计一个类：只能在堆上创建对象、只能在栈上创建对象、只能创建一个对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、只能在堆上创建对象"><span class="nav-number">16.1.</span> <span class="nav-text">一、只能在堆上创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、只能在栈上创建对象"><span class="nav-number">16.2.</span> <span class="nav-text">二、只能在栈上创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、只能创建一个对象"><span class="nav-number">16.3.</span> <span class="nav-text">三、只能创建一个对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串编码方式"><span class="nav-number">17.</span> <span class="nav-text">字符串编码方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Unicode"><span class="nav-number">17.1.</span> <span class="nav-text">Unicode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASCLL码"><span class="nav-number">17.2.</span> <span class="nav-text">ASCLL码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile"><span class="nav-number">18.</span> <span class="nav-text">volatile</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">翟安然</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  
  
    <script src="/js/cursor/fireworks.js"></script>
  

</body>
</html>

