<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统," />










<meta name="description" content="操作系统 什么是操作系统？ Linux内核子系统   操作系统的作用 以现代标准而言，一个标准PC的操作系统应该提供以下的功能 操作系统的特性">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="翟安然&#39;s Blog">
<meta property="og:description" content="操作系统 什么是操作系统？ Linux内核子系统   操作系统的作用 以现代标准而言，一个标准PC的操作系统应该提供以下的功能 操作系统的特性">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux32.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80.jpg">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3329890-cb2bce0f5e6bcf7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/411/format/webp">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/inode.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%98%BB%E5%A1%9EIO.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO%E5%A4%8D%E7%94%A8.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BC%82%E6%AD%A5IO.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FD_SET.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/EBADF.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/process.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2012072019525880.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2012072020252592.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2012072020020166.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AF%84%E5%AD%98%E5%99%A8.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%B4%E7%95%8C%E5%8C%BA.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E6%97%8B%E9%94%81.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mmap.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shm.png">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mmap.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/zero.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shouhu.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/thread.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/neihethread.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/zuhe.jpg">
<meta property="article:published_time" content="2020-03-25T16:23:38.000Z">
<meta property="article:modified_time" content="2021-04-15T13:48:01.326Z">
<meta property="article:author" content="翟安然">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/26/操作系统/"/>





  <title>操作系统 | 翟安然's Blog</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">翟安然's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="翟安然">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="翟安然's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-26T00:23:38+08:00">
                2020-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

<ul>
<li><a href="#操作系统">操作系统</a><ul>
<li><a href="#什么是操作系统">什么是操作系统？</a><ul>
<li><a href="#linux内核子系统httpsblogcsdnnetxiaomage_307_articledetails79117881">Linux内核子系统</a></li>
</ul>
</li>
<li><a href="#操作系统的作用">操作系统的作用</a><ul>
<li><a href="#以现代标准而言一个标准pc的操作系统应该提供以下的功能">以现代标准而言，一个标准PC的操作系统应该提供以下的功能</a></li>
<li><a href="#操作系统的特性">操作系统的特性</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li><a href="#linux系统结构详解">Linux系统结构详解</a><ul>
<li><a href="#1-linux系统一般有4个主要部分内核-shell-文件系统和应用程序">1. Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。</a><ul>
<li><a href="#用户空间-内核空间"><strong>用户空间 / 内核空间</strong></a></li>
</ul>
</li>
<li><a href="#2-内存管理">2. 内存管理</a><ul>
<li><a href="#虚拟内存管理">虚拟内存管理</a></li>
<li><a href="#地址映射">地址映射</a></li>
<li><a href="#程序内存区域分配">程序内存区域分配</a></li>
<li><a href="#物理内存管理">物理内存管理</a></li>
</ul>
</li>
<li><a href="#3-文件系统httpszhuanlanzhihucomp183238194utm_sourcewechat_sessionutm_mediumsocialutm_oi1126107633157103616">3. 文件系统</a></li>
<li><a href="#inode-的诸多优点">inode 的诸多优点</a><ul>
<li><a href="#io-和cache的区别">IO 和cache的区别</a></li>
<li><a href="#linux虚拟文件系统四大对象">Linux虚拟文件系统四大对象：</a></li>
<li><a href="#挂载详解httpsblogcsdnnetwuruixnarticledetails9619127">挂载详解</a></li>
<li><a href="#常规文件系统操作调用readfreadwrite等类函数中函数的调用过程">常规文件系统操作（调用read/fread/write等类函数）中函数的调用过程</a></li>
<li><a href="#文件描述符-打开文件描述符表-文件表-inode节点">文件描述符、打开文件描述符表、文件表、inode节点</a></li>
<li><a href="#目录项">目录项</a></li>
<li><a href="#inode">inode</a></li>
<li><a href="#文件存储结构示意图">文件存储结构示意图</a></li>
<li><a href="#inode的大小">inode的大小</a></li>
<li><a href="#inode号码">inode号码</a></li>
<li><a href="#硬链接">硬链接</a></li>
<li><a href="#软链接">软链接</a></li>
</ul>
</li>
<li><a href="#4-linux的五种io模型">4. Linux的五种IO模型</a><ul>
<li><a href="#1-阻塞io">1、阻塞IO</a></li>
<li><a href="#2-非阻塞io">2、非阻塞IO</a></li>
<li><a href="#3-io多路复用httpswwwjianshucompdb5da880154a">3、 IO多路复用</a></li>
<li><a href="#4-信号驱动io">4、信号驱动IO</a></li>
<li><a href="#5-异步io">5、异步IO</a></li>
<li><a href="#select-poll-epoll的区别httpscloudtencentcomdeveloperarticle1005481">select poll epoll的区别</a></li>
<li><a href="#select注意要点">select注意要点</a></li>
</ul>
</li>
<li><a href="#5-linux进程管理httpszhuanlanzhihucomp158965214">5. Linux进程管理</a><ul>
<li><a href="#什么是协程">什么是协程</a></li>
<li><a href="#进程的状态与转换">进程的状态与转换</a></li>
<li><a href="#进程创建fork和vfork">进程创建fork和vfork</a></li>
<li><a href="#进程和线程的区别">进程和线程的区别</a></li>
<li><a href="#线程有什么是共享的什么是私有的">线程有什么是共享的什么是私有的</a></li>
<li><a href="#线程同步">线程同步</a></li>
<li><a href="#为什么进程开销比线程大">为什么进程开销比线程大</a></li>
<li><a href="#线程通信">线程通信</a></li>
<li><a href="#临界区critical-section与互斥体mutex的区别httpwwwgooglecomhkurlsatrctjq临界互斥sourcewebcd3ved0cdoqfjacurlhttp3a2f2fwwwdiyblcom2fcourse2f3_program2fc2b2b2fcppsl2f20085252f117880htmleixlsut9kfpngtiaef0cxoawusgafqjcnexjmto_ag7hikjn33leodctcvjygcadrjt">临界区(Critical section)与互斥体(Mutex)的区别</a></li>
<li><a href="#进程间的通信方式ipcinter-process-communicationhttpswwwjianshucompc1015f5ffa74">进程间的通信方式（IPC,inter-Process Communication）</a></li>
<li><a href="#共享内存的实现方式">共享内存的实现方式</a></li>
<li><a href="#消息队列和管道基本上都是4次拷贝而共享内存只有两次">消息队列和管道基本上都是4次拷贝，而共享内存只有两次。</a></li>
<li><a href="#mmap和shm的不同">mmap和shm的不同</a></li>
<li><a href="#mmap内存映射原理httpswwwcnblogscomhuxiao-teep4660352html"><strong>mmap内存映射原理</strong></a></li>
<li><a href="#linux中的零拷贝技术">Linux中的零拷贝技术</a></li>
<li><a href="#windows进程通信">windows进程通信</a></li>
<li><a href="#windows命名管道和linux命名管道的区别">windows命名管道和Linux命名管道的区别</a></li>
<li><a href="#死锁死锁产生的原因死锁的必要条件怎么处理死锁">死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？</a></li>
<li><a href="#什么时候使用多线程什么时候使用多进程">什么时候使用多线程？什么时候使用多进程？</a></li>
<li><a href="#进程调度">进程调度</a><ul>
<li><a href="#抢占和上下文">抢占和上下文</a><ul>
<li><a href="#进程上下文">进程上下文</a></li>
</ul>
</li>
<li><a href="#守护进程">守护进程</a><ul>
<li><a href="#用户抢占">用户抢占</a></li>
<li><a href="#内核抢占">内核抢占</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#线程的3种实现方式">线程的3种实现方式</a></li>
<li><a href="#用户级线程和内核级线程的区别">用户级线程和内核级线程的区别</a><ul>
<li><a href="#用户线程的缺点">用户线程的缺点</a></li>
<li><a href="#内核线程优缺点">内核线程优缺点</a></li>
<li><a href="#组合方式">组合方式</a></li>
<li><a href="#内核栈和用户栈的区别httpsblogcsdnnetwestonduoarticledetails39033031">内核栈和用户栈的区别</a></li>
</ul>
</li>
<li><a href="#线程调用">线程调用</a></li>
<li><a href="#线程切换">线程切换</a></li>
<li><a href="#什么引起线程切换">什么引起线程切换</a></li>
<li><a href="#进程线程调度算法">进程线程调度算法</a></li>
<li><a href="#协程">协程</a></li>
</ul>
</li>
<li><a href="#中断和中断处理">中断和中断处理</a></li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->

<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h3><p>操作系统是管理计算机硬件与软件资源的计算机程序，负责计算机系统软、硬件资源的分配和使用；控制和协调并发活动；提供用户接口，使用户获得良好的工作环境，同时也是计算机系统的内核与基石。</p>
<p>操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p>
<h4 id="Linux内核子系统"><a href="#Linux内核子系统" class="headerlink" title="Linux内核子系统"></a><a href="https://blog.csdn.net/xiaomage_307_/article/details/79117881" target="_blank" rel="noopener">Linux内核子系统</a></h4><p>Linux内核主要由进程调度（SCHED）、内存管理（MM）、虚拟文件系统（VFS）、网络接口（NET）和进程间通信（IPC）5个子系统组成。</p>
<h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><p>操作系统位于底层硬件与用户之间，是两者沟通的桥梁。用户可以通过操作系统的用户界面，输入命令。操作系统则对命令进行解释，驱动硬件设备，实现用户要求。</p>
<h4 id="以现代标准而言，一个标准PC的操作系统应该提供以下的功能"><a href="#以现代标准而言，一个标准PC的操作系统应该提供以下的功能" class="headerlink" title="以现代标准而言，一个标准PC的操作系统应该提供以下的功能"></a>以现代标准而言，一个标准PC的操作系统应该提供以下的功能</h4><p>1、进程管理</p>
<p>又称处理器管理，其主要任务是对处理器的时间进行合理分配、对处理器的运行实施有效的管理。</p>
<p>2、存储器管理</p>
<p>由于多道程序共享内存资源，所以存储器管理的主要任务是对存储器进行分配、保护和扩充。</p>
<p>3、设备管理</p>
<p>根据确定的设备分配原则对设备进行分配，使设备与主机能够并行工作，为用户提供良好的设备使用界面。</p>
<p>4、文件管理</p>
<p>有效地管理文件的存储空间，合理地组织和管理文件系统，为文件访问和文件保护提供有效的方法及手段。</p>
<p>5、用户接口</p>
<p>用户操作计算机的界面称为用户接口（或用户界面），通过用户接口，用户只需进行简单操作，就能实现复杂的应用处理。</p>
<p>操作系统的主要功能可以分为三个方面：</p>
<p>　　1、对系统资源实施管理和调度</p>
<p>　　2、控制和协调并发活动</p>
<p>　　3、对外提供用户界面。</p>
<p>系统资源管理和并发活动控制是操作系统的核心功能，这两个部分是互相联系、不可分割的</p>
<h4 id="操作系统的特性"><a href="#操作系统的特性" class="headerlink" title="操作系统的特性"></a>操作系统的特性</h4><p>　操作系统的四个基本特征：并发，共享，异步，虚拟。<br>　　<strong>并发：</strong>是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它应该具有处理和调度多个程序同时执行的能力。在这种多道程序环境下，一段时间内，宏观上有多个程序在同时运行，而每一时刻，单处理器环境下实际仅能有一道程序执行，故微观上这些程序还是在分时地交替执行。操作系统的并发性是通过分时得以实现的。（<strong>并行</strong>是指计算机系统具有可以同时进行运算或操作的特性，在同一时间完成两种或两种以上的工作。并行性需要有相关硬件的支持，如多流水线或多处理器硬件环境）。<br>　　<strong>共享：</strong>是指系统中的资源（硬件资源和信息资源）可以被多个并发执行的程序共同使用，而不是被其中一个独占。资源共享有两种方式：互斥访问和同时访问。<br>　　<strong>异步：</strong>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底。而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。<br>　　<strong>虚拟：</strong>虚拟性是一种管理技术，把物理上的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物的技术。采用虚拟技术的目的是为用户提供易于使用、方便高效的操作环境。</p>
<h2 id="Linux系统结构详解"><a href="#Linux系统结构详解" class="headerlink" title="Linux系统结构详解"></a>Linux系统结构详解</h2><h3 id="1-Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。"><a href="#1-Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。" class="headerlink" title="1. Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。"></a>1. Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。</h3><p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90.jpg" alt="Linux系统组成部分层次结构"></p>
<h4 id="用户空间-内核空间"><a href="#用户空间-内核空间" class="headerlink" title="用户空间 / 内核空间"></a><strong>用户空间 / 内核空间</strong></h4><p> 现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。 操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p>
<p>注：<a href="https://blog.csdn.net/zqf5816/article/details/4594806?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">对于32位机来讲，最简单的方法就是用一个32位数来标识一个字节的存储地址，寻址时只要给出一个32位数就可以直接找到地址</a></p>
<p>内核是操作系统的核心，具有很多最基本功能，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。Linux 内核主要由内存管理、进程管理、设备驱动程序、文件系统和网络管理等组成。</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8.jpg" alt="Linux内核组成"></p>
<p>由于操作系统都包括内核空间和用户空间（或者说内核态和用户态），内核空间主要存放的是内核代码和数据，是供系统进程使用的空间。而用户空间主要存放的是用户代码和数据，是供用户进程使用的空间。目前Linux系统简化了分段机制，使得虚拟地址与线性地址总是保持一致，因此，Linux系统的虚拟地址也是0~4G。Linux系统将这4G空间分为了两个部分：将最高的1G空间（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，即为“内核空间”，而将较低的3G空间（从虚拟地址 0x00000000到0xBFFFFFFF）供用户进程使用，即为“用户空间”。同时由于每个用户进程都可以通过系统调用进入到内核空间，因此Linux的内核空间可以认为是被所有用户进程所共享的，因此对于一个具体用户进程来说，它可以访问的虚拟内存地址就是0~4G。另外Linux系统分为了四种特权级：0～3，主要是用来保护资源。0级特权最高，而3级则为最低，系统进程主要运行在0级，用户进程主要运行在3级。</p>
<p>用户空间对应进程，所以每当进程切换，用户空间就会跟着变化；而内核空间是由内核负责映射，它并不会跟着进程改变，是固定的。内核空间地址有自己对应的页表（init_mm.pgd），用户进程各自有不同的页表。每个进程的用户空间都是完全独立、互不相干的。</p>
<p><strong>进程管理</strong></p>
<p>进程实际是某特定应用程序的一个运行实体。在 Linux  系统中，能够同时运行多个进程，Linux  通过在短的时间间隔内轮流运行这些进程而实现“多任务”。这一短的时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度” ，完成调度的程序称为调度程序。</p>
<p>进程调度控制进程对CPU的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待CPU资源的进程，如果某个进程在等待其它资源，则该进程是不可运行进程。Linux使用了比较简单的基于优先级的进程调度算法选择新的进程。</p>
<p>通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且只能由这一进程访问，这样，操作系统避免了进程之间的互相干扰以及“坏”程序对系统可能造成的危害。 为了完成某特定任务，有时需要综合两个程序的功能，例如一个程序输出文本，而另一个程序对文本进行排序。为此，操作系统还提供进程间的通讯机制来帮助完成这样的任务。Linux 中常见的进程间通讯机制有信号、管道、共享内存、信号量和套接字等。</p>
<p>内核通过系统调用接口（SCI） 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSⅨ] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSⅨ 机制）。</p>
<p> 为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的，并且进程切换是非常耗费资源的。</p>
<p><strong>进程阻塞</strong><br> 正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得了CPU资源），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p>
<p><strong>文件描述符</strong><br> 文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。<br> 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<p><strong>缓存I/O</strong><br> 缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><p>对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的物理内存满足应用程序对内存的大需求量，<strong>Linux  采用了称为“虚拟内存”的内存管理方式</strong>。Linux  将内存划分为容易处理的“内存页”（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。</p>
<p>不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。</p>
<p>为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。</p>
<h4 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h4><p><strong>虚拟内存技术实际上就是建立了“内存—-外存”的两级存储结构，利用局部性原理实现高速缓存。</strong></p>
<p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还可以通过覆盖或者把处于不活动状态的程序以及它们的数据全部交换到外部磁盘存储器上临时存储。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。</p>
<p>进程由不同长度的段组成：代码段、动态库的代码、全局变量和动态产生数据的堆、栈等，在Linux中为每个进程管理了一套虚拟地址空间：</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B.jpg" alt="每个进程管理一套虚拟地址空间"></p>
<p>在我们写代码malloc完以后，并没有马上占用那么大的物理内存，而仅仅是维护上面的虚拟地址空间而已，只有在真正需要的时候才分配物理内存，这就是COW（COPY-ON-WRITE:写时复制）技术，而物理分配的过程就是最复杂的缺页异常处理环节。对于32位的Linux操作系统，系统为每个进程分配4G的虚拟内存。<img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux32.png" alt="进程虚拟内存管理"></p>
<p>虚拟内存中，允许将一个作业分多次调入内存。釆用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：</p>
<ul>
<li>请求分页存储管理。</li>
<li>请求分段存储管理。</li>
<li>请求段页式存储管理。 </li>
</ul>
<p>不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面： </p>
<ul>
<li><p>一定容量的内存和外存。 </p>
</li>
<li><p>页表机制（或段表机制）：作为主要的数据结构。 </p>
</li>
<li><p>中断机制：当用户程序要访问的部分尚未调入内存，则产生中断。 </p>
</li>
<li><p>地址变换机制：逻辑地址到物理地址的变换。{</p>
<p>页面置换算法：</p>
<p>​    1）最佳置换算法 OPT</p>
<p>​    2）最近最久未使用算法 LRU</p>
<p>​    3）先进先出算法 FIFO</p>
<p>​    4）始终（CLOCK）置换算法</p>
<p>}</p>
</li>
</ul>
<h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><p>在Linux内部的地址的映射过程为逻辑地址–&gt;线性地址–&gt;物理地址，物理地址最简单：地址总线中传输的数字信号，而线性地址和逻辑地址所表示的则是一种转换规则，线性地址规则如下：</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.jpg" alt="img"></p>
<p>这部分由MMU完成，其中涉及到主要的寄存器有CR0、CR3。机器指令中出现的是逻辑地址，逻辑地址规则如下：</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80.jpg" alt="逻辑地址规则"></p>
<p>在Linux中的逻辑地址等于线性地址，也就是说Inter为了兼容把事情搞得很复杂，Linux简化顺便偷个懒。</p>
<h4 id="程序内存区域分配"><a href="#程序内存区域分配" class="headerlink" title="程序内存区域分配"></a>程序内存区域分配</h4><ol>
<li><p>一个程序本质上都是由 bss段、data段、text段三个组成的。bss段通常是指用来存放程序中静态变量和未初始化的全局变量一块内存区域，一般在初始化时bss 段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。比如，在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，静态变量和未初始化的全局变量保存在.bss 段中。text和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化。bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小；bss段的大小从可执行文件中得到 ，然后链接器得到这个大小的内存块，紧跟在数据段后面。data段（已手动初始化的数据）则为数据分配空间，数据保存在目标文件中；data段包含经过初始化的全局变量以及它们的值。当这个内存区进入程序的地址空间后全部清零。包含data段和bss段的整个区段此时通常称为数据区。</p>
</li>
<li><p>同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。</p>
</li>
</ol>
<h4 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h4><p><strong>Linux内核管理物理内存是通过分页机制</strong>实现的，它将整个内存划分成无数个4k（在i386体系结构中）大小的页，从而分配和回收内存的基本单位便是内存页了。利用<strong>分页管理</strong>有助于灵活分配内存地址，因为分配时不必要求必须有大块的连续内存，系统可以东一页、西一页的凑出所需要的内存供进程使用。虽然如此，但是实际上系统使用内存时还是倾向于分配连续的内存块，因为分配连续内存时，页表不需要更改，因此能降低TLB的刷新率（频繁刷新会在很大程度上降低访问速度）。物理内存的使用主要分为以下几个方面：</p>
<p>（1）内核使用</p>
<p>操作系统启动时，位于/boot目录下的压缩内核文件会被加载到内存中并解压。这部分内容在系统允许期间都会常驻在内存的起始位置。</p>
<p>（2）slab分配器</p>
<p>操作系统的运行还需要更多的空间来分配给管理进程、文件描述符、socket和加载的内和模块等内容。所以内核会通过slab分配器动态分配内存。</p>
<p>​    PS：slab是Linux操作系统的一种内存分配机制。其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用brk系统调用来进行分配和释放，不仅会造成大量的碎片，而且也会影响性能。而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给操作系统，从而避免这些出现内存碎片。slab分配器并不丢弃已分配的对象，而是释放并把它们保存在内存中。当以后又要请求新的对象时，就可以从内存直接获取而不用重复初始化。可以在/proc/meminfo中查看当前slab分配器中的内存大小。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3329890-cb2bce0f5e6bcf7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/411/format/webp" alt="img"></p>
<p>（3）进程使用</p>
<p>除去内核使用的部分，所有的进程都需要分配物理内存页给它们的代码、数据和堆栈。进程消耗的这些物理内存被称为“驻留内存”，RSS。</p>
<p>（4）页缓存page cache</p>
<p>​     除去在内核和进程使用的部分，物理内存剩下的部分被称为页缓存，page cache。因为磁盘io的速度远远低于内存的访问速度，所以为了加快访问磁盘数据的速度，页缓存尽可能的保存着从磁盘读入的数据。page cache中还有一部分称为buffer，它的作用是缓存要写入到磁盘的数据。</p>
<p>​     页缓存的大小是在一直动态变化的。当系统内存充足时，页缓存会一直增大；当系统free内存不足时，这时如果有进程申请内存，操作系统会从page cache中回收内存页进行分配，如果page cache也已不足，那么系统会将当期驻留在内存中的数据置换到事先配置在磁盘上的swap空间中，然后空出来的这部分内存就可以用来分配了。这就是swap交换。</p>
<p>​     PS：出现swap交换时，数据被置换到swap空间后(swap out)，该进程使用的内存量下降，在atop等监控工具中的RGROW列为负值，但这并不表示该进程释放了内存，当它需要时，这部分数据又会被换入到内存中(swap in)。另外， swap交换往往会带来磁盘IO的大量消耗，严重影响到系统正常的磁盘io。出现大量的swap交换说明系统已经快要不行了，需要重点关注。</p>
<p><a href="https://zhuanlan.zhihu.com/p/117375905" target="_blank" rel="noopener">扇区 磁盘块 内存页</a></p>
<p><strong>总结</strong>：系统内核为每个进程都维护了一份从虚拟内存到物理内存的映射表，称为页表。页表根据虚拟地址，查找出锁映射的物理页位置和数据在物理页中的偏移量，便得到了实际需要访问的物理地址。</p>
<p>进程在运行过程中，会加载许多操作系统的动态库，比如 libc.so、libld.so等。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为<strong>共享内存</strong>。如途中进程1和进程2的共享内存段，实际都映射到同一块物理内存。注意，进程占用的共享内存也是计算到驻留内存中的。</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98.png" alt="虚拟内存映射物理内存"></p>
<h3 id="3-文件系统"><a href="#3-文件系统" class="headerlink" title="3. 文件系统"></a>3. <a href="https://zhuanlan.zhihu.com/p/183238194?utm_source=wechat_session&utm_medium=social&utm_oi=1126107633157103616" target="_blank" rel="noopener">文件系统</a></h3><p>文件系统指文件存在的物理空间，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。一个操作系统的运行离不开对文件的操作，因此必然要拥有并维护自己的文件系统。</p>
<p>和 DOS 等操作系统不同，Linux 操作系统中单独的文件系统并不是由驱动器号或驱动器名称（如 A:  或 C:  等）来标识的。相反，和 UNIX  操作系统一样，Linux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。Linux  将新的文件系统通过一个称为“挂装”或“挂上”的操作将其挂装到某个目录上，从而让不同的文件系统结合成为一个整体。Linux  操作系统的一个重要特点是它支持许多不同类型的文件系统。Linux 中最普遍使用的文件系统是 Ext2，它也是 Linux  土生土长的文件系统。但 Linux  也能够支持 FAT、VFAT、FAT32、MINIX 等不同类型的文件系统，从而可以方便地和其它操作系统交换数据。由于 Linux  支持许多不同的文件系统，并且将它们组织成了一个统一的虚拟文件系统.</p>
<p>虚拟文件系统（VirtualFileSystem,VFS）:隐藏了各种硬件的具体细节，把文件系统操作和不同文件系统的具体实现细节分离了开来，为所有的设备提供了统一的接口，VFS提供了多达数十种不同的文件系统。虚拟文件系统可以分为逻辑文件系统和设备驱动程序。逻辑文件系统指Linux所支持的文件系统，如ext2,fat等，设备驱动程序指为每一种硬件控制器所编写的设备驱动程序模块。</p>
<p>虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层。即<strong>VFS 在用户和文件系统之间提供了一个交换层</strong>。</p>
<p>在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 ./linux/fs 中找到。</p>
<p><strong>文件系统层之下是缓冲区缓存</strong>，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。</p>
<p>因此，用户和进程不需要知道文件所在的文件系统类型，而只需要象使用 Ext2  文件系统中的文件一样使用它们。</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt="文件系统结构"></p>
<p>微软的DOS和windows也是采用树型结构，但是在DOS和 windows中这样的树型结构的根是磁盘分区的盘符，有几个分区就有几个树型结构，他们之间的关系是并列的。最顶部的是不同的磁盘（分区），如：C，D，E，F等。</p>
<p>但是在linux中，无论操作系统管理几个磁盘分区，这样的目录树只有一个。从结构上讲，各个磁盘分区上的树型目录不一定是并列的。</p>
<p><strong>Linux文件存储结构：大部分的Linux文件系统（如ext2、ext3）规定，一个文件由目录项、inode和数据区组成</strong>。</p>
<p>目录项：包括文件名和inode节点号。目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。<br>inode：又称文件索引节点，包含文件的基础信息以及数据块的指针。<br>数据块：包含文件的具体内容。</p>
<h3 id="inode-的诸多优点"><a href="#inode-的诸多优点" class="headerlink" title="inode 的诸多优点"></a>inode 的诸多优点</h3><p>（1）对于有些无法删除的文件可以通过删除inode节点来删除；<br>（2）移动或者重命名文件，只是改变了目录下的文件名到inode的映射，并不需要实际对硬盘操作；<br>（3）删除文件的时候，只需要删除inode，不需要实际清空那块硬盘，只需要在下次写入的时候覆盖即可（这也是为什么删除了数据可以进行数据恢复的原因之一）；<br>（4）打开一个文件后，只需要通过inode来识别文件。</p>
<h5 id="IO-和cache的区别"><a href="#IO-和cache的区别" class="headerlink" title="IO 和cache的区别"></a>IO 和cache的区别</h5><p><strong>Buffer</strong>（缓冲区）是系统两端处理<strong>速度平衡</strong>（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到<strong>流量整形</strong>的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。<br><strong>Cache</strong>（缓存）则是系统两端处理<strong>速度不匹配</strong>时的一种<strong>折衷策略</strong>。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。</p>
<h5 id="Linux虚拟文件系统四大对象："><a href="#Linux虚拟文件系统四大对象：" class="headerlink" title="Linux虚拟文件系统四大对象："></a>Linux虚拟文件系统四大对象：</h5><p>存储在磁盘：</p>
<p>1）超级块(super block)</p>
<p>2）索引节点(inode)</p>
<p>存储在内存：</p>
<p>3）目录项(dentry)</p>
<p>4）文件对象(file)</p>
<h5 id="挂载详解"><a href="#挂载详解" class="headerlink" title="挂载详解"></a><a href="https://blog.csdn.net/wuruixn/article/details/9619127" target="_blank" rel="noopener">挂载详解</a></h5><p>挂载条件<br>1、挂载点必须是一个目录。<br>2、一个分区挂载在一个已存在的目录上，这个目录可以不为空，但挂载后这个目录下以前的内容将不可用。对于其他操作系统建立的文件系统的挂载也是这样。</p>
<p>struct path结构体中主要包含了两个成员变量，分别是struct vfsmount，struct dentry。前者指向文件系统装载对象的指针，后者指向目录项对象的指针。挂载后当前目录项对象失效，使用vfsmount对象的目录项替代。</p>
<p>基于 Linux 一切皆文件的设计思想，目录其实也是个文件，你甚至可以通过 vim 打开它，它也有 inode，inode 里面也是指向一些块。</p>
<p>和普通文件不同的是，普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。</p>
<p>在目录文件的块中，最简单的保存格式就是列表，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。</p>
<p>列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6.jpg" alt></p>
<p>通常，第一项是「.」，表示当前目录，第二项是「..」，表示上一级目录，接下来就是一项一项的文件名和 inode。</p>
<p>如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。</p>
<p>于是，保存目录的格式改成哈希表，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。</p>
<p>Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。</p>
<p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。</p>
<h5 id="常规文件系统操作（调用read-fread-write等类函数）中函数的调用过程"><a href="#常规文件系统操作（调用read-fread-write等类函数）中函数的调用过程" class="headerlink" title="常规文件系统操作（调用read/fread/write等类函数）中函数的调用过程"></a>常规文件系统操作（调用read/fread/write等类函数）中函数的调用过程</h5><p>VFS所隐含的主要思想在于引入了一个通用的文件模型（common file model)，这个模型能够表示所有支持的文件系统。linux内核对每个文件读写操作都必须使用一个指针，指向要访问的具体文件系统的适当函数。换句话说，当应用程序对read()或是write()调用引起内核调用相应的sys_read()或是sys_write()服务程,文件在内核内存中是由一个file数据结构来表示的。这种数据结构中包含一个称为f_op的字段，该字段中包含一个指向专对某一个文件系统(如sysfs虚拟文件系统)的读写函数指针，sys_read()或是sys_write()查找到指向该函数的指针，并调用它。这样一来，应用程序的read()或是write()就被转化为相对间接的调用：</p>
<p>file-&gt;f_op-&gt;read() 或 file-&gt;f_op-&gt;write()</p>
<p><a href="https://blog.csdn.net/qq_28114615/article/details/94590598" target="_blank" rel="noopener">参考</a></p>
<ul>
<li><p><strong>读文件</strong><br>1、进程调用库函数向内核发起读文件请求；</p>
<p>2、内核通过检查进程的文件描述符定位到虚拟文件系统VFS的已打开文件列表表项；</p>
<p>3、调用该文件可用的系统调用函数read()</p>
<p>3、read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode；</p>
<p>4、在inode中，通过文件内容偏移量计算出要读取的页；</p>
<p>5、通过inode找到文件对应的address_space；</p>
<p>6、在address_space中访问该文件的页缓存树，查找对应的页缓存结点：</p>
<p>（1）如果页缓存命中，那么直接返回文件内容；</p>
<p>（2）如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址(每个inode号在磁盘上有固定位置)，读取相应的页填充该缓存页；重新进行第6步查找页缓存；</p>
<p>7、文件内容读取成功。</p>
<p><strong>写文件</strong><br>前5步和读文件一致，在address_space中查询对应页的页缓存是否存在：</p>
<p>6、如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。</p>
<p>7、如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。</p>
<p>8、一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：</p>
<p>（1）手动调用sync()或者fsync()系统调用把脏页写回</p>
<p>（2）pdflush进程会定时把脏页写回到磁盘</p>
<p>同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。</p>
</li>
</ul>
<p>将磁盘上的数据缓存在内存中，加速文件的读写。实际上，在一般情况下，read/write是只跟缓存打交道的。read就直接从缓存读数据。如果要读的数据还不在缓存中，则触发一次读盘操作，然后等待磁盘上的数据被更新到磁盘高速缓存中；write也是直接写到缓存里去，然后就不用管了。后续内核会负责将数据写回磁盘。为了实现这样的缓存，每个文件的inode内嵌了一个address_space结构，通过inode-&gt;i_mapping来访问。<strong>address_space结构中维护了一棵radix树，用于磁盘高速缓存的内存页面就挂在这棵树上。而既然磁盘高速缓存是跟文件的inode关联上的，则打开这个文件的每个进程都共用同一份缓存</strong>。</p>
<h5 id="文件描述符、打开文件描述符表、文件表、inode节点"><a href="#文件描述符、打开文件描述符表、文件表、inode节点" class="headerlink" title="文件描述符、打开文件描述符表、文件表、inode节点"></a>文件描述符、打开文件描述符表、文件表、inode节点</h5><p>在内核中每一个打开的文件都需要由3种数据结构来进行维护：</p>
<p>1）每个进程对应一张<strong>打开文件描述符表</strong>，这是进程级数据结构，也就是每一个进程都各自有这样一个数据结构；</p>
<p>2）内核维持一张打开文件表，<strong>文件表</strong>由多个文件表项组成，这是系统级数据结构，也就是说这样的数据结构是针对于整个内核而言的，每个进程都可共享的；</p>
<p>3.每个打开的文件对应一个i节点（i-node）数据结构（Linux下只有i节点没有v节点），由于这是每一个打开的文件与之对应的，因此这也是一个系统级数据结构，存在于内核中，非进程所独有。</p>
<p>不同进程打开现存文件或新建文件时，内核会返回一个<strong>文件描述符</strong>（file descriptor），它是个非负整数。对于每一个进程，都会分配一个PCB数据结构，它其中包含了该进程的所有信息，而在代码实现上，这个数据结构名为<strong>task_struct</strong>， 在<strong>task_struct</strong>中，有一个成员变量名为<strong>files</strong>，这是一个描述打开文件信息的变量，其类型为<strong>struct files_struct</strong>。在所有进程的PCB（Process Control Block）中均会保存一份<strong>打开文件描述符表</strong>，实际上就是files_struct 中的成员struct file * fd_array[NR_OPEN_DEFAULT]它是一个指针数组，数组每一个元素都是一个指向file类型的指针，可想而知，这些指针都会指向一个打开的文件，并且file这一数据结构就是用来描述一个打开的文件的，<strong>而我们所说的文件描述符，实际上就是这个指针数组的索引</strong>。这也是为什么文件描述符是非负整数。文件描述符就是这个表的索引（数组下标），每个表项都有一个指向已打开文件的指针（数组的内容），<strong>具体是指向文件表中该文件对应的表格项</strong>。</p>
<p>在Linux系统中，已打开的文件形成<strong>打开文件表</strong>（open file table,存储在物理内存中），存放在<strong>内核空间</strong>（系统级）中，并由系统里的所有进程共享。该表中每个表格保存了一个打开文件的全部信息，如下所示：</p>
<ul>
<li>当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）；</li>
<li>打开文件时所使用的状态标识（即，open()的flags参数）；<br>文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）；</li>
<li>与信号驱动相关的设置；</li>
<li>对该文件<strong>i-node</strong>对象的引用；</li>
<li>文件类型（例如：常规文件、套接字或FIFO）和访问权限；</li>
<li>一个指针，指向该文件所持有的锁列表；</li>
<li>文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳；</li>
</ul>
<p>文件表项的数据结构就是file结构体，而在实际上内核中也并不存在这样一张文件表，只是每个打开的文件都对应一个file结构体，也就是一个文件表项，<strong>打开文件描述符表struct file * fd_array[NR_OPEN_DEFAULT]</strong>数组中的每一项都会指向这样一个文件表项。 在file结构体中，不得不再说一下它的f_path成员，这是一个struct path类型的变量，该类型定义于include/linux/path.h：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct path &#123;</span><br><span class="line">	struct vfsmount *mnt;</span><br><span class="line">	struct dentry *dentry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的dentry实际上就指向文件所在的目录项了，struct dentry的类型定义于include/linux/dcache.h。 在dentry结构体中，描述了根结点、父节点等等信息，尤其还要注意的是<strong>struct inode *d_inode</strong>这一变量，它则是指向了一个i-node结点。</p>
<p>文件描述符是一个POSIX标准下的概念，为系统调用接口，常见于Linux系统。Windows也是声称遵循POSIX标准的，所以Windows也有文件描述符等概念，但不常用。文件描述符的分配规则： 从当前未被分配的最小整数处分匹配，特别的有：标准输入（stdin）的文件描述符是 0；标准输出（stdout）的文件描述符是 1；标准错误（stderr）的文件描述符是 2。</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/inode.png" alt></p>
<p>当进程试图访问磁盘上的一个文件时（比如执行open系统调用），需要将该文件的磁盘inode中的一部分信息拷贝到内存中，这部分内容进而构成了内存中的”struct inode”结构体。</p>
<p><strong>假设现在一个进程要在”/a/b/c/d/“目录下新建一个名称为”e”的文件，那么路径查找的过程大致如下</strong>：<br><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B.jpg" alt><br>在VFS的概念里，「目录」被视作一种特殊的文件，也具有对应的inode对象。因而在整个查找过程中，需要将多达6个inode的内容拷贝到内存。</p>
<h5 id="目录项"><a href="#目录项" class="headerlink" title="目录项"></a>目录项</h5><p>Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</p>
<p>ls命令只列出目录文件中的所有文件名：ls /etc<br>ls -i命令列出整个目录文件，即文件名和inode号码：ls -i /etc</p>
<h5 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h5><p>理解inode，要从文件储存说起。文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector），每个扇区储存512字节（相当于0.5KB）。操作系统读取硬盘的时候，不会一个扇区一个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个sector组成一个block。</p>
<p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p>
<p>inode包含文件的元信息内容：（存放除文件名之外的所有文件信息）</p>
<p>文件的字节数。<br>文件类型。<br>文件拥有者的User ID。<br>文件的Group ID。<br>文件的读、写、执行权限。<br>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。<br>链接数，即有多少文件名指向这个inode。<br>文件数据block的位置（数据块指针）。<br>stat命令（display file or file system status）：查看某个文件或文件系统的status信息</p>
<h5 id="文件存储结构示意图"><a href="#文件存储结构示意图" class="headerlink" title="文件存储结构示意图"></a>文件存储结构示意图</h5><p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt></p>
<h5 id="inode的大小"><a href="#inode的大小" class="headerlink" title="inode的大小"></a>inode的大小</h5><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。<br>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p>
<p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df -i 命令。</p>
<p>查看每个inode节点的大小，可以用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dumpe2fs -h /dev/hda | grep <span class="string">"Inode size"</span></span><br></pre></td></tr></table></figure>


<p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p>
<h5 id="inode号码"><a href="#inode号码" class="headerlink" title="inode号码"></a>inode号码</h5><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。<br>使用ls -i命令，可以看到文件名对应的inode号码，例如：ls -i demo.txt</p>
<p><strong>操作系统打开文件</strong>：对Linux系统内部而言，打开文件不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。表面上，用户通过文件名，打开文件。系统内部这个过程分成三步：首先，系统在目录项中得到这个文件名对应的inode号码；其次，通过inode号码，获取文件的所有信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p>
<p><strong>详细流程</strong>：文件中的数据是放在磁盘的数据区中的，而一个文件名则是通过对应的i节点与这些磁盘块联系起来，这些盘块的号码就存放在i节点的逻辑块数组i_zone[]中。在文件系统的一个目录中，其中所有文件名信息对应的目录项保存在该目录名文件的数据块中，例如，root/下的所有文件名的目录项就保存在root/目录名文件的数据块中，而文件系统根目录下的所有文件名信息则保存在指定i节点（1号节点)的数据块中，文件名的目录项结构如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct dir_entry&#123;</span><br><span class="line"></span><br><span class="line">unsigned short indoe;&#x2F;&#x2F;i节点号</span><br><span class="line"></span><br><span class="line">char name[NAME_LEN];&#x2F;&#x2F;文件名</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>目录项结构大小是16B，那么一个逻辑盘块可以存放1024/16=64个目录项。有关文件的其他信息则保存在该i节点号指定的i节点结构中，每个i节点号的i节点都位于磁盘的固定地方。</p>
<p>在打开一个文件时，文件系统会根据给定的文件名找到其i节点号，从而通过其对应i节点信息找到文件所在的磁盘块位置。例如要查找文件/usr/bin/vi的i节点号，文件系统首先从固定i节点号(1号i节点)的根目录开始寻找，即从该i节点号1的数据块中找到名为usr的目录项，从而得到名为usr的目录项，从而得到文件/usr的i节点号，根据该i节点号文件系统可以顺利取得目录usr/的内容，并从其中找到bin的目录项，同理知道bin的i节点号，这样就知道了/usr/bin目录的位置，读取其i节点号的数据块内容，找到vi对应的目录项，从而得到vi的i节点号。</p>
<p>三、共享文件（静态共享）<br>现代常用的有两种共享方式。</p>
<h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><p>Linux系统允许，可以为一个或多个文件名指向同一个inode号码（索引节点中的链接计数count）。这意味着，可以用不同的文件名访问同样的内容；</p>
<p>同时对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。</p>
<p>ln命令：创建硬链接</p>
<p>ln source_file target_file<br>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。<br>inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域（数据空间）。</p>
<h5 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h5><p>除了硬链接以外，还有一种特殊情况。文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。<br>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。</p>
<p>ln -s命令可以创建软链接，语法为：</p>
<p>ln -s source_file target_file</p>
<h3 id="4-Linux的五种IO模型"><a href="#4-Linux的五种IO模型" class="headerlink" title="4. Linux的五种IO模型"></a>4. Linux的五种IO模型</h3><p>1）阻塞IO</p>
<p>2）非阻塞IO</p>
<p>3）IO复用（select和poll）</p>
<p>4）信号驱动IO（sigio）</p>
<p>5）异步IO（aio_）</p>
<p>一般来说，IO操作都分为两个阶段，就拿套接口的输入操作来说，它的两个阶段主要是：</p>
<p>1）等待网络数据到来，当分组到来时，将其拷贝到内核空间的临时缓冲区中</p>
<p>2）将内核空间临时缓冲区中的数据拷贝到用户空间缓冲区中</p>
<h4 id="1、阻塞IO"><a href="#1、阻塞IO" class="headerlink" title="1、阻塞IO"></a>1、阻塞IO</h4><p>默认情况下，所有套接口都是阻塞的。</p>
<p>例如recvfrom函数是一个系统调用：</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%98%BB%E5%A1%9EIO.png" alt="img"></p>
<p>说明：任何一个系统调用都会产生一个由用户态到内核态切换，再从内核态到用户态切换的过程，而进程上下文切换是通过系统中断程序来实现的，需要保存当前进程的上下文状态，这是一个极其费力的过程。</p>
<h4 id="2、非阻塞IO"><a href="#2、非阻塞IO" class="headerlink" title="2、非阻塞IO"></a>2、非阻塞IO</h4><p>当我们把套接口设置成非阻塞时，就是由用户进程不停地询问内核某种操作是否准备就绪，这就是我们常说的“轮询”。这同样是一件比较浪费CPU的方式。</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png" alt="img"></p>
<h4 id="3、-IO多路复用"><a href="#3、-IO多路复用" class="headerlink" title="3、 IO多路复用"></a>3、 <a href="https://www.jianshu.com/p/db5da880154a" target="_blank" rel="noopener">IO多路复用</a></h4><p>我们常用到的IO多路复用，主要是select和poll。这里同样是会阻塞进程的，但是这里进程是阻塞在select或者poll这两个系统调用上，而不是阻塞在真正的IO操作上。</p>
<p>看起来它与blocking I/O很相似，两个阶段都阻塞。但它与blocking I/O的一个重要区别就是它可以等待多个数据报就绪（datagram ready），即可以处理多个连接，而阻塞IO一次性只能监听一个套接口。这里的select相当于一个“代理”，调用select以后进程会被select阻塞，这时候在内核空间内select会监听指定的多个datagram (如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。</p>
<p>在select模型中每个socket一般都设置成non-blocking，虽然等待数据阶段仍然是阻塞状态，但是它是被select调用阻塞的，而不是直接被I/O阻塞的。select底层通过轮询机制来判断每个socket读写是否就绪。</p>
<p>当然select也有一些缺点，比如底层轮询机制会增加开销、支持的文件描述符数量过少等。为此，Linux引入了epoll作为select的改进版本。</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO%E5%A4%8D%E7%94%A8.png" alt="img"></p>
<ul>
<li><a href="https://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">多路复用三种机制select,poll,epoll的区别</a>：</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th>select</th>
<th align="left">poll</th>
<th align="left"><a href="https://www.jianshu.com/p/dd72cceaabc1" target="_blank" rel="noopener">epoll</a></th>
</tr>
</thead>
<tbody><tr>
<td align="left">操作方式</td>
<td>遍历</td>
<td align="left">遍历</td>
<td align="left">回调</td>
</tr>
<tr>
<td align="left">底层实现</td>
<td>数组</td>
<td align="left">链表</td>
<td align="left">红黑树和就绪链表</td>
</tr>
<tr>
<td align="left">IO效率</td>
<td>每次调用都进行线性遍历，时间复杂度为O(n)</td>
<td align="left">每次调用都进行线性遍历，时间复杂度为O(n)</td>
<td align="left">事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1)</td>
</tr>
<tr>
<td align="left">最大连接数</td>
<td>1024（x86）或2048（x64）</td>
<td align="left">无上限</td>
<td align="left">无上限</td>
</tr>
<tr>
<td align="left">fd拷贝</td>
<td>每次调用select，都需要把fd集合从用户态拷贝到内核态</td>
<td align="left">每次调用poll，都需要把fd集合从用户态拷贝到内核态</td>
<td align="left">调用epoll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝</td>
</tr>
</tbody></table>
<p>epoll是Linux目前大规模网络并发程序开发的首选模型。在绝大多数情况下性能远超select和poll。目前流行的高性能web服务器Nginx正式依赖于epoll提供的高效网络套接字轮询服务。但是，在并发连接不高的情况下，多线程+阻塞I/O方式可能性能更好。</p>
<p>select：内核需要将消息传递到用户空间，需要内核拷贝动作<br>poll：内核需要将消息拷贝到用户空间，需要内核拷贝动作<br>epoll：通过内核和用户空间共享一块内存来实现（直接内存）不需要拷贝动作。</p>
<h4 id="4、信号驱动IO"><a href="#4、信号驱动IO" class="headerlink" title="4、信号驱动IO"></a>4、信号驱动IO</h4><p>信号驱动IO就是说我们可以通过sigaction系统调用注册一个信号处理程序，然后主程序可以继续向下执行，当我们所监控的套接口有IO操作准备就绪时，由内核通知触发前面注册的信号处理程序执行，然后将我们所需要的数据从内核空间拷贝到用户空间。</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO.png" alt="img"></p>
<h4 id="5、异步IO"><a href="#5、异步IO" class="headerlink" title="5、异步IO"></a>5、异步IO</h4><p>异步IO与信号驱动IO最主要的区别就是信号驱动IO是由内核通知我们何时可以进行IO操作了，而异步IO则是由内核告诉我们IO操作何时完成了。具体来说就是，信号驱动IO当内核通知触发信号处理程序时，信号处理程序还需要阻塞在从内核空间缓冲区拷贝数据到用户空间缓冲区这个阶段，而异步IO直接是在第二个阶段完成后内核直接通知可以进程后续操作了。</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BC%82%E6%AD%A5IO.png" alt="img"></p>
<p>综上所述，我们发现 前四种IO模型的主要区别是在第一阶段，因为它们的第二阶段都是在阻塞等待数据由内核空间拷贝到用户空间；而异步IO很明显与前面四种有所不同，它在第一阶段和第二阶段都不会阻塞。具体参考如下：</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83.png" alt="img"></p>
<p>最后，总结下同步IO与异步IO的区别：</p>
<p>1）同步IO操作会引起进程阻塞直到IO操作完成。</p>
<p>2）异步IO操作不引起进程阻塞。</p>
<p>因此，由上面定义可以看出，阻塞IO、非阻塞IO、IO复用、信号驱动IO都是属于同步IO，而异步IO模型才与异步IO定义所匹配。</p>
<h4 id="select-poll-epoll的区别"><a href="#select-poll-epoll的区别" class="headerlink" title="select poll epoll的区别"></a><a href="https://cloud.tencent.com/developer/article/1005481" target="_blank" rel="noopener">select poll epoll的区别</a></h4><h4 id="select注意要点"><a href="#select注意要点" class="headerlink" title="select注意要点"></a>select注意要点</h4><ol>
<li>FD_SET()初始化fd_set的文件描述符一定是有效的file descriptor,不然会直接返回EBADF ERRORS。</li>
</ol>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FD_SET.png" alt></p>
<p>当把listensock改成大于listensock的值时运行程序出现：</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/EBADF.png" alt></p>
<ol start="2">
<li>调用epoll时不用把用户空间fd_set拷贝到内核空间，用户态和内核态内存映射mmap;当我们调用epoll_wait时，epoll_wait只需要检查rdlist双向链表中是否有存在注册的事件，效率非常可观,这里也需要将发生了的事件复制到用户态内存中即可。</li>
<li>ET模式要结合非阻塞</li>
</ol>
<h3 id="5-Linux进程管理"><a href="#5-Linux进程管理" class="headerlink" title="5. Linux进程管理"></a>5. <a href="https://zhuanlan.zhihu.com/p/158965214" target="_blank" rel="noopener">Linux进程管理</a></h3><p>linux内核空间，每个进程都有一个独立的数据结构，用来保存该进程的ID、优先级、地址的空间等信息，这个结构也被称做进程控制块（Process Control Block）。所谓的进程管理就是对进程控制块的管理。</p>
<p>当程序需要运行时，操作系统将代码和所有静态数据记载到内存和进程的地址空间（每个进程都拥有唯一的地址空间，见下图所示）中，通过创建和初始化栈（局部变量，函数参数和返回地址)、分配堆内存以及与IO相关的任务，当前期准备工作完成，启动程序，OS将CPU的控制权转移到新创建的进程，进程开始运行。</p>
<p>操作系统对进程的控制和管理通过PCB(Processing Control Block)，PCB通常是系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息(包括：进程标识号,进程状态,进程优先级,文件系统指针以及各个寄存器的内容等)，进程的PCB是系统感知进程的唯一实体。</p>
<p>进程的五种状态：创建状态、就绪状态、运行状态、阻塞状态、结束状态</p>
<h4 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h4><p>协程（Coroutine，又称微线程）是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制。协程与线程以及进程的关系见下图所示。</p>
<ul>
<li>协程可以比作子程序，但执行过程中，子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来继续执行。协程之间的切换不需要涉及任何系统调用或任何阻塞调用</li>
<li>协程只在一个线程中执行，是子程序之间的切换，发生在用户态上。而且，线程的阻塞状态是由操作系统内核来完成，发生在内核态上，因此协程相比线程节省了线程创建和切换的开销</li>
<li>协程中不存在同时写变量冲突，因此，也就不需要用来守卫关键区块的同步性原语，比如互斥锁、信号量等，并且不需要来自操作系统的支持。</li>
</ul>
<p>协程适用于IO阻塞且需要大量并发的场景，当发生IO阻塞，由协程的调度器进行调度，通过将数据流yield掉，并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复协程栈，并把阻塞的结果放到这个线程上去运行。</p>
<h4 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h4><p>进程在其生命周期内通常进程主要有以下三种状态：</p>
<p>1) 运行状态：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。</p>
<p>2) 就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。</p>
<p>3) 阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。</p>
<p>注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地转换到就绪状态的；而其他资源（如外设）的使用和分配或者某一事件的发生（如I/O操作的完成）对应的时间相对来说很长，进程转换到等待状态的次数也相对较少。这样来看，就绪状态和等待状态是进程生命周期中两个完全不同的状态，需要加以区分。</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/process.jpg" alt="进程状态转换"></p>
<p>就绪状态 -&gt; 运行状态：CPU 空闲时选择一个就绪进程，处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。</p>
<p>运行状态 -&gt; 就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。</p>
<p>运行状态 -&gt; 阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。</p>
<p>阻塞状态 -&gt; 就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.jpg" alt></p>
<h4 id="进程创建fork和vfork"><a href="#进程创建fork和vfork" class="headerlink" title="进程创建fork和vfork"></a>进程创建fork和vfork</h4><ul>
<li><p>进程描述符task_struct</p>
</li>
<li><p>在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。   </p>
</li>
<li><p>fork后操作系统会复制一个与父进程完全相同的子进程，两个进程共享代码空间，但数据空间相互独立，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别做不同的工作，也就是分岔了。</p>
</li>
<li><p>fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为调用了exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为调用了exec，exec负责读取可执行文件并将其载入地址空间开始运行，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</p>
</li>
</ul>
<p>fork之后内核会通过将子进程放在队列的前面，以让子进程先执行，因为一般子进程都会马上调用exec()函数，这样可以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能会开始向地址空间写入。</p>
<p>fork时子进程获得父进程数据空间、堆和栈的复制，所以变量的地址（当然是虚拟地址）也是一样的。每个进程都有自己的虚拟地址空间，不同进程的相同的虚拟地址显然可以对应不同的物理地址。因此地址相同（虚拟地址）而值不同没什么奇怪。<br>具体过程是这样的：<br>fork子进程完全复制父进程的栈空间，也复制了页表，但没有复制物理页面，所以这时虚拟地址相同，物理地址也相同，但是会把父子共享的页面标记为“只读”（类似mmap的private的方式），如果父子进程一直对这个页面是同一个页面，知道其中任何一个进程要对共享的页面“写操作”，这时内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为“可写”，留给另外一个进程使用。</p>
<p><strong>exec()</strong><br>对于exec系列函数一个进程一旦调用exec类函数，它本身就“死亡”了，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。不过exec类函数中有的还允许继承环境变量之类的信息，这个通过exec系列函数中的一部分函数的参数可以得到。</p>
<p>  <strong>fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别：</strong></p>
<ol>
<li>fork ()：子进程拷贝父进程的数据段、代码段<br>vfork ()：子进程与父进程共享数据段、代码段，子进程不能向地址空间写入。</li>
<li>fork ()父子进程的执行次序不确定<br>vfork 保证子进程先运行，子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，知道子进程退出或执行exec()。</li>
<li>若vfork ()调用exec 或<code>_exit()</code> 之前子进程依赖于父进程的进一步动作，会导致死锁。</li>
</ol>
<p>  <strong>现在由于在执行fork()时引入了写时拷贝页并且明确了子进程先执行，vfork()的好处就仅限于不拷贝父进程的页表项了，另外最好不要使用vfork()（如果exec调用失败，试想会发生什么）</strong></p>
<ul>
<li><p><strong>COW详述：</strong></p>
<p>   现在有一个父进程P1，这是一个主体，那么它是有灵魂也就身体的。现在在其虚拟地址空间（有相应的数据结构表示）上有：正文段，数据段，堆，栈这四个部分，相应的，内核要为这四个部分分配各自的物理块。即：正文段块，数据段块，堆块，栈块。至于如何分配，这是内核去做的事，在此不详述。</p>
<ol>
<li>现在P1用fork()函数为进程创建一个子进程P2，</li>
</ol>
<p>内核：</p>
<p>（1）复制P1的正文段，数据段，堆，栈这四个部分，注意是其内容相同。</p>
<p>（2）为这四个部分分配物理块，P2的：正文段－＞PI的正文段的物理块，其实就是不为P2分配正文段块，让P2的正文段指向P1的正文段块，数据段－＞P2自己的数据段块（为其分配对应的块），堆－＞P2自己的堆块，栈－＞P2自己的栈块。如下图所示：同左到右大的方向箭头表示复制内容。</p>
</li>
</ul>
<p>  <img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2012072019525880.jpg" alt="img"></p>
<ol start="2">
<li>写时复制技术：内核只为新生成的子进程创建虚拟空间结构，它们来复制于父进程的虚拟究竟结构，但是不为这些段分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。</li>
</ol>
<p>  <img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2012072020252592.jpg" alt="img"></p>
<ol start="3">
<li>vfork()：这个做法更加火爆，内核连子进程的虚拟地址空间结构也不创建了，直接共享了父进程的虚拟空间，当然了，这种做法就顺水推舟的共享了父进程的物理空间</li>
</ol>
<p>  <img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2012072020020166.jpg" alt="img"></p>
<p>  通过以上的分析，相信大家对进程有个深入的认识，它是怎么一层层体现出自己来的，进程是一个主体，那么它就有灵魂与身体，系统必须为实现它创建相应的实体， 灵魂实体与物理实体。这两者在系统中都有相应的数据结构表示，物理实体更是体现了它的物理意义。以下援引LKD</p>
<pre><code>传统的fork()系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，更糟的情况是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。Linux的fork()使用写时拷贝（copy-on-write）页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候。在页根本不会被写入的情况下—举例来说，fork()后立即调用exec()—它们就无需复制了。fork()的实际开销就是复制父进程的页表以及给子进程创建惟一的进程描述符。在一般情况下，进程创建后都会马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据（地址空间里常常包含数十兆的数据）。由于Unix强调进程快速执行的能力，所以这个优化是很重要的。这里补充一点：**Linux COW与exec没有必然联系**</code></pre><p><strong>线程是进程当中的一条执行流程。</strong></p>
<p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程都有独立一套的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B.jpg" alt></p>
<p>线程的优点：</p>
<ul>
<li>一个进程中可以同时存在多个线程；</li>
<li>各个线程之间可以并发执行；</li>
<li>各个线程之间可以共享地址空间和文件等资源；</li>
</ul>
<p>线程的缺点：</p>
<ul>
<li>当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃。</li>
</ul>
<h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ul>
<li>进程是资源的分配和调度的独立单元。进程拥有完整的虚拟地址空间，当发生进程切换时，不同的进程拥有不同的虚拟地址空间。而同一进程的多个线程共享同一地址空间（不同进程之间的线程无法共享）</li>
<li>进程是资源分配和调度的一个独立单元，是线程集合、资源集合（虚拟内存空间、文件描述符），线程是CPU执行单位。</li>
<li>线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，基本上不拥有系统资源。</li>
<li>一个进程至少包括一个线程，并且同一个进程的所有线程共享整个进程的资源，由于线程之间能够共享地址空间，因此，需要考虑同步和互斥操作</li>
<li>一个线程的意外终止会影响整个进程的正常运行，但是一个进程的意外终止不会影响其他的进程的运行。因此，多进程程序安全性更高。</li>
<li>进程的创建调用fork或者vfork，而线程的创建调用pthread_create。</li>
<li>进程间通信IPC需要特别的方法，线程间可以直接读写进程数据段（如全局变量）来进行通信。</li>
</ul>
<blockquote>
<p>多进程程序安全性高，进程切换开销大，效率低；多线程程序维护成本高，线程切换开销小，效率高。</p>
</blockquote>
<p><strong>线程崩溃了是否会影响其他线程或进程</strong><br>进程（主线程）创建了多个线程，多个子线程均拥有自己独立的栈空间（存储函数参数、局部变量等），但是多个子线程和主线程共享堆、全局变量等非栈内存。如果detach的子线程的崩溃是由于私有资源的，那就不会对主线程和其他子线程产生影响，但是如果子线程的崩溃是因为对共享区域造成了破坏，且没有错误处理的handler函数，那么大家就一起崩溃了。</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AF%84%E5%AD%98%E5%99%A8.png" alt></p>
<h4 id="线程有什么是共享的什么是私有的"><a href="#线程有什么是共享的什么是私有的" class="headerlink" title="线程有什么是共享的什么是私有的"></a>线程有什么是共享的什么是私有的</h4><p>线程共享的环境包括：</p>
<ol>
<li><p>进程堆、地址空间、全局变量(利用这些共享的数据，线程很容易的实现相互之间的通讯) </p>
</li>
<li><p>进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p>
</li>
</ol>
<p>线程独立的资源包括：</p>
<ol>
<li><p>线程ID</p>
</li>
<li><p>寄存器组的值</p>
</li>
</ol>
<p>由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。</p>
<ol start="3">
<li>程序计数器</li>
</ol>
<p>程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>如果线程执行 Java 方法，程序计数器记录的是正在执行的虚拟机字节码指令的地址。如果执行 Navtive 方法，程序计数器值则为空（Undefined）。因为 Navtive 方法是 Java 通过 JNI 直接调用本地 C/C++ 库，可以认为是 Native 方法相当于 C/C++ 暴露给 Java 的一个接口，Java 通过调用这个接口从而调用到 C/C++ 方法。由于该方法是通过 C/C++ 而不是 Java 进行实现。那么自然无法产生相应的字节码，并且 C/C++ 执行时的内存分配是由自己语言决定的，而不是由 JVM 决定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在多线程环境下，每个线程拥有一个栈和一个程序计数器。栈和程序计数器用来保存线程的执行历史和线程的执行状态，是线程私有的资源。其他的资源（比如堆、地址空间、全局变量）是由同一个进程内的多个线程共享</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>线程的栈</li>
</ol>
<p>栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数栈， 使得函数调用可以正常执行，不受其他线程的影响。</p>
<ol start="5">
<li>线程的错误返回码</li>
</ol>
<p>由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。线程返回0表示线程创建成功，1-255表示线程异常。进程fork()返回两个非负值为成功，子进程返回零，父进程返回子进程的PID；返回负数代表创建进程失败。</p>
<ol start="6">
<li>线程的信号屏蔽码</li>
<li>线程的优先级</li>
</ol>
<p>注：线程有自己的私有属性线程控制块TCB，进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志</p>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>用户态下的方法有：</p>
<ul>
<li><p>临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。只允许一个进程访问，不可能两个进程进行竞争。一个进程创建了临界区以后，其他进程是不可能获取到该临界区的进入权利的，但是允许进程内的多个线程竞争。适用范围是单一进程的各线程之间。它是<strong>一个局部性对象，不是一个核心对象。</strong>快速而有效率。<strong>不能够同时有一个以上的 critical section 被等待。</strong>无法侦测是否已被某个线程放弃。<br><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%B4%E7%95%8C%E5%8C%BA.png" alt></p>
</li>
<li><p>原子操作</p>
</li>
</ul>
<p>内核态的方法：锁机制：自旋锁、读写锁、互斥锁，完成变量，信号量机制，信号机制。</p>
<p>1、自旋锁：一个被征用的自旋锁使得请求它的线程在等待锁重新可用时自旋（特别浪费处理器时间）。自旋锁不可睡眠，不可递归，顺序锁可递归。</p>
<p>2、互斥锁（Mutex）:为协调共同对一个共享资源的单独访问而设计的。以排他的方式，防止共享资源被并发访问；互斥锁为<strong>二元变量</strong>， 状态为<strong>0-开锁</strong>、<strong>1-上锁</strong>;开锁必须由上锁的线程执行，不受其它线程干扰.相比信号量优先使用mutex。<br>3、信号量:为控制一个具有有限数量用户资源而设计的一种睡眠锁。如果有一个任务试图获得一个不可用（已被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠，这时处理器重获自由，从而去执行其他代码。当持有的信号量可用（被释放）后，处于等待队列中的那个任务将被唤醒，被获得该信号量。<br>4、条件变量（完成变量）:用来通知线程有一些事件已发生，从而启动后继任务的开始。满足某个特定条件时，可通过条件变量通知其它线程do-something;必须与互斥锁<strong>联合使用</strong>，单独无法执行.</p>
<p>5、读写锁：针对<strong>多读者，少写者</strong>的情况设定</p>
<blockquote>
<ul>
<li>允许<strong>多读</strong>，但此时<strong>不可写</strong>；</li>
<li><strong>唯一写</strong>，此时<strong>不可读</strong>.</li>
</ul>
</blockquote>
<p>就使用效率来说，临界区的效率是最高的，因为它不是内核对象，而其它的三个都是内核对象，要借助操作系统来实现，效率相对来说就比较低。但如果要跨进程使用还是要用到互斥体、事件对象和信号量。<br>6、信号机制</p>
<ol>
<li>如果是异常产生的信号（比如程序错误，像SIGPIPE、SIGEGV这些），则只有产生异常的线程收到并处理。</li>
<li>如果是用pthread_kill产生的内部信号，则只有pthread_kill参数中指定的目标线程收到并处理。</li>
<li>如果是外部使用kill命令产生的信号，通常是SIGINT、SIGHUP等job control信号，则会遍历所有线程，直到找到一个不阻塞该信号的线程，然后调用它来处理。(一般从主线程找起)，注意只有一个线程能收到。<br>　　其次，每个线程都有自己独立的signal mask，但所有线程共享进程的signal action。这意味着，你可以在线程中调用pthread_sigmask(不是sigmask)来决定本线程阻塞哪些信号。但你不能调用sigaction来指定单个线程的信号处理方式。如果在某个线程中调用了sigaction处理某个信号，那么这个进程中的未阻塞这个信号的线程在收到这个信号都会按同一种方式处理这个信号。另外，注意子线程的mask是会从主线程继承而来的。</li>
</ol>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E6%97%8B%E9%94%81.png" alt="信号量"></p>
<h4 id="为什么进程开销比线程大"><a href="#为什么进程开销比线程大" class="headerlink" title="为什么进程开销比线程大"></a>为什么进程开销比线程大</h4><p>线程调度：使用相同资源的<code>struct task_struct</code>之间的调度<br>进程调度：使用不同资源的<code>struct task_struct</code>之间的调度<br>任务调度的开销主要有：</p>
<ol>
<li>CPU执行任务调度的开销，主要是进程上下文切换的开销</li>
<li>任务调度后，CPU Cache/TLB不命中，导致缺页中断的开销</li>
</ol>
<p>原因：</p>
<ol>
<li>线程上下文是进程上下文的子集。由于保存线程的上下文明显比进程的上下文小，因此系统切换线程时，必然开销更小。</li>
<li>既然线程调度的struct task_struct都使用相同的资源，是不是就意味着，我即使切换到了其他的线程，CPU Cache/TLB命中的概率会高很多？相反，进程调度使用的是不同的资源，每次换了个进程，就意味着原有的Cache就不适用了，没命中，就触发更多的缺页中断，开销自然就更多。</li>
</ol>
<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><p><strong>线程间通信：由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）,不过要注意的是线程间需要做好同步，一般用mutex。</strong></p>
<p>1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。<br>2、互斥量:为协调共同对一个共享资源的单独访问而设计的。<br>3、信号量:为控制一个具有有限数量用户资源而设计。<br>4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。wait/notify  join信号机制，等待通知模式</p>
<h4 id="临界区-Critical-section-与互斥体-Mutex-的区别"><a href="#临界区-Critical-section-与互斥体-Mutex-的区别" class="headerlink" title="临界区(Critical section)与互斥体(Mutex)的区别"></a><a href="http://www.google.com.hk/url?sa=t&rct=j&q=临界+互斥&source=web&cd=3&ved=0CDoQFjAC&url=http%3A%2F%2Fwww.diybl.com%2Fcourse%2F3_program%2Fc%2B%2B%2Fcppsl%2F2008525%2F117880.html&ei=xLSUT9KfPNGTiAeF0cXOAw&usg=AFQjCNExJmTo_ag7HIKJn33LeoDctCvJyg&cad=rjt" target="_blank" rel="noopener">临界区(Critical section)与互斥体(Mutex)的区别</a></h4><p>1、临界区只能用于对象在同一进程里线程间的互斥访问；互斥体可以用于对象进程间或线程间的互斥访问。</p>
<p>2、临界区是非内核对象，只在用户态进行锁操作，速度快；互斥体是内核对象，在核心态进行锁操作，速度慢。</p>
<p>3、临界区和互斥体在Windows平台都下可用；Linux下只有互斥体可用。在WINDOWS中，临界区是一种应用层的同步对象，非内核对象，并且临界区优先采用自旋的方式进行抢占。</p>
<p><strong>信号量与互斥量</strong>之间的区别：</p>
<p><strong>1. 互斥量用于线程的互斥，信号量用于线程的同步。</strong> 这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。  只有可以睡眠的函数才能获取内核信号量；中断处理程序和可延迟函数都不能使用内核信号量。 </p>
<p>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 </p>
<p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源 。</p>
<p><strong>2. 互斥量值只能为0/1，信号量值可以为非负整数。</strong> </p>
<p>也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。当s==0时，线/进程会被压入等待队列，当s&gt;0时唤醒队列中的一个线/进程。 </p>
<p><strong>3. 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</strong></p>
<h4 id="进程间的通信方式（IPC-inter-Process-Communication）"><a href="#进程间的通信方式（IPC-inter-Process-Communication）" class="headerlink" title="进程间的通信方式（IPC,inter-Process Communication）"></a><a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener">进程间的通信方式（IPC,inter-Process Communication）</a></h4><p>同一主机中两个进程间的通信由操作系统决定，不同主机间的通信进程通过网络交换报文进行。</p>
<ol>
<li><p>信号：用于通知进程某个事件已经发生</p>
</li>
<li><p>管道：读写操作符合先进先出原则，对于两端的进程而言就是文件，向管道中写入数据时,linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。</p>
</li>
</ol>
<ul>
<li><p>无名管道pipe:半双工的通信方式，数据单向流动，只能在具有亲缘关系的进程间使用，从结构上看，无名管道没有文件路径名，不占用文件目录项，因此文件目录结构中的链表不适用于这种文件，它只是存在于打开文件结构中的一个临时文件，依附于进程临时存在。</p>
</li>
<li><p>命名管道FIFO:半双工，数据单向流动，允许无亲缘关系进程间的通信，FIFO是一种永久性的机制，它具有普通的UNIX系统文件名。在系统下可利用mkfifo命令建立永久的管道，除非刻意删除它，否则它将一直保持在系统中。</p>
</li>
<li><p><strong>联系</strong>：</p>
</li>
</ul>
<p>1) 通信数据只存在于内存缓冲页面中；</p>
<p>2) 都是半双工通信；</p>
<ul>
<li><strong>区别</strong>：</li>
</ul>
<p>(1)无名管道是无名的，有名管道是有名的；</p>
<p>(2)无名管道只能用于父子进程或兄弟进程之间的通信，而有名管道可用于任意两进程之间通信</p>
<p>(3)无名管道是无形的，即无名管道的 inode 结构不是在磁盘上存储的，而是临时生成的，而有名管道的 inode 结点在磁盘上。</p>
<ol start="3">
<li>消息队列：消息的链表存放在内核中并由消息队列标识符标识，克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点，但只有在内核重启时才能删除一个消息队列，内核重启也就是系统重启。</li>
<li>共享内存：最快的IPC方式，映射一段能被其他进程所访问的内存。往往与其他通信机制如信号两两配合使用，来实现进程间的同步和通信。采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。</li>
</ol>
<h4 id="共享内存的实现方式"><a href="#共享内存的实现方式" class="headerlink" title="共享内存的实现方式"></a>共享内存的实现方式</h4><p>进程间通信的只要方式有，管道，有名管道，消息队列，共享内存，socket等方式，共享内存是最高效的</p>
<p>进程间通信的方式，因为把同一块物理内存的地址空间映射到不同进程的地址空间当中，那么不同的进程之间</p>
<p>通信，通过直接修改地址空间当中的内存即可，该机制的实现只需要两次拷贝即可实现，不需要像其它的进程</p>
<p>通信机制那样将数据从用户空间拷贝到内核，然后在从内核拷贝到用户空间，实行四次拷贝操作，因此使用共</p>
<p>享内存通信比较高效。</p>
<p>　　使用共享内存的话，需要对共享的进程对共享内存的访问进行同步，防止访问对于共享数据的破坏。</p>
<p>　　共享内存的实现方式：</p>
<pre><code>一 基于物理内存实现的shm_get()实现的共享内存</code></pre><p>　　1 shm_get()</p>
<p>　　　　使用该系统调用来申请一块共享内存，使用了该系统调用之后会返回一个共享内存的键值，进程可以</p>
<p>使用该key值来使用这块共享内存。shm_get()操作会返回一个和key值关联的shmid,其它的进程可以通过该</p>
<p>shmid将该贡献内存添加到进程的地址空间里面。</p>
<p>　　2 shmat(id,addr,flag)</p>
<p>　　使用该系统调用将使用shm_get()获得的共享内存挂载到当前进程的地址空间，addr参数可以选择连接的</p>
<p>地址位置，通常设置为0，让操作系统选择合适的连接位置，flag也是设置为默认值0。</p>
<p>　　3 shm_dt()</p>
<p>　　可以删除指定的共享内存，从当前的进程的地址空间当中删除。通过shmat()返回的挂载的地址，将加到进程</p>
<p>地址空间当中的内存删除。</p>
<p>　　4 shm_ctl()</p>
<p>　　对指定的共向内存空间进行操作。也是通过shm_get()返回的标识符来进行相关的操作。</p>
<p>　　二 基于文件映射实现的mmap实现的共享内存</p>
<p>　　进程通过将一个普通文件的内映射到每个进程的地址空间当中，对映射区的修改会被写回到文件当中，其他</p>
<p>进程可以共享这些修改。将文件映射到了进程的地址空间之后，可以直接对该段虚拟地址空间进行读写操作，不需</p>
<p>使用read,write等系统调用来进行读写。</p>
<p>　　mmap实现的共享内存，每个文件有自己的内存映射区，在munmap调用之后，会将修改的内容写回文件当中。</p>
<h4 id="消息队列和管道基本上都是4次拷贝，而共享内存只有两次。"><a href="#消息队列和管道基本上都是4次拷贝，而共享内存只有两次。" class="headerlink" title="消息队列和管道基本上都是4次拷贝，而共享内存只有两次。"></a>消息队列和管道基本上都是4次拷贝，而共享内存只有两次。</h4><p>4次：1，由用户空间的buf中将数据拷贝到内核buf中。2，内核将数据拷贝到内存中。3，内存到内核buf。4，内核到用户空间的buf.<br>2次： 1，用户空间到内存。 2，内存到用户空间。<br>消息队列和管道都是内核对象，所执行的操作也都是系统调用，而这些数据最终是要存储在内存中执行的。因此不可避免的要经过4次数据的拷贝。但是共享内存不同，当执行mmap或者shmget时，会在内存中开辟空间，然后再将这块空间映射到用户进程的虚拟地址空间中，即返回值为一个指向一个内存地址的指针。当用户使用这个指针时，例如赋值操作，会引起一个从虚拟地址到物理地址的转化，会将数据直接写入对应的物理内存中，省去了拷贝到内核中的过程。当读取数据时，也是类似的过程，因此总共有两次数据拷贝。<br>对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p>
<h4 id="mmap和shm的不同"><a href="#mmap和shm的不同" class="headerlink" title="mmap和shm的不同"></a>mmap和shm的不同</h4><p>Linux提供了内存映射函数mmap, 它把磁盘文件内容映射到一段内存上(准确说是虚拟内存上，运行着进程), 通过对这段内存的读取和修改, 实现对文件的读取和修改。mmap()系统调用使得进程之间可以通过映射一个普通的文件实现共享内存。普通文件映射到进程地址空间后，进程可以像访问内存的方式对文件进行访问，不需要其他内核态的系统调用(read,write)去操作。<br>这里是讲设备或者硬盘存储的一块空间映射到物理内存，然后操作这块物理内存就是在操作实际的硬盘空间，不需要经过内核态传递。比如你的硬盘上有一个文件，你可以使用linux系统提供的mmap接口，将这个文件映射到进程一块虚拟地址空间，这块空间会对应一块物理内存，当你读写这块物理空间的时候，就是在读取实际的磁盘文件，就是这么直接高效。通常诸如共享库的加载都是通过内存映射的方式加载到物理内存的。<br><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mmap.png" alt></p>
<p><strong>mmap和shm在实现原理上的区别在于</strong>：</p>
<p>进程之间的内存是隔离的，所以无论如何进程A和进程B不会直接操作同一块内存<br>使用mmap时，进程A和进程B分别把文件映射到自己的内存地址空间<br>使用shm时，进程A和进程B分别把同一块共享内存映射到自己的内存空间</p>
<p>system V共享内存<br><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shm.png" alt></p>
<p>总结：</p>
<p>　　1、mmap是在磁盘上建立一个文件，每个进程地址空间中开辟出一块空间进行映射。而shm共享内存，每个进程最终会映射到同一块物理内存。shm保存在物理内存，这样读写的速度肯定要比磁盘要快，但是存储量不是特别大。</p>
<p>　　2、相对于shm来说，mmap更加简单，调用更加方便，所以这也是大家都喜欢用的原因。</p>
<p>　　3、另外mmap有一个好处是当机器重启，因为mmap把文件保存在磁盘上，这个文件还保存了操作系统同步的映像，所以mmap不会丢失，但是shm在内存里面就会丢失。</p>
<p>　　4、总之，共享内存是在内存中创建空间，每个进程映射到此处。内存映射是创建一个文件，并且映射到每个进程开辟的空间中。</p>
<p>可以看到，两种方式实现通信，其实只是共享空间的载体不同，mmap是共享了文件，shm是共享了内存，因此在使用上也有如下区别：mmap会把数据同步到文件中（会有缓存机制），shm不会把数据写入文件，这意味着mmap重启不会丢失共享数据mmap共享数据需要通过文件，io效率要比shm的内存读写肯定要低很多内存空间比磁盘空间小很多，所以使用mmap可以共享的数据比shm大很多</p>
<h4 id="mmap内存映射原理"><a href="#mmap内存映射原理" class="headerlink" title="mmap内存映射原理"></a><strong><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">mmap内存映射原理</a></strong></h4><p><strong>内存映射，简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间&lt;—-&gt;用户空间两者之间需要大量数据传输等操作的话效率是非常高的。以下是一个把普遍文件映射到用户空间的内存区域的示意图。</strong></p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mmap.jpg" alt="mmap"></p>
<ol start="5">
<li><p>信号量Semaphore:信号量是一个计数器，可以用来控制多个进程对共享资源的访问。常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，<strong>主要作为进程间以及同一进程内不同线程之间的同步手段</strong>。</p>
</li>
<li><p>套接字Socket:套接字也是一种进程间通信机制，包括IPC 套接字（即 Unix 套接字）给予进程在相同设备（主机）上基于通道的通信能力；而网络套接字给予进程运行在不同主机的能力，因此也带来了网络通信的能力。IPC 套接字依赖于本地系统内核的支持来进行通信。网络套接字需要底层协议的支持，例如 TCP（传输控制协议）或 UDP（用户数据报协议），包括流套接字（TCP/IP）和数据报套接字（UDP/IP），利用三元组（<strong>ip地址，协议，端口</strong>）构成套接字；传输层实现端到端的通信，传输层连接的端点叫做套接字。</p>
</li>
</ol>
<h4 id="Linux中的零拷贝技术"><a href="#Linux中的零拷贝技术" class="headerlink" title="Linux中的零拷贝技术"></a>Linux中的零拷贝技术</h4><p>当应用程序访问某块数据时，操作系统首先会检查，是不是最近访问过此文件，文件内容是否缓存在内核缓冲区，如果是，操作系统则直接根据read系统调用提供的buf地址，将内核缓冲区的内容拷贝到buf所指定的用户空间缓冲区中去。如果不是，操作系统则首先将磁盘上的数据拷贝的内核缓冲区，这一步目前主要依靠DMA来传输，然后再把内核缓冲区上的内容拷贝到用户缓冲区中。接下来，write系统调用再把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区中，最后socket再把内核缓冲区的内容发送到网卡上。<br><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/zero.jpg" alt><br>从上图中可以看出，共产生了四次数据拷贝，即使使用了DMA来处理了与硬件的通讯，CPU仍然需要处理两次数据拷贝，与此同时，在用户态与内核态也发生了多次上下文切换，无疑也加重了CPU负担。在此过程中，我们没有对文件内容做任何修改，那么在内核空间和用户空间来回拷贝数据无疑就是一种浪费，而零拷贝主要就是为了解决这种低效性。<br><strong>什么是零拷贝技术（zero-copy）？</strong><br>零拷贝主要的任务就是避免CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。<br><a href="https://www.jianshu.com/p/fad3339e3448" target="_blank" rel="noopener">mmap()  sendfile()  splice()</a></p>
<p>写时复制。大概描述下就是：如果多个程序同时访问同一块数据，那么每个程序都拥有指向这块数据的指针，在每个程序看来，自己都是独立拥有这块数据的，只有当程序需要对数据内容进行修改时，才会把数据内容拷贝到程序自己的应用空间里去，这时候，数据才成为该程序的私有数据。如果程序不需要对数据进行修改，那么永远都不需要拷贝数据到自己的应用空间里,这样就减少了数据的拷贝。</p>
<h4 id="windows进程通信"><a href="#windows进程通信" class="headerlink" title="windows进程通信"></a>windows进程通信</h4><p><em>标准的Windows</em>进程间通信方法有三种：匿名管道、命名管道（又叫<em>FIFO</em>，命名管道可以控制读消息的长度，一个命名管道可以有多个实例，具体通信还是一对一）、邮槽（<em>MailSlot</em>）。共享内存也可用于windows进程通信，但因为其实是<em>Windows</em>“内存映射文件”的一个特殊用法，所以不算作标准的windows进程间通信方法。</p>
<table>
<thead>
<tr>
<th align="center">对比点</th>
<th align="center">匿名管道</th>
<th align="center">命名管道</th>
<th align="center">邮槽</th>
<th align="center">共享内存</th>
</tr>
</thead>
<tbody><tr>
<td align="center">消息格式</td>
<td align="center">字符</td>
<td align="center">二进制</td>
<td align="center">数据包</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">工作模式</td>
<td align="center">半双工</td>
<td align="center">全双工</td>
<td align="center">单向</td>
<td align="center">双向</td>
</tr>
<tr>
<td align="center">访问模式</td>
<td align="center">只能在一台机器上</td>
<td align="center">可以跨网络</td>
<td align="center">可以跨网络</td>
<td align="center">只能在一台机器上</td>
</tr>
<tr>
<td align="center">通信模式</td>
<td align="center">父子进程用</td>
<td align="center">不同进程均可用</td>
<td align="center">广播机制</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h4 id="windows命名管道和Linux命名管道的区别"><a href="#windows命名管道和Linux命名管道的区别" class="headerlink" title="windows命名管道和Linux命名管道的区别"></a>windows命名管道和Linux命名管道的区别</h4><table>
<thead>
<tr>
<th align="center">对比点</th>
<th align="center">Linux命名管道</th>
<th align="center">Windows命名管道</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">消息格式</td>
<td align="center">字节流</td>
<td align="center">二进制</td>
<td align="center">windows更牛</td>
</tr>
<tr>
<td align="center">工作模式</td>
<td align="center">半双工</td>
<td align="center">全双工</td>
<td align="center">windows更牛</td>
</tr>
<tr>
<td align="center">访问模式</td>
<td align="center">只能在一台机器上</td>
<td align="center">可以跨网络</td>
<td align="center">windows更牛</td>
</tr>
</tbody></table>
<h4 id="死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？"><a href="#死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？" class="headerlink" title="死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？"></a>死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？</h4><p>​           （1）相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态<br>​          （2）系统资源不足、进程（线程）推进的顺序不对、请求资源顺序不当<br>​          （3）死锁的必要条件：</p>
<ol>
<li>互斥条件：进程（线程）申请的资源在一段时间中只能被一个进程（线程）使用。</li>
<li>请求与保持条件：进程（线程）已经拥有了一个资源，但是又申请新的资源，拥有的资源保持不变 。</li>
<li>不可剥夺条件：在一个进程（线程）没有用完，主动释放资源的时候，不能被抢占。</li>
<li>循环等待条件：多个进程（线程）之间存在资源循环链。</li>
</ol>
<p>​          （4）因为互斥是不可改变的，所以只能破坏其他三个条件中的一个来解除死锁，方法：</p>
<ul>
<li><p>破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中。</p>
</li>
<li><p>破坏”请求与保持条件“：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。</p>
</li>
<li><p>破坏“循环等待”条件：资源有序分配（将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程）</p>
<p>（5） 几种常见的死锁</p>
</li>
</ul>
<p>1.线程将自己锁住</p>
<p>为了保证线程之间的同步和互斥，我们往往需要给其加锁，有时候，线程申请了锁资源，还没有等待释放，又一次申请这把锁，结果就是挂起等待这把锁的释放，但是这把锁是被自己拿着，所以就会永远挂起等待，就造成了死锁。</p>
<p>2.多线程竞争资源循环等待</p>
<p>有两个线程P1和P2，P1首先申请得到了锁L1,P2申请得到了锁L2,这个时候P1有向去申请锁L2，结果是被挂起等待P2释放锁L2,而P2恰好也想申请锁L1，结果是挂起等待P1释放锁L1，此时就造成两个线程互相僵持，造成死锁。</p>
<p>3.进程推进顺序不当引起的死锁问题。</p>
<p>有三个线程，P1，P2和P3，分别生产数据M1，M2，M3，同时分别接收别的线程产生的数据M3,M2,M1,如果线程推进的顺序正确，即三个线程都先生产数据，再接收，那么没有问题，但是一旦线程先接受数据，再生产数据，因为一开始没有数据产生，那么就会造成三个线程的死锁问题。</p>
<h4 id="什么时候使用多线程？什么时候使用多进程？"><a href="#什么时候使用多线程？什么时候使用多进程？" class="headerlink" title="什么时候使用多线程？什么时候使用多进程？"></a>什么时候使用多线程？什么时候使用多进程？</h4><p>多进程：<br>稳定性优先选多进程；多进程适用于多核多机分布式；多进程占用内存多，创建销毁、切换复杂、速度慢，CPU利用率低<br>多线程：<br>性能优先选多线程；多线程适用于多核分布式；多线程占用内存少，创建销毁、切换简单、速度快，CPU利用率高</p>
<h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><h5 id="抢占和上下文"><a href="#抢占和上下文" class="headerlink" title="抢占和上下文"></a>抢占和上下文</h5><p>上下文代表着内核活动的范围。实际上我们可以将每个处理器在任何指定时间点上的活动必然概况为下列三者之一：</p>
<ul>
<li>运行于用户空间，执行用户进程</li>
<li>运行于内核空间，处于进程上下文，代表某个特定的进程执行</li>
<li>运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断</li>
</ul>
<p>当CPU空闲时，内核就运行一个空进程，处于进程上下文，但运行于内核空间。</p>
<h6 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h6><p>可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行。当一个程序调用执行了系统调用或者触发了异常，他就陷入了内核空间，此时我们称内核“代表进程执行”并处于进程上下文中。在此上下文中current宏是有效的。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出时，程序恢复在用户空间会继续执行。</p>
<p>系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行—对内核的所有访问必须通过这些接口。</p>
<h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</p>
<p>守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。</p>
<p>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。</p>
<p>如何查看守护进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在终端敲：ps axj</span><br><span class="line">a 表示不仅列当前用户的进程，也列出所有其他用户的进程</span><br><span class="line">x 表示不仅列有控制终端的进程，也列出所有无控制终端的进程</span><br><span class="line">j 表示列出与作业控制相关的信息</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shouhu.jpg" alt><br>从上图可以看出守护进行的一些特点：</p>
<p>(1)守护进程基本上都是以超级用户启动（ UID 为 0 ）<br>(2)没有控制终端（ TTY 为 ？）<br>(3)终端进程组 ID 为 -1 （ TPGID 表示终端进程组 ID）</p>
<p>一般情况下，守护进程可以通过以下方式启动：</p>
<p>(1)在系统启动时由启动脚本启动，这些启动脚本通常放在 /etc/rc.d 目录下；<br>(2)利用 inetd 超级服务器启动，如 telnet 等；<br>(3)由 cron 定时启动以及在终端用 nohup 启动的进程也是守护进程。</p>
<p>如何编写守护进程？<br>下面是编写守护进程的基本过程</p>
<p>1）屏蔽一些控制终端操作的信号</p>
<p>这是为了防止守护进行在没有运行起来前，控制终端受到干扰退出或挂起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGTTOU,SIG_IGN);   </span><br><span class="line">signal(SIGTTIN,SIG_IGN);   </span><br><span class="line">signal(SIGTSTP,SIG_IGN);   </span><br><span class="line">signal(SIGHUP ,SIG_IGN);</span><br></pre></td></tr></table></figure>

<p>2）在后台运行</p>
<p>这是为避免挂起控制终端将守护进程放入后台执行。方法是在进程中调用 fork() 使父进程终止， 让守护进程在子进程中后台执行。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if( pid &#x3D; fork() )&#123; &#x2F;&#x2F; 父进程  </span><br><span class="line">    exit(0);        &#x2F;&#x2F;结束父进程，子进程继续  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）脱离控制终端、登录会话和进程组</p>
<p>有必要先介绍一下 Linux 中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的 shell 登录终端。 控制终端、登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们 ，使之不受它们的影响。因此需要调用 setsid() 使子进程成为新的会话组长。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsid();</span><br></pre></td></tr></table></figure>

<p>setsid() 调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。 </p>
<p>4）禁止进程重新打开控制终端</p>
<p>现在，进程已经成为无终端的会话组长，但它可以重新申请打开一个控制终端。可以通过使进程不再成为会话组长来禁止进程重新打开控制终端，采用的方法是再次创建一个子进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if( pid&#x3D;fork() )&#123; &#x2F;&#x2F; 父进程  </span><br><span class="line">    exit(0);      &#x2F;&#x2F; 结束第一子进程，第二子进程继续（第二子进程不再是会话组长）   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）关闭打开的文件描述符</p>
<p>进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; NOFILE 为 &lt;sys&#x2F;param.h&gt; 的宏定义  </span><br><span class="line">&#x2F;&#x2F; NOFILE 为文件描述符最大个数，不同系统有不同限制  </span><br><span class="line">for(i&#x3D;0; i&lt; NOFILE; ++i)&#123;&#x2F;&#x2F; 关闭打开的文件描述符  </span><br><span class="line">    close(i);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）改变当前工作目录</p>
<p>进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如 /tmp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdir(&quot;&#x2F;&quot;);</span><br></pre></td></tr></table></figure>
<p>7）重设文件创建掩模</p>
<p>进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask(0);</span><br></pre></td></tr></table></figure>

<p>8）处理 SIGCHLD 信号</p>
<p>但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在 Linux 下可以简单地将 SIGCHLD 信号的操作设为 SIG_IGN 。</p>
<h6 id="用户抢占"><a href="#用户抢占" class="headerlink" title="用户抢占"></a>用户抢占</h6><ul>
<li>从系统调用返回用户空间时</li>
<li>从中断处理程序返回用户空间时</li>
</ul>
<h6 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h6><ul>
<li>中断处理程序正在执行，且返回内核空间之前</li>
<li>内核代码再一次具有可抢占性</li>
<li>如果内核中的任务显示调用schedule</li>
<li>如果内核中的任务阻塞（这同样也会导致调用schedule）</li>
</ul>
<h4 id="线程的3种实现方式"><a href="#线程的3种实现方式" class="headerlink" title="线程的3种实现方式"></a>线程的3种实现方式</h4><p>在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换</p>
<p>根据操作系统内核是否对线程可感知，可以把线程分为<strong>内核线程</strong>和<strong>用户线程</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>用户级线程(User-LevelThread, ULT)</td>
<td>由应用程序所支持的线程实现, 内核意识不到用户级线程的实现</td>
</tr>
<tr>
<td>内核级线程(Kemel-LevelThread, KLT)</td>
<td>内核级线程又称为内核支持的线程</td>
</tr>
</tbody></table>
<p>在多线程操作系统中，各个系统的实现方式并不相同，在有的系统中实现了用户级线程，有的系统中实现了内核级线程。有些情况下,也把内核级线程叫做轻量级进程(LWP), 但是这个是一个不准备的描述, 其实LWP的术语是借自于SVR4/MP和Solaris 2.x系统中, 有些系统将LWP称为虚拟处理器, 将之称为轻量级进程的原因可能是, 在内核线程的支持下，LWP是独立的调度单元，就像普通的进程一样。所以LWP的最大特点还是每个LWP都有一个内核线程支持。</p>
<h4 id="用户级线程和内核级线程的区别"><a href="#用户级线程和内核级线程的区别" class="headerlink" title="用户级线程和内核级线程的区别"></a>用户级线程和内核级线程的区别</h4><p>1）内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。</p>
<p>2）用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的，所以保存线程状态的过程和调用程序都只是本地过程，创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多，且用户级线程不需要陷阱，不需要上下文切换，也不需要对内存高速缓存进行刷新，使得线程调用非常快捷；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。</p>
<p>3）用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。</p>
<p>4）在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。</p>
<p>5） 用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。</p>
<p>6）用户线程能够利用的表空间和堆栈空间比内核级线程多</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/thread.jpg" alt="  用户级线程和内核级线程的区别"></p>
<h5 id="用户线程的缺点"><a href="#用户线程的缺点" class="headerlink" title="用户线程的缺点"></a>用户线程的缺点</h5><ol>
<li>线程发生I/O或页面故障引起的阻塞时，如果调用阻塞系统调用则内核由于不知道有多线程的存在，而会阻塞整个进程从而阻塞所有线程, 因此同一进程中只能同时有一个线程在运行</li>
<li>页面失效也会产生类似的问题。</li>
<li>一个单独的进程内部，没有时钟中断，所以不可能用轮转调度的方式调度线程</li>
<li>资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用</li>
</ol>
<blockquote>
<p>补充<br>在用户级线程中，每个进程里的线程表由运行时系统管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放的进程的信息完全一样</p>
</blockquote>
<h5 id="内核线程优缺点"><a href="#内核线程优缺点" class="headerlink" title="内核线程优缺点"></a>内核线程优缺点</h5><p>内核线程驻留在内核空间，它们是内核对象。有了内核线程，每个用户线程被映射或绑定到一个内核线程。用户线程在其生命期内都会绑定到该内核线程。一旦用户线程终止，两个线程都将离开系统。这被称作”一对一”线程映射，</p>
<ol>
<li>线程的创建、撤销和切换等，都需要内核直接实现，即内核了解每一个作为可调度实体的线程</li>
<li>这些线程可以在全系统内进行资源的竞争</li>
<li>内核空间内为每一个内核支持线程设置了一个线程控制块（TCB），内核根据该控制块，感知线程的存在，并进行控制</li>
</ol>
<p>如图所示,即内核级线程的实现方式, 每个用户线程都直接与一个内核线程相关联.</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/neihethread.jpg" alt="内核级线程的实现方式"></p>
<p>操作系统调度器管理、调度并分派这些线程。运行时库为每个用户级线程请求一个内核级线程。操作系统的内存管理和调度子系统必须要考虑到数量巨大的用户级线程。您必须了解每个进程允许的线程的最大数目是多少。操作系统为每个线程创建上下文。进程的每个线程在资源可用时都可以被指派到处理器内核。</p>
<p>当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用</p>
<p>内核线程的优点:</p>
<ol>
<li>多处理器系统中，内核能够并行执行同一进程内的多个线程</li>
<li>如果进程中的一个线程被阻塞，能够切换同一进程内的其他线程继续执行（用户级线程的一个缺点）</li>
<li>所有能够阻塞线程的调用都以系统调用的形式实现，代价可观</li>
<li>当一个线程阻塞时，内核根据选择可以运行另一个进程的线程，而用户空间实现的线程中，运行时系统始终运行自己进程中的线程</li>
<li>信号是发给进程而不是线程的，当一个信号到达时，应该由哪一个线程处理它？线程可以“注册”它们感兴趣的信号</li>
</ol>
<p>内核线程实际上是直接由内核本身启动的进程。Linux的内核线程是由kernel_thread()函数在内核态下创建的。（将创建时得到的函数永远执行下去，由一个循环组成，在需要的时候，内核线程将被唤醒执行）。</p>
<p>​    <strong>当前系统中有一些工作是由内核线程完成的：</strong></p>
<ul>
<li>周期性地将修改的内存页与页来源块设备同步</li>
<li>如果内存页很少使用，则写入交换区</li>
<li>管理延时动作</li>
<li>实现文件系统的事务日志</li>
<li>执行软中断（ksoftirqd）</li>
</ul>
<p>​    <strong>内核线程可能用于两种场景：</strong></p>
<ul>
<li>启动一个内核线程，然后一直处于等待状态直到被唤醒以完成某种服务</li>
<li>启动一个周期性运行的内核线程，以检查特定资源的使用情况，并作出适当的反映</li>
</ul>
<p>​    <strong>内核线程由内核自身生成，其特点在于：</strong></p>
<ul>
<li>它们在内核态执行，而不是用户态。</li>
<li><strong>它们只可以访问虚拟地址空间的内核部分（高于TASK_SIZE的所有地址），但不能访问用户空间</strong>。</li>
</ul>
<p>​    内核线程池不会被销毁和重建，这些线程总是位于系统中。它们会在必要时分配给不同的用户级线程，而不是当创建新的用户级线程时就创建一个新的内核线程，而纯内核级线程被创建时，就会创建一个新的内核线程。只对池中的每个线程创建上下文。有了内核线程和混合线程，操作系统分配一组处理器内核，进程的线程可以在这些处理器内核之上运行。线程只能在为它们所属线程指派的处理器内核上运行。</p>
<h5 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h5><hr>
<p>在一些系统中，使用<strong>组合方式的多线程实现</strong>, 线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行. 一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。</p>
<p>下图说明了用户级与内核级的组合实现方式, 在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合</p>
<p><img src="/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/zuhe.jpg" alt="用户级与内核级的组合实现方式"></p>
<p>posix线程调度是一个混合模型，很灵活，足以在标准的特定实现中支持用户级和内核级的线程。模型中包括两级调度–线程及和内核实体级。线程级与用户级线程类似，内核实体由内核调度。由线程库来决定它需要多少内核实体，以及他们是如何映射的。</p>
<p>POSIX 引入了一个线程调度竞争范围(thread-scheduling contention scope)的概念，这个. 概念赋予了程序员一些控制权，使它们可以控制怎样将内核实体映射为线程。线程的contentionscope属性可是PTHREAD_SCOPE_PROCESS,也可以是PTHREAD_SCOPE_SYSTEM。带有PTHREAD_SCOPE_PROCESS属性的线程与它所在的进程中的其他线程竞争处理器资源。带有PTHREAD_SCOPE_SYSTEM属性的线程很像内核级线程，他们在全系统的范围内竞争处理器资源。POSIX的一种映射方式将PTHREAD_SCOPE_SYSTEM线程和内核实体之间绑定起来。</p>
<p>内核级线程创建时先设置线程属性PTHREAD_SCOPE_SYSTEM，代码如下，:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">pthread_attr_init(&amp;attr);</span><br><span class="line">pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM); <span class="comment">//设置内核级的线程,以获取较高的响应速度</span></span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line"></span><br><span class="line">ret = pthread_create(&amp;iAcceptThreadId, &amp;attr, AcceptThread, <span class="literal">NULL</span>);<span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>POSIX的标准中定义了两个值：</p>
<p>PTHREAD_SCOPE_SYSTEM和PTHREAD_SCOPE_PROCESS，前者表示与系统中所有线程一起竞争CPU时间，后者表示仅与同进程中的线程竞争CPU</p>
<p>默认为PTHREAD_SCOPE_PROCESS。目前LinuxThreads仅实现了PTHREAD_SCOPE_SYSTEM一值。</p>
<p>关于线程的绑定，牵涉到另外一个概念：轻进程（LWP：Light Weight Process）。轻进程可以理解为内核线程，它位于用户层和系统层之间。系统对线程资源的分配、对线程的控制是通过轻进程来实现的，一个轻进程可以控制一个或多个线程。默认状况下，启动多少轻进程、哪些轻进程来控制哪些线程是由系统来控制的，这种状况即称为非绑定的。绑定状况下，则顾名思义，即某个线程固定的”绑”在一个轻进程之上。被绑定的线程具有较高的响应速度，这是因为CPU时间片的调度是面向轻进程的，绑定的线程可以保证在需要的时候它总有一个轻进程可用。通过设置被绑定的轻进程的优先级和调度级可以使得绑定的线程满足诸如实时反应之类的要求。</p>
<p>设置线程绑定状态的函数为pthread_attr_setscope，它有两个参数，第一个是指向属性结构的指针，第二个是绑定类型，它有两个取值：PTHREAD_SCOPE_SYSTEM（绑定的）和PTHREAD_SCOPE_PROCESS（非绑定的）。</p>
<h5 id="内核栈和用户栈的区别"><a href="#内核栈和用户栈的区别" class="headerlink" title="内核栈和用户栈的区别"></a><a href="https://blog.csdn.net/westonduo/article/details/39033031" target="_blank" rel="noopener">内核栈和用户栈的区别</a></h5><p>内核在创建进程时，会同时创建task_struct和进程相应堆栈。每个进程都会有两个堆栈，一个用户栈，存在于用户空间，一个内核栈，存在于内核空间。当进程在用户空间运行时，CPU堆栈寄存器的内容是用户堆栈地址，使用用户栈。当进程在内核空间时，CPU堆栈寄存器的内容是内核栈地址空间，使用的是内核栈。</p>
<p>当进程因为中断或系统调用进入内核时，进程使用的堆栈也需要从用户栈到内核栈。进程陷入内核态后，先把用户堆栈的地址保存到内核堆栈中，然后设置设置CPU堆栈寄存器为内核栈的地址，这样就完成了用户栈到内核栈的转换。</p>
<p>当进程从内核态恢复到用户态时，把内核中保存的用户态堆栈的地址恢复到堆栈指针寄存器即可。这样就实现了内核栈到用户栈的转换。</p>
<p>注意：陷入内核栈时，如何知道内核栈的地址呢？<br> 进程由用户栈到内核栈转换时，进程的内核栈总是空的。每次从用户态陷入内核时，得到的内核栈都是空的，所以在进程陷入内核时，直接把内核栈顶地址给堆栈指针寄存器即可。</p>
<p><strong>为何要设置两个不同的栈?</strong>？？？？？</p>
<p>共享原因：</p>
<p>内核的代码和数据是为所有的进程共享的，如果不为每一个进程设置对应的内核栈，那么就不能实现不同的进程执行不同的代码。</p>
<p>安全原因：</p>
<p>如果只有一个栈，那么用户就可以修改栈内容来突破内核安全保护。</p>
<h4 id="线程调用"><a href="#线程调用" class="headerlink" title="线程调用"></a>线程调用</h4><p>用户态线程属于自己用户态创建、管理和销毁，运行模式也在用户态。由系统 或者基于系统的第三方支持库完成，如 pthread，c11提到但并没实现的轻量级多线程库等等.</p>
<p>内核态线程则运行与内核中，由内核调度。</p>
<h4 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h4><p>内核级线程切换只能在内核态完成，线程切换时，必然需要将旧线程的<code>task_struct</code>从内核切出，将新线程的切入，带来上下文切换。除此之外，还需要切换寄存器、程序计数器、线程栈（包括操作栈、数据栈）等；用户级线程如果是不同进程中线程的切换，则必然引起用户态与内核态的切换，如果是同一进程中的线程切换，则不需转换到内核空间，可直接由线程库管理。</p>
<h4 id="什么引起线程切换"><a href="#什么引起线程切换" class="headerlink" title="什么引起线程切换"></a>什么引起线程切换</h4><ul>
<li>时间片轮转</li>
<li>线程阻塞</li>
<li>线程主动放弃时间片</li>
</ul>
<h4 id="进程线程调度算法"><a href="#进程线程调度算法" class="headerlink" title="进程线程调度算法"></a>进程线程调度算法</h4><p>调度算法<br>先来先服务<br>短作业优先<br>最短剩余时间优先<br>高响应比优先<br>优先级<br>时间片轮转</p>
<h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>协程：io密集型（更省cpu） 计算密集型不适合   速度快（协程也叫用户态线程，协程之间的切换发生在用户态。在用户态没有时钟中断，系统调用等机制,因此效率高）      内存占的少（协程跟线程一样共享堆不共享栈，协程只需要极少的栈内存（大概是4～5KB），默认情况下，线程栈的大小为1MB）</p>
<p>线程：io密集型（更省cpu） 计算密集型    速度相对协程慢   内存占的多</p>
<h3 id="中断和中断处理"><a href="#中断和中断处理" class="headerlink" title="中断和中断处理"></a>中断和中断处理</h3><p><a href="https://blog.csdn.net/xuchenhuics/article/details/79120644" target="_blank" rel="noopener">硬中断和软中断的区别</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/25/Linux%E5%AE%89%E8%A3%85Matlab/" rel="next" title="Linux或windows安装Matlab注意事项">
                <i class="fa fa-chevron-left"></i> Linux或windows安装Matlab注意事项
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/26/Linux%E5%AE%89%E8%A3%85Qt-Clion%E7%BC%96%E8%AF%91Boost-Opencv/" rel="prev" title="Linux安装Qt/Clion编译Boost/Opencv">
                Linux安装Qt/Clion编译Boost/Opencv <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">翟安然</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统"><span class="nav-number">1.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是操作系统？"><span class="nav-number">1.1.</span> <span class="nav-text">什么是操作系统？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux内核子系统"><span class="nav-number">1.1.1.</span> <span class="nav-text">Linux内核子系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的作用"><span class="nav-number">1.2.</span> <span class="nav-text">操作系统的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#以现代标准而言，一个标准PC的操作系统应该提供以下的功能"><span class="nav-number">1.2.1.</span> <span class="nav-text">以现代标准而言，一个标准PC的操作系统应该提供以下的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作系统的特性"><span class="nav-number">1.2.2.</span> <span class="nav-text">操作系统的特性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux系统结构详解"><span class="nav-number">2.</span> <span class="nav-text">Linux系统结构详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。"><span class="nav-number">2.1.</span> <span class="nav-text">1. Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用户空间-内核空间"><span class="nav-number">2.1.1.</span> <span class="nav-text">用户空间 &#x2F; 内核空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-内存管理"><span class="nav-number">2.2.</span> <span class="nav-text">2. 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟内存管理"><span class="nav-number">2.2.1.</span> <span class="nav-text">虚拟内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#地址映射"><span class="nav-number">2.2.2.</span> <span class="nav-text">地址映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#程序内存区域分配"><span class="nav-number">2.2.3.</span> <span class="nav-text">程序内存区域分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#物理内存管理"><span class="nav-number">2.2.4.</span> <span class="nav-text">物理内存管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-文件系统"><span class="nav-number">2.3.</span> <span class="nav-text">3. 文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inode-的诸多优点"><span class="nav-number">2.4.</span> <span class="nav-text">inode 的诸多优点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IO-和cache的区别"><span class="nav-number">2.4.0.1.</span> <span class="nav-text">IO 和cache的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Linux虚拟文件系统四大对象："><span class="nav-number">2.4.0.2.</span> <span class="nav-text">Linux虚拟文件系统四大对象：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#挂载详解"><span class="nav-number">2.4.0.3.</span> <span class="nav-text">挂载详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#常规文件系统操作（调用read-fread-write等类函数）中函数的调用过程"><span class="nav-number">2.4.0.4.</span> <span class="nav-text">常规文件系统操作（调用read&#x2F;fread&#x2F;write等类函数）中函数的调用过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#文件描述符、打开文件描述符表、文件表、inode节点"><span class="nav-number">2.4.0.5.</span> <span class="nav-text">文件描述符、打开文件描述符表、文件表、inode节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#目录项"><span class="nav-number">2.4.0.6.</span> <span class="nav-text">目录项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#inode"><span class="nav-number">2.4.0.7.</span> <span class="nav-text">inode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#文件存储结构示意图"><span class="nav-number">2.4.0.8.</span> <span class="nav-text">文件存储结构示意图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#inode的大小"><span class="nav-number">2.4.0.9.</span> <span class="nav-text">inode的大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#inode号码"><span class="nav-number">2.4.0.10.</span> <span class="nav-text">inode号码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#硬链接"><span class="nav-number">2.4.0.11.</span> <span class="nav-text">硬链接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#软链接"><span class="nav-number">2.4.0.12.</span> <span class="nav-text">软链接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Linux的五种IO模型"><span class="nav-number">2.5.</span> <span class="nav-text">4. Linux的五种IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、阻塞IO"><span class="nav-number">2.5.1.</span> <span class="nav-text">1、阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、非阻塞IO"><span class="nav-number">2.5.2.</span> <span class="nav-text">2、非阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、-IO多路复用"><span class="nav-number">2.5.3.</span> <span class="nav-text">3、 IO多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、信号驱动IO"><span class="nav-number">2.5.4.</span> <span class="nav-text">4、信号驱动IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、异步IO"><span class="nav-number">2.5.5.</span> <span class="nav-text">5、异步IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select-poll-epoll的区别"><span class="nav-number">2.5.6.</span> <span class="nav-text">select poll epoll的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select注意要点"><span class="nav-number">2.5.7.</span> <span class="nav-text">select注意要点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Linux进程管理"><span class="nav-number">2.6.</span> <span class="nav-text">5. Linux进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是协程"><span class="nav-number">2.6.1.</span> <span class="nav-text">什么是协程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的状态与转换"><span class="nav-number">2.6.2.</span> <span class="nav-text">进程的状态与转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程创建fork和vfork"><span class="nav-number">2.6.3.</span> <span class="nav-text">进程创建fork和vfork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程和线程的区别"><span class="nav-number">2.6.4.</span> <span class="nav-text">进程和线程的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程有什么是共享的什么是私有的"><span class="nav-number">2.6.5.</span> <span class="nav-text">线程有什么是共享的什么是私有的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程同步"><span class="nav-number">2.6.6.</span> <span class="nav-text">线程同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么进程开销比线程大"><span class="nav-number">2.6.7.</span> <span class="nav-text">为什么进程开销比线程大</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程通信"><span class="nav-number">2.6.8.</span> <span class="nav-text">线程通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#临界区-Critical-section-与互斥体-Mutex-的区别"><span class="nav-number">2.6.9.</span> <span class="nav-text">临界区(Critical section)与互斥体(Mutex)的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程间的通信方式（IPC-inter-Process-Communication）"><span class="nav-number">2.6.10.</span> <span class="nav-text">进程间的通信方式（IPC,inter-Process Communication）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享内存的实现方式"><span class="nav-number">2.6.11.</span> <span class="nav-text">共享内存的实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息队列和管道基本上都是4次拷贝，而共享内存只有两次。"><span class="nav-number">2.6.12.</span> <span class="nav-text">消息队列和管道基本上都是4次拷贝，而共享内存只有两次。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap和shm的不同"><span class="nav-number">2.6.13.</span> <span class="nav-text">mmap和shm的不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap内存映射原理"><span class="nav-number">2.6.14.</span> <span class="nav-text">mmap内存映射原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux中的零拷贝技术"><span class="nav-number">2.6.15.</span> <span class="nav-text">Linux中的零拷贝技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#windows进程通信"><span class="nav-number">2.6.16.</span> <span class="nav-text">windows进程通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#windows命名管道和Linux命名管道的区别"><span class="nav-number">2.6.17.</span> <span class="nav-text">windows命名管道和Linux命名管道的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？"><span class="nav-number">2.6.18.</span> <span class="nav-text">死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么时候使用多线程？什么时候使用多进程？"><span class="nav-number">2.6.19.</span> <span class="nav-text">什么时候使用多线程？什么时候使用多进程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程调度"><span class="nav-number">2.6.20.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#抢占和上下文"><span class="nav-number">2.6.20.1.</span> <span class="nav-text">抢占和上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#进程上下文"><span class="nav-number">2.6.20.1.1.</span> <span class="nav-text">进程上下文</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#守护进程"><span class="nav-number">2.6.20.2.</span> <span class="nav-text">守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#用户抢占"><span class="nav-number">2.6.20.2.1.</span> <span class="nav-text">用户抢占</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#内核抢占"><span class="nav-number">2.6.20.2.2.</span> <span class="nav-text">内核抢占</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的3种实现方式"><span class="nav-number">2.6.21.</span> <span class="nav-text">线程的3种实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户级线程和内核级线程的区别"><span class="nav-number">2.6.22.</span> <span class="nav-text">用户级线程和内核级线程的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#用户线程的缺点"><span class="nav-number">2.6.22.1.</span> <span class="nav-text">用户线程的缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内核线程优缺点"><span class="nav-number">2.6.22.2.</span> <span class="nav-text">内核线程优缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#组合方式"><span class="nav-number">2.6.22.3.</span> <span class="nav-text">组合方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内核栈和用户栈的区别"><span class="nav-number">2.6.22.4.</span> <span class="nav-text">内核栈和用户栈的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程调用"><span class="nav-number">2.6.23.</span> <span class="nav-text">线程调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程切换"><span class="nav-number">2.6.24.</span> <span class="nav-text">线程切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么引起线程切换"><span class="nav-number">2.6.25.</span> <span class="nav-text">什么引起线程切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程线程调度算法"><span class="nav-number">2.6.26.</span> <span class="nav-text">进程线程调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#协程"><span class="nav-number">2.6.27.</span> <span class="nav-text">协程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断和中断处理"><span class="nav-number">2.7.</span> <span class="nav-text">中断和中断处理</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">翟安然</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  
  
    <script src="/js/cursor/fireworks.js"></script>
  

</body>
</html>

