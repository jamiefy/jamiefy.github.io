<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="刷题建议 第一课：链表 ###########33333 链表的必备知识要点(包括基础知识、刷题中使用的STL等知识)   第二课：栈、队列、堆  ####33333 栈、队列知识要点与实现(数组、链表) 堆(优先级队列)知识要点与实现   第三课：贪心 ** 贪心算法知识要点，刷题必备的STL知识   第四课：递归、分治、回溯 递归的知识要点，回溯算法 分治算法知识要点 快速排序算法与">
<meta property="og:type" content="article">
<meta property="og:title" content="刷题记录">
<meta property="og:url" content="http://yoursite.com/2020/07/26/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="翟安然&#39;s Blog">
<meta property="og:description" content="刷题建议 第一课：链表 ###########33333 链表的必备知识要点(包括基础知识、刷题中使用的STL等知识)   第二课：栈、队列、堆  ####33333 栈、队列知识要点与实现(数组、链表) 堆(优先级队列)知识要点与实现   第三课：贪心 ** 贪心算法知识要点，刷题必备的STL知识   第四课：递归、分治、回溯 递归的知识要点，回溯算法 分治算法知识要点 快速排序算法与">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/07/26/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98.png">
<meta property="og:image" content="http://yoursite.com/2020/07/26/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/atoi.png">
<meta property="article:published_time" content="2020-07-26T01:57:49.000Z">
<meta property="article:modified_time" content="2020-09-30T02:36:37.000Z">
<meta property="article:author" content="翟安然">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/07/26/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/07/26/刷题记录/"/>





  <title>刷题记录 | 翟安然's Blog</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">翟安然's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/26/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="翟安然">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="翟安然's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">刷题记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-26T09:57:49+08:00">
                2020-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

<ul>
<li><a href="#刷题建议"><strong>刷题建议</strong></a><ul>
<li><a href="#第一课链表-33333">第一课：链表 ###########33333</a><ul>
<li><a href="#链表的必备知识要点包括基础知识-刷题中使用的stl等知识">链表的必备知识要点(包括基础知识、刷题中使用的STL等知识)</a></li>
</ul>
</li>
<li><a href="#第二课栈-队列-堆-33333">第二课：栈、队列、堆  ####33333</a><ul>
<li><a href="#栈-队列知识要点与实现数组-链表">栈、队列知识要点与实现(数组、链表)</a></li>
<li><a href="#堆优先级队列知识要点与实现">堆(优先级队列)知识要点与实现</a></li>
</ul>
</li>
<li><a href="#第三课贪心">第三课：贪心 <strong>**</strong></a><ul>
<li><a href="#贪心算法知识要点刷题必备的stl知识">贪心算法知识要点，刷题必备的STL知识</a></li>
</ul>
</li>
<li><a href="#第四课递归-分治-回溯">第四课：递归、分治、回溯</a><ul>
<li><a href="#递归的知识要点回溯算法">递归的知识要点，回溯算法</a></li>
<li><a href="#分治算法知识要点">分治算法知识要点</a></li>
<li><a href="#快速排序算法与经典实现">快速排序算法与经典实现</a></li>
</ul>
</li>
<li><a href="#第五课树与图">第五课：树与图</a><ul>
<li><a href="#树与图的数据结构与基本算法树遍历的回调函数实现并使用自动机概念实现非递归树前-中-后遍历">树与图的数据结构与基本算法，树遍历的回调函数实现，并使用自动机概念实现非递归树前、中、后遍历</a></li>
</ul>
</li>
<li><a href="#第六课二分查找-二叉排序树-位运算的应用">第六课：二分查找、二叉排序树、位运算的应用</a><ul>
<li><a href="#二分查找-二叉排序树的知识要点">二分查找、二叉排序树的知识要点</a></li>
<li><a href="#位运算的知识要点">位运算的知识要点  *****</a></li>
</ul>
</li>
<li><a href="#第七课哈希表与字符串">第七课：哈希表与字符串  *****</a><ul>
<li><a href="#哈希表与字符串知识要点">哈希表与字符串知识要点</a></li>
</ul>
</li>
<li><a href="#第八课搜索">第八课：搜索</a><ul>
<li><a href="#深度优先搜索与广度优先搜索算法">深度优先搜索与广度优先搜索算法</a></li>
</ul>
</li>
<li><a href="#第九课动态规划">第九课：动态规划 <strong>***</strong></a><ul>
<li><a href="#动态规划知识要点">动态规划知识要点</a></li>
</ul>
</li>
<li><a href="#第十课复杂数据结构">第十课：复杂数据结构</a><ul>
<li><a href="#trie树的构造与基本算法">Trie树的构造与基本算法</a></li>
<li><a href="#并查集的基本算法">并查集的基本算法</a></li>
<li><a href="#线段树与树状数组">线段树与树状数组</a></li>
</ul>
</li>
<li><a href="#第十一课-滑动窗口">第十一课 滑动窗口</a></li>
</ul>
</li>
<li><a href="#重难点记录">重难点记录</a><ul>
<li><a href="#寻找旋转数组">寻找旋转数组：</a><ul>
<li><a href="#153寻找旋转排序数组最小值">153寻找旋转排序数组最小值</a></li>
<li><a href="#154-寻找旋转排序数组最小值2存在重复">154 寻找旋转排序数组最小值2（存在重复）</a></li>
<li><a href="#33-搜索旋转排序数组">33 搜索旋转排序数组</a></li>
<li><a href="#81-搜索旋转排序数组2存在重复">81 搜索旋转排序数组2（存在重复）</a></li>
</ul>
</li>
<li><a href="#最短路径问题">最短路径问题：</a></li>
<li><a href="#双指针问题">双指针问题：</a></li>
<li><a href="#等差数列问题">等差数列问题：</a></li>
<li><a href="#双端队列">双端队列：</a></li>
<li><a href="#动态规划">动态规划：</a></li>
<li><a href="#位运算">位运算：</a></li>
<li><a href="#二叉树的前中后序遍历">二叉树的前中后序遍历：</a></li>
<li><a href="#括号匹配">括号匹配：</a></li>
<li><a href="#单调栈">单调栈：</a></li>
<li><a href="#字符串转换整数">字符串转换整数</a></li>
<li><a href="#买卖股票的最佳时机httpsleetcode-cncomproblemsbest-time-to-buy-and-sell-stock-iiisolutionyi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen">买卖股票的最佳时机</a></li>
<li><a href="#在排序数组中查找数字i">在排序数组中查找数字I</a></li>
<li><a href="#基本计算器">基本计算器</a></li>
<li><a href="#链表">链表</a></li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->



<h2 id="刷题建议"><a href="#刷题建议" class="headerlink" title="刷题建议"></a><strong>刷题建议</strong></h2><h3 id="第一课：链表-33333"><a href="#第一课：链表-33333" class="headerlink" title="第一课：链表 ###########33333"></a>第一课：链表 ###########33333</h3><h4 id="链表的必备知识要点-包括基础知识、刷题中使用的STL等知识"><a href="#链表的必备知识要点-包括基础知识、刷题中使用的STL等知识" class="headerlink" title="链表的必备知识要点(包括基础知识、刷题中使用的STL等知识)"></a>链表的必备知识要点(包括基础知识、刷题中使用的STL等知识)</h4><ol>
<li><p>链表逆序(LeetCode 92,206. Reverse Linked List 1,2)</p>
</li>
<li><p>求两个链表的交点(LeetCode 160. Intersection of Two Linked     Lists)</p>
</li>
<li><p>链表的节点交换(LeetCode 24. Swap Nodes in Pairs)</p>
</li>
<li><p>链表求环(LeetCode 141,142. Linked List Cycle 1,2) 双指针</p>
</li>
<li><p>链表重新构造(LeetCode 86. Partition List)</p>
</li>
<li><p>复杂的链表复制(LeetCode 138. Copy List with Random Pointer)</p>
</li>
<li><p>排序链表合并(2个与多个) (LeetCode     21,23 Merge Two(k) Sorted ListsLeetCode)</p>
</li>
</ol>
<a id="more"></a>

<h3 id="第二课：栈、队列、堆-33333"><a href="#第二课：栈、队列、堆-33333" class="headerlink" title="第二课：栈、队列、堆  ####33333"></a>第二课：栈、队列、堆  ####33333</h3><h4 id="栈、队列知识要点与实现-数组、链表"><a href="#栈、队列知识要点与实现-数组、链表" class="headerlink" title="栈、队列知识要点与实现(数组、链表)"></a>栈、队列知识要点与实现(数组、链表)</h4><ol>
<li>使用队列实现栈(LeetCode 232. Implement Queue using Stacks)</li>
<li>使用栈实现队列(LeetCode 225. Implement Stack using Queues)</li>
<li>包含min函数的栈(LeetCode 155. Min     Stack)</li>
<li>简单的计算器(栈的应用)( LeetCode 224.     Basic Calculator)</li>
</ol>
<h4 id="堆-优先级队列-知识要点与实现"><a href="#堆-优先级队列-知识要点与实现" class="headerlink" title="堆(优先级队列)知识要点与实现"></a>堆(优先级队列)知识要点与实现</h4><ol>
<li>数组中第K大的数(堆的应用) (LeetCode 215. Kth Largest Element in an Array)</li>
</ol>
<h3 id="第三课：贪心"><a href="#第三课：贪心" class="headerlink" title="第三课：贪心 **"></a>第三课：贪心 <strong>**</strong></h3><h4 id="贪心算法知识要点，刷题必备的STL知识"><a href="#贪心算法知识要点，刷题必备的STL知识" class="headerlink" title="贪心算法知识要点，刷题必备的STL知识"></a>贪心算法知识要点，刷题必备的STL知识</h4><ol>
<li>贪心题目1(LeetCode 455. Assign Cookies)</li>
<li>贪心题目2(LeetCode 402. Remove K Digits)</li>
<li>贪心题目3(LeetCode 134. Gas Station)</li>
<li>贪心题目4(LeetCode 135. Candy)</li>
<li>贪心题目5(LeetCode 502. IPO)</li>
<li>贪心题目6(LeetCode 321. Create Maximum Number)</li>
<li>贪心题目7(codeforces 582A GCD Table)</li>
</ol>
<h3 id="第四课：递归、分治、回溯"><a href="#第四课：递归、分治、回溯" class="headerlink" title="第四课：递归、分治、回溯"></a>第四课：递归、分治、回溯</h3><h4 id="递归的知识要点，回溯算法"><a href="#递归的知识要点，回溯算法" class="headerlink" title="递归的知识要点，回溯算法"></a>递归的知识要点，回溯算法</h4><ol>
<li>生成组合数(LeetCode 39. Combination Sum, LeetCode 40.     Combination Sum II)</li>
<li>生成排列数(LeetCode 46. Permutations, LeetCode 47.     Permutations II)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归+剪枝 （另一种方法是set+递归（交换））</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; used,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ret.push_back(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i的初始值为0而不是index，每次都要遍历所有位，从未使用的位中挑选下一位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">         <span class="comment">//大前提必须是该位没有被使用过</span></span><br><span class="line">         <span class="keyword">if</span>(used[i])<span class="keyword">continue</span>;</span><br><span class="line">         <span class="comment">//如果该位等于前一位且前一位没有被占用则取该位会导致重复，所以去重</span></span><br><span class="line">         <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i<span class="number">-1</span>]==nums[i]&amp;&amp;!used[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">         cur.push_back(nums[i]);</span><br><span class="line">         used[i]=<span class="literal">true</span>;</span><br><span class="line">         dfs(nums,index+<span class="number">1</span>,used,cur,ret);</span><br><span class="line">         used[i]=<span class="literal">false</span>;</span><br><span class="line">         cur.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">    dfs(nums,<span class="number">0</span>,used,cur,ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>N皇后问题(LeetCode 51. N-Queens, LeetCode 52. N-Queens II)</li>
</ol>
<h4 id="分治算法知识要点"><a href="#分治算法知识要点" class="headerlink" title="分治算法知识要点"></a>分治算法知识要点</h4><h4 id="快速排序算法与经典实现"><a href="#快速排序算法与经典实现" class="headerlink" title="快速排序算法与经典实现"></a>快速排序算法与经典实现</h4><ol>
<li>不同的加括号方法(LeetCode 241. Different Ways to Add     Parentheses)</li>
<li>两个数组的中位数(LeetCode 4. Median of Two Sorted Arrays)(贼难)</li>
</ol>
<h3 id="第五课：树与图"><a href="#第五课：树与图" class="headerlink" title="第五课：树与图"></a>第五课：树与图</h3><h4 id="树与图的数据结构与基本算法，树遍历的回调函数实现，并使用自动机概念实现非递归树前、中、后遍历"><a href="#树与图的数据结构与基本算法，树遍历的回调函数实现，并使用自动机概念实现非递归树前、中、后遍历" class="headerlink" title="树与图的数据结构与基本算法，树遍历的回调函数实现，并使用自动机概念实现非递归树前、中、后遍历"></a>树与图的数据结构与基本算法，树遍历的回调函数实现，并使用自动机概念实现非递归树前、中、后遍历</h4><ol>
<li>树与链表的转换(LeetCode 114. Flatten Binary Tree to Linked     List)</li>
<li>最近的公共祖先(LeetCode 236. Lowest Common Ancestor of a     Binary Tree)</li>
<li>树的层次遍历应用(LeetCode 199. Binary Tree Right Side View)</li>
<li>树的改造(LeetCode 117. Populating Next Right Pointers in     Each Node 1,2)</li>
<li>图的复制(LeetCode 133. Clone Graph)</li>
<li>图的搜索与应用(LeetCode 207.Course Schedule)</li>
</ol>
<h3 id="第六课：二分查找、二叉排序树、位运算的应用"><a href="#第六课：二分查找、二叉排序树、位运算的应用" class="headerlink" title="第六课：二分查找、二叉排序树、位运算的应用"></a>第六课：二分查找、二叉排序树、位运算的应用</h3><h4 id="二分查找、二叉排序树的知识要点"><a href="#二分查找、二叉排序树的知识要点" class="headerlink" title="二分查找、二叉排序树的知识要点"></a>二分查找、二叉排序树的知识要点</h4><ol>
<li>数组的二分查找(LeetCode 33,81 Search in Rotated Sorted     Array 1,2)</li>
<li>区间二分查找(LeetCode 34. Search for a Range)</li>
<li>排序链表转换为二叉排序树(LeetCode 109. Convert Sorted List to B-     Search Tree)</li>
<li>二叉排序树的遍历与改造(LeetCode 538 Convert BST to Greater     Tree)</li>
<li>二叉排序树中的第K大的数(LeetCode 230.     Kth Smallest Element in a BST)</li>
</ol>
<h4 id="位运算的知识要点"><a href="#位运算的知识要点" class="headerlink" title="位运算的知识要点  *****"></a>位运算的知识要点  *****</h4><ol>
<li><p>使用位运算表示集合(LeetCode 78. Subsets)</p>
</li>
<li><p>位运算应用题目(LeetCode 136,137,260. Single Number1,2,3)</p>
</li>
</ol>
<h3 id="第七课：哈希表与字符串"><a href="#第七课：哈希表与字符串" class="headerlink" title="第七课：哈希表与字符串  *****"></a>第七课：哈希表与字符串  *****</h3><h4 id="哈希表与字符串知识要点"><a href="#哈希表与字符串知识要点" class="headerlink" title="哈希表与字符串知识要点"></a>哈希表与字符串知识要点</h4><ol>
<li>哈希题目 (LeetCode 290. Word Pattern)</li>
<li>哈希与字符串综合 (LeetCode 3.Longest Substring Without     Repeating Characters)</li>
<li>哈希与字符串综合 (LeetCode 76. Minimum Window Substring)</li>
<li>哈希与字符串综合 (LeetCode 30. Substring with Concatenation     of All Words)</li>
<li>字符串题目 (LeetCode 459. Repeated Substring Pattern)</li>
<li>字符串题目 (LeetCode 468. Validate IP Address)</li>
</ol>
<h3 id="第八课：搜索"><a href="#第八课：搜索" class="headerlink" title="第八课：搜索"></a>第八课：搜索</h3><h4 id="深度优先搜索与广度优先搜索算法"><a href="#深度优先搜索与广度优先搜索算法" class="headerlink" title="深度优先搜索与广度优先搜索算法"></a>深度优先搜索与广度优先搜索算法</h4><ol>
<li>深搜题目 (LeetCode 200. Number of Islands)</li>
<li>深搜题目 (LeetCode 473. Matchsticks to Square)</li>
<li>深搜题目 (LeetCode 491. Increasing Subsequences)</li>
<li>广搜题目 (LeetCode 417. Pacific Atlantic Water Flow)</li>
<li>广搜题目 (LeetCode 407. Trapping Rain Water II)</li>
</ol>
<h3 id="第九课：动态规划"><a href="#第九课：动态规划" class="headerlink" title="第九课：动态规划 ***"></a>第九课：动态规划 <strong>***</strong></h3><h4 id="动态规划知识要点"><a href="#动态规划知识要点" class="headerlink" title="动态规划知识要点"></a>动态规划知识要点</h4><ol>
<li>动态规划题目1(LeetCode 120. Triangle)</li>
<li>动态规划题目2(LeetCode 53. Maximum Subarray)</li>
<li>动态规划题目3(LeetCode 198. House Robber 1) </li>
<li>动态规划题目4(LeetCode 322. Coin Change)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//凑零钱问题动态规划，类似于背包问题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChangeDP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(coins.<span class="built_in">size</span>()==<span class="number">0</span>||amount&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//因为凑成 amount 金额的硬币数最多只可能等于 amount（全用 1 元面值的硬币），所以dp 数组初始化为 amount + 1 就相当于初始化为正无穷，便于后续取最小值。</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,amount+<span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;amount+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; coin:coins)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-coin&lt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            dp[i]=<span class="built_in">min</span>(dp[i],<span class="number">1</span>+dp[i-coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]==amount+<span class="number">1</span>?<span class="number">-1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="6">
<li>0-1背包问题 <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/" target="_blank" rel="noopener">leetcode 416分割等和子集</a></li>
</ol>
<p><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/targetsum" target="_blank" rel="noopener">leetcode 494 目标和</a></p>
<ol start="7">
<li>最长回文子串  leetcode 5</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; ++l) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + l &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + l;</span><br><span class="line">                <span class="keyword">if</span> (l == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = (s[i] == s[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; l + <span class="number">1</span> &gt; ans.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    ans = s.substr(i, l + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>最长回文子序列  <a href="https://leetcode-cn.com/problems/longest-common-subsequence/solution/ni-de-yi-fu-wo-ba-liao-zui-chang-gong-gong-zi-xu-2/" target="_blank" rel="noopener">拓展:最长公共子序列 数组交集  不相交的线段</a></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// dp 数组全部初始化为 0</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 反着遍历保证正确的状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 整个 s 的最长回文子串长度</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="第十课：复杂数据结构"><a href="#第十课：复杂数据结构" class="headerlink" title="第十课：复杂数据结构"></a>第十课：复杂数据结构</h3><h4 id="Trie树的构造与基本算法"><a href="#Trie树的构造与基本算法" class="headerlink" title="Trie树的构造与基本算法"></a>Trie树的构造与基本算法</h4><ol>
<li>Trie树的构造 (LeetCode 208. Implement Trie (Prefix Tree))</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode():isEnd(<span class="literal">false</span>),path(<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//memset只能填int值，注意指针数组初始化分配空间</span></span><br><span class="line">        <span class="comment">//# include &lt;string.h&gt;//memset是c函数</span></span><br><span class="line">		<span class="comment">//void *memset(void *s, int c, unsigned long n);</span></span><br><span class="line">        <span class="built_in">memset</span>(children,<span class="number">0</span>,<span class="keyword">sizeof</span>(children));</span><br><span class="line">        <span class="comment">//或者</span></span><br><span class="line">        <span class="comment">//for(int i=0;i&lt;26;i++)</span></span><br><span class="line">        <span class="comment">//  next[i]=NULL;</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//不能是private，外部需要直接调用，或者设置成private并对每个操作定义对应函数</span></span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    <span class="keyword">int</span> path;</span><br><span class="line">    TrieNode* children[<span class="number">26</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">       root=<span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        TrieNode* node=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">word</span>.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=<span class="keyword">word</span>[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;children[index]==<span class="number">0</span>)</span><br><span class="line">                node-&gt;children[index]=<span class="keyword">new</span> TrieNode();</span><br><span class="line">            node-&gt;children[index]-&gt;path++;</span><br><span class="line">            node=node-&gt;children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加hasPrefix避免后两个函数包含重复代码</span></span><br><span class="line">    <span class="function">TrieNode* <span class="title">hasPrefix</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* node=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> w:prefix)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=w-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;children[index]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node=node-&gt;children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        TrieNode* node=hasPrefix(<span class="keyword">word</span>);</span><br><span class="line">        <span class="keyword">return</span> node==<span class="literal">nullptr</span>?<span class="literal">false</span>:node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* node=hasPrefix(prefix);</span><br><span class="line">        <span class="keyword">return</span> node!=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>Trie树的应用 (LeetCode 212. Word Search II)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode():isEnd(<span class="literal">false</span>),path(<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//memset只能填int值，注意指针数组初始化分配空间</span></span><br><span class="line">        <span class="comment">//# include &lt;string.h&gt;//memset是c函数</span></span><br><span class="line">        <span class="comment">//void *memset(void *s, int c, unsigned long n);</span></span><br><span class="line">        <span class="built_in">memset</span>(children,<span class="number">0</span>,<span class="keyword">sizeof</span>(children));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不能是private，外部需要直接调用，或者设置成private并对每个操作定义对应函数</span></span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    <span class="keyword">int</span> path;</span><br><span class="line">    TrieNode* children[<span class="number">26</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root=<span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        TrieNode* node=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">word</span>.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=<span class="keyword">word</span>[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;children[index]==<span class="number">0</span>)</span><br><span class="line">                node-&gt;children[index]=<span class="keyword">new</span> TrieNode();</span><br><span class="line">            node-&gt;children[index]-&gt;path++;</span><br><span class="line">            node=node-&gt;children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>,4&gt; row&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>,4&gt; col&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited,<span class="keyword">int</span> i,<span class="keyword">int</span> j,TrieNode* curnode,<span class="built_in">string</span> path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curnode-&gt;isEnd)&#123;</span><br><span class="line">            ret.push_back(path);</span><br><span class="line">            <span class="comment">//避免重复获取同一个string</span></span><br><span class="line">            curnode-&gt;isEnd=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newrow=i+row[k];</span><br><span class="line">            <span class="keyword">int</span> newcol=j+col[k];</span><br><span class="line">            <span class="keyword">if</span>(newrow&lt;<span class="number">0</span> || newrow&gt;=board.<span class="built_in">size</span>() || newcol&lt;<span class="number">0</span> || newcol&gt;=board[<span class="number">0</span>].<span class="built_in">size</span>() || visited[newrow][newcol])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> index=board[newrow][newcol]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(curnode-&gt;children[index]!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                visited[newrow][newcol]=<span class="literal">true</span>;</span><br><span class="line">                dfs(board,visited,newrow,newcol,curnode-&gt;children[index],path+board[newrow][newcol]);</span><br><span class="line">                visited[newrow][newcol]= <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        Trie* trie=<span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s:words)</span><br><span class="line">            trie-&gt;insert(s);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(board.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(board[<span class="number">0</span>].<span class="built_in">size</span>(),<span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> index=board[i][j]-<span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(trie-&gt;root-&gt;children[index]!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    visited[i][j]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">1</span>,board[i][j])</span></span>;</span><br><span class="line">                    dfs(board,visited,i,j,trie-&gt;root-&gt;children[index],s);</span><br><span class="line">                    visited[i][j]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>数组中两个数的最大异或值 leetcode421</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.将数组中的数全部存入字典树中</span></span><br><span class="line"><span class="comment">//2.遍历树中的每一个数在字典树中异或的最大结果，最后再求最大结果里面的最大值返回就是了</span></span><br><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie* next[<span class="number">2</span>];</span><br><span class="line">    Trie()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span>(next));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    Trie* root = <span class="keyword">new</span> Trie();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将数按照二进制形式全部存入字典树里面</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            Trie* node = root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> bt = num &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;next[bt] == <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    node-&gt;next[bt] = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                node = node-&gt;next[bt];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找最大^值</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            Trie* node = root;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> bt = num &gt;&gt; i &amp; <span class="number">1</span>;  </span><br><span class="line">                <span class="comment">// 如果bt==1则贪心的去找0异或  否则找1异或</span></span><br><span class="line">                <span class="keyword">if</span>(bt == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += node-&gt;next[<span class="number">0</span>] != <span class="literal">nullptr</span> ? <span class="number">1</span> &lt;&lt; i : <span class="number">0</span> ;</span><br><span class="line">                    node = node-&gt;next[<span class="number">0</span>] != <span class="literal">nullptr</span> ? node-&gt;next[<span class="number">0</span>] : node-&gt;next[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    sum += node-&gt;next[<span class="number">1</span>] != <span class="literal">nullptr</span> ? <span class="number">1</span> &lt;&lt; i : <span class="number">0</span> ;</span><br><span class="line">                    node = node-&gt;next[<span class="number">1</span>] != <span class="literal">nullptr</span> ? node-&gt;next[<span class="number">1</span>] : node-&gt;next[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="并查集的基本算法"><a href="#并查集的基本算法" class="headerlink" title="并查集的基本算法"></a>并查集的基本算法</h4><ol>
<li><a href="https://leetcode-cn.com/problems/friend-circles/solution/peng-you-quan-by-leetcode/" target="_blank" rel="noopener">并查集的应用 (LeetCode 547. Friend Circles)</a></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent.emplace_back(i);</span><br><span class="line">            rank.emplace_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent[x]==x?x:parent[x]=<span class="built_in">find</span>(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xroot=<span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> yroot=<span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(xroot==yroot)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[xroot]&lt;rank[yroot])</span><br><span class="line">            parent[xroot]=yroot;  <span class="comment">// 合并是从rank小的向rank大的连边</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent[yroot]=xroot;</span><br><span class="line">            <span class="keyword">if</span>(rank[xroot]==rank[yroot]) rank[xroot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=M.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        init(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(M[i][j])</span><br><span class="line">                    unite(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent[i]==i)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>情侣配对（lc765 minSwapsCouples）（也可用<a href="https://leetcode-cn.com/problems/couples-holding-hands/solution/qing-lu-qian-shou-by-leetcode/" target="_blank" rel="noopener">贪心算法</a>）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            parent.emplace_back(i);</span><br><span class="line">            parent.emplace_back(i);</span><br><span class="line">            rank.push_back(<span class="number">1</span>);</span><br><span class="line">            rank.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//路径压缩</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent[x]==x?x:(parent[x]=<span class="built_in">find</span>(parent[x]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootx=<span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rooty=<span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(rootx==rooty)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[rootx]&lt;rank[rooty])</span><br><span class="line">            parent[rootx]=rooty;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rooty]=rootx;</span><br><span class="line">            <span class="keyword">if</span>(rank[rootx]==rank[rooty])</span><br><span class="line">                rank[rootx]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;row)</span></span>&#123;</span><br><span class="line">        init(row.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">//把可以交换的块全都连在一起，形成一个错误环，每个错误环(包含k组)需要交换k-1调整</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row.<span class="built_in">size</span>()<span class="number">-1</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            unite(row[i],row[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一共有row.size()/2组,每组一个环的话，每组需要交换1-1=0次</span></span><br><span class="line">        <span class="keyword">int</span> ans=row.<span class="built_in">size</span>()/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//减去环数即为需要交换的次数</span></span><br><span class="line">            <span class="keyword">if</span>(parent[i]==i)ans--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="线段树与树状数组"><a href="#线段树与树状数组" class="headerlink" title="线段树与树状数组"></a>线段树与树状数组</h4><ol>
<li>线段树与树状数组的应用(LeetCode 307. Range Sum Query – Mutable)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线段树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        tree.resize(<span class="number">2</span>*n,<span class="number">0</span>);</span><br><span class="line">        buildTree(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j = <span class="number">0</span>;  i &lt; <span class="number">2</span> * n; i++,  j++)</span><br><span class="line">        tree[i] = nums[j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度：O(n)。因为我们在 for 循环的每次迭代中计算一个节点的和。而一个线段树中大约有2n 个节点。</span></span><br><span class="line"><span class="comment">//这可以通过以下方式证明：具有 n 个元素的数组线段树有 n 个叶节点（数组元素本身）。每一层中的节点数是下面一层中节点数的一半。</span></span><br><span class="line"><span class="comment">//因此，如果我们按层对节点数求和，二叉树总共有2^h-1个节点，共有2^(h-1)个叶节点。</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)，我们用了 2n 的额外空间来存储整个线段树。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更新线段树 :当我们更新数组中某个索引 i处的元素时，我们需要重建线段树，因为一些树节点上的和值也会随之产生变化。我们将再次使用</span></span><br><span class="line"><span class="comment">//自下而上的方法。首先更新存储 a[i] 元素的叶节点。从那里我们将一路向上，直到根节点，并用其子节点值的总和来更新每个父节点的值。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    pos += n;</span><br><span class="line">    tree[pos] = val;</span><br><span class="line">    <span class="keyword">while</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = pos;</span><br><span class="line">        <span class="keyword">int</span> right = pos;</span><br><span class="line">        <span class="keyword">if</span> (pos % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            right = pos + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = pos - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// parent is updated after child is updated</span></span><br><span class="line">        tree[pos / <span class="number">2</span>] = tree[left] + tree[right];</span><br><span class="line">        pos /= <span class="number">2</span>;<span class="comment">//pos等于2或者3时除以2等于1，进入循环后会更改tree[0]的值但是不影响结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度：O(logn)。因为有几个树节点的范围包括第 i 个数组元素，每个层上都有一个。共有log(n) 层。</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//区域和检索：我们可以通过以下方式使用线段树进行区域和检索 [L,R]：算法保持循环不变：l≤r 以及已经算出 [L…l] 和 [r…R] 的总和，</span></span><br><span class="line"><span class="comment">//其中 l 和 r 分别是计算总和时的左边界和右边界。每次迭代的范围 [l,r] 都会缩小，直到在算法的大约 logn 次迭代后两个边界相遇为止。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// get leaf with value 'l'</span></span><br><span class="line">    l += n;</span><br><span class="line">    <span class="comment">// get leaf with value 'r'</span></span><br><span class="line">    r += n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当l==r时仍会进入循环进入其中一个if，把tree[l]加进总和</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((l % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            sum += tree[l];</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tree[r];</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        l /= <span class="number">2</span>;</span><br><span class="line">        r /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line"> 	   <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><a href="https://blog.csdn.net/pcwl1206/article/details/95013825" target="_blank" rel="noopener">归并排序及其解决逆序对数、小和问题</a></li>
</ol>
<p><img src="/2020/07/26/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98.png" alt="小和问题"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//离散化树状数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bit</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bit(<span class="keyword">int</span> _n):n(_n),bits(n+<span class="number">1</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            sum+=bits[x];</span><br><span class="line">            x-=lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">            bits[x]+=val;</span><br><span class="line">            x+=lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bits;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">index</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    sort(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="comment">//要得到的是num在排序数组中的index+1，即在离散化树状数组中第几个（从1开始），这样</span></span><br><span class="line">        <span class="comment">//插入之前可以计算它前面的所有值的和，从而得到它在数组中的在它左边的比他小的数的和</span></span><br><span class="line">        index[i]=lower_bound(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>(),nums[i])-tmp.<span class="built_in">begin</span>()+<span class="number">1</span>;</span><br><span class="line">    <span class="function">Bit <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        sum+=<span class="built_in">bit</span>.query(index[i]<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">bit</span>.update(index[i],nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>offer51 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/" target="_blank" rel="noopener">数组中的逆序对</a> <a href="https://blog.csdn.net/flushhip/article/details/79165701" target="_blank" rel="noopener">树状数组解释</a>  <a href="https://blog.csdn.net/c20190102/article/details/70841745" target="_blank" rel="noopener">树状数组详解</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315  计算右侧小于当前元素的个数</a></p>
</li>
</ol>
<h3 id="第十一课-滑动窗口"><a href="#第十一课-滑动窗口" class="headerlink" title="第十一课 滑动窗口"></a>第十一课 滑动窗口</h3><ol start="3">
<li><p>无重复字符的最长子串</p>
</li>
<li><p>串联所有单词的子串  leetcode 30</p>
</li>
<li><p>最小覆盖子串</p>
</li>
<li><p>至多包含两个不同字符的最长子串（会员）</p>
</li>
<li><p>长度最小的子数组</p>
</li>
<li><p>滑动窗口最大值</p>
</li>
<li><p>字符串的排列</p>
</li>
<li><p>最小区间</p>
</li>
<li><p>最小窗口子序列（会员）</p>
</li>
</ol>
<h2 id="重难点记录"><a href="#重难点记录" class="headerlink" title="重难点记录"></a>重难点记录</h2><h3 id="寻找旋转数组："><a href="#寻找旋转数组：" class="headerlink" title="寻找旋转数组："></a>寻找旋转数组：</h3><h4 id="153寻找旋转排序数组最小值"><a href="#153寻找旋转排序数组最小值" class="headerlink" title="153寻找旋转排序数组最小值"></a>153寻找旋转排序数组最小值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func findMin (nums []int) int &#123;</span><br><span class="line">  left, right := <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">  <span class="keyword">for</span> left &lt;= right &#123; <span class="comment"># 实际上是不会跳出循环，当 left==right 时直接返回</span></span><br><span class="line">    <span class="keyword">if</span> nums[left] &lt;= nums[right] <span class="comment"># 如果 [left,right] 递增，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br><span class="line">    mid := left + (right-left)&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> nums[left] &lt;= nums[mid] <span class="comment"># [left,mid] 连续递增，则在 [mid+1,right] 查找</span></span><br><span class="line">      left = mid + <span class="number">1</span></span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      right = mid <span class="comment"># [left,mid] 不连续，在 [left,mid] 查找</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="154-寻找旋转排序数组最小值2（存在重复）"><a href="#154-寻找旋转排序数组最小值2（存在重复）" class="headerlink" title="154 寻找旋转排序数组最小值2（存在重复）"></a>154 寻找旋转排序数组最小值2（存在重复）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func findMin (nums []int) int &#123;</span><br><span class="line">  left, right := <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">  <span class="keyword">for</span> left &lt;= right &#123; <span class="comment">#实际上不会跳出循环</span></span><br><span class="line">    <span class="keyword">if</span> nums[left] &lt; nums[right] || left == right <span class="comment"># 这里的判断条件增加一个判断条件</span></span><br><span class="line">      <span class="keyword">return</span> nums[left]</span><br><span class="line">    mid := left + (right-left)&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> nums[left] &lt; nums[mid] </span><br><span class="line">      left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> nums[left] == nums[mid] </span><br><span class="line">      left++ // 无法判断 mid 位于哪一部分，去掉干扰项</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      right = mid</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33 搜索旋转排序数组"></a>33 搜索旋转排序数组</h4><h4 id="81-搜索旋转排序数组2（存在重复）"><a href="#81-搜索旋转排序数组2（存在重复）" class="headerlink" title="81 搜索旋转排序数组2（存在重复）"></a>81 搜索旋转排序数组2（存在重复）</h4> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(nums[left]==target)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(nums[right]==target)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(right-left==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span>(nums[mid]&lt;nums[right])&#123;<span class="comment">//旋转点在左侧</span></span><br><span class="line">         <span class="keyword">if</span>(nums[mid]&lt;target&amp;&amp;nums[right]&gt;target)</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(nums[right]&lt;target||nums[mid]&gt;target)</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;nums[right])&#123;<span class="comment">//旋转点在右侧</span></span><br><span class="line">         <span class="keyword">if</span>(nums[mid]&gt;target&amp;&amp;nums[left]&lt;target)</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target||nums[left]&gt;target)</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span></span><br><span class="line">         left++;<span class="comment">//比不重复的多此句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]==target?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<h3 id="最短路径问题："><a href="#最短路径问题：" class="headerlink" title="最短路径问题："></a>最短路径问题：</h3><p>1368 使网格图至少有一条有效路径的最小代价（方法1 Dijkstra算法；方法2 0-1广度优先搜索寻找最短路径，双端队列代替普通先进先出队列）</p>
<p>994.腐烂的橘子（多源广度优先搜索）</p>
<h3 id="双指针问题："><a href="#双指针问题：" class="headerlink" title="双指针问题："></a>双指针问题：</h3><p>面试题57-2 和为s的连续正数序列（也可以采用枚举+数学优化解决）</p>
<p>LeetCode 160 求两个链表的交点(Intersection of Two Linked Lists)</p>
<h3 id="等差数列问题："><a href="#等差数列问题：" class="headerlink" title="等差数列问题："></a>等差数列问题：</h3><p>1103 分糖果2</p>
<h3 id="双端队列："><a href="#双端队列：" class="headerlink" title="双端队列："></a>双端队列：</h3><p>面试题59-2队列的最大值（维护一个单调的双端队列）</p>
<h3 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h3><p>322 零钱兑换（自上而下递归；自下而上循环，dfs剪枝+贪心算法）</p>
<p>873 最长的斐波那契子序列的长度</p>
<p>1027 最长等差数列</p>
<p>1049 最后一块石头的重量 II  <a href="https://leetcode-cn.com/problems/last-stone-weight-ii/solution/you-qian-ru-shen-si-lu-ji-0-1-bei-bao-xiang-jie-mo/" target="_blank" rel="noopener">0-1背包问题</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">现在有n个物品，每个物品都有一个价值，现在想将这些物品分给两个人，要求这两个人分到的物品价值总和相同(个数可以不同，总价值相同即可)，剩下的物品就要扔掉，现在想知道最少需要扔多少价值的物品才能满足要求分给两个人。</span><br><span class="line">输入描述</span><br><span class="line">第一行输入一个整数T，代表有T组测试数据</span><br><span class="line">对于每一组测试数据，一行输入一个整数n，代表物品的个数</span><br><span class="line">接下来n个数，a[i]代表每一个物品的价值</span><br><span class="line"><span class="number">1</span> &lt;= T &lt;= <span class="number">10</span></span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">15</span></span><br><span class="line"><span class="number">1</span> &lt;= a[i] &lt;= <span class="number">100000</span></span><br><span class="line">输出描述</span><br><span class="line">每一行输出最少需要扔掉多少价值的物品</span><br><span class="line">示例<span class="number">1</span></span><br><span class="line">输入</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">30</span> <span class="number">60</span> <span class="number">5</span> <span class="number">15</span> <span class="number">30</span></span><br><span class="line">输出</span><br><span class="line"><span class="number">20</span></span><br><span class="line">说明</span><br><span class="line">样例解释，扔掉第三个和第四个物品，然后将第一个物品和第五个物品给第一个人，第二个物品给第二个人，每个人分到的价值为<span class="number">60</span>，扔掉的价值为<span class="number">20</span>。</span><br><span class="line">解法</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> siz=<span class="number">1500000</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>],dp[siz+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, n, i, j, ans, sum;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j = sum; j &gt;= a[i]; --j)</span><br><span class="line">            dp[j] = dp[j] | dp[j-a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = sum;</span><br><span class="line">        <span class="keyword">for</span> (i = sum; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span>( i % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &amp;&amp; dp[i/<span class="number">2</span>]) &#123;</span><br><span class="line">                ans = sum - i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="位运算："><a href="#位运算：" class="headerlink" title="位运算："></a>位运算：</h3><p>136 137 260只出现一次的数字</p>
<p>1349参加考试的最大学生数（记忆化递归+压缩状态）</p>
<h3 id="二叉树的前中后序遍历："><a href="#二叉树的前中后序遍历：" class="headerlink" title="二叉树的前中后序遍历："></a>二叉树的前中后序遍历：</h3><p>173二叉搜索树迭代器（中序遍历和反向中序遍历均可解决）</p>
<p>145二叉树的后序遍历（<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode/" target="_blank" rel="noopener">二叉树后序是前序的逆序输出</a>;<a href="https://leetcode-cn.com/submissions/detail/91461093/" target="_blank" rel="noopener">二叉树后序遍历pair01</a>;<a href="https://leetcode-cn.com/submissions/detail/69281706/" target="_blank" rel="noopener">二叉树后序遍历压入null</a>;<a href="https://leetcode-cn.com/submissions/detail/69276364/" target="_blank" rel="noopener">二叉树后序遍历precur</a>）</p>
<p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/bian-li-tong-jie-by-long_wotu/" target="_blank" rel="noopener">二叉树迭代前中后</a></p>
<p><a href="https://www.jianshu.com/p/959247c29a7b" target="_blank" rel="noopener">二叉树mirrors前中后</a></p>
<p>235二叉搜索树的最近公共祖先  <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian--2/" target="_blank" rel="noopener">递归or迭代套用二分查找</a></p>
<p>236二叉树最近公共祖先  <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/" target="_blank" rel="noopener">递归or哈希表存储父节点</a></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**说明:</span></span><br><span class="line"><span class="comment">所有节点的值都是唯一的。</span></span><br><span class="line"><span class="comment">p、q 为不同节点且均存在于给定的二叉树中。</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//pair存储状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">enum</span> &#123;BOTH_DONE = <span class="number">0</span>,LEFT_DONE,BOTH_PENDING&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;pair&lt;TreeNode *, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">    TreeNode* LCA=<span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* childnode=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">bool</span> one_node_find= <span class="literal">false</span>;</span><br><span class="line">    st.push(pair&lt;TreeNode*,<span class="keyword">int</span>&gt;(root,BOTH_PENDING));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">        <span class="keyword">auto</span> top=st.top();</span><br><span class="line">        TreeNode* parentnode=top.first;</span><br><span class="line">        <span class="keyword">if</span>(top.second!=BOTH_DONE)&#123;</span><br><span class="line">            <span class="comment">//如果该节点左右节点没有遍历完</span></span><br><span class="line">            <span class="keyword">if</span>(top.second==BOTH_PENDING)&#123;</span><br><span class="line">                <span class="comment">//如果该节点左节点还未遍历，visit该节点</span></span><br><span class="line">                <span class="keyword">if</span>(top.first==p||top.first==q)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(one_node_find)&#123;</span><br><span class="line">                        <span class="keyword">return</span> LCA;</span><br><span class="line">                    &#125;</span><br><span class="line">                    one_node_find=<span class="literal">true</span>;</span><br><span class="line">                    LCA=top.first;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//不管该节点是否是所查找的节点都要继续向左遍历</span></span><br><span class="line">                childnode=top.first-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果该节点左节点已经遍历过了，说明已经visit该节点，则此次不用visit，可直接遍历其右节点</span></span><br><span class="line">                childnode=top.first-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//改变该节点的遍历状态</span></span><br><span class="line">            st.top().second-=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//当子节点不为空时把子节点压入栈</span></span><br><span class="line">            <span class="keyword">if</span>(childnode!=<span class="literal">NULL</span>)</span><br><span class="line">                st.push(pair&lt;TreeNode*,<span class="keyword">int</span>&gt;(childnode,BOTH_PENDING));</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//该节点左右节点都遍历过了，判断该节点是否被LCA指向，如果指向且已经找到一个节点则改变LCA记录当前最小公共父节点，</span></span><br><span class="line">            <span class="comment">//继续寻找另一个；不指向或者并没有找到一个节点则直接弹出</span></span><br><span class="line">            <span class="keyword">if</span>(parentnode==LCA &amp;&amp; one_node_find)&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                LCA=st.top().first;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="括号匹配："><a href="#括号匹配：" class="headerlink" title="括号匹配："></a>括号匹配：</h3><p>22 括号生成（回溯，闭合数）</p>
<p>20 有效的括号（栈）</p>
<h3 id="单调栈："><a href="#单调栈：" class="headerlink" title="单调栈："></a>单调栈：</h3><p>84 柱状图中的最大矩形</p>
<p>42 接雨水：动态编程 /单调栈/ 双指针</p>
<p>402 RemoveKDigits</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">size</span>=num.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span>==k||<span class="built_in">size</span>==<span class="number">0</span>)<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="built_in">string</span> st;</span><br><span class="line">    <span class="keyword">auto</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index&lt;<span class="built_in">size</span>&amp;&amp;k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.empty()||st.back()&lt;=num[index])&#123;</span><br><span class="line">            st+=num[index++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            st.pop_back();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 如果index == size, 则 k 可能不等于0, 移除掉st末尾k个元素.</span></span><br><span class="line">    <span class="comment">// 2. 如果k == 0, 则 index 可能不等于size, 需要加上num中index之后的元素.</span></span><br><span class="line">    st=st.substr(<span class="number">0</span>,st.<span class="built_in">size</span>()-k)+num.substr(index);<span class="comment">//点睛之笔，牛逼</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">begin</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 移除开头的0,在全0的情况下保证至少剩下一个0.</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">begin</span>&lt;st.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;st[<span class="built_in">begin</span>]==<span class="string">'0'</span>)<span class="built_in">begin</span>++;</span><br><span class="line">    <span class="keyword">return</span> st.substr(<span class="built_in">begin</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/dan-tiao-zhan" target="_blank" rel="noopener">循环数组</a>:数组长度翻倍</p>
<h3 id="字符串转换整数"><a href="#字符串转换整数" class="headerlink" title="字符串转换整数"></a>字符串转换整数</h3><p>8  字符串转换整数（atoi）</p>
<p><img src="/2020/07/26/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/atoi.png" alt="有限状态机"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有限状态机</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)，其中 n 为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为O(1)。</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)，自动机的状态只需要常数空间存储。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automaton</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> state = <span class="string">"start"</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">"start"</span>, &#123;<span class="string">"start"</span>, <span class="string">"signed"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"signed"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"in_number"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"end"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_col</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span> <span class="keyword">or</span> c == <span class="string">'-'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table[state][get_col(c)];</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">"in_number"</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">            ans = sign == <span class="number">1</span> ? <span class="built_in">min</span>(ans, (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MAX) : <span class="built_in">min</span>(ans, -(<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">"signed"</span>)</span><br><span class="line">            sign = c == <span class="string">'+'</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str)</span><br><span class="line">            automaton.<span class="built_in">get</span>(c);</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if-else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;index&lt;str.<span class="built_in">size</span>()&amp;&amp;str[index]==<span class="string">' '</span>;index++);</span><br><span class="line">    <span class="keyword">int</span> sign=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(str[index]==<span class="string">'+'</span>||str[index]==<span class="string">'-'</span>)</span><br><span class="line">        sign=str[index++]==<span class="string">'-'</span>?<span class="number">-1</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index&lt;str.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(str[index]))&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=((sign?INT32_MIN:INT32_MIN+<span class="number">1</span>)+(str[index]-<span class="string">'0'</span>))/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;ans)</span><br><span class="line">                <span class="keyword">return</span> sign?INT32_MIN:INT32_MAX;</span><br><span class="line">            ans=ans*<span class="number">10</span>-(str[index++]-<span class="string">'0'</span>);</span><br><span class="line"><span class="comment">//            int tmp= (sign?INT32_MIN+(str[index]-'0'):INT32_MAX-(str[index]-'0'))/10;</span></span><br><span class="line"><span class="comment">//            if(sign)&#123;</span></span><br><span class="line"><span class="comment">//                if(tmp&lt;=ans)//必须加上等号</span></span><br><span class="line"><span class="comment">//                    ans=ans*10-(str[index++]-'0');</span></span><br><span class="line"><span class="comment">//                else</span></span><br><span class="line"><span class="comment">//                    return INT32_MIN;</span></span><br><span class="line"><span class="comment">//            &#125;else&#123;</span></span><br><span class="line"><span class="comment">//                if(tmp&gt;=ans)//必须加上等号</span></span><br><span class="line"><span class="comment">//                    ans=ans*10+(str[index++]-'0');</span></span><br><span class="line"><span class="comment">//                else</span></span><br><span class="line"><span class="comment">//                    return INT32_MAX;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sign?ans:-ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/" target="_blank" rel="noopener">买卖股票的最佳时机</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base case：</span></span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">0</span>] = dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">1</span>] = dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态转移方程：</span></span><br><span class="line">dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])<span class="comment">//买入时已完成交易数+1，持股状态+1；当i是从0开始for循环时，若有手续费只能在此步-fee不能在卖出时-fee，因为存在max取值导致i==0时dp_0=0,dp_1=-prices[0],从而没把手续费计算进去</span></span><br></pre></td></tr></table></figure>

<p>买卖股票的最佳时机 III <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/liang-ci-jiao-yi-chai-cheng-zuo-bian-zui-da-dan-ci/" target="_blank" rel="noopener">两次交易拆成左边最大单次收益和右边最大单次收益之和</a></p>
<p>买卖股票的最佳时机 IIII</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</span></span><br><span class="line"><span class="comment">//设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</span></span><br><span class="line"><span class="comment">//注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_inf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不管k==1还是k==2还是k等于无穷大为了好记for循环均从0开始，初始化值为-1天时的dp</span></span><br><span class="line">        <span class="keyword">int</span> dp_0=<span class="number">0</span>,dp_1=INT32_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=dp_0;</span><br><span class="line">            dp_0=<span class="built_in">max</span>(dp_0,dp_1+prices[i]);</span><br><span class="line">            dp_1=<span class="built_in">max</span>(dp_1,tmp-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//交易数大于当前股票最大能进行的交易数时把k当成无限值处理，不然会超出时间限制</span></span><br><span class="line">        <span class="keyword">if</span>(k&gt;n/<span class="number">2</span>) <span class="keyword">return</span> maxProfit_k_inf(prices);</span><br><span class="line">        vector&lt;array&lt;int,2&gt;&gt; dp(k+1,array&lt;int,2&gt;&#123;0,INT32_MIN&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">                dp[j][<span class="number">0</span>]=<span class="built_in">max</span>(dp[j][<span class="number">0</span>],dp[j][<span class="number">1</span>]+prices[i]);</span><br><span class="line">                dp[j][<span class="number">1</span>]=<span class="built_in">max</span>(dp[j][<span class="number">1</span>],dp[j<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);<span class="comment">//买入股票时已完成交易+1，持股状态+1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回第prices.size()天已完成k笔交易，手持股份为0的状态</span></span><br><span class="line">        <span class="keyword">return</span> dp[k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="在排序数组中查找数字I"><a href="#在排序数组中查找数字I" class="headerlink" title="在排序数组中查找数字I"></a>在排序数组中查找数字I</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>,high=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//开区间右边界</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)low=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组中不存在目标值,直接返回</span></span><br><span class="line">        <span class="keyword">if</span>((high&gt;=<span class="number">0</span>&amp;&amp;nums[high]!=target)||high&lt;<span class="number">0</span> )<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录右边第一个大于target</span></span><br><span class="line">        <span class="keyword">int</span> right=low;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开区间左边界</span></span><br><span class="line">        low=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)high=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录左边第一个小于target</span></span><br><span class="line">        <span class="keyword">int</span> left=high;</span><br><span class="line">        <span class="keyword">return</span> right-left<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="基本计算器"><a href="#基本计算器" class="headerlink" title="基本计算器"></a>基本计算器</h3><ol>
<li>基本计算器   leetcode224<br>（1）栈+反转字符串<br>（2）栈+不反转字符串</li>
<li>基本计算器2  leetcode227<br>加减乘除=&gt;栈</li>
<li>基本计算器3  leetcode772</li>
</ol>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol>
<li>旋转链表 leetcode61</li>
</ol>
<p><a href="https://leetcode-cn.com/problems/rotate-list/solution/xuan-zhuan-lian-biao-by-leetcode/" target="_blank" rel="noopener">方法一</a>(1) 先将链表闭合成环<br>(2) 从头结点出发向后走n-k%n-1步断开这个环，确定新的链表头和链表尾</p>
<p><a href="https://leetcode-cn.com/problems/rotate-list/solution/kuai-man-zhi-zhen-xi-jie-yao-gao-hao-by-lilychao/" target="_blank" rel="noopener">方法二</a>快慢指针：快指针比慢指针先走k%n步，当fast指针到达尾部时与头结点相连，在slow指针处断开链表作为新的链表头</p>
<ol start="2">
<li>反转链表 剑指offer24</li>
</ol>
<p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-yi-dong-de-shuang-zhi-zhen-jia/" target="_blank" rel="noopener">双指针 递归 妖魔化的双指针</a></p>
<p>反转链表2 leetcode92<br><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode/" target="_blank" rel="noopener">递归 迭代链接反转</a></p>
<ol start="3">
<li>排序链表 leetcode148</li>
<li>合并两个有序链表 leetcode21</li>
</ol>
<h3 id="最长公共子序列-子串"><a href="#最长公共子序列-子串" class="headerlink" title="最长公共子序列/子串"></a>最长公共子序列/子串</h3><p><a href="https://github.com/xuexueq/blog/issues/29" target="_blank" rel="noopener">动态规划 LCS</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/12/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/" rel="next" title="深度搜索C++对象模型">
                <i class="fa fa-chevron-left"></i> 深度搜索C++对象模型
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/10/17/c-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="prev" title="c++网络编程">
                c++网络编程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">翟安然</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#刷题建议"><span class="nav-number">1.</span> <span class="nav-text">刷题建议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一课：链表-33333"><span class="nav-number">1.1.</span> <span class="nav-text">第一课：链表 ###########33333</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#链表的必备知识要点-包括基础知识、刷题中使用的STL等知识"><span class="nav-number">1.1.1.</span> <span class="nav-text">链表的必备知识要点(包括基础知识、刷题中使用的STL等知识)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二课：栈、队列、堆-33333"><span class="nav-number">1.2.</span> <span class="nav-text">第二课：栈、队列、堆  ####33333</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#栈、队列知识要点与实现-数组、链表"><span class="nav-number">1.2.1.</span> <span class="nav-text">栈、队列知识要点与实现(数组、链表)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆-优先级队列-知识要点与实现"><span class="nav-number">1.2.2.</span> <span class="nav-text">堆(优先级队列)知识要点与实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三课：贪心"><span class="nav-number">1.3.</span> <span class="nav-text">第三课：贪心 **</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#贪心算法知识要点，刷题必备的STL知识"><span class="nav-number">1.3.1.</span> <span class="nav-text">贪心算法知识要点，刷题必备的STL知识</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四课：递归、分治、回溯"><span class="nav-number">1.4.</span> <span class="nav-text">第四课：递归、分治、回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#递归的知识要点，回溯算法"><span class="nav-number">1.4.1.</span> <span class="nav-text">递归的知识要点，回溯算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分治算法知识要点"><span class="nav-number">1.4.2.</span> <span class="nav-text">分治算法知识要点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速排序算法与经典实现"><span class="nav-number">1.4.3.</span> <span class="nav-text">快速排序算法与经典实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第五课：树与图"><span class="nav-number">1.5.</span> <span class="nav-text">第五课：树与图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#树与图的数据结构与基本算法，树遍历的回调函数实现，并使用自动机概念实现非递归树前、中、后遍历"><span class="nav-number">1.5.1.</span> <span class="nav-text">树与图的数据结构与基本算法，树遍历的回调函数实现，并使用自动机概念实现非递归树前、中、后遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第六课：二分查找、二叉排序树、位运算的应用"><span class="nav-number">1.6.</span> <span class="nav-text">第六课：二分查找、二叉排序树、位运算的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二分查找、二叉排序树的知识要点"><span class="nav-number">1.6.1.</span> <span class="nav-text">二分查找、二叉排序树的知识要点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#位运算的知识要点"><span class="nav-number">1.6.2.</span> <span class="nav-text">位运算的知识要点  *****</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第七课：哈希表与字符串"><span class="nav-number">1.7.</span> <span class="nav-text">第七课：哈希表与字符串  *****</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希表与字符串知识要点"><span class="nav-number">1.7.1.</span> <span class="nav-text">哈希表与字符串知识要点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第八课：搜索"><span class="nav-number">1.8.</span> <span class="nav-text">第八课：搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#深度优先搜索与广度优先搜索算法"><span class="nav-number">1.8.1.</span> <span class="nav-text">深度优先搜索与广度优先搜索算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第九课：动态规划"><span class="nav-number">1.9.</span> <span class="nav-text">第九课：动态规划 ***</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态规划知识要点"><span class="nav-number">1.9.1.</span> <span class="nav-text">动态规划知识要点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十课：复杂数据结构"><span class="nav-number">1.10.</span> <span class="nav-text">第十课：复杂数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Trie树的构造与基本算法"><span class="nav-number">1.10.1.</span> <span class="nav-text">Trie树的构造与基本算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并查集的基本算法"><span class="nav-number">1.10.2.</span> <span class="nav-text">并查集的基本算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线段树与树状数组"><span class="nav-number">1.10.3.</span> <span class="nav-text">线段树与树状数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十一课-滑动窗口"><span class="nav-number">1.11.</span> <span class="nav-text">第十一课 滑动窗口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重难点记录"><span class="nav-number">2.</span> <span class="nav-text">重难点记录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#寻找旋转数组："><span class="nav-number">2.1.</span> <span class="nav-text">寻找旋转数组：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#153寻找旋转排序数组最小值"><span class="nav-number">2.1.1.</span> <span class="nav-text">153寻找旋转排序数组最小值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#154-寻找旋转排序数组最小值2（存在重复）"><span class="nav-number">2.1.2.</span> <span class="nav-text">154 寻找旋转排序数组最小值2（存在重复）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-搜索旋转排序数组"><span class="nav-number">2.1.3.</span> <span class="nav-text">33 搜索旋转排序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#81-搜索旋转排序数组2（存在重复）"><span class="nav-number">2.1.4.</span> <span class="nav-text">81 搜索旋转排序数组2（存在重复）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最短路径问题："><span class="nav-number">2.2.</span> <span class="nav-text">最短路径问题：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双指针问题："><span class="nav-number">2.3.</span> <span class="nav-text">双指针问题：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等差数列问题："><span class="nav-number">2.4.</span> <span class="nav-text">等差数列问题：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双端队列："><span class="nav-number">2.5.</span> <span class="nav-text">双端队列：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划："><span class="nav-number">2.6.</span> <span class="nav-text">动态规划：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位运算："><span class="nav-number">2.7.</span> <span class="nav-text">位运算：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的前中后序遍历："><span class="nav-number">2.8.</span> <span class="nav-text">二叉树的前中后序遍历：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#括号匹配："><span class="nav-number">2.9.</span> <span class="nav-text">括号匹配：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单调栈："><span class="nav-number">2.10.</span> <span class="nav-text">单调栈：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串转换整数"><span class="nav-number">2.11.</span> <span class="nav-text">字符串转换整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#买卖股票的最佳时机"><span class="nav-number">2.12.</span> <span class="nav-text">买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在排序数组中查找数字I"><span class="nav-number">2.13.</span> <span class="nav-text">在排序数组中查找数字I</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本计算器"><span class="nav-number">2.14.</span> <span class="nav-text">基本计算器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表"><span class="nav-number">2.15.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长公共子序列-子串"><span class="nav-number">2.16.</span> <span class="nav-text">最长公共子序列&#x2F;子串</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">翟安然</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  
  
    <script src="/js/cursor/fireworks.js"></script>
  

</body>
</html>

