{"meta":{"title":"翟安然's Blog","subtitle":"","description":"","author":"翟安然","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-03-25T10:41:58.000Z","updated":"2020-03-25T14:54:20.795Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-25T10:37:44.000Z","updated":"2020-03-25T15:00:42.002Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-03-25T10:42:40.000Z","updated":"2020-03-25T13:48:56.355Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-25T10:41:44.000Z","updated":"2020-03-25T13:49:16.049Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"刷题记录","slug":"刷题记录","date":"2020-07-26T01:57:49.000Z","updated":"2020-08-20T05:57:35.000Z","comments":true,"path":"2020/07/26/刷题记录/","link":"","permalink":"http://yoursite.com/2020/07/26/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"刷题建议第一课：链表链表的必备知识要点(包括基础知识、刷题中使用的STL等知识) 链表逆序(LeetCode 92,206. Reverse Linked List 1,2) 求两个链表的交点(LeetCode 160. Intersection of Two Linked Lists) 链表的节点交换(LeetCode 24. Swap Nodes in Pairs) 链表求环(LeetCode 141,142. Linked List Cycle 1,2) 双指针 链表重新构造(LeetCode 86. Partition List) 复杂的链表复制(LeetCode 138. Copy List with Random Pointer) 排序链表合并(2个与多个) (LeetCode 21,23 Merge Two(k) Sorted ListsLeetCode) 第二课：栈、队列、堆栈、队列知识要点与实现(数组、链表) 使用队列实现栈(LeetCode 232. Implement Queue using Stacks) 使用栈实现队列(LeetCode 225. Implement Stack using Queues) 包含min函数的栈(LeetCode 155. Min Stack) 简单的计算器(栈的应用)( LeetCode 224. Basic Calculator) 堆(优先级队列)知识要点与实现 数组中第K大的数(堆的应用) (LeetCode 215. Kth Largest Element in an Array) 第三课：贪心 **贪心算法知识要点，刷题必备的STL知识 贪心题目1(LeetCode 455. Assign Cookies) 贪心题目2(LeetCode 402. Remove K Digits) 贪心题目3(LeetCode 134. Gas Station) 贪心题目4(LeetCode 135. Candy) 贪心题目5(LeetCode 502. IPO) 贪心题目6(LeetCode 321. Create Maximum Number) 贪心题目7(codeforces 582A GCD Table) 第四课：递归、分治、回溯递归的知识要点，回溯算法 生成组合数(LeetCode 39. Combination Sum, LeetCode 40. Combination Sum II) 生成排列数(LeetCode 46. Permutations, LeetCode 47. Permutations II) 1234567891011121314151617181920212223242526272829//递归+剪枝 （另一种方法是set+递归（交换））void dfs(vector&lt;int&gt;&amp; nums,int index,vector&lt;bool&gt;&amp; used,vector&lt;int&gt;&amp; cur,vector&lt;vector&lt;int&gt;&gt;&amp; ret) &#123; if (index == nums.size()) &#123; ret.push_back(cur); return; &#125; //i的初始值为0而不是index，每次都要遍历所有位，从未使用的位中挑选下一位 for(int i=0;i&lt;nums.size();i++)&#123; //大前提必须是该位没有被使用过 if(used[i])continue; //如果该位等于前一位且前一位没有被占用则取该位会导致重复，所以去重 if(i&gt;0&amp;&amp;nums[i-1]==nums[i]&amp;&amp;!used[i-1])continue; cur.push_back(nums[i]); used[i]=true; dfs(nums,index+1,used,cur,ret); used[i]=false; cur.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums)&#123; vector&lt;vector&lt;int&gt;&gt; ret; sort(nums.begin(),nums.end()); vector&lt;bool&gt; used(nums.size(),false); vector&lt;int&gt; cur; dfs(nums,0,used,cur,ret); return ret;&#125;&#125;; N皇后问题(LeetCode 51. N-Queens, LeetCode 52. N-Queens II) 分治算法知识要点快速排序算法与经典实现 不同的加括号方法(LeetCode 241. Different Ways to Add Parentheses) 两个数组的中位数(LeetCode 4. Median of Two Sorted Arrays)(贼难) 第五课：树与图树与图的数据结构与基本算法，树遍历的回调函数实现，并使用自动机概念实现非递归树前、中、后遍历 树与链表的转换(LeetCode 114. Flatten Binary Tree to Linked List) 最近的公共祖先(LeetCode 236. Lowest Common Ancestor of a Binary Tree) 树的层次遍历应用(LeetCode 199. Binary Tree Right Side View) 树的改造(LeetCode 117. Populating Next Right Pointers in Each Node 1,2) 图的复制(LeetCode 133. Clone Graph) 图的搜索与应用(LeetCode 207.Course Schedule) 第六课：二分查找、二叉排序树、位运算的应用二分查找、二叉排序树的知识要点 数组的二分查找(LeetCode 33,81 Search in Rotated Sorted Array 1,2) 区间二分查找(LeetCode 34. Search for a Range) 排序链表转换为二叉排序树(LeetCode 109. Convert Sorted List to B- Search Tree) 二叉排序树的遍历与改造(LeetCode 538 Convert BST to Greater Tree) 二叉排序树中的第K大的数(LeetCode 230. Kth Smallest Element in a BST) 位运算的知识要点 ***** 使用位运算表示集合(LeetCode 78. Subsets) 位运算应用题目(LeetCode 136,137,260. Single Number1,2,3) 第七课：哈希表与字符串 *****哈希表与字符串知识要点 哈希题目 (LeetCode 290. Word Pattern) 哈希与字符串综合 (LeetCode 3.Longest Substring Without Repeating Characters) 哈希与字符串综合 (LeetCode 76. Minimum Window Substring) 哈希与字符串综合 (LeetCode 30. Substring with Concatenation of All Words) 字符串题目 (LeetCode 459. Repeated Substring Pattern) 字符串题目 (LeetCode 468. Validate IP Address) 第八课：搜索深度优先搜索与广度优先搜索算法 深搜题目 (LeetCode 200. Number of Islands) 深搜题目 (LeetCode 473. Matchsticks to Square) 深搜题目 (LeetCode 491. Increasing Subsequences) 广搜题目 (LeetCode 417. Pacific Atlantic Water Flow) 广搜题目 (LeetCode 407. Trapping Rain Water II) 第九课：动态规划 ***动态规划知识要点 动态规划题目1(LeetCode 120. Triangle) 动态规划题目2(LeetCode 53. Maximum Subarray) 动态规划题目3(LeetCode 198. House Robber 1) 动态规划题目4(LeetCode 322. Coin Change) 123456789101112131415//凑零钱问题动态规划，类似于背包问题int coinChangeDP(vector&lt;int&gt;&amp; coins, int amount)&#123; if(coins.size()==0||amount&lt;0) return -1;//因为凑成 amount 金额的硬币数最多只可能等于 amount（全用 1 元面值的硬币），所以dp 数组初始化为 amount + 1 就相当于初始化为正无穷，便于后续取最小值。 vector&lt;int&gt; dp(amount+1,amount+1); dp[0]=0; for(int i=1;i&lt;amount+1;i++)&#123; for(const auto&amp; coin:coins)&#123; if(i-coin&lt;0)continue; dp[i]=min(dp[i],1+dp[i-coin]); &#125; &#125; return dp[amount]==amount+1?-1:dp[amount];&#125; 0-1背包问题 leetcode 416分割等和子集 leetcode 494 目标和 最长回文子串 leetcode 5 1234567891011121314151617181920212223242526class Solution &#123;public: string longestPalindrome(string s) &#123; int n = s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); string ans; for (int l = 0; l &lt; n; ++l) &#123; for (int i = 0; i + l &lt; n; ++i) &#123; int j = i + l; if (l == 0) &#123; dp[i][j] = 1; &#125; else if (l == 1) &#123; dp[i][j] = (s[i] == s[j]); &#125; else &#123; dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]); &#125; if (dp[i][j] &amp;&amp; l + 1 &gt; ans.size()) &#123; ans = s.substr(i, l + 1); &#125; &#125; &#125; return ans; &#125;&#125;; 最长回文子序列 拓展:最长公共子序列 数组交集 不相交的线段 1234567891011121314151617181920int longestPalindromeSubseq(string s) &#123; int n = s.size(); // dp 数组全部初始化为 0 vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); // base case for (int i = 0; i &lt; n; i++) dp[i][i] = 1; // 反着遍历保证正确的状态转移 for (int i = n - 2; i &gt;= 0; i--) &#123; for (int j = i + 1; j &lt; n; j++) &#123; // 状态转移方程 if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); &#125; &#125; // 整个 s 的最长回文子串长度 return dp[0][n - 1];&#125; 第十课：复杂数据结构Trie树的构造与基本算法 Trie树的构造 (LeetCode 208. Implement Trie (Prefix Tree)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class TrieNode&#123;public: TrieNode():isEnd(false),path(0)&#123; //memset只能填int值，注意指针数组初始化分配空间 //# include &lt;string.h&gt;//memset是c函数 //void *memset(void *s, int c, unsigned long n); memset(children,0,sizeof(children)); //或者 //for(int i=0;i&lt;26;i++) // next[i]=NULL; &#125; //不能是private，外部需要直接调用，或者设置成private并对每个操作定义对应函数 bool isEnd; int path; TrieNode* children[26];&#125;;class Trie &#123;public: /** Initialize your data structure here. */ Trie() &#123; root=new TrieNode(); &#125; /** Inserts a word into the trie. */ void insert(string word) &#123; TrieNode* node=root; for(int i=0;i&lt;word.size();i++)&#123; int index=word[i]-'a'; if(node-&gt;children[index]==0) node-&gt;children[index]=new TrieNode(); node-&gt;children[index]-&gt;path++; node=node-&gt;children[index]; &#125; node-&gt;isEnd=true; &#125; //添加hasPrefix避免后两个函数包含重复代码 TrieNode* hasPrefix(string prefix) &#123; TrieNode* node=root; for(auto w:prefix)&#123; int index=w-'a'; if(node-&gt;children[index]==0) return nullptr; else node=node-&gt;children[index]; &#125; return node; &#125; /** Returns if the word is in the trie. */ bool search(string word) &#123; TrieNode* node=hasPrefix(word); return node==nullptr?false:node-&gt;isEnd; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) &#123; TrieNode* node=hasPrefix(prefix); return node!=nullptr; &#125;private: TrieNode* root;&#125;;/** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-&gt;insert(word); * bool param_2 = obj-&gt;search(word); * bool param_3 = obj-&gt;startsWith(prefix); */ Trie树的应用 (LeetCode 212. Word Search II) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class TrieNode&#123;public: TrieNode():isEnd(false),path(0)&#123; //memset只能填int值，注意指针数组初始化分配空间 //# include &lt;string.h&gt;//memset是c函数 //void *memset(void *s, int c, unsigned long n); memset(children,0,sizeof(children)); &#125; //不能是private，外部需要直接调用，或者设置成private并对每个操作定义对应函数 bool isEnd; int path; TrieNode* children[26];&#125;;class Trie &#123;public: /** Initialize your data structure here. */ Trie() &#123; root=new TrieNode(); &#125; /** Inserts a word into the trie. */ void insert(string word) &#123; TrieNode* node=root; for(int i=0;i&lt;word.size();i++)&#123; int index=word[i]-'a'; if(node-&gt;children[index]==0) node-&gt;children[index]=new TrieNode(); node-&gt;children[index]-&gt;path++; node=node-&gt;children[index]; &#125; node-&gt;isEnd=true; &#125; TrieNode* root;&#125;;class Solution &#123;public: vector&lt;string&gt; ret; array&lt;int,4&gt; row&#123;-1,0,1,0&#125;; array&lt;int,4&gt; col&#123;0,1,0,-1&#125;; void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,vector&lt;vector&lt;bool&gt;&gt;&amp; visited,int i,int j,TrieNode* curnode,string path)&#123; if(curnode-&gt;isEnd)&#123; ret.push_back(path); //避免重复获取同一个string curnode-&gt;isEnd=false; &#125; for(int k=0;k&lt;4;k++)&#123; int newrow=i+row[k]; int newcol=j+col[k]; if(newrow&lt;0 || newrow&gt;=board.size() || newcol&lt;0 || newcol&gt;=board[0].size() || visited[newrow][newcol]) continue; int index=board[newrow][newcol]-'a'; if(curnode-&gt;children[index]!=nullptr)&#123; visited[newrow][newcol]=true; dfs(board,visited,newrow,newcol,curnode-&gt;children[index],path+board[newrow][newcol]); visited[newrow][newcol]= false; &#125; &#125; &#125; vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123; if(board.size()==0) return vector&lt;string&gt;(); Trie* trie=new Trie(); for(auto s:words) trie-&gt;insert(s); vector&lt;vector&lt;bool&gt;&gt; visited(board.size(),vector&lt;bool&gt;(board[0].size(),false)); for(int i=0;i&lt;board.size();i++)&#123; for(int j=0;j&lt;board[0].size();j++)&#123; int index=board[i][j]-'a'; if(trie-&gt;root-&gt;children[index]!= nullptr)&#123; visited[i][j]=true; string s(1,board[i][j]); dfs(board,visited,i,j,trie-&gt;root-&gt;children[index],s); visited[i][j]=false; &#125; &#125; &#125; return ret; &#125;&#125;; 数组中两个数的最大异或值 leetcode421 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//1.将数组中的数全部存入字典树中//2.遍历树中的每一个数在字典树中异或的最大结果，最后再求最大结果里面的最大值返回就是了//时间复杂度O(n),空间复杂度O(1)class Trie&#123;public: Trie* next[2]; Trie() &#123; memset(next, 0, sizeof(next)); &#125;&#125;;class Solution &#123; Trie* root = new Trie();public: int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123; // 将数按照二进制形式全部存入字典树里面 for(int num : nums) &#123; Trie* node = root; for(int i = 30; i &gt;= 0; i--) &#123; int bt = num &gt;&gt; i &amp; 1; if(node-&gt;next[bt] == nullptr) &#123; node-&gt;next[bt] = new Trie(); &#125; node = node-&gt;next[bt]; &#125; &#125; // 找最大^值 int res = 0; for(int num : nums) &#123; Trie* node = root; int sum = 0; for(int i = 30; i &gt;= 0; i--) &#123; int bt = num &gt;&gt; i &amp; 1; // 如果bt==1则贪心的去找0异或 否则找1异或 if(bt == 1) &#123; sum += node-&gt;next[0] != nullptr ? 1 &lt;&lt; i : 0 ; node = node-&gt;next[0] != nullptr ? node-&gt;next[0] : node-&gt;next[1]; &#125; else &#123; sum += node-&gt;next[1] != nullptr ? 1 &lt;&lt; i : 0 ; node = node-&gt;next[1] != nullptr ? node-&gt;next[1] : node-&gt;next[0]; &#125; &#125; res = max(res, sum); &#125; return res; &#125;&#125;; 并查集的基本算法 并查集的应用 (LeetCode 547. Friend Circles) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//并查集class Solution &#123;public: void init(int n)&#123; for(int i=0;i&lt;n;i++)&#123; parent.emplace_back(i); rank.emplace_back(0); &#125; &#125; int find(int x)&#123; return parent[x]==x?x:parent[x]=find(parent[x]); &#125; void unite(int x,int y)&#123; int xroot=find(x); int yroot=find(y); if(xroot==yroot)return; if(rank[xroot]&lt;rank[yroot]) parent[xroot]=yroot; // 合并是从rank小的向rank大的连边 else &#123; parent[yroot]=xroot; if(rank[xroot]==rank[yroot]) rank[xroot]++; &#125; return; &#125; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; int n=M.size(); if(n==0)return 0; init(n); for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(M[i][j]) unite(i,j); &#125; &#125; int cnt=0; for(int i=0;i&lt;n;i++)&#123; if(parent[i]==i) cnt++; &#125; return cnt; &#125;private: vector&lt;int&gt; parent; vector&lt;int&gt; rank;&#125;; 情侣配对（lc765 minSwapsCouples）（也可用贪心算法） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution&#123;public: void init(int n)&#123; for(int i=0;i&lt;n;i+=2)&#123; parent.emplace_back(i); parent.emplace_back(i); rank.push_back(1); rank.push_back(0); &#125; &#125; //路径压缩 int find(int x)&#123; return parent[x]==x?x:(parent[x]=find(parent[x])); &#125; void unite(int x,int y)&#123; int rootx=find(x); int rooty=find(y); if(rootx==rooty)return; if(rank[rootx]&lt;rank[rooty]) parent[rootx]=rooty; else&#123; parent[rooty]=rootx; if(rank[rootx]==rank[rooty]) rank[rootx]++; &#125; &#125; int minSwapsCouples(vector&lt;int&gt; &amp;row)&#123; init(row.size()); //把可以交换的块全都连在一起，形成一个错误环，每个错误环(包含k组)需要交换k-1调整 for(int i=0;i&lt;row.size()-1;i+=2)&#123; unite(row[i],row[i+1]); &#125; //一共有row.size()/2组,每组一个环的话，每组需要交换1-1=0次 int ans=row.size()/2; for(int i=0;i&lt;row.size();i++)&#123; //减去环数即为需要交换的次数 if(parent[i]==i)ans--; &#125; return ans; &#125;private: vector&lt;int&gt; parent; vector&lt;int&gt; rank;&#125;; 线段树与树状数组 线段树与树状数组的应用(LeetCode 307. Range Sum Query – Mutable) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//线段树class NumArray &#123;public: NumArray(vector&lt;int&gt; &amp;nums) &#123; if (nums.size() &gt; 0) &#123; n = nums.size(); tree.resize(2*n,0); buildTree(nums); &#125;&#125;void buildTree(vector&lt;int&gt; nums) &#123; for (int i = n, j = 0; i &lt; 2 * n; i++, j++) tree[i] = nums[j]; for (int i = n - 1; i &gt; 0; --i) tree[i] = tree[i * 2] + tree[i * 2 + 1];&#125;//时间复杂度：O(n)。因为我们在 for 循环的每次迭代中计算一个节点的和。而一个线段树中大约有2n 个节点。//这可以通过以下方式证明：具有 n 个元素的数组线段树有 n 个叶节点（数组元素本身）。每一层中的节点数是下面一层中节点数的一半。//因此，如果我们按层对节点数求和，二叉树总共有2^h-1个节点，共有2^(h-1)个叶节点。//空间复杂度：O(n)，我们用了 2n 的额外空间来存储整个线段树。//更新线段树 :当我们更新数组中某个索引 i处的元素时，我们需要重建线段树，因为一些树节点上的和值也会随之产生变化。我们将再次使用//自下而上的方法。首先更新存储 a[i] 元素的叶节点。从那里我们将一路向上，直到根节点，并用其子节点值的总和来更新每个父节点的值。void update(int pos, int val) &#123; pos += n; tree[pos] = val; while (pos &gt; 0) &#123; int left = pos; int right = pos; if (pos % 2 == 0) &#123; right = pos + 1; &#125; else &#123; left = pos - 1; &#125; // parent is updated after child is updated tree[pos / 2] = tree[left] + tree[right]; pos /= 2;//pos等于2或者3时除以2等于1，进入循环后会更改tree[0]的值但是不影响结果 &#125;&#125;//时间复杂度：O(logn)。因为有几个树节点的范围包括第 i 个数组元素，每个层上都有一个。共有log(n) 层。//空间复杂度：O(1)。//区域和检索：我们可以通过以下方式使用线段树进行区域和检索 [L,R]：算法保持循环不变：l≤r 以及已经算出 [L…l] 和 [r…R] 的总和，//其中 l 和 r 分别是计算总和时的左边界和右边界。每次迭代的范围 [l,r] 都会缩小，直到在算法的大约 logn 次迭代后两个边界相遇为止。int sumRange(int l, int r) &#123; // get leaf with value 'l' l += n; // get leaf with value 'r' r += n; int sum = 0; //当l==r时仍会进入循环进入其中一个if，把tree[l]加进总和 while (l &lt;= r) &#123; if ((l % 2) == 1) &#123; sum += tree[l]; l++; &#125; if ((r % 2) == 0) &#123; sum += tree[r]; r--; &#125; l /= 2; r /= 2; &#125; return sum;&#125;private: vector&lt;int&gt; tree; int n;&#125;; 归并排序及其解决逆序对数、小和问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//离散化树状数组#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Bit&#123;public: Bit(int _n):n(_n),bits(n+1)&#123;&#125; static int lowbit(int x)&#123; return x&amp;(-x); &#125; int query(int x)&#123; int sum=0; while(x)&#123; sum+=bits[x]; x-=lowbit(x); &#125; return sum; &#125; void update(int x,int val)&#123; while(x&lt;=n)&#123; bits[x]+=val; x+=lowbit(x); &#125; &#125;private: vector&lt;int&gt; bits; int n;&#125;;int minSum(vector&lt;int&gt;&amp; nums)&#123; int n=nums.size(); if(n==0||n==1) return 0; vector&lt;int&gt; tmp(nums); vector&lt;int&gt; index(n,0); sort(tmp.begin(),tmp.end()); for(int i=0;i&lt;n;i++) //要得到的是num在排序数组中的index+1，即在离散化树状数组中第几个（从1开始），这样 //插入之前可以计算它前面的所有值的和，从而得到它在数组中的在它左边的比他小的数的和 index[i]=lower_bound(tmp.begin(),tmp.end(),nums[i])-tmp.begin()+1; Bit bit(n); int sum=0; for(int i=0;i&lt;n;i++)&#123; sum+=bit.query(index[i]-1); bit.update(index[i],nums[i]); &#125; return sum;&#125; offer51 数组中的逆序对 树状数组解释 树状数组详解 315 计算右侧小于当前元素的个数 第十一课 滑动窗口 无重复字符的最长子串 串联所有单词的子串 最小覆盖子串 至多包含两个不同字符的最长子串（会员） 长度最小的子数组 滑动窗口最大值 字符串的排列 最小区间 最小窗口子序列（会员） 重难点记录寻找旋转数组：153寻找旋转排序数组最小值12345678910111213func findMin (nums []int) int &#123; left, right := 0, len(nums)-1 for left &lt;= right &#123; # 实际上是不会跳出循环，当 left==right 时直接返回 if nums[left] &lt;= nums[right] # 如果 [left,right] 递增，直接返回 return nums[left] mid := left + (right-left)&gt;&gt;1 if nums[left] &lt;= nums[mid] # [left,mid] 连续递增，则在 [mid+1,right] 查找 left = mid + 1 else right = mid # [left,mid] 不连续，在 [left,mid] 查找 &#125; return -1&#125; 154 寻找旋转排序数组最小值2（存在重复）123456789101112131415func findMin (nums []int) int &#123; left, right := 0, len(nums)-1 for left &lt;= right &#123; #实际上不会跳出循环 if nums[left] &lt; nums[right] || left == right # 这里的判断条件增加一个判断条件 return nums[left] mid := left + (right-left)&gt;&gt;1 if nums[left] &lt; nums[mid] left = mid + 1 else if nums[left] == nums[mid] left++ // 无法判断 mid 位于哪一部分，去掉干扰项 else right = mid &#125; return -1&#125; 33 搜索旋转排序数组81 搜索旋转排序数组2（存在重复） 1234567891011121314151617181920212223242526272829303132bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int n=nums.size(); if(n==0) return false; int left=0; int right=n-1; while(left&lt;right)&#123; int mid=left+(right-left)/2; if(nums[mid]==target) return true; if(nums[left]==target) return true; if(nums[right]==target) return true; if(right-left==1) return false; if(nums[mid]&lt;nums[right])&#123;//旋转点在左侧 if(nums[mid]&lt;target&amp;&amp;nums[right]&gt;target) left=mid+1; else if(nums[right]&lt;target||nums[mid]&gt;target) right=mid-1; &#125;else if(nums[mid]&gt;nums[right])&#123;//旋转点在右侧 if(nums[mid]&gt;target&amp;&amp;nums[left]&lt;target) right=mid-1; else if(nums[mid]&lt;target||nums[left]&gt;target) left=mid+1; &#125;else left++;//比不重复的多此句 &#125; return nums[left]==target?true:false; &#125; 最短路径问题：1368 使网格图至少有一条有效路径的最小代价（方法1 Dijkstra算法；方法2 0-1广度优先搜索寻找最短路径，双端队列代替普通先进先出队列） 994.腐烂的橘子（多源广度优先搜索） 双指针问题：面试题57-2 和为s的连续正数序列（也可以采用枚举+数学优化解决） LeetCode 160 求两个链表的交点(Intersection of Two Linked Lists) 等差数列问题：1103 分糖果2 双端队列：面试题59-2队列的最大值（维护一个单调的双端队列） 动态规划：322 零钱兑换（自上而下递归；自下而上循环，dfs剪枝+贪心算法） 873 最长的斐波那契子序列的长度 1027 最长等差数列 1049 最后一块石头的重量 II 0-1背包问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253现在有n个物品，每个物品都有一个价值，现在想将这些物品分给两个人，要求这两个人分到的物品价值总和相同(个数可以不同，总价值相同即可)，剩下的物品就要扔掉，现在想知道最少需要扔多少价值的物品才能满足要求分给两个人。输入描述第一行输入一个整数T，代表有T组测试数据对于每一组测试数据，一行输入一个整数n，代表物品的个数接下来n个数，a[i]代表每一个物品的价值1 &lt;= T &lt;= 101 &lt;= n &lt;= 151 &lt;= a[i] &lt;= 100000输出描述每一行输出最少需要扔掉多少价值的物品示例1输入1530 60 5 15 30输出20说明样例解释，扔掉第三个和第四个物品，然后将第一个物品和第五个物品给第一个人，第二个物品给第二个人，每个人分到的价值为60，扔掉的价值为20。解法#include &lt;bits/stdc++.h&gt;using namespace std;const int siz=1500000;int a[20],dp[siz+5];int main()&#123; int T, n, i, j, ans, sum; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; sum = 0; for (i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; a[i]; sum += a[i]; &#125; memset(dp, 0, sizeof(dp)); dp[0] = 1; for (i = 0; i &lt; n; ++i)&#123; for (j = sum; j &gt;= a[i]; --j) dp[j] = dp[j] | dp[j-a[i]]; &#125; ans = sum; for (i = sum; i &gt;= 0; --i) &#123; if( i % 2 != 0) continue; if(dp[i] &amp;&amp; dp[i/2]) &#123; ans = sum - i; break; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 位运算：136 137 260只出现一次的数字 1349参加考试的最大学生数（记忆化递归+压缩状态） 二叉树的前中后序遍历：173二叉搜索树迭代器（中序遍历和反向中序遍历均可解决） 145二叉树的后序遍历（二叉树后序是前序的逆序输出;二叉树后序遍历pair01;二叉树后序遍历压入null;二叉树后序遍历precur） 二叉树迭代前中后 二叉树mirrors前中后 235二叉搜索树的最近公共祖先 递归or迭代套用二分查找 236二叉树最近公共祖先 递归or哈希表存储父节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/**说明:所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。 * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *///pair存储状态class Solution &#123;enum &#123;BOTH_DONE = 0,LEFT_DONE,BOTH_PENDING&#125;;public:TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) &#123; if (root == NULL) return NULL; stack&lt;pair&lt;TreeNode *, int&gt;&gt; st; TreeNode* LCA=NULL; TreeNode* childnode=NULL; bool one_node_find= false; st.push(pair&lt;TreeNode*,int&gt;(root,BOTH_PENDING)); while(!st.empty())&#123; auto top=st.top(); TreeNode* parentnode=top.first; if(top.second!=BOTH_DONE)&#123; //如果该节点左右节点没有遍历完 if(top.second==BOTH_PENDING)&#123; //如果该节点左节点还未遍历，visit该节点 if(top.first==p||top.first==q)&#123; if(one_node_find)&#123; return LCA; &#125; one_node_find=true; LCA=top.first; &#125; //不管该节点是否是所查找的节点都要继续向左遍历 childnode=top.first-&gt;left; &#125; else&#123; //如果该节点左节点已经遍历过了，说明已经visit该节点，则此次不用visit，可直接遍历其右节点 childnode=top.first-&gt;right; &#125; //改变该节点的遍历状态 st.top().second-=1; //当子节点不为空时把子节点压入栈 if(childnode!=NULL) st.push(pair&lt;TreeNode*,int&gt;(childnode,BOTH_PENDING)); &#125; else&#123; //该节点左右节点都遍历过了，判断该节点是否被LCA指向，如果指向且已经找到一个节点则改变LCA记录当前最小公共父节点， //继续寻找另一个；不指向或者并没有找到一个节点则直接弹出 if(parentnode==LCA &amp;&amp; one_node_find)&#123; st.pop(); LCA=st.top().first; &#125; else st.pop(); &#125; &#125; return NULL;&#125;&#125;; 括号匹配：22 括号生成（回溯，闭合数） 20 有效的括号（栈） 单调栈：82 柱状图中的最大矩形 42 接雨水 402 RemoveKDigits 字符串转换整数8 字符串转换整数（atoi） 123456789101112131415161718192021222324252627282930313233343536373839404142//有限状态机//时间复杂度：O(n)，其中 n 为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为O(1)。//空间复杂度：O(1)，自动机的状态只需要常数空间存储。class Automaton &#123; string state = \"start\"; unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123; &#123;\"start\", &#123;\"start\", \"signed\", \"in_number\", \"end\"&#125;&#125;, &#123;\"signed\", &#123;\"end\", \"end\", \"in_number\", \"end\"&#125;&#125;, &#123;\"in_number\", &#123;\"end\", \"end\", \"in_number\", \"end\"&#125;&#125;, &#123;\"end\", &#123;\"end\", \"end\", \"end\", \"end\"&#125;&#125; &#125;; int get_col(char c) &#123; if (isspace(c)) return 0; if (c == '+' or c == '-') return 1; if (isdigit(c)) return 2; return 3; &#125;public: int sign = 1; long long ans = 0; void get(char c) &#123; state = table[state][get_col(c)]; if (state == \"in_number\") &#123; ans = ans * 10 + c - '0'; ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN); &#125; else if (state == \"signed\") sign = c == '+' ? 1 : -1; &#125;&#125;;class Solution &#123;public: int myAtoi(string str) &#123; Automaton automaton; for (char c : str) automaton.get(c); return automaton.sign * automaton.ans; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435//if-else#include &lt;iostream&gt;using namespace std;int myAtoi(string str) &#123; if(str.size()==0) return 0; int index=0; for(;index&lt;str.size()&amp;&amp;str[index]==' ';index++); int sign=0; if(str[index]=='+'||str[index]=='-') sign=str[index++]=='-'?-1:0; int ans=0; while(index&lt;str.size())&#123; if(isdigit(str[index]))&#123; int tmp=((sign?INT32_MIN:INT32_MIN+1)+(str[index]-'0'))/10; if(tmp&gt;ans) return sign?INT32_MIN:INT32_MAX; ans=ans*10-(str[index++]-'0');// int tmp= (sign?INT32_MIN+(str[index]-'0'):INT32_MAX-(str[index]-'0'))/10;// if(sign)&#123;// if(tmp&lt;=ans)//必须加上等号// ans=ans*10-(str[index++]-'0');// else// return INT32_MIN;// &#125;else&#123;// if(tmp&gt;=ans)//必须加上等号// ans=ans*10+(str[index++]-'0');// else// return INT32_MAX;// &#125; &#125;else break; &#125; return sign?ans:-ans;&#125; 买卖股票的最佳时机买卖股票的最佳时机 III 两次交易拆成左边最大单次收益和右边最大单次收益之和","categories":[],"tags":[]},{"title":"深度搜索C++对象模型","slug":"深度搜索C-对象模型","date":"2020-07-12T14:36:38.000Z","updated":"2020-07-26T02:28:07.787Z","comments":true,"path":"2020/07/12/深度搜索C-对象模型/","link":"","permalink":"http://yoursite.com/2020/07/12/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/","excerpt":"第一章 关于对象1、c语言是程序性语言，数据和处理数据的操作是分开来声明的，只有struct没有class 2、c++是面向对象的，具有抽象数据类型（abstract data type，ADT） c++对象模型 简单对象模型 表格驱动对象模型 c++对象模型 programming paradigms程序设计范式","text":"第一章 关于对象1、c语言是程序性语言，数据和处理数据的操作是分开来声明的，只有struct没有class 2、c++是面向对象的，具有抽象数据类型（abstract data type，ADT） c++对象模型 简单对象模型 表格驱动对象模型 c++对象模型 programming paradigms程序设计范式 第二章 构造函数语意Defaut constructors and Copy constructorsimplicit nontrivial default constructors和implicit nontrivial copy constructors在必要的时候才由编译器产生出来，区别：合成defautl constructors中只有base class subjects和member class objects会被初始化，所有其他nonstatic member(如整数、整数指针、整数数组等)都不会被初始化；合成的copy constructors中，如整数、指针、数组等的nonstatic members也会被复制。 有三种情况会以一个object的内容作为另一个class object的初值：（1）对一个object做显示地初始化操作；（2）当object被当做参数交给某个函数时；（3）当函数传回一个class object时。 第三章 Data语意学任何name-managling做法都有两个重点： 一个算法，推导出独一无二的名称 万一编译系统（或环境工具）必须和使用者交谈，那些独一无二的名称可以轻易被推导回到原来的名称","categories":[],"tags":[]},{"title":"effective modern c++","slug":"effective-modern-c","date":"2020-05-24T01:13:12.000Z","updated":"2020-07-08T12:18:15.547Z","comments":true,"path":"2020/05/24/effective-modern-c/","link":"","permalink":"http://yoursite.com/2020/05/24/effective-modern-c/","excerpt":"[TOC] 一、型别推导条款1：理解模板型别推导12template&lt;typename T&gt;void f(ParamType param); 1、T的型别推导结果，不仅仅依赖expr的型别，还依赖ParamType的形式，具体分三种情况讨论（1）ParamType是个指针或引用，但不是万能引用 i）若expr具有引用型别，先将引用部分忽略。 ii）尔后，对expr的型别和ParamType的型别执行模式匹配，来决定T的型别 （2）ParamType是个万能引用 i）如果expr是个左值，T和ParamType都会被推导为左值引用。这个结果具有双重的奇特之处：首先，这是在模板型别推导中，T被推导为引用型别的唯一情形。其次，尽管在声明时使用的是右值引用的语法，它的型别推导结果却是左值引用。","text":"[TOC] 一、型别推导条款1：理解模板型别推导12template&lt;typename T&gt;void f(ParamType param); 1、T的型别推导结果，不仅仅依赖expr的型别，还依赖ParamType的形式，具体分三种情况讨论（1）ParamType是个指针或引用，但不是万能引用 i）若expr具有引用型别，先将引用部分忽略。 ii）尔后，对expr的型别和ParamType的型别执行模式匹配，来决定T的型别 （2）ParamType是个万能引用 i）如果expr是个左值，T和ParamType都会被推导为左值引用。这个结果具有双重的奇特之处：首先，这是在模板型别推导中，T被推导为引用型别的唯一情形。其次，尽管在声明时使用的是右值引用的语法，它的型别推导结果却是左值引用。 ii）如果expr是个右值，则应用“常规”（即情况1中的）规则。 （3）ParamType既非指针也非引用 i）一如之前，若expr具有引用型别，则忽略其引用部分。 ii）忽略expr的引用性后，若expr是个cv（const and volatile）对象，也忽略之（volatile对象不常用，一般仅用于实现设备驱动程序）。 2、数组实参和函数实参数组参数在c++中可以退化为指针进行传参，所以补充对数组参数的类型推导。针对数组型别推导的一切讨论都适用于函数及其向函数指针的退化。 当PT为传值类型（就是T）时，推导为退化的指针类型； 当PT为引用类型（T&amp;），推导为带有数组大小的明确的数组类型（如const char[13]）； 123456789//数组参数 const char name[] = \"C++11\"; #template&lt;typename T&gt;void f(T param);f(name); //PT为 const char[6]由指针退化规则退化为const char*,T被推导为const char* #template&lt;typename T&gt;void f(T&amp; param);f(name); //PT为const char (&amp;)[6], T被推导为const char[6] 利用数组引用这一能力创造出一个模板，用来推导出数组含有的元素个数： 123456template&lt;typename T,std::size_t&gt;constexpr std::size_t arraySize(T (&amp;)[N]) noexcept&#123; return N;&#125;int keyVals[]=&#123;1,2,3,4,5,6,7&#125;;int mappedVals[arraySize(keyVals)]; //mappedVals被指定与keyVals尺寸相同 将函数声明为constexpr，能够使得其返回值在编译期就可用，相对于内建数组，优选std::array: 1std::array&lt;int,arraySize(keyVals)&gt; mappedVals; 在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用。12345678910void someFunc(int,double);template&lt;typename T&gt;void f1(T param);template&lt;typename T&gt;void f2(T&amp; param);f1(someFunc);//param被推导为函数指针，void (*)(int,double)f2(someFunc);//param被推导为函数引用，void (&amp;)(int,double) 条款2：理解auto型别推导1、一般情况下，auto型别推导和模板型别推导一模一样，但auto型别推导会假定用大括号括起来的初始化表达式代表一个std::initializer_list，模板型别推导则不能。2、在函数返回值或lambda表达式的形参中使用auto，意思是使用模板型别推导而非auto型别推导。三、转向现代C++条款14：只要函数不会发射异常，就为其加上noexcept声明1、noexcept声明时函数接口的组成部分，这意味着调用方可能会对它有依赖。2、相对于不带noexcept声明的函数，带有noexcept声明的函数有更多机会得到优化。3、noexcept性质对于移动操作、swap、内存释放函数和析构函数最有价值。4、大多数函数都是异常中立的，不具备noexcept性质。条款15：只要有可能使用constexpr，就使用它1、constexpr对象都具有const属性，并由编译期已知的值完成初始化。2、constexpr函数在调用时若传入的实参值时编译期已知的，则会产出编译期结果。3、比起非constexpr对象或constexpr函数而言，constexpr对象或是constexpr函数可以用在一个作用域更广的语境中。条款16：保证const成员函数的线程安全性1、保证const成员函数的线程安全性，除非可以确信它们不会用在并发语境中。2、运用std::atomic型别的变量会比运用互斥量提供更好的性能，但前者仅适用对单个变量或内存区域的操作。","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"effective","slug":"effective","permalink":"http://yoursite.com/tags/effective/"}]},{"title":"more effective c++","slug":"more-effective-c","date":"2020-05-21T09:26:49.000Z","updated":"2020-05-22T06:37:18.408Z","comments":true,"path":"2020/05/21/more-effective-c/","link":"","permalink":"http://yoursite.com/2020/05/21/more-effective-c/","excerpt":"[TOC] 一、基础议题：pointers、references、casts、arrays、constructors条款1：仔细区分pointers和references 指针和引用的区别： （1）引用是别名，创建的同时必须被初始化，一旦被初始化就不能改变引用关系，不能为NULL；指针是变量，独立可变可空 （2）引用是间接寻址；指针是直接寻址 （3）引用有类型检查；指针无类型检查","text":"[TOC] 一、基础议题：pointers、references、casts、arrays、constructors条款1：仔细区分pointers和references 指针和引用的区别： （1）引用是别名，创建的同时必须被初始化，一旦被初始化就不能改变引用关系，不能为NULL；指针是变量，独立可变可空 （2）引用是间接寻址；指针是直接寻址 （3）引用有类型检查；指针无类型检查 总结 当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由pointers达成（例如operator [ ]特别地必须返回某种“能够被当做assignment赋值对象”的东西），你就应该选择references。任何其他时候，请采用pointers。 条款2：最好使用c++转型操作符reinterpret_cast最常用用途是转换“函数指针”类型。 条款3：绝对不要以多态（polymorphically）方式处理数组多态（polymorphism）和指针算术不能混用。数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用。 条款4：非必要不提供default constructor二、操作符条款5：对定制的“类型转换函数”保持警觉两种函数允许编译器执行隐式类型转换：单自变量constructors和隐式类型转换操作符。 尽量避免使用类型转换操作符。 阻止编译器不分青红皂白地调用constructors进行隐式类型转换：（1）explicit关键字（2）类内定义使用代理类(proxy classes) 条款6：区别increment/decrement操作符的前置（prefix）和后置（postfix）形式++和–操作符的前置式返回一个reference，后置式返回一个const对象。increment的前置式意义“increment and fetch”（累加然后取出），后置式意义“fetch and increment”（取出后累加）。 条款7：千万不要重载&amp;&amp; ，|| 和 ，操作符重载&amp;&amp;和||会破坏c++对于“真假表达式”采用的所谓的“骤死式”评估方式。 c++采用同样地规则用来定义逗号操作符面对内建类型的行为。 不能重载的操作符： 12. .* :: ?: new delete sizeof typeidstatic_cast dynamic_cast const_cast reinterpret_cast 条款8：了解各种不同意义的new和deleteC++中的new/delete与operator new/operator deletenew operator/delete operator就是new和delete操作符，而operator new/operator delete是函数。 new operator（1）调用operator new分配足够的空间，并调用相关对象的构造函数 （2）不可以被重载 （3）返回相应指针 operator new（1）只分配所要求的空间，不调用相关对象的构造函数。当无法满足所要求分配的空间时，则 -&gt;如果有new_handler，则调用new_handler，否则 -&gt;如果没要求不抛出异常（以nothrow参数表达），则执行bad_alloc异常，否则 -&gt;返回0（2）可以被重载（3）重载时，返回类型必须声明为void*（4）重载时，第一个参数类型必须为表达要求分配空间的大小（字节），类型为size_t（5）重载时，可以带其它参数 delete 与 delete operator类似 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class X&#123;public: X() &#123; cout&lt;&lt;\"constructor of X\"&lt;&lt;endl; &#125; ~X() &#123; cout&lt;&lt;\"destructor of X\"&lt;&lt;endl;&#125; void* operator new(size_t size,string str) &#123; cout&lt;&lt;\"operator new size \"&lt;&lt;size&lt;&lt;\" with string \"&lt;&lt;str&lt;&lt;endl; return ::operator new(size); &#125; void operator delete(void* pointee) &#123; cout&lt;&lt;\"operator delete\"&lt;&lt;endl; ::operator delete(pointee); &#125;private: int num;&#125;;int main()&#123; X *px = new(\"A new class\") X;//new operator delete px;//delete operator return 0;&#125; X* px = new X; //该行代码中的new为new operator，它将调用类X中的operator new，为该类的对象分配空间，然后调用当前实例的构造函数。delete px; //该行代码中的delete为delete operator，它将调用该实例的析构函数，然后调用类X中的operator delete，以释放该实例占用的空间。 new operator与delete operator的行为是不能够也不应该被改变，这是C++标准作出的承诺。而operator new与operator delete和C语言中的malloc与free对应，只负责分配及释放空间。但使用operator new分配的空间必须使用operator delete来释放，而不能使用free，因为它们对内存使用的登记方式不同。反过来亦是一样。你可以重载operator new和operator delete以实现对内存管理的不同要求，但你不能重载new operator或delete operator以改变它们的行为。 为什么有必要写自己的operator new和operator delete？答案通常是：为了效率。缺省的operator new和operator delete具有非常好的通用性，它的这种灵活性也使得在某些特定的场合下，可以进一步改善它的性能。尤其在那些需要动态分配大量的但很小的对象的应用程序里，情况更是如此。具体可参考《Effective C++》中的第二章内存管理。 Placement newplacement new 是重载operator new 的一个标准、全局的版本，它不能够被自定义的版本代替（不像普通版本的operator new和operator delete能够被替换）。 12//返回类型为void*void *operator new( size_t, void * p ) throw() &#123; return p; &#125; placement new的执行忽略了size_t参数，只返还第二个参数。其结果是允许用户把一个对象放到一个特定的地方，达到调用构造函数的效果。和其他普通的new不同的是，它在括号里多了另外一个参数。比如： 12Widget * p = new Widget; //ordinary newpi = new (ptr) int; //placement new 括号里的参数ptr是一个指针，它指向一个内存缓冲器，placement new将在这个缓冲器上分配一个对象。Placement new的返回值是这个被构造对象的地址(比如括号中的传递参数)。placement new主要适用于：在对时间要求非常高的应用程序中，因为这些程序分配的时间是确定的；长时间运行而不被打断的程序；以及执行一个垃圾收集器 (garbage collector)。 new 、operator new 和 placement new 区别（1）new ：不能被重载，其行为总是一致的。它先调用operator new分配内存，然后调用构造函数初始化那段内存。 new 操作符的执行过程： 调用operator new分配内存 ； 调用构造函数生成类对象； 返回相应指针。 （2）operator new：要实现不同的内存分配行为，应该重载operator new，而不是new。 operator new就像operator + 一样，是可以重载的。如果类中没有重载operator new，那么调用的就是全局的::operator new来完成堆的分配。同理，operator new[]、operator delete、operator delete[]也是可以重载的。 （3）placement new：只是operator new重载的一个版本。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此不能删除它，但需要调用对象的析构函数。 如果你想在已经分配的内存中创建一个对象，使用new时行不通的。也就是说placement new允许你在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中void* p实际上就是指向一个已经分配好的内存缓冲区的的首地址。 Placement new 存在的理由 1.用placement new 解决buffer的问题 问题描述：用new分配的数组缓冲时，由于调用了默认构造函数，因此执行效率上不佳。若没有默认构造函数则会发生编译时错误。如果你想在预分配的内存上创建对象，用缺省的new操作符是行不通的。要解决这个问题，你可以用placement new构造。它允许你构造一个新对象到预分配的内存上。 2.增大时空效率的问题 使用new操作符分配内存需要在堆中查找足够大的剩余空间，显然这个操作速度是很慢的，而且有可能出现无法分配内存的异常（空间不够）。placement new就可以解决这个问题。我们构造对象都是在一个预先准备好了的内存缓冲区中进行，不需要查找内存，内存分配的时间是常数；而且不会出现在程序运行中途出现内存不足的异常。所以，placement new非常适合那些对时间要求比较高，长时间运行不希望被打断的应用程序。 Placement new使用步骤 在很多情况下，placement new的使用方法和其他普通的new有所不同。这里提供了它的使用步骤。 第一步 缓存提前分配，三种缓存分配方式 为了保证通过placement new使用的缓存区的memory alignment(内存队列)正确准备，使用普通的new来分配它：在堆上进行分配class Task ;char * buff = new [sizeof(Task)]; //分配内存(请注意auto或者static内存并非都正确地为每一个对象类型排列，所以，你将不能以placement new使用它们。) 在栈上进行分配class Task ;char buf[N*sizeof(Task)]; //分配内存 还有一种方式，就是直接通过地址来使用。(必须是有意义的地址)void* buf = reinterpret_cast&lt;void*&gt; (0xF00F); 第二步：对象的分配 在刚才已分配的缓存区调用placement new来构造一个对象。Task *ptask = new (buf) Task 第三步：使用 按照普通方式使用分配的对象： ptask-&gt;memberfunction(); ptask-&gt; member; //… 第四步：对象的析构 一旦你使用完这个对象，你必须调用它的析构函数来毁灭它。按照下面的方式调用析构函数：ptask-&gt;~Task(); //调用外在的析构函数 第五步：释放内存空间 你可以反复利用缓存并给它分配一个新的对象（重复步骤2，3，4），如果你不打算再次使用这个缓存，你可以像这样释放它：delete [] buf; 跳过任何步骤就可能导致运行时间的崩溃，内存泄露，以及其它的意想不到的情况。如果你确实需要使用placement new，请认真遵循以上的步骤。 三、异常条款9：利用destructors避免泄漏资源RAII 智能指针 条款10：在constructors内阻止资源泄露RAII 智能指针 条款11：禁止异常（exceptions）流出destructors之外（1）避免terminate函数在exception传播过程的栈展开（stack-unwinding）机制中被调用 （2）协助确保destructors完成其应该完成的所有事情 条款12：了解”抛出一个exception”与”传递一个参数”或”调用一个虚函数”之间的差异传递给函数参数的对象不一定得复制；exception objects总是会被复制，如果以by value方式捕获，它们甚至被复制两次。 虚函数：最佳吻合；exception：最先吻合。","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"effective","slug":"effective","permalink":"http://yoursite.com/tags/effective/"}]},{"title":"effectiveC++","slug":"effectiveC","date":"2020-04-22T05:16:45.000Z","updated":"2020-07-07T14:07:59.706Z","comments":true,"path":"2020/04/22/effectiveC/","link":"","permalink":"http://yoursite.com/2020/04/22/effectiveC/","excerpt":"[TOC] 一、让自己习惯C++条款01: 视C++为一个语言联邦条款02：尽量以const,enums,and inlines to #defines条款03：尽可能使用const条款04：确定对象使用前已先被初始化 如果内置类型（初始化与赋值成本相同）的变量未被显示地初始化，它的值将由定义的位置决定。 （1）定义在函数体之外的变量将被初始化为0。","text":"[TOC] 一、让自己习惯C++条款01: 视C++为一个语言联邦条款02：尽量以const,enums,and inlines to #defines条款03：尽可能使用const条款04：确定对象使用前已先被初始化 如果内置类型（初始化与赋值成本相同）的变量未被显示地初始化，它的值将由定义的位置决定。 （1）定义在函数体之外的变量将被初始化为0。 （2）定义在函数体内部的变量将不被初始化，它的值是任意的。 对于无任何成员的内置类型，手工初始化；内置类型以外，确保每一个构造函数都将对象的每一个成员在成员初始列进行初始化。 为免除“跨编译单元值初始化次序”问题，以local static对象替代non-local static对象。 二、构造/析构/赋值运算条款05：了解c++默默编写并调用哪些函数四、设计与声明条款27：尽量减少转型动作const_cast/dynamic_cast/reinterpret_cast/static_cast详解const_cast：移除cv限定const_cast运算符用来修改类型的const(唯一有此能力的C++-style转型操作符)或volatile属性。 ①常量指针被转化成非常量的指针，并且仍然指向原来的对象； ②常量引用被转换成非常量的引用，并且仍然指向原来的对象； ③const_cast一般用于修改底层指针。如const char *p形式。 dynamic_cast:进行有检查的多态转换转换方式：dynamic_cast&lt; type* &gt;(e) type必须是一个类类型-&gt;type*有效的指针dynamic_cast&lt; type&amp; &gt;(e)type必须是一个类类型-&gt;type&amp;左值dynamic_cast&lt; type&amp;&amp; &gt;(e)type必须是一个类类型-&gt;type&amp;&amp;右值 e的类型必须符合以下三个条件中的任何一个：1、e的类型是目标类型type的公有派生类2、e的类型是目标type的公有基类3、e的类型就是目标type的类型。 如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个std::bad_cast异常(该异常定义在typeinfo标准库头文件中)。e也可以是一个空指针，结果是所需类型的空指针。 dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换（cross cast）。 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。dynamic_cast是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。 reinterpret_cast：通过重新解释底层位模式在类型间转换12345678910111213#include &lt;iostream&gt;using namespace std;int main(int argc, char** argv)&#123; int num = 0x00636261;//用16进制表示32位int，0x61是字符'a'的ASCII码 int * pnum = &amp;num; char * pstr = reinterpret_cast&lt;char *&gt;(pnum); cout&lt;&lt;\"pnum指针的值: \"&lt;&lt;pnum&lt;&lt;endl;//0x7ffcfa7e861c cout&lt;&lt;\"pstr指针的值: \"&lt;&lt;static_cast&lt;void *&gt;(pstr)&lt;&lt;endl;//0x7ffcfa7e861c 直接输出pstr会输出其指向的字符串，这里的类型转换是为了保证输出pstr的值 cout&lt;&lt;\"pnum指向的内容: \"&lt;&lt;hex&lt;&lt;*pnum&lt;&lt;endl;//636261 cout&lt;&lt;\"pstr指向的内容: \"&lt;&lt;pstr&lt;&lt;endl;//abc return 0;&#125; 定义了一个整型变量num，并初始化为0x00636261（十六进制表示），然后取num的地址用来初始化整型指针变量pnum。接着到了关键的地方，使用reinterpret_cast运算符把pnum从int转变成char类型并用于初始化pstr。 将pnum和pstr两个指针的值输出，对比发现，两个指针的值是完全相同的，这是因为“reinterpret_cast 运算符并不会改变括号中运算对象的值，而是对该对象从位模式上进行重新解释”。 使用reinterpret_cast运算符把pnum从int转变成char类型并用于初始化pstr后，pstr也指向num的内存区域，但是由于pstr是char类型的，通过pstr读写num内存区域将不再按照整型变量的规则，而是按照char型变量规则。一个char型变量占用一个Byte，对pstr解引用得到的将是一个字符，也就是’a’。而在使用输出流输出pstr时，将输出pstr指向的内存区域的字符，那pstr指向的是一个的字符，那为什么输出三个字符呢？这是由于在输出char指针时，输出流会把它当做输出一个字符串来处理，直至遇到’\\0’才表示字符串结束。对代码稍做改动，就会得到不一样的输出结果，例如将num的值改为0x63006261,输出的字符串就变为”ab”。 static_cast：进行基本转换static_cast&lt; new_type &gt;(expression) static_cast相当于传统的C语言里的强制转换，该运算符把expression转换为new_type类型，用来强迫隐式转换如non-const对象转为const对象，编译时检查，用于非多态的转换，可以转换指针及其他，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法： ①用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。②用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。③把空指针转换成目标类型的空指针。④把任何类型的表达式转换成void类型。注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性 c++强制转换注意事项 新式转换较旧式转换更受欢迎。原因有二，一是新式转型较易辨别，能简化“找出类型系统在哪个地方被破坏”的过程；二是各转型动作的目标愈窄化，编译器愈能诊断出错误的运用。 尽量少使用转型操作，尤其是dynamic_cast，耗时较高，会导致性能的下降，尽量使用其他方法替代。 五、实现条款30：透彻了解inline的里里外外inline免除函数调用成本；编译器最优化机制通常被设计用来浓缩那些”不含函数调用”的代码，对函数本体执行预警相关最优化。 将大多数inlining限制在小型、被频繁调用的函数身上。inline在大多数c++程序中是编译期行为，将“对函数的每一个调用”都以函数本体替换之。如果inline函数的本体很小，编译器针对“函数本体”所产出的码可能比针对“函数调用”所产出的码更小，inlining可能导致较小的目标码和较高的指令高速缓存装置集中率；过度热衷inlining会造成程序体积太大（对可用空间而言）。即使拥有虚内存，inline造成的代码膨胀亦会导致额外的换页行为（paging），降低指令高速缓存装置的集中率（instruction cache hit rate），以及伴随这些而来的效率损失。 不要只因为funtiong templates出现在头文件，就将它们申明为inline。如果你写的template没有理由要求它所具现化的每一个函数都是inlined，就应该避免将这个template声明为inline(不论显式或隐式)。 inline是个申请，编译器可以加以忽略。编译器通常不对“通过函数指针而进行的调用”实施inlining。 构造函数和析构函数往往是inlining的糟糕候选人。 inline函数无法随着程序库的升级而升级。换句话说如果f是程序库内的一个inline函数，客户将“f函数本体”编进程序中，一旦程序库设计者决定改变f，所有用到f的客户端程序都必须重新编译。然而如果f是non-inline函数，一旦它有任何修改，客户端只需要重新连接就好，远比重新编译的负担少很多。如果程序库采取动态连接，升级版函数甚至可以不知不觉的被应用程序吸纳。","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"effective","slug":"effective","permalink":"http://yoursite.com/tags/effective/"}]},{"title":"日常常用技巧","slug":"日常常用技巧","date":"2020-03-27T06:11:04.000Z","updated":"2020-03-27T06:26:06.780Z","comments":true,"path":"2020/03/27/日常常用技巧/","link":"","permalink":"http://yoursite.com/2020/03/27/%E6%97%A5%E5%B8%B8%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"1、windows+chrome长截屏 原生长截屏 123Fn+F12Ctrl+Shift+p搜索capture full size screenshot","text":"1、windows+chrome长截屏 原生长截屏 123Fn+F12Ctrl+Shift+p搜索capture full size screenshot 安装插件Fireshot","categories":[{"name":"常用技巧","slug":"常用技巧","permalink":"http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"},{"name":"截屏","slug":"截屏","permalink":"http://yoursite.com/tags/%E6%88%AA%E5%B1%8F/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"高效算法","slug":"高效算法","date":"2020-03-25T16:51:01.000Z","updated":"2020-05-10T15:53:54.504Z","comments":true,"path":"2020/03/26/高效算法/","link":"","permalink":"http://yoursite.com/2020/03/26/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95/","excerpt":"（一）素数筛 素数的性质： 定义：一个大于1的自然数，除了1和它本身以外，不能被任何自然数整除。所以2是最小的素数，0和1不是质数也不是合数。 任意一个合数都可以表示几个质数的乘积-&gt;任意一个合数都可以表示成一个质数和另一个数的乘积 一个合数和一个质数的乘积=一个更大的合数和一个更小的质数的乘积","text":"（一）素数筛 素数的性质： 定义：一个大于1的自然数，除了1和它本身以外，不能被任何自然数整除。所以2是最小的素数，0和1不是质数也不是合数。 任意一个合数都可以表示几个质数的乘积-&gt;任意一个合数都可以表示成一个质数和另一个数的乘积 一个合数和一个质数的乘积=一个更大的合数和一个更小的质数的乘积 知识点扩展：判断互质数的五种方法 概念判断法。公约数只有1的两个数叫做互质数。根据互质数的概念可以对一组数是否互质进行判断。如：9和11的公约数只有1，则它们是互质数。 规律判断法。根据互质数的定义，可总结出一些规律，利用这些规律能迅速判断一组数是否互质。 （1）两个不相同的质数一定是互质数。如：7和11、17和31是互质数。 （2）两个连续的自然数一定是互质数。如：4和5、13和14是互质数。 （3）相邻的两个奇数一定是互质数。如：5和7、75和77是互质数。 （4）1和其他所有的自然数一定是互质数。如：1和4、1和13是互质数。 （5）两个数中的较大一个是质数，这两个数一定是互质数。如：3和19、16和97是互质数。 （6）两个数中的较小一个是质数，而较大数是合数且不是较小数的倍数，这两个数一定是互质数。如：2和15、7和54是互质数。 （7）较大数比较小数的2倍多1或少1，这两个数一定是互质数。如：13和27、13和25是互质数。 分解判断法。如果两个数都是合数，可先将两个数分别分解质因数，再看两个数是否含有相同的质因数。如果没有，这两个数是互质数。如：130和231，先将它们分解质因数：130＝2×5×13，231＝3×7×11。分解后，发现它们没有相同的质因数，则130和231是互质数。 求差判断法。如果两个数相差不大，可先求出它们的差，再看差与其中较小数是否互质。如果互质，则原来两个数一定是互质数。如：194和201，先求出它们的差，201－194＝7，因7和194互质，则194和201是互质数。 求商判断法用大数除以小数，如果除得的余数与其中较小数互质，则原来两个数是互质数。如：317和52，317÷52＝6……5，因余数5与52互质，则317和52是互质数。 实现 123456789101112131415161718192021222324252627282930313233//普通筛-埃拉托斯特尼sieve of Eratosthenes 时间复杂度O(nlogn)#include &lt;vector&gt;auto eratosthenes(int upperbound)&#123; std::vector&lt;bool&gt; flag(upperbound+1, true); flag[0]=flag[1]=false; //exclude 0 and 1 //二次筛选法:i是素数，则下一个起点是i*i(比i小的数在前面已经乘过i了),把后面的所有的i*i+2*n*i筛掉 for(int i=2; i&lt;=sqrt(upperbound); ++i) if(flag[i]) // if i is prime number for(int j=i*i; j&lt;=upperbound; j+=i) flag[j] = false; return flag;&#125;//线性筛-欧拉筛//prime数组中的素数是递增的,当i能整除prime[j]，那么i*prime[j+1]这个合数肯定被prime[j]乘以某个数筛掉。因为i中含有prime[j],prime[j]比prime[j+1]小，即i=k*prime[j]，那么i*prime[j+1]=(k*prime[j])*prime[j+1]=k’*prime[j]，接下去的素数同理。所以不用筛下去了。因此，在满足i%prime[j]==0这个条件之前以及第一次满足该条件时,prime[j]必定是prime[j]*i的最小因子#include &lt;vector&gt;auto eratosthenes(int upperbound)&#123; std::vector&lt;bool&gt; flag(upperbound+1, true); std::vector&lt;bool&gt; prime; flag[0]=flag[1]=false; //exclude 0 and 1 for(int i=2;i&lt;upperbound;i++)&#123; if(flag[i]) prime.emplace_back(i); for(int j=0;j&lt;primer.size()&amp;&amp;prime[j]*i&lt;=upperbound;j++)&#123; flag[prime[j]*i]=false; if(i%prime[j]==0)//保证每个合数只会被它的最小质因数筛去，因此每个数只会被标记一次 break; &#125; &#125; return prime;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"素数筛","slug":"素数筛","permalink":"http://yoursite.com/tags/%E7%B4%A0%E6%95%B0%E7%AD%9B/"}]},{"title":"Linux安装Qt/Clion编译Boost/Opencv","slug":"Linux安装Qt-Clion编译Boost-Opencv","date":"2020-03-25T16:35:36.000Z","updated":"2020-03-25T16:59:55.697Z","comments":true,"path":"2020/03/26/Linux安装Qt-Clion编译Boost-Opencv/","link":"","permalink":"http://yoursite.com/2020/03/26/Linux%E5%AE%89%E8%A3%85Qt-Clion%E7%BC%96%E8%AF%91Boost-Opencv/","excerpt":"（一）qt 安装: 首先从Qt官网上下载安装包，下载网址 给.run文件添加执行权限 1sudo chmod +x qt-opensource-linux-x64-5.12.0.run","text":"（一）qt 安装: 首先从Qt官网上下载安装包，下载网址 给.run文件添加执行权限 1sudo chmod +x qt-opensource-linux-x64-5.12.0.run 执行.run进行qt的安装 1sudo ./qt-opensource-linux-x64-5.12.0.run (二)clion安装: 官网下载 解压 1tar -zxvf CLion-2016.2.2.tar.gz 运行脚本 12cd clion-2016.2.2/bin/ ./clion.sh (三)boost编译: 官网下载压缩包.tar.gz tar -xvf boost(tab) cd boost_1_71_0 chmod 777 bootstrap.sh ./bootstrap.sh --with-libraries=all --with-toolset=gcc 指定编译boost的哪些库,all是全编译,只想编译部分库的话就把库名写上用逗号分隔开(在这步之前保证gcc g++至少为version 7),编译器用gcc 提示:to build,run:./b2 sudo ./b2 install 编译大约十分钟，提示…failed updating 60… (四)opencv编译： 到官网下载opencv4.1.0点击此处，选择source进行下载(opencv4.1.2会出错) 解压缩包unzip opencv-4.1.0.zip 对解压的文件夹进行重命名mv opencv-4.1.0 opencv sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev cd ~/opencv mkdir build cd build cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. make -j n # n为你的CPU线程数（几核就填几，电脑能力范围内的最大值） sudo make install","categories":[{"name":"安装编译","slug":"安装编译","permalink":"http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"Clion","slug":"Clion","permalink":"http://yoursite.com/tags/Clion/"},{"name":"Boost","slug":"Boost","permalink":"http://yoursite.com/tags/Boost/"},{"name":"Opencv","slug":"Opencv","permalink":"http://yoursite.com/tags/Opencv/"}]},{"title":"操作系统","slug":"操作系统","date":"2020-03-25T16:23:38.000Z","updated":"2020-08-26T15:21:26.544Z","comments":true,"path":"2020/03/26/操作系统/","link":"","permalink":"http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"Linux系统结构详解1. Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。 用户空间 / 内核空间 现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。 操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。","text":"Linux系统结构详解1. Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。 用户空间 / 内核空间 现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。 操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。 内核是操作系统的核心，具有很多最基本功能，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。Linux 内核主要由内存管理、进程管理、设备驱动程序、文件系统和网络管理等组成。 由于操作系统都包括内核空间和用户空间（或者说内核态和用户态），内核空间主要存放的是内核代码和数据，是供系统进程使用的空间。而用户空间主要存放的是用户代码和数据，是供用户进程使用的空间。目前Linux系统简化了分段机制，使得虚拟地址与线性地址总是保持一致，因此，Linux系统的虚拟地址也是0~4G。Linux系统将这4G空间分为了两个部分：将最高的1G空间（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，即为“内核空间”，而将较低的3G空间（从虚拟地址 0x00000000到0xBFFFFFFF）供用户进程使用，即为“用户空间”。同时由于每个用户进程都可以通过系统调用进入到内核空间，因此Linux的内核空间可以认为是被所有用户进程所共享的，因此对于一个具体用户进程来说，它可以访问的虚拟内存地址就是0~4G。另外Linux系统分为了四种特权级：0～3，主要是用来保护资源。0级特权最高，而3级则为最低，系统进程主要运行在0级，用户进程主要运行在3级。 用户空间对应进程，所以每当进程切换，用户空间就会跟着变化；而内核空间是由内核负责映射，它并不会跟着进程改变，是固定的。内核空间地址有自己对应的页表（init_mm.pgd），用户进程各自有不同的页表。每个进程的用户空间都是完全独立、互不相干的。 进程管理 进程实际是某特定应用程序的一个运行实体。在 Linux 系统中，能够同时运行多个进程，Linux 通过在短的时间间隔内轮流运行这些进程而实现“多任务”。这一短的时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度” ，完成调度的程序称为调度程序。 进程调度控制进程对CPU的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待CPU资源的进程，如果某个进程在等待其它资源，则该进程是不可运行进程。Linux使用了比较简单的基于优先级的进程调度算法选择新的进程。 通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且只能由这一进程访问，这样，操作系统避免了进程之间的互相干扰以及“坏”程序对系统可能造成的危害。 为了完成某特定任务，有时需要综合两个程序的功能，例如一个程序输出文本，而另一个程序对文本进行排序。为此，操作系统还提供进程间的通讯机制来帮助完成这样的任务。Linux 中常见的进程间通讯机制有信号、管道、共享内存、信号量和套接字等。 内核通过系统调用接口（SCI） 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSⅨ] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSⅨ 机制）。 为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的，并且进程切换是非常耗费资源的。 进程阻塞 正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得了CPU资源），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。 文件描述符 文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。 缓存I/O 缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。 2. 内存管理对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的物理内存满足应用程序对内存的大需求量，Linux 采用了称为“虚拟内存”的内存管理方式。Linux 将内存划分为容易处理的“内存页”（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。 不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。 为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。 虚拟内存管理虚拟内存技术实际上就是建立了“内存—-外存”的两级存储结构，利用局部性原理实现高速缓存。 虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还可以通过覆盖或者把处于不活动状态的程序以及它们的数据全部交换到外部磁盘存储器上临时存储。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。 进程由不同长度的段组成：代码段、动态库的代码、全局变量和动态产生数据的堆、栈等，在Linux中为每个进程管理了一套虚拟地址空间： 在我们写代码malloc完以后，并没有马上占用那么大的物理内存，而仅仅是维护上面的虚拟地址空间而已，只有在真正需要的时候才分配物理内存，这就是COW（COPY-ON-WRITE:写时复制）技术，而物理分配的过程就是最复杂的缺页异常处理环节。对于32位的Linux操作系统，系统为每个进程分配4G的虚拟内存。 虚拟内存中，允许将一个作业分多次调入内存。釆用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式： 请求分页存储管理。 请求分段存储管理。 请求段页式存储管理。 不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面： 一定容量的内存和外存。 页表机制（或段表机制）：作为主要的数据结构。 中断机制：当用户程序要访问的部分尚未调入内存，则产生中断。 地址变换机制：逻辑地址到物理地址的变换。{ 页面置换算法： ​ 1）最佳置换算法 OPT ​ 2）最近最久未使用算法 LRU ​ 3）先进先出算法 FIFO ​ 4）始终（CLOCK）置换算法 } 地址映射在Linux内部的地址的映射过程为逻辑地址–&gt;线性地址–&gt;物理地址，物理地址最简单：地址总线中传输的数字信号，而线性地址和逻辑地址所表示的则是一种转换规则，线性地址规则如下： 这部分由MMU完成，其中涉及到主要的寄存器有CR0、CR3。机器指令中出现的是逻辑地址，逻辑地址规则如下： 在Linux中的逻辑地址等于线性地址，也就是说Inter为了兼容把事情搞得很复杂，Linux简化顺便偷个懒。 程序内存区域分配 一个程序本质上都是由 bss段、data段、text段三个组成的。bss段通常是指用来存放程序中静态变量和未初始化的全局变量一块内存区域，一般在初始化时bss 段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。比如，在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，静态变量和未初始化的全局变量保存在.bss 段中。text和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化。bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小；bss段的大小从可执行文件中得到 ，然后链接器得到这个大小的内存块，紧跟在数据段后面。data段（已手动初始化的数据）则为数据分配空间，数据保存在目标文件中；data段包含经过初始化的全局变量以及它们的值。当这个内存区进入程序的地址空间后全部清零。包含data段和bss段的整个区段此时通常称为数据区。 同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。 物理内存管理Linux内核管理物理内存是通过分页机制实现的，它将整个内存划分成无数个4k（在i386体系结构中）大小的页，从而分配和回收内存的基本单位便是内存页了。利用分页管理有助于灵活分配内存地址，因为分配时不必要求必须有大块的连续内存，系统可以东一页、西一页的凑出所需要的内存供进程使用。虽然如此，但是实际上系统使用内存时还是倾向于分配连续的内存块，因为分配连续内存时，页表不需要更改，因此能降低TLB的刷新率（频繁刷新会在很大程度上降低访问速度）。物理内存的使用主要分为以下几个方面： （1）内核使用 操作系统启动时，位于/boot目录下的压缩内核文件会被加载到内存中并解压。这部分内容在系统允许期间都会常驻在内存的起始位置。 （2）slab分配器 操作系统的运行还需要更多的空间来分配给管理进程、文件描述符、socket和加载的内和模块等内容。所以内核会通过slab分配器动态分配内存。 ​ PS：slab是Linux操作系统的一种内存分配机制。其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用brk系统调用来进行分配和释放，不仅会造成大量的碎片，而且也会影响性能。而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给操作系统，从而避免这些出现内存碎片。slab分配器并不丢弃已分配的对象，而是释放并把它们保存在内存中。当以后又要请求新的对象时，就可以从内存直接获取而不用重复初始化。可以在/proc/meminfo中查看当前slab分配器中的内存大小。 （3）进程使用 除去内核使用的部分，所有的进程都需要分配物理内存页给它们的代码、数据和堆栈。进程消耗的这些物理内存被称为“驻留内存”，RSS。 （4）页缓存page cache ​ 除去在内核和进程使用的部分，物理内存剩下的部分被称为页缓存，page cache。因为磁盘io的速度远远低于内存的访问速度，所以为了加快访问磁盘数据的速度，页缓存尽可能的保存着从磁盘读入的数据。page cache中还有一部分称为buffer，它的作用是缓存要写入到磁盘的数据。 ​ 页缓存的大小是在一直动态变化的。当系统内存充足时，页缓存会一直增大；当系统free内存不足时，这时如果有进程申请内存，操作系统会从page cache中回收内存页进行分配，如果page cache也已不足，那么系统会将当期驻留在内存中的数据置换到事先配置在磁盘上的swap空间中，然后空出来的这部分内存就可以用来分配了。这就是swap交换。 ​ PS：出现swap交换时，数据被置换到swap空间后(swap out)，该进程使用的内存量下降，在atop等监控工具中的RGROW列为负值，但这并不表示该进程释放了内存，当它需要时，这部分数据又会被换入到内存中(swap in)。另外， swap交换往往会带来磁盘IO的大量消耗，严重影响到系统正常的磁盘io。出现大量的swap交换说明系统已经快要不行了，需要重点关注。 总结：系统内核为每个进程都维护了一份从虚拟内存到物理内存的映射表，称为页表。页表根据虚拟地址，查找出锁映射的物理页位置和数据在物理页中的偏移量，便得到了实际需要访问的物理地址。 进程在运行过程中，会加载许多操作系统的动态库，比如 libc.so、libld.so等。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。如途中进程1和进程2的共享内存段，实际都映射到同一块物理内存。注意，进程占用的共享内存也是计算到驻留内存中的。 3. 文件系统文件系统指文件存在的物理空间，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。一个操作系统的运行离不开对文件的操作，因此必然要拥有并维护自己的文件系统。 和 DOS 等操作系统不同，Linux 操作系统中单独的文件系统并不是由驱动器号或驱动器名称（如 A: 或 C: 等）来标识的。相反，和 UNIX 操作系统一样，Linux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。Linux 将新的文件系统通过一个称为“挂装”或“挂上”的操作将其挂装到某个目录上，从而让不同的文件系统结合成为一个整体。Linux 操作系统的一个重要特点是它支持许多不同类型的文件系统。Linux 中最普遍使用的文件系统是 Ext2，它也是 Linux 土生土长的文件系统。但 Linux 也能够支持 FAT、VFAT、FAT32、MINIX 等不同类型的文件系统，从而可以方便地和其它操作系统交换数据。由于 Linux 支持许多不同的文件系统，并且将它们组织成了一个统一的虚拟文件系统. 虚拟文件系统（VirtualFileSystem,VFS）:隐藏了各种硬件的具体细节，把文件系统操作和不同文件系统的具体实现细节分离了开来，为所有的设备提供了统一的接口，VFS提供了多达数十种不同的文件系统。虚拟文件系统可以分为逻辑文件系统和设备驱动程序。逻辑文件系统指Linux所支持的文件系统，如ext2,fat等，设备驱动程序指为每一种硬件控制器所编写的设备驱动程序模块。 虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层。即VFS 在用户和文件系统之间提供了一个交换层。 在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 ./linux/fs 中找到。 文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。 因此，用户和进程不需要知道文件所在的文件系统类型，而只需要象使用 Ext2 文件系统中的文件一样使用它们。 微软的DOS和windows也是采用树型结构，但是在DOS和 windows中这样的树型结构的根是磁盘分区的盘符，有几个分区就有几个树型结构，他们之间的关系是并列的。最顶部的是不同的磁盘（分区），如：C，D，E，F等。 但是在linux中，无论操作系统管理几个磁盘分区，这样的目录树只有一个。从结构上讲，各个磁盘分区上的树型目录不一定是并列的。 Linux文件存储结构：大部分的Linux文件系统（如ext2、ext3）规定，一个文件由目录项、inode和数据区组成。 目录项：包括文件名和inode节点号。inode：又称文件索引节点，包含文件的基础信息以及数据块的指针。数据块：包含文件的具体内容。 IO 和cache的区别Buffer（缓冲区）是系统两端处理速度平衡（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到流量整形的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。Cache（缓存）则是系统两端处理速度不匹配时的一种折衷策略。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。 常规文件系统操作（调用read/fread/write等类函数）中函数的调用过程VFS所隐含的主要思想在于引入了一个通用的文件模型（common file model)，这个模型能够表示所有支持的文件系统。linux内核对每个文件读写操作都必须使用一个指针，指向要访问的具体文件系统的适当函数。换句话说，当应用程序对read()或是write()调用引起内核调用相应的sys_read()或是sys_write()服务例程，文件在内核内存中是由一个file数据结构来表示的。这种数据结构中包含一个称为f_op的字段，该字段中包含一个指向专对某一个文件系统(如sysfs虚拟文件系统)的读写函数指针，sys_read()或是sys_write()查找到指向该函数的指针，并调用它。这样一来，应用程序的read()或是write()就被转化为相对间接的调用： file-&gt;f_op-&gt;read() 或 file-&gt;f_op-&gt;write() 参考 读文件1、进程调用库函数向内核发起读文件请求； 2、内核通过检查进程的文件描述符定位到虚拟文件系统VFS的已打开文件列表表项； 3、调用该文件可用的系统调用函数read() 3、read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode； 4、在inode中，通过文件内容偏移量计算出要读取的页； 5、通过inode找到文件对应的address_space； 6、在address_space中访问该文件的页缓存树，查找对应的页缓存结点： （1）如果页缓存命中，那么直接返回文件内容； （2）如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第6步查找页缓存； 7、文件内容读取成功。 写文件前5步和读文件一致，在address_space中查询对应页的页缓存是否存在： 6、如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。 7、如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。 8、一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘： （1）手动调用sync()或者fsync()系统调用把脏页写回 （2）pdflush进程会定时把脏页写回到磁盘 同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。 将磁盘上的数据缓存在内存中，加速文件的读写。实际上，在一般情况下，read/write是只跟缓存打交道的。read就直接从缓存读数据。如果要读的数据还不在缓存中，则触发一次读盘操作，然后等待磁盘上的数据被更新到磁盘高速缓存中；write也是直接写到缓存里去，然后就不用管了。后续内核会负责将数据写回磁盘。为了实现这样的缓存，每个文件的inode内嵌了一个address_space结构，通过inode-&gt;i_mapping来访问。address_space结构中维护了一棵radix树，用于磁盘高速缓存的内存页面就挂在这棵树上。而既然磁盘高速缓存是跟文件的inode关联上的，则打开这个文件的每个进程都共用同一份缓存。 文件描述符、打开文件描述符表、文件表、inode节点在内核中每一个打开的文件都需要由3种数据结构来进行维护： 1）每个进程对应一张打开文件描述符表，这是进程级数据结构，也就是每一个进程都各自有这样一个数据结构； 2）内核维持一张打开文件表，文件表由多个文件表项组成，这是系统级数据结构，也就是说这样的数据结构是针对于整个内核而言的，每个进程都可共享的； 3.每个打开的文件对应一个i节点（i-node）数据结构（Linux下只有i节点没有v节点），由于这是每一个打开的文件与之对应的，因此这也是一个系统级数据结构，存在于内核中，非进程所独有。 不同进程打开现存文件或新建文件时，内核会返回一个文件描述符（file descriptor），它是个非负整数。对于每一个进程，都会分配一个PCB数据结构，它其中包含了该进程的所有信息，而在代码实现上，这个数据结构名为task_struct， 在task_struct中，有一个成员变量名为files，这是一个描述打开文件信息的变量，其类型为struct files_struct。在所有进程的PCB（Process Control Block）中均会保存一份打开文件描述符表，实际上就是files_struct 中的成员struct file * fd_array[NR_OPEN_DEFAULT]它是一个指针数组，数组每一个元素都是一个指向file类型的指针，可想而知，这些指针都会指向一个打开的文件，并且file这一数据结构就是用来描述一个打开的文件的，而我们所说的文件描述符，实际上就是这个指针数组的索引。这也是为什么文件描述符是非负整数。文件描述符就是这个表的索引（数组下标），每个表项都有一个指向已打开文件的指针（数组的内容），具体是指向文件表中该文件对应的表格项。 在Linux系统中，已打开的文件形成打开文件表（open file table），存放在内核空间（系统级）中，并由系统里的所有进程共享。该表中每个表格保存了一个打开文件的全部信息，如下所示： 当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）； 打开文件时所使用的状态标识（即，open()的flags参数）；文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）； 与信号驱动相关的设置； 对该文件i-node对象的引用； 文件类型（例如：常规文件、套接字或FIFO）和访问权限； 一个指针，指向该文件所持有的锁列表； 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳； 文件表项的数据结构就是file结构体，而在实际上内核中也并不存在这样一张文件表，只是每个打开的文件都对应一个file结构体，也就是一个文件表项，打开文件描述符表struct file * fd_array[NR_OPEN_DEFAULT]数组中的每一项都会指向这样一个文件表项。 在file结构体中，不得不再说一下它的f_path成员，这是一个struct path类型的变量，该类型定义于include/linux/path.h： struct path { struct vfsmount mnt; struct dentry dentry;}; 这里的dentry实际上就指向文件所在的目录项了，struct dentry的类型定义于include/linux/dcache.h。 在dentry结构体中，描述了根结点、父节点等等信息，尤其还要注意的是struct inode *d_inode**这一变量，它则是指向了一个i-node结点。 文件描述符是一个POSIX标准下的概念，为系统调用接口，常见于Linux系统。Windows也是声称遵循POSIX标准的，所以Windows也有文件描述符等概念，但不常用。文件描述符的分配规则： 从当前未被分配的最小整数处分匹配，特别的有：标准输入（stdin）的文件描述符是 0；标准输出（stdout）的文件描述符是 1；标准错误（stderr）的文件描述符是 2。 目录项Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。 ls命令只列出目录文件中的所有文件名：ls /etcls -i命令列出整个目录文件，即文件名和inode号码：ls -i /etc inode理解inode，要从文件储存说起。文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector），每个扇区储存512字节（相当于0.5KB）。操作系统读取硬盘的时候，不会一个扇区一个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个sector组成一个block。 文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。 inode包含文件的元信息内容：（存放除文件名之外的所有文件信息） 文件的字节数。文件类型。文件拥有者的User ID。文件的Group ID。文件的读、写、执行权限。文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。链接数，即有多少文件名指向这个inode。文件数据block的位置（数据块指针）。stat命令（display file or file system status）：查看某个文件或文件系统的status信息 文件存储结构示意图 inode的大小inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。 查看每个硬盘分区的inode总数和已经使用的数量，可以使用df -i 命令。 查看每个inode节点的大小，可以用如下命令： 1sudo dumpe2fs -h /dev/hda | grep \"Inode size\" 由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。 inode号码每个inode都有一个号码，操作系统用inode号码来识别不同的文件。使用ls -i命令，可以看到文件名对应的inode号码，例如：ls -i demo.txt 操作系统打开文件：对Linux系统内部而言，打开文件不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。表面上，用户通过文件名，打开文件。系统内部这个过程分成三步：首先，系统在目录项中得到这个文件名对应的inode号码；其次，通过inode号码，获取文件的所有信息；最后，根据inode信息，找到文件数据所在的block，读出数据。 三、共享文件（静态共享）现代常用的有两种共享方式。 硬链接Linux系统允许，可以为一个或多个文件名指向同一个inode号码（索引节点中的链接计数count）。这意味着，可以用不同的文件名访问同样的内容； 同时对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。 ln命令：创建硬链接 ln source_file target_file运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域（数据空间）。 软链接除了硬链接以外，还有一种特殊情况。文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。 ln -s命令可以创建软链接，语法为： ln -s source_file target_file 4. Linux的五种IO模型1）阻塞IO 2）非阻塞IO 3）IO复用（select和poll） 4）信号驱动IO（sigio） 5）异步IO（aio_） 一般来说，IO操作都分为两个阶段，就拿套接口的输入操作来说，它的两个阶段主要是： 1）等待网络数据到来，当分组到来时，将其拷贝到内核空间的临时缓冲区中 2）将内核空间临时缓冲区中的数据拷贝到用户空间缓冲区中 1、阻塞IO默认情况下，所有套接口都是阻塞的。 例如recvfrom函数是一个系统调用： 说明：任何一个系统调用都会产生一个由用户态到内核态切换，再从内核态到用户态切换的过程，而进程上下文切换是通过系统中断程序来实现的，需要保存当前进程的上下文状态，这是一个极其费力的过程。 2、非阻塞IO当我们把套接口设置成非阻塞时，就是由用户进程不停地询问内核某种操作是否准备就绪，这就是我们常说的“轮询”。这同样是一件比较浪费CPU的方式。 3、 IO多路复用我们常用到的IO多路复用，主要是select和poll。这里同样是会阻塞进程的，但是这里进程是阻塞在select或者poll这两个系统调用上，而不是阻塞在真正的IO操作上。 看起来它与blocking I/O很相似，两个阶段都阻塞。但它与blocking I/O的一个重要区别就是它可以等待多个数据报就绪（datagram ready），即可以处理多个连接，而阻塞IO一次性只能监听一个套接口。这里的select相当于一个“代理”，调用select以后进程会被select阻塞，这时候在内核空间内select会监听指定的多个datagram (如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。 在select模型中每个socket一般都设置成non-blocking，虽然等待数据阶段仍然是阻塞状态，但是它是被select调用阻塞的，而不是直接被I/O阻塞的。select底层通过轮询机制来判断每个socket读写是否就绪。 当然select也有一些缺点，比如底层轮询机制会增加开销、支持的文件描述符数量过少等。为此，Linux引入了epoll作为select的改进版本。 多路复用三种机制select,poll,epoll的区别： select poll epoll 操作方式 遍历 遍历 回调 底层实现 数组 链表 红黑树和就绪链表 IO效率 每次调用都进行线性遍历，时间复杂度为O(n) 每次调用都进行线性遍历，时间复杂度为O(n) 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1) 最大连接数 1024（x86）或2048（x64） 无上限 无上限 fd拷贝 每次调用select，都需要把fd集合从用户态拷贝到内核态 每次调用poll，都需要把fd集合从用户态拷贝到内核态 调用epoll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝 epoll是Linux目前大规模网络并发程序开发的首选模型。在绝大多数情况下性能远超select和poll。目前流行的高性能web服务器Nginx正式依赖于epoll提供的高效网络套接字轮询服务。但是，在并发连接不高的情况下，多线程+阻塞I/O方式可能性能更好。 select：内核需要将消息传递到用户空间，需要内核拷贝动作poll：内核需要将消息拷贝到用户空间，需要内核拷贝动作epoll：通过内核和用户空间共享一块内存来实现（直接内存）不需要拷贝动作。 4、信号驱动IO信号驱动IO就是说我们可以通过sigaction系统调用注册一个信号处理程序，然后主程序可以继续向下执行，当我们所监控的套接口有IO操作准备就绪时，由内核通知触发前面注册的信号处理程序执行，然后将我们所需要的数据从内核空间拷贝到用户空间。 5、异步IO异步IO与信号驱动IO最主要的区别就是信号驱动IO是由内核通知我们何时可以进行IO操作了，而异步IO则是由内核告诉我们IO操作何时完成了。具体来说就是，信号驱动IO当内核通知触发信号处理程序时，信号处理程序还需要阻塞在从内核空间缓冲区拷贝数据到用户空间缓冲区这个阶段，而异步IO直接是在第二个阶段完成后内核直接通知可以进程后续操作了。 综上所述，我们发现 前四种IO模型的主要区别是在第一阶段，因为它们的第二阶段都是在阻塞等待数据由内核空间拷贝到用户空间；而异步IO很明显与前面四种有所不同，它在第一阶段和第二阶段都不会阻塞。具体参考如下： 最后，总结下同步IO与异步IO的区别： 1）同步IO操作会引起进程阻塞直到IO操作完成。 2）异步IO操作不引起进程阻塞。 因此，由上面定义可以看出，阻塞IO、非阻塞IO、IO复用、信号驱动IO都是属于同步IO，而异步IO模型才与异步IO定义所匹配。 5. Linux进程管理进程的状态与转换进程在其生命周期内通常进程主要有以下三种状态： 1) 运行状态：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。 2) 就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。 3) 阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。 注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地转换到就绪状态的；而其他资源（如外设）的使用和分配或者某一事件的发生（如I/O操作的完成）对应的时间相对来说很长，进程转换到等待状态的次数也相对较少。这样来看，就绪状态和等待状态是进程生命周期中两个完全不同的状态，需要加以区分。 就绪状态 -&gt; 运行状态：CPU 空闲时选择一个就绪进程，处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。 运行状态 -&gt; 就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。 运行状态 -&gt; 阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。 阻塞状态 -&gt; 就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。 进程创建fork和vfork 进程描述符task_struct 在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。 fork后操作系统会复制一个与父进程完全相同的子进程，两个进程共享代码空间，但数据空间相互独立，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别做不同的工作，也就是分岔了。 fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为调用了exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为调用了exec，exec负责读取可执行文件并将其载入地址空间开始运行，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。 fork之后内核会通过将子进程放在队列的前面，以让子进程先执行，因为一般子进程都会马上调用exec()函数，这样可以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能会开始向地址空间写入。fork时子进程获得父进程数据空间、堆和栈的复制，所以变量的地址（当然是虚拟地址）也是一样的。每个进程都有自己的虚拟地址空间，不同进程的相同的虚拟地址显然可以对应不同的物理地址。因此地址相同（虚拟地址）而值不同没什么奇怪。具体过程是这样的：fork子进程完全复制父进程的栈空间，也复制了页表，但没有复制物理页面，所以这时虚拟地址相同，物理地址也相同，但是会把父子共享的页面标记为“只读”（类似mmap的private的方式），如果父子进程一直对这个页面是同一个页面，知道其中任何一个进程要对共享的页面“写操作”，这时内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为“可写”，留给另外一个进程使用。 fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别： fork ()：子进程拷贝父进程的数据段、代码段vfork ()：子进程与父进程共享数据段、代码段，子进程不能向地址空间写入。 fork ()父子进程的执行次序不确定vfork 保证子进程先运行，子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，知道子进程退出或执行exec()。 若vfork ()调用exec 或_exit() 之前子进程依赖于父进程的进一步动作，会导致死锁。 现在由于在执行fork()时引入了写时拷贝页并且明确了子进程先执行，vfork()的好处就仅限于不拷贝父进程的页表项了，另外最好不要使用vfork()（如果exec调用失败，试想会发生什么） COW详述： 现在有一个父进程P1，这是一个主体，那么它是有灵魂也就身体的。现在在其虚拟地址空间（有相应的数据结构表示）上有：正文段，数据段，堆，栈这四个部分，相应的，内核要为这四个部分分配各自的物理块。即：正文段块，数据段块，堆块，栈块。至于如何分配，这是内核去做的事，在此不详述。 现在P1用fork()函数为进程创建一个子进程P2， 内核： （1）复制P1的正文段，数据段，堆，栈这四个部分，注意是其内容相同。 （2）为这四个部分分配物理块，P2的：正文段－＞PI的正文段的物理块，其实就是不为P2分配正文段块，让P2的正文段指向P1的正文段块，数据段－＞P2自己的数据段块（为其分配对应的块），堆－＞P2自己的堆块，栈－＞P2自己的栈块。如下图所示：同左到右大的方向箭头表示复制内容。 写时复制技术：内核只为新生成的子进程创建虚拟空间结构，它们来复制于父进程的虚拟究竟结构，但是不为这些段分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。 vfork()：这个做法更加火爆，内核连子进程的虚拟地址空间结构也不创建了，直接共享了父进程的虚拟空间，当然了，这种做法就顺水推舟的共享了父进程的物理空间 通过以上的分析，相信大家对进程有个深入的认识，它是怎么一层层体现出自己来的，进程是一个主体，那么它就有灵魂与身体，系统必须为实现它创建相应的实体， 灵魂实体与物理实体。这两者在系统中都有相应的数据结构表示，物理实体更是体现了它的物理意义。以下援引LKD 传统的fork()系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，更糟的情况是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。Linux的fork()使用写时拷贝（copy-on-write）页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候。在页根本不会被写入的情况下—举例来说，fork()后立即调用exec()—它们就无需复制了。fork()的实际开销就是复制父进程的页表以及给子进程创建惟一的进程描述符。在一般情况下，进程创建后都会马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据（地址空间里常常包含数十兆的数据）。由于Unix强调进程快速执行的能力，所以这个优化是很重要的。这里补充一点：**Linux COW与exec没有必然联系**进程和线程的区别​ （1）进程是资源分配和调度的一个独立单元，而线程是CPU调度和分派的基本单元​ （2）一个进程至少包括一个线程，并且同一个进程的所有线程共享整个进程的资源，因此线程执行时一般都要进行同步和互斥​ （3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束​ （4）线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成访问淘宝，加入购物车，的​ （5）进程间通信IPC需要特别的方法，线程间可以直接读写进程数据段（如全局变量）来进行通信。 线程有什么是共享的什么是私有的线程共享的环境包括： 1.进程数据段、代码段 2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯) 3.进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。 线程独立的资源包括： 1.线程ID 2.寄存器组的值 由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。 3.线程的栈 栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数栈， 使得函数调用可以正常执行，不受其他线程的影响。 4.线程的错误返回码 由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。线程返回0表示线程创建成功，1-255表示线程异常。进程fork()返回两个非零值为成功，子进程返回零，父进程返回子进程的PID；返回负数代表创建进程失败。 5.线程的信号屏蔽码 6.线程的优先级 注：线程有自己的私有属性线程控制块TCB，进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志 线程同步用户态下的方法有： 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。只允许一个进程访问，不可能两个进程进行竞争。一个进程创建了临界区以后，其他进程是不可能获取到该临界区的进入权利的，但是允许进程内的多个线程竞争。适用范围是单一进程的各线程之间。它是一个局部性对象，不是一个核心对象。快速而有效率。不能够同时有一个以上的 critical section 被等待。无法侦测是否已被某个线程放弃。 原子操作 内核态的方法：自旋锁、完成变量，信号量，互斥体。 1、自旋锁：一个被征用的自旋锁使得请求它的线程在等待锁重新可用时自旋（特别浪费处理器时间）。自旋锁不可睡眠，不可递归，顺序锁可递归。 2、互斥体（Mutex）:为协调共同对一个共享资源的单独访问而设计的。以排他的方式，防止共享资源被并发访问；互斥锁为二元变量， 状态为0-开锁、1-上锁;开锁必须由上锁的线程执行，不受其它线程干扰.相比信号量优先使用mutex。3、信号量:为控制一个具有有限数量用户资源而设计的一种睡眠锁。如果有一个任务试图获得一个不可用（已被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠，这时处理器重获自由，从而去执行其他代码。当持有的信号量可用（被释放）后，处于等待队列中的那个任务将被唤醒，被获得该信号量。4、条件变量（完成变量）:用来通知线程有一些事件已发生，从而启动后继任务的开始。满足某个特定条件时，可通过条件变量通知其它线程do-something;必须与互斥锁联合使用，单独无法执行. 5、读写锁：针对多读者，少写者的情况设定 允许多读，但此时不可写； 唯一写，此时不可读. 就使用效率来说，临界区的效率是最高的，因为它不是内核对象，而其它的三个都是内核对象，要借助操作系统来实现，效率相对来说就比较低。但如果要跨进程使用还是要用到互斥体、事件对象和信号量。 线程通信线程间通信：由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）,不过要注意的是线程间需要做好同步，一般用mutex。 1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。2、互斥量:为协调共同对一个共享资源的单独访问而设计的。3、信号量:为控制一个具有有限数量用户资源而设计。4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。wait/notify join信号机制，等待通知模式 临界区(Critical section)与互斥体(Mutex)的区别1、临界区只能用于对象在同一进程里线程间的互斥访问；互斥体可以用于对象进程间或线程间的互斥访问。 2、临界区是非内核对象，只在用户态进行锁操作，速度快；互斥体是内核对象，在核心态进行锁操作，速度慢。 3、临界区和互斥体在Windows平台都下可用；Linux下只有互斥体可用。 进程间的通信方式（IPC,inter-Process Communication）同一主机中两个进程间的通信由操作系统决定，不同主机间的通信进程通过网络交换报文进行。 信号：用于通知进程某个事件已经发生 管道：读写操作符合先进先出原则，对于两端的进程而言就是文件，向管道中写入数据时,linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。 无名管道pipe:半双工的通信方式，数据单向流动，只能在具有亲缘关系的进程间使用，从结构上看，无名管道没有文件路径名，不占用文件目录项，因此文件目录结构中的链表不适用于这种文件，它只是存在于打开文件结构中的一个临时文件，依附于进程临时存在。 命名管道FIFO:半双工，数据单向流动，允许无亲缘关系进程间的通信，FIFO是一种永久性的机制，它具有普通的UNIX系统文件名。在系统下可利用mkfifo命令建立永久的管道，除非刻意删除它，否则它将一直保持在系统中。 联系： 1) 通信数据只存在于内存缓冲页面中； 2) 都是半双工通信； 区别： (1)无名管道是无名的，有名管道是有名的； (2)无名管道只能用于父子进程或兄弟进程之间的通信，而有名管道可用于任意两进程之间通信 (3)无名管道是无形的，即无名管道的 inode 结构不是在磁盘上存储的，而是临时生成的，而有名管道的 inode 结点在磁盘上。 消息队列：消息的链表存放在内核中并由消息队列标识符标识，克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点，但只有在内核重启时才能删除一个消息队列，内核重启也就是系统重启。 共享内存：最快的IPC方式，映射一段能被其他进程所访问的内存。往往与其他通信机制如信号两两配合使用，来实现进程间的同步和通信。 mmap内存映射原理内存映射，简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间&lt;—-&gt;用户空间两者之间需要大量数据传输等操作的话效率是非常高的。以下是一个把普遍文件映射到用户空间的内存区域的示意图。 信号量Semaphore:信号量是一个计数器，可以用来控制多个进程对共享资源的访问。常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 套接字Socket:套接字也是一种进程间通信机制，包括IPC 套接字（即 Unix 套接字）给予进程在相同设备（主机）上基于通道的通信能力；而网络套接字给予进程运行在不同主机的能力，因此也带来了网络通信的能力。IPC 套接字依赖于本地系统内核的支持来进行通信。网络套接字需要底层协议的支持，例如 TCP（传输控制协议）或 UDP（用户数据报协议），包括流套接字（TCP/IP）和数据报套接字（UDP/IP），利用三元组（ip地址，协议，端口）构成套接字；传输层实现端到端的通信，传输层连接的端点叫做套接字。 windows进程通信标准的Windows进程间通信方法有三种：匿名管道、命名管道（又叫FIFO，命名管道可以控制读消息的长度，一个命名管道可以有多个实例，具体通信还是一对一）、邮槽（MailSlot）。共享内存也可用于windows进程通信，但因为其实是Windows“内存映射文件”的一个特殊用法，所以不算作标准的windows进程间通信方法。 对比点 匿名管道 命名管道 邮槽 共享内存 消息格式 字符 二进制 数据包 - 工作模式 半双工 全双工 单向 双向 访问模式 只能在一台机器上 可以跨网络 可以跨网络 只能在一台机器上 通信模式 父子进程用 不同进程均可用 广播机制 - windows命名管道和Linux命名管道的区别 对比点 Linux命名管道 Windows命名管道 备注 消息格式 字节流 二进制 windows更牛 工作模式 半双工 全双工 windows更牛 访问模式 只能在一台机器上 可以跨网络 windows更牛 死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？​ (1）相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态​ （2）系统资源不足、相互竞争资源、请求资源顺序不当​ （3）互斥、不可剥夺、循环等待、请求与保持​ （4）因为互斥是不可改变的，所以只能破坏其他三个条件中的一个来解除死锁，方法： 破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中。 破坏”请求与保持条件“：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。 破坏“循环等待”条件：资源有序分配（将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程） 进程调度抢占和上下文上下文代表着内核活动的范围。实际上我们可以将每个处理器在任何指定时间点上的活动必然概况为下列三者之一： 运行于用户空间，执行用户进程 运行于内核空间，处于进程上下文，代表某个特定的进程执行 运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断 当CPU空闲时，内核就运行一个空进程，处于进程上下文，但运行于内核空间。 进程上下文可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行。当一个程序调用执行了系统调用或者触发了异常，他就陷入了内核空间，此时我们称内核“代表进程执行”并处于进程上下文中。在此上下文中current宏是有效的。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出时，程序恢复在用户空间会继续执行。 系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行—对内核的所有访问必须通过这些接口。 用户抢占 从系统调用返回用户空间时 从中断处理程序返回用户空间时 内核抢占 中断处理程序正在执行，且返回内核空间之前 内核代码再一次具有可抢占性 如果内核中的任务显示调用schedule 如果内核中的任务阻塞（这同样也会导致调用schedule）","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Linux或windows安装Matlab注意事项","slug":"Linux安装Matlab","date":"2020-03-25T15:59:41.000Z","updated":"2020-03-25T17:00:55.060Z","comments":true,"path":"2020/03/25/Linux安装Matlab/","link":"","permalink":"http://yoursite.com/2020/03/25/Linux%E5%AE%89%E8%A3%85Matlab/","excerpt":"1、一定要把iso挂载的文件复制到home目录下，使用完整路径启动install,而不能直接进入挂载的dvd中sudo ./install","text":"1、一定要把iso挂载的文件复制到home目录下，使用完整路径启动install,而不能直接进入挂载的dvd中sudo ./install 2、windows安装注意事项： 如果之前安装过即使没安装成功，要彻底删除安装过程中产生的所有文件 安装路径不能存在中文 防火墙等杀毒软件要关闭","categories":[{"name":"安装编译","slug":"安装编译","permalink":"http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"}]},{"title":"Git操作注意事项","slug":"Git操作注意事项","date":"2020-03-25T15:53:25.000Z","updated":"2020-03-25T17:00:45.990Z","comments":true,"path":"2020/03/25/Git操作注意事项/","link":"","permalink":"http://yoursite.com/2020/03/25/Git%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"Git常规笔记及注意事项 切换到历史版本(要求此时本地项目没有未提交的修改)：git checkout &lt;版本号&gt; 查看文件的历史记录、查看某个文件在某次提交中的修改参照：使用git查看版本记录","text":"Git常规笔记及注意事项 切换到历史版本(要求此时本地项目没有未提交的修改)：git checkout &lt;版本号&gt; 查看文件的历史记录、查看某个文件在某次提交中的修改参照：使用git查看版本记录 从缓存中删除的文件git rm -r . –cached可以采用git reset HEAD .进行恢复 git reset --mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息git reset --soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git reset --hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，此命令 慎用！","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"面试要点记录","slug":"面试要点记录","date":"2020-03-24T13:59:01.000Z","updated":"2020-08-26T03:58:29.901Z","comments":true,"path":"2020/03/24/面试要点记录/","link":"","permalink":"http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/","excerpt":"（一）面向对象的三个基本特征：封装、继承、多态 继承 子类对象可以直接调用父类中的成员函数 子类对象可以直接赋值给父类对象。 子类对象可以直接初始化父类对象。 父类引用可以直接引用子类对象。 父类指针可以直接指向子类对象。","text":"（一）面向对象的三个基本特征：封装、继承、多态 继承 子类对象可以直接调用父类中的成员函数 子类对象可以直接赋值给父类对象。 子类对象可以直接初始化父类对象。 父类引用可以直接引用子类对象。 父类指针可以直接指向子类对象。 子类初始化一定会先初始化父类，析构顺序相反。 虚继承对构造函数的影响：指南。构造函数的调用可能内带大量的隐藏码，因为编译器会对构造函数进行扩充，一般而言编译器所作的扩充规则如下： （1）记录在成员初始化列表中的数据成员的初始化操作会被放到构造函数本身中，按照数据成员声明的顺序 （2）如果有一个数据成员没有出现在初始化列表中，但是它有一个默认构造函数，那么这个默认构造函数会被调用 （3）在那之前，如果有虚函数表，会调整虚函数表指针 （4）在那之前，会对上一层基类的构造函数进行调用 （5）在那之前，所有虚基类的构造函数必须被调用，按照声明的继承顺序从左往右，从最深到最浅的顺序 继承的优点： （1）继承使得所有的子类的公共部分都放在了父类中，使得代码得到了共享。提高了代码的重用性，避免了重复。 （2）继承可使得修改或扩展继承而来的实现都较为容易 （3）使类与类之间产生联系，为多态提供了前提 继承的缺点： （1）继承具有入侵性（即继承必须拥有父类的所有非私有属性和方法） （2）父类变，子类变 （2）继承破坏封装，父类实现细节暴露给子类，增大了两个类之间的耦合性 多态:C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。 运行期多态发生的三个必要条件： 要有继承。 要有虚函数重写。 父类指针或引用 指向 子类对象。 运行期多态的优缺点 （1）优点：提高了代码的维护性（由继承保证）和扩展性（由多态保证） （2）缺点： 运行期间进行虚函数绑定，提高了程序运行开销 庞大的类继承层次，对接口的修改易影响类继承层次 由于虚函数在运行期确定，所以编译器无法对虚函数进行优化 虚表指针增加了对象空间，类也多了一张虚函数表。 虚析构函数：在多态时，要调用析构函数时，注意在父类的析构成员函数前加virtual。 动态绑定必须使用指针或者引用，不能使用. 虚函数表指针在内存中的分布:参考 编译期多态 对模板参数而言，多态是通过模板具现化和函数重载解析实现的。以不同的模板参数具现化导致调用不同的函数，这就是所谓的编译期多态。 （1）编译期多态优点 泛型编程 在编译器完成多态，提高运行期效率 具有很强的适配性和松耦合性，对于特殊类型可由模板偏特化、全特化来处理 （2）编译期多态缺点 程序可读性降低，代码调试困难 无法实现模板分离编译，当工程很大时，编译时间不可小觑 无法处理异质对象集合 重载/重写（覆盖）/重定义（隐藏） 重载（overload）-编译时的多态性 （1）重载只能通过不同的参数样式（参数类型、个数、顺序至少有一个不相同），不能通过访问权限、返回类型、抛出的异常进行重载。 重写（override）-运行时的多态性 （1）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 （2）被定义为final的方法不能被重写。 重定义（隐藏hiding） （1）隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt; using namespace std; class Base &#123; private: virtual void display() &#123; cout&lt;&lt;\"Base display()\"&lt;&lt;endl; &#125; void show()&#123; cout&lt;&lt;\"Base show()\"&lt;&lt;endl; &#125; public: void exec()&#123; display(); show(); &#125; void fun(string s) &#123; cout&lt;&lt;\"Base fun(string)\"&lt;&lt;endl; &#125; void fun(int a) &#123; cout&lt;&lt;\"Base fun(int)\"&lt;&lt;endl; &#125;//overload:两个fun函数在Base类的内部被重载 virtual int function()&#123;&#125; &#125;; class ClassA:public Base &#123; public: void display() &#123; cout&lt;&lt;\"ClassA display()\"&lt;&lt;endl; &#125;//override:基类中display为虚函数，且参数列表一直，故此处为重写 void fun(int a,int b) &#123; cout&lt;&lt;\"ClassA fun(int,int)\"&lt;&lt;endl; &#125;//redefining:fun函数在Base类中不为虚函数，故此处为重定义 void show() &#123; cout&lt;&lt;\"ClassA show()\"&lt;&lt;endl; &#125;//redefining:理由同上 int function(int a)&#123;&#125;//overload:注意这是重载而不是重写，因为参数列表不同，在编译时ClassA中其实还有个编译器自己偷偷加上的从Base继承来的int function()&#123;&#125;; &#125;; int main()&#123; ClassA a; Base *base=&amp;a; base-&gt;exec();//display()是ClassA的，因为覆盖了，show()是Base自己的 a.exec();//结果同上,子类对象可以直接调用父类中的成员函数 a.show();//show()是ClassA重定义的 base-&gt;fun(1);//fun()是Base自己的，因为直接从对象base调用 a.fun(1, 1);//fun()是ClassA重定义的 return 0; &#125; //输出结果ClassA display()Base show()ClassA display()Base show()//父类中的成员函数直接调用自身的Base show()ClassA show()Base fun(int)ClassA fun(int,int) 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual void f(float x)&#123; cout &lt;&lt; \"Base::f(float) \" &lt;&lt; x &lt;&lt; endl; &#125; void g(float x)&#123; cout &lt;&lt; \"Base::g(float) \" &lt;&lt; x &lt;&lt; endl; &#125; void h(float x)&#123; cout &lt;&lt; \"Base::h(float) \" &lt;&lt; x &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: virtual void f(float x)&#123; cout &lt;&lt; \"Derived::f(float) \" &lt;&lt; x &lt;&lt; endl; &#125; void g(int x)&#123; cout &lt;&lt; \"Derived::g(int) \" &lt;&lt; x &lt;&lt; endl; &#125; void h(float x)&#123; cout &lt;&lt; \"Derived::h(float) \" &lt;&lt; x &lt;&lt; endl; &#125;&#125;;int main(void)&#123; Derived d; Base *pb = &amp;d; Derived *pd = &amp;d; // Good : behavior depends solely on type of the object pb-&gt;f(3.14f); //Derived::f(float) 3.14 pd-&gt;f(3.14f); //Derived::f(float) 3.14 // Bad : behavior depends on type of the pointer pb-&gt;g(3.14f); //Base::g(float) 3.14 pd-&gt;g(3.14f); //Derived::g(int) 3 // Bad : behavior depends on type of the pointer pb-&gt;h(3.14f); //Base::h(float) 3.14 pd-&gt;h(3.14f); //Derived::h(float) 3.14 system(\"pause\"); return 0;&#125;//函数Derived::f(float)覆盖了Base::f(float)//函数Derived::g(int)隐藏了Base::g(float)，而不是重载//函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖 三者 作用域 有无virtual 函数名 参数列表 返回类型 重载 相同 可有可无 相同 不同 可同可不同 重写 不同 必有 相同 相同 相同（协变） 隐藏 不同 可有可无 相同 可同可不同 可同可不同 （二）bash shell bash是borne again shell的缩写，是shell的一种,Linux上默认采用的是bash。 Shell 是一个 C 语言编写的程序，一般都是放在/bin或者/user/bin目录下，当前 Linux 系统可用的 Shell 都记录在/etc/shells文件中。/etc/shells是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令查看它。 123$ cat /etc/shells #通过 cat 命令来查看当前 Linux 系统的可用 Shell$ echo $SHELL #查看当前Linux默认的shell，输出 SHELL 环境变量$ echo $BASH_VERSION #查看shell版本 设置取消alias：指南 PHP即“超文本预处理器”，是一种通用开源脚本语言。PHP是一种在服务器端执行的嵌入HTML文档的脚本语言。PHP 独特的语法混合了C、Java、Perl 以及 PHP 自创新的语法，它可以比 CGI 或者 Perl 更快速的执行动态网页，主要适用于Web开发领域。 （三）图 拓扑排序 一个有向无环图可以有一个或多个拓扑排序序列。 判断有向图是否有环的两种方法：(1)拓扑排序 (2)DFS 五大常用算法 分冶法 分治法所能解决的问题一般具有以下几个特征： 1) 该问题的规模缩小到一定的程度就可以容易地解决 2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。 3) 利用该问题分解出的子问题的解可以合并为该问题的解； 4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加； 第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用； 第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。 第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。可用分冶法求解的一些经典问题：二分查找；快速排序。 动态规划 (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 (3) 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。 递归常常用于分冶算法和动态规划算法中。 贪心算法 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。 从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的地求得更好的解。当达到算法中的某一步不能再继续前进时，算法停止。该算法存在问题： 不能保证求得的最后解是最佳的； 不能用来求最大或最小解问题； 只能求满足某些约束条件的可行解的范围。 贪心策略适用的前提是：局部最优策略能导致产生全局最优解。贪心算法和动态规划的区别： 贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解则不作保留；动态规划：全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有的局部最优解 。求一个问题的最优解相当于遍历所有的子集来找最优解，但是这样解随着解空间的维度成指数增长，动态规划其实就是一种遍历，但是他是带备忘录的遍历，我前面算到的子问题，到这儿我不在计算，我直接调用之前保存的值，这样就节省了大量的时间。 动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常自顶向下的方式进行。 根据以上两条可以知道，贪心不能保证求得的最后解是最佳的，一般复杂度低；而动态规划本质是穷举法，可以保证结果是最佳的，复杂度高。 回溯法 在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。 分支界限法 回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。 分支限界法的搜索策略是：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。 最小生成树-Prim算法和Kruskal算法 a. 最小生成树 生成树是连通图的\\最小连通子图**。所谓最小是指：若在树中任意增加一条边，则将出现一个回路；若去掉一条边，将会使之变成非连通图。按照该定义，n个顶点的连通网络的生成树有n个顶点，n-1条边。生成树各边的权值总和称为生成树的权，\\权最小的生成树称为最小生成树**。常见的构造最小生成树的方法有Prim算法和Kruskal算法。 b. Prim算法：选取与当前节点连接的权值最小边 c. Kruskal算法：所有边按权值从小到大排序，依次选取不使最小生成树存在回路的最小权值边 最短路径-Dijkstra算法和Floyd算法：具体代码参考 a. Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。注意该算法要求图中不存在负权边。 主要思想：通过“边”来松弛v1顶点到其余各个顶点的路程。 b. Floyd算法 Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd算法是一个经典的动态规划算法。 （四）IO库 当操作符改变流的格式状态时，通常改变后的状态对所以后续IO都生效。setw类似endl不改变输出流的内部状态，只决定下一个输出的大小。 操作符hex(0x)、oct(0)、dec只影响整型运算对象，浮点型的表示形式不受影响。使用nouppercase、noshoubase和dec来重置流状态。 showbase:当打印整型值时显示进制 ios::internal:数值的符号位在域宽内左对齐,数值右对齐,中间由填充字符填充 setfill()：允许一个字符替代默认的字符填补空白 setbase：将整数设置为b进制 cout.setf()的作用是通过设置格式标志来控制输出形式；cin&gt;&gt;noskipws设置cin读取空白符; cin&gt;&gt;skipws将cin恢复到默认状态，丢弃空白符 12345std::cout.setf ( std::ios::hex, std::ios::basefield );//set hex as the basefieldstd::cout.setf ( std::ios::showbase ); //activate showbasestd::cout &lt;&lt; 100 &lt;&lt; '\\n'; //输出0x100std::cout.unsetf ( std::ios::showbase ); //deactivate showbasestd::cout &lt;&lt; 100 &lt;&lt; '\\n'; //输出100 未格式化输出中is.get()将is的下一个字节作为int返回，头文件cstdio定义了一个名为EOF的const，用来检测返回的值是否是文件末尾，而不必记忆表示文件尾的实际数值。 1234int ch;//使用一个int,而不是char来保存get()的返回值,否则循环可能永远不会停止，循环也可能会在遇见'\\377'的字符提前终止（-1转换为一个singed char会得到'\\377'）//循环读取并输出输入中的所有数据while((ch=cin.get())!=EOF) cout.put(ch); istream和ostream类通常不支持随机访问，只有fstream、sstream支持。 （五）搜狗 STL : std::map/std::set std::unordered_map/std::unordered_set结构 std::map:红黑树，自动排序，稳定查找插入删除时间复杂度O(lgn)，空间占用高，因为红黑树每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间 std::unordered_map:哈希表，无序，快速查找插入删除，insert/find/erase的平均时间复杂度是O(1)，但是最坏复杂度是O(N)，相比于map空间占用更高，哈希表建立比较耗费时间，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表地址顺序从前往后依次遍历的 存储小对象，内存消耗依次是：vector &lt;&lt;map &lt;&lt;unordered_map;当存储的对象增大时，vector的优势变得并不明显。因为随着对象增大，用于存储对象的空间所占的比例越来越大。因此单从内存消耗的角度来看，当存储的是小对象时，vector占很大的优势。但是，当存储的对象本身大小增大时，它的优势变得不再那么明显。 hash表：（1）插入删除接近常量，大o表示法最快的方式（2）哈希表查询也快,但是底层存储结构是数组，一旦创建无法改变大小（3）哈希表无法用来有序遍历 二叉树/平衡二叉树/红黑树/b树/b+树 顺序容器 vector:可变大小数组，支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢，vector插入insert删除erase时间复杂度均是O(n) deque:双端队列，支持快速随机访问。在头尾部位置插入/删除速度很快 list:双向链表。支持双向顺序访问，在链表任何位置进行插入/删除操作速度都很快 forward_list:单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快 array:固定大小数组，支持快速随机访问。不能添加或删除元素 string:与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快 除固定大小的array外，其他容器都提供高效、灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器大小。string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入和删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。而且添加一个元素有时可能还需要分配额外的存储空间。在这种情况下，每个元素必须都移动到新的存储空间中。 list和forward_list两个容器添加和删除操作都很快，但是不支持元素的随机访问，为了访问一个元素，只能遍历整个容器，与vector、deque、array相比，这两个容器的额外内存开销很大。 指针大小由当前CPU运行模式的寻址位数决定 32位处理器上32位操作系统的32位编译器，指针大小4字节。32位处理器上32位操作系统的16位编译器，指针大小2字节。32位处理器上16位操作系统的16位编译器，指针大小2字节。16位处理器上16位操作系统的16位编译器，指针大小2字节。 这从结果看起来指针的大小和编译器有关？？ 实际不是这样的，有这样的结果是因为以上几种情况，处理器当前运行模式的寻址位数是不一样的，如下： Intel 32位处理器32位运行模式，逻辑寻址位数32，指针也就是32位，即4个字节 Intel 32位处理器16位虚拟机运行模式，逻辑寻址位数16，指针也就是16位，即2个字节 编译器的作用是根据目标硬件（即CPU）的特性将源程序编译为可在该硬件上运行的目标文件。如果一个编译器支持某32位的CPU，那么它就可以将源程序编译为可以在该CPU上运行的目标文件。该源程序中指针大小也会被编译器根据该CPU的寻址位数（如32位）编译选择为4字节。 sizeof和strlen的区别 ❀第一个例子：char* ss = “0123456789”;1、sizeof(ss)的结果是4,ss是指向字符串常量的字符指针2、sizeof(*ss)的结果是1，*ss是第一个字符 ❀第二个例子：char ss[] = “01233456789”;1、sizeof(ss)结果是11，ss是数组，计算到’\\0’的位置，因此是10+12、sizeof(*ss)结果是1，*ss是第一个字符 ❀第三个例子char ss[100] = “0123456789”;1、sizeof(ss)的结果是100，ss表示在内存中预分配的大小：100*12、strlen(ss)的结果是10，它的内部实现是用一个循环计算字符串的长度，直到’\\0’为止。 ❀第四个例子int ss[100] = {0,1,2,3,4,5,6,7,8,9};1、sizeof(ss)的结果是400，ss表示在内存中的大小，为10042、strlen(ss)错误，strlen的参数只能是char，且必须是以’\\0’结尾的。 OSI模型：应用层（HTTP FTP（基于TCP） DNS(基于UDP（客户端和服务器）和TCP（服务器和服务器））） 表示层（加密 SSL握手协议） 会话层（建立和维持会话，并能使会话获得同步 SSL记录协议） 传输层（TCP/UDP端到端 段Segment 数据报文） 网络层 (IP ICMP ARP RARP数据包Packet) 数据链路层(逻辑链路控制子层（LLC）媒体访问控制子层（MAC）数据帧Frame) 物理层(物理介质Bit) 消息（message）：是指起始点和目的地都在网络层以上（经常在应用层）的信息单元。 SSL握手协议：它建立在SSL记录协议之上，用于在实际的数据传输开始之前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 SSL记录协议：它建立在可靠的传输（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能。 TCP/UDP五层模型：应用层 传输层 网络层 数据链路层 物理层 编程内存的基本构成（堆、存储区别） 1、内存 （1）静态内存（静态分配）：发生在程序编译和链接阶段，存在于程序的整个生命周期，内存大小固定，不占用CPU资源 全局/静态存储区 （i）.bss段：存放未初始化的全局变量和静态变量 （ii）.data段（全局初始化区）：存放初始化的全局变量和static变量 常量存储区 :常量字符串就是放在这里的。 程序结束后由系统释放。虚函数表在常量存储区。 代码区（.txt段）：存放函数体的二进制代码，虚函数存放在代码区。 注意： ​ 函数指针指向Code区，是程序运行的指令代码，数据指针指向Data,Heap,Stack 区，是程序依赖以运行的各种数据。 ​ 在文件作用域声明inline函数默认为static存储类型,const常量默认为static存储， 如果加上extern，则为外部存储类型 （2）动态内存（动态分配）：发生在程序调入和执行阶段，根据程序的需要分配和释放，其大小可变，占用CPU资源 堆：链表结构，有序数组链表，程序通过调用malloc和new分配，调用free和delete释放；堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存4G。由此可见，堆获得的空间比较灵活，也比较大。堆中的存储内容一般是在堆的头部用一个字节存放堆的大小。 栈：线性结构，有序数组，由编译器自动分配与释放，速度较快，是一块连续的内存的区域，存储函数（包括main函数）的方法调用、函数参数、内部局部变量、返回地址和CPU系统提供的两个特殊的寄存器用于标识位于系统栈顶端的栈帧（(1)ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈的上面一个栈帧的栈顶。(2) EBP：基址指针寄存器(extended base pointer)-其内存放着一个指针，该指针永远指向系统栈上面一个栈帧的底部），存储地址由高地址向低地址，栈顶的地址和栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，提示Stack Overflow，出现溢出现象。栈中的存储内容在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。函数退出时，其占用内存被收回；进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。 堆栈的区别： 1、管理方式不同（堆手动分配释放new/delete；栈编译器自动分配和释放）：栈内存由一个栈指针来开辟和回收，栈内存是从高地址向低地址增长的，增长时，栈指针向低地址方向移动，指针的地址值也就相应的减小；回收时，栈指针向高地址方向移动，地址值也就增加。所以栈内存的开辟和回收都只是指针的加减，由此相对于分配堆内存可以获得一定的性能提升。 2、空间大小不同（堆32位系统可达4G;栈Linux 10M,Windows 1M） 3、能否产生碎片不同（堆能；栈不能） 4、生长方向不同（堆从低地址到高地址；栈从高地址到低地址） 5、分配方式不同（堆动态分配；栈动静分配都可以，栈的动态使用分配） 6、分配效率不同（堆效率低；栈效率高） 7、申请后系统的响应不同 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表 中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的 首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。 另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中 栈数据的写入跟读出不需要提供地址，而是根据写入的顺序决定读出的顺序。通用寄存器、主存储器、输入输出设备存储数据时均需要编址。 12345678910111213141516171819202122//main.cpp int a = 0; //a存储在全局初始化区 ，静态内存，0存储在常量区随程序结束而释放char *p1; //全局未初始化区 ，静态内存int* p=new int(4); //p存储在全局初始化区，静态内存，分配得来的4存储在堆区main() &#123; int b; //栈 ，编译时char s[] = \"abc\"; //栈 ，运行时赋值char *p2; // 栈 char *p3 = \"123456\"; //\"123456\\0\"在常量区（不同于数组数据可存储在数组里），编译时就确定下来，静态内存，p3在栈上。 static int c =0； //全局（静态）初始化区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); //分配得来的10和20字节的区域就在堆区。 strcpy(p1, \"123456\"); //\"123456\\0\"放在常量区，编译器可能会将它与p3所指向的\"123456\"优化成一个地方。 char* p = \"Hello World1\";char a[] = \"Hello World2\";p[2] = 'A';a[2] = 'A';char* p1 = \"Hello World1\"; //这个程序是有错误的，错误发生在p[2] = 'A'这行代码处，为什么呢，是变量p和变量数组a都存在于栈区的（任何临时变量都是处于栈区的，包括在main（）函数中定义的变量）。但是，数据“Hello World1”和数据“Hello World2”是存储于不同的区域的。因为数据“Hello World2”存在于数组中，所以，此数据存储于栈区，对它修改是没有任何问题的。因为指针变量p仅仅能够存储某个存储空间的地址，数据“Hello World1”为字符串常量，所以存储在静态存储区。虽然通过p[2]可以访问到静态存储区中的第三个数据单元，即字符‘l’所在的存储的单元。但是因为数据“Hello World1”为字符串常量，不可以改变，所以在程序运行时，会报告内存错误。并且，如果此时对p和p1输出的时候会发现p和p1里面保存的地址是完全相同的。换句话说，在数据区只保留一份相同的数据。 2、内存申请函数 malloc calloc realloc alloca的区别 123456void* malloc(unsigned size);void* realloc(void* ptr, unsigned newsize); void* calloc(size_t numElements, size_t sizeOfElement); void * __cdecl alloca(size_t);free将malloc申请的内存最终需要通过该函数进行释放. sbrk则是增加数据段的大小; 都在stdlib.h函数库内，它们的返回值都是请求系统分配的地址,如果请求失败就返回NULL. (1)函数malloc() 在内存的动态存储区中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度，返回该区域的首地址。由于没有初始化内存的内容，所以调用malloc后一般调用函数memset来初始化这部分内存空间。 (2)函数calloc() 与malloc相似,参数sizeOfElement为申请地址的单位元素长度,numElements为元素个数，即在内存中申请numElements*sizeOfElement字节大小的连续地址空间，返回该区域的首地址。初始化所分配的内存空间，设置为0。 malloc() 函数和calloc ()函数的主要区别是前者不能初始化所分配的内存空间，而后者能。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是 0；反之，如果这部分内存空间曾经被分配、释放和重新分配，则其中可能遗留各种各样的数据。也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常运行，但经过一段时间后(内存空间已被重新分配)可能会出现问题。 calloc() 函数会将所分配的内存空间中的每一位都初始化为零，也就是说，如果你是为字符类型或整数类型的元素分配内存，那么这些元素将保证会被初始化为零；如果你是为指针类型的元素分配内存，那么这些元素通常(但无法保证)会被初始化为空指针；如果你是为实数类型的元素分配内存，那么这些元素可能(只在某些计算机中)会被初始化为浮点型的零。 (3)函数realloc()给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度.如果在该存储区后有足够的空间可供扩充，则可在原存储区位置上向高地址方向扩充，并返回传送给它的同样的指针值。如果在原存储区后没有足够的空间，则realloc分配另一个足够大的存储区，将现存的512个元素数组的内容复制到新分配的存储区。因为这种存储区可能会移动位置，所以不应当使用任何指针指在该区中。注意，realloc的最后一个参数是存储区的newsize(新长度)，不是新、旧长度之差。作为一个特例，若ptr是一个空指针，则realloc的功能与malloc相同，用于分配一个指定长度newsize的存储区。 （4）alloca()是在栈(stack)上申请空间的，而栈内存一般可以由编译器自动释放。既然是在栈内申请内存，这就决定了其固有的局限性。其一是不适用于那些比创建它们的函数生命周期更长的结构；其二是不具可移植性，而且在没有传统堆栈的机器上很难高效地实现。这是因为当它的返回值直接传入另一个函数时会带来问题。这就决定了alloca()不宜使用在需要广泛移植的程序中，这也是很多人不太提倡使用alloca()的一个原因。 Linux malloc底层实现原理 malloc和free的操作原则 1) 配对使用，避免内存泄漏和多重释放（C语言提供了malloc和free两个系统函数，完成对堆内存的申请和释放。而C++则提供了两个关键字new和delete）。 2) 尽量在同一层上使用，不要像上面那种，malloc在函数中，而free在函数外。最好在同一调用层上使用这两个函数。 3) malloc分配的内存一定要初始化。free后的指针一定要设置为NULL。 注意：new/delete是关键字，效率高于malloc和free。new/delete 主要是用在类对象的申请和释放。申请的时候会调用构造器完成初始化，释放的时候，会调用析构器完成内存清理。 3、new和malloc的区别 属性 new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持。 参数 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。 返回类型 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。 自定义类型 new做两件事：分配内存和调用类的构造函数，new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。 1234//为什么有了malloc还要设计newdelete：调用类的析构函数和释放内存。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。而malloc和free只是分配和释放内存。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。 重载 C++允许重载new/delete操作符，malloc不允许重载。 内存区域 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。 分配失败 new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。 内存泄漏 内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc确不可以。 4、delete和free的区别 new/delete是关键字，而free/malloc是库函数，需要头文件支持;free对应的是malloc；delete对应的是new；free用来释放malloc出来动态内存，delete用来释放new出来的动态内存空间。 无论释放几个空间大小，free只传递指针，多个对象时delete需加[]。数组的时候int* p=(int)malloc(10*sizeof(int)) 释放的时候 free(p)即可；这是因为编译器对malloc做了一些特殊的处理，以保证可以正确释放内存。而当int *p=new int[10]释放的时候应为delete []p，注意[]的作用说明释放的是一个数组的内存，如果delete p则只是释放的p[0]，其余9个int的内存没有释放；这是因为当指明为[]的时候，编译器实际上是做了一个循环来释放这个数组的所有内存。 在类和对象的时候会有很大区别。在使用malloc和free来处理动态内存的时候，仅仅是释放了这个对象所占的内存，而不会调用这个对象的析构函数；使用new和delete就可以既释放对象的内存的同时，调用这个对象的析构函数。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。 共同之处： 它们都是只把指针所指向的内存释放掉了，并没有把指针本身干掉。在free和delete之后，都需要把指向清理内存的指针置为空，即p=NULL，否则指针指向的内存空间虽然释放了，但是指针p的值还是记录的那块地址，该地址对应的内存是垃圾，p就成了“野指针”。同样会使人认为p是个合法的指针，如果程序较长，我们通常在使用一个指针前会检查p！=NULL，这样就起不到作用了。此时如果再释放p指向的空间，编译器就会报错，因为释放一个已经被释放过的空间是不合法的。而将其置为NULL之后再重复释放就不会产生问题，因为delete一个0指针是安全的。 指针和动态申请的内存空间总结如下： 1. 指针消亡了，并不表示它指示的动态内存会自动释放； 2. 动态内存释放掉了，如果这个内存是一个动态对象，则并不表示一定会调用这个对象的析构函数； 3. 动态内存释放掉了，并且调用了析构函数，并不表示指针会消亡或者自动变成了NULL。 c内存存储 在C++中，内存区分为6个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区、代码区； 在C中，C内存区分为5个区堆、栈、全局/静态存储区、常量存储区、代码区 堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。 为什么栈生长方向是从高地址到低地址？最大程度地共用剩余的地址空间，达到利用率的最大化。如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。 快速排序 堆排序 给你100个数找出最大的前五十个 partition 时间复杂度O(n) 最小堆 时间复杂度O(nlgk) (海量数据) mutiset 时间复杂度O(n)空间复杂度O(n) 笔试题： 123456789101112131415161718192021222324252627282930提示：优先写源码，源码有难度可以写伪代码 或 思路。要求：c或c++, 尽量使得时间复杂度较低，写出完整代码。题目：查找元素element在非降序正整数数组a中的最左下标位置,数组大小为size.例子：元素2在数组a[1,1,2,2,4,6,21]的最左位置为2.int searchRange(int *a, int left,int right,int target)&#123;while(left&lt;right)&#123;int middle=(right-left)/2+left;if(a[middle]==target)&#123;middle-=1;while(a[middle]==target)midlle--;return middle+1;&#125;if(a[middle]&lt;target)left=middle+1;elseright=middle-1;&#125;return left;&#125;int find_pos(int* a, int size, int element)&#123;if(size==0)return -1; int leftIndex=searchBoundEqual(a,0,size-1,element); if(leftIndex==size||a[leftIndex]!=target) return -1; return leftIndex;&#125;std::find(a,a+size,target); （六）手写代码一个数组中有多个整数， 其中有两个重复的数字，如何找出来，考虑一下时间复杂度和空间复杂度 给两个字符串A和B，找出A对于B的最长前缀。 单链表逆序 一个链表的连续区间和最大值，及其对应区 数组中，连续和最大的区间 判断一个链表是否有环，并确定环的位置，如何确定两个链表是否有相同的部分 写个小程序，一个数组，长100，里边乱序分布数字1-100，在数组中随机挑选一个位置的数字，将其替换为-1，如何判断，被替换掉的数字是多少？ 跳台阶，一次跳1个，也可以跳2个，问，n个台阶有多少种跳法 dfs bfs dp迷宫 最小圆覆盖 1）任意选取距离最远两点p1、p2，以p1p2做直径画圆； 2）如果所有点都在圆内，则该圆即为包括所有点的最小圆；否则选取圆外一点距离圆心最远点pi,寻找覆盖pi和集合Di-1的最小圆Di=MiniDiskWithPoints({p1，p2，p3......pi-1}，pi)，循环第（2）步直到Di包括所有点，即得到最小包围圆。 123456789101112131415161718Function MiniDiskWithPoints（P，q）Input：由平面上n个点构成的一个集合P，以及另外一个点qOutput：在满足“边界穿过q”的前提下，P的最小包围圆 1.令D1为对应于&#123;p1，q&#125;的最小包围圆 2.for j ← 2 to n 3. do if pj ∈Dj-1 4. then Dj ← Dj-1 5. else Dj ← MiniDiskWithPoints&#123;&#123;p1，p2,p3......pj-1&#125;，pj，pi&#125; 6.return DnFunction MiniDiskWithPoints（P，q1，q2）Input：由平面上n个点构成的一个集合P，以及另外两个点q1，q2Output：在满足“边界穿过q1，q2”的前提下，P的最小包围圆1. 令D0为对应于q1，q2的最小包围圆2. for k ← 1 to n3. do if pk∈Dk-14. then Dk ← Dk-15. else Dk ← q1，q2和pk确定的圆6. return Dn 给定一个无序数组，求这个数组变为有序后相邻元素之差的最大值是多少，要求时间复杂度是O(n) 方法一：排序，计算。时间复杂度O(nlgn)，空间复杂度O(1) 方法二：std::multiset，计算。时间复杂度O(n),空间复杂度O(n) 方法三：桶排序。时间复杂度O(n),空间复杂度O(n) 算法题给定一个长字符串zesfjjk和一个短字符串xsfjx，求短字符串在长字符串中出现的最长部分是什么？sfj 最长公共子字符串 （七）SAP linux命令 查找 vi 保存 修改权限 C语言和c++的区别 c++兼容c。区块（blocks）、语句（statements）、预处理器（preprocessors）、内置数据类型（build-in data types）、数组（arrays）、指针（pointers）等统统来源于c。 c仅支持面向过程，c++还支持面向对象：包含封装、继承、多态三大特性和虚函数、虚函数表指针、虚基类表指针等。 c++包含泛型编程、模板元编程。 c++包含STL。 （八）进程间的通信方式（IPC,inter-Process Communication）同一主机中两个进程间的通信由操作系统决定，不同主机间的通信进程通过网络交换报文进行。 信号：用于通知进程某个事件已经发生 管道：读写操作符合先进先出原则，对于两端的进程而言就是文件，向管道中写入数据时,linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。 无名管道pipe:半双工的通信方式，数据单向流动，只能在具有亲缘关系的进程间使用，从结构上看，无名管道没有文件路径名，不占用文件目录项，因此文件目录结构中的链表不适用于这种文件，它只是存在于打开文件结构中的一个临时文件，依附于进程临时存在。 命名管道FIFO:半双工，数据单向流动，允许无亲缘关系进程间的通信，FIFO是一种永久性的机制，它具有普通的UNIX系统文件名。在系统下可利用mkfifo命令建立永久的管道，除非刻意删除它，否则它将一直保持在系统中。 联系： 1) 通信数据只存在于内存缓冲页面中； 2) 都是半双工通信； 区别： (1)无名管道是无名的，有名管道是有名的； (2)无名管道只能用于父子进程或兄弟进程之间的通信，而有名管道可用于任意两进程之间通信； (3)无名管道是无形的，即无名管道的 inode 结构不是在磁盘上存储的，而是临时生成的，而有名管道的 inode 结点在磁盘上。 消息队列：消息的链表存放在内核中并由消息队列标识符标识，克服了信号传递信息少，管道只能承载无格式字节流以及缓冲器大小受限等缺点，但只有在内核重启时才能删除一个消息队列，内核重启也就是系统重启。 共享内存：最快的IPC方式，映射一段能被其他进程所访问的内存。往往与其他通信机制如信号两两配合使用，来实现进程间的同步和通信。 信号量Semaphore:信号量是一个计数器，可以用来控制多个进程对共享资源的访问。常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 套接字Socket:套接字也是一种进程间通信机制，包括IPC 套接字（即 Unix 套接字）给予进程在相同设备（主机）上基于通道的通信能力；而网络套接字给予进程运行在不同主机的能力，因此也带来了网络通信的能力。IPC 套接字依赖于本地系统内核的支持来进行通信。网络套接字需要底层协议的支持，例如 TCP（传输控制协议）或 UDP（用户数据报协议），包括流套接字（TCP/IP）和数据报套接字（UDP/IP），利用三元组（ip地址，协议，端口）构成套接字；传输层实现端到端的通信，传输层连接的端点叫做套接字。 进程创建fork和vfork 进程描述符task_struct fork后操作系统会复制一个与父进程完全相同的子进程，两个进程共享代码空间，但数据空间相互独立，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别作不同的工作，也就是分岔了。 fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为调用了exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为调用了exec，exec负责读取可执行文件并将其载入地址空间开始运行，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。 fork之后内核会通过将子进程放在队列的前面，以让子进程先执行，因为一般紫禁城都会马上调用exec()函数，这样可以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能会开始向地址空间写入。fork时子进程获得父进程数据空间、堆和栈的复制，所以变量的地址（当然是虚拟地址）也是一样的。每个进程都有自己的虚拟地址空间，不同进程的相同的虚拟地址显然可以对应不同的物理地址。因此地址相同（虚拟地址）而值不同没什么奇怪。具体过程是这样的：fork子进程完全复制父进程的栈空间，也复制了页表，但没有复制物理页面，所以这时虚拟地址相同，物理地址也相同，但是会把父子共享的页面标记为“只读”（类似mmap的private的方式），如果父子进程一直对这个页面是同一个页面，知道其中任何一个进程要对共享的页面“写操作”，这时内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为“可写”，留给另外一个进程使用。 fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别： fork ()：子进程拷贝父进程的数据段、代码段vfork ()：子进程与父进程共享数据段、代码段，子进程不能向地址空间写入。 fork ()父子进程的执行次序不确定vfork 保证子进程先运行，子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，知道子进程退出或执行exec()。 若vfork ()调用exec 或_exit() 之前子进程依赖于父进程的进一步动作，会导致死锁。 现在由于在执行fork()时引入了写时拷贝页并且明确了子进程先执行，vfork()的好处就仅限于不拷贝父进程的页表项了，另外最好不要使用vfork()（如果exec调用失败，试想会发生什么） 进程和线程的区别​ （1）进程是资源分配和调度的一个独立单元，而线程是CPU调度和分派的基本单元​ （2）一个进程至少包括一个线程，并且同一个进程的所有线程共享整个进程的资源，因此线程执行时一般都要进行同步和互斥​ （3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束​ （4）线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的​ （5）进程间通信IPC需要特别的方法，线程间可以直接读写进程数据段（如全局变量）来进行通信。 线程有什么是共享的什么是私有的线程共享的环境包括： 1.进程数据段、代码段 2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯) 3.进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。 线程独立的资源包括： 1.线程ID 2.寄存器组的值 由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。 3.线程的堆栈 堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。 4.线程的错误返回码 由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。 5.线程的信号屏蔽码 6.线程的优先级 注：线程有自己的私有属性线程控制块TCB，进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志。 进程的三种基本状态 就绪状态：当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态就称为就绪状态； 执行状态：当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态； 阻塞状态：正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而进入阻塞状态。引起进程阻塞的事件有很多种，例如，等待I/O完成、申请缓冲区不能满足、等待信号等。 进程三种状态间的转换 执行–&gt;就绪：时间片完；优先级更高的进程占用CPU 就绪–&gt;执行：被调度； 执行–&gt;阻塞：等待事件，io请求； 阻塞-&gt;就绪：io完成 一个进程在运行期间，不断地从一种状态转换到另一种状态，它可以多次处于就绪状态和执行状态，也可以多次处于阻塞状态。A. 就绪—&gt;执行处于就绪状态的进程，当进程调度程序为之分配好了处理机后，该进程便由就绪状态转换为执行状态；B. 执行—&gt;就绪处于执行状态的进程在其执行过程中，因分配给它的一个时间片已经用完而不得不让出处理机，于是进程从执行状态转换为就绪状态；C. 执行—&gt;阻塞正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态；D. 阻塞—&gt;就绪处于阻塞状态的进程，若其等待的事件已经发生，于是进程便从阻塞状态转变为就绪状态。 线程同步 临界区就是访问和操作共享数据的代码段，多个执行线程并发访问同一个资源通常是不安全的。 用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区，读/写锁，条件变量。 内核同步的方法：原子操作、自旋锁、完成变量，信号量，互斥体。1、互斥体:为协调共同对一个共享资源的单独访问而设计的。2、信号量:为控制一个具有有限数量用户资源而设计。3、完成变量:用来通知线程有一些事件已发生，从而启动后继任务的开始。 4、自旋锁：一个被征用的自旋锁使得请求它的线程在等待锁重新可用时自旋（特别浪费处理器时间） 线程间通信：由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）。 进程间的通信则不同，它的数据空间的独立性决定了它的通信相对比较复杂，需要通过操作系统。以前进程间的通信只能是单机版的，现在操作系统都继承了基于套接字（socket）的进程间的通信机制。这样进程间的通信就不局限于单台计算机了，也可以实现不同操作系统间的网络通信，eg.windows和Linux操作系统通过Socket进行进程间通信。 windows进程通信 标准的Windows进程间通信方法有三种：匿名管道、命名管道（又叫FIFO，命名管道可以控制读消息的长度，一个命名管道可以有多个实例，具体通信还是一对一）、邮槽（MailSlot）。共享内存也可用于windows进程通信，但因为其实是Windows“内存映射文件”的一个特殊用法，所以不算作标准的windows进程间通信方法。 对比点 匿名管道 命名管道 邮槽 共享内存 消息格式 字符 二进制 数据包 - 工作模式 半双工 全双工 单向 双向 访问模式 只能在一台机器上 可以跨网络 可以跨网络 只能在一台机器上 通信模式 一对一，父子进程用 一对多，不同进程均可用 广播机制 - windows命名管道和Linux命名管道的区别 对比点 Linux命名管道 Windows命名管道 备注 消息格式 字节流 二进制 windows更牛 工作模式 半双工 全双工 windows更牛 访问模式 只能在一台机器上 可以跨网络 windows更牛 windows线程通信 windows下，一个典型的线程拥有自己的堆栈、寄存器（包括程序计数器PC，用于指向下一条应该执行的指令在内存中的位置），而代码段、数据段、打开文件这些进程级资源是同一进程内多个线程所共享的。因此同一进程的不同线程可以很方便的通过全局变量（数据段）进行通信，使用多线程相对于多进程来说有很多优点： ① 无需跨进程边界； ② 程序逻辑和控制方式简单； ③ 所有线程可以直接共享内存和变量等； ④ 线程方式消耗的总资源比进程方式好； windows多线程通信的方法主要有三种：1.全局变量 由于同一进程下的线程之间共享数据空间。当需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，来告诉编译器这个全局变量是“易变”（更直接的讲是“直接存取原始内存地址”，更明确的说是不要编辑器去读缓存中的数据，而是直接从内存中获取变量的值）的，让编译器不要对这个变量进行优化。 2.Message消息机制常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。 3.CEvent对象 CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。 Linux线程通信 线程间无需特别的手段进行通信，因为线程间可以共享数据结构，也就是一个全局变量可以被两个线程同时使用。不过要注意的是线程间需要做好同步，一般用mutex。 死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？​ (1）相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态​ （2）系统资源不足、相互竞争资源、请求资源顺序不当​ （3）互斥、不可剥夺、循环等待、请求与保持​ （4）因为互斥是不可改变的，所以只能破坏其他三个条件中的一个来解除死锁，方法： 破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中。 破坏”请求与保持条件“：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。 破坏“循环等待”条件：资源有序分配（将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程） （九）SQL 一致性哈希？渐进性哈希？ 一致性哈希是一种特殊的哈希算法，目的是解决分布式缓存的问题。在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表( Distributed Hash Table，DHT) 中存在的动态伸缩等问题。 首先，对存储节点的哈希值进行计算，其将存储空间抽象为一个环，将存储节点配置到环上。环上所有的节点都有一个值。其次，对数据进行哈希计算，按顺时针方向将其映射到离其最近的节点上去。当有节点出现故障离线时，按照算法的映射方法，受影响的仅仅为环上故障节点开始逆时针方向至下一个节点之间区间的数据对象，而这些对象本身就是映射到故障节点之上的。当有节点增加时，比如，在节点A和B之间重新添加一个节点H，受影响的也仅仅是节点H逆时针遍历直到B之间的数据对象，将这些重新映射到H上即可，因此，当有节点出现变动时，不会使得整个存储空间上的数据都进行重新映射，解决了简单哈希算法增删节点，重新映射所有数据带来的效率低下的问题。 渐进性哈希 当hash表满员时（或负载因子高于阈值时）会进行rehash,也就是重新调整空间大小，并拷贝原来的数据。这里rehash就是优化效率的关键。例如假设有1w个元素，rehash时要拷贝1w元素到新的空间，这样势必会成为很大的负担。 redis的数据库使用字典来作为底层实现的，对数据库的增删查改操作也是构建在对字典的操作之上。redis的字典使用hash表作为底层实现。 redis作为一个广泛使用的内存数据库，时间和空间效率都是至关重要的。（redis的根本就是一个大的hashmap，所以对hashmap的优化十分重视） redis采用渐进式rehash优化效率。 何为渐进式rehash？就是把拷贝节点数据的过程平摊到后续的操作中，而不是一次性拷贝。所谓平摊到后续的操作中，就是对节点操作，例如再次插入，查找，删除，修改时都会进行拷贝。 友元函数注意事项 1）必须在类的说明中说明友元函数，说明时以关键字friend开头，后跟友元函数的函数原型，友元函数的说明可以出现在类的任何地方，包括在private和public部分；2）注意友元函数不是类的成员函数，所以友元函数的实现和普通函数一样，在实现时不用”::”指示属于哪个类，只有成员函数才使用”::”作用域符号；3）友元函数不能直接访问类的成员，只能访问对象成员，4）友元函数可以访问对象的私有成员，但普通函数不行；5）调用友元函数时，在实际参数中需要指出要访问的对象，6）友元的声明只能出现在类定义的内部（最好在类定义开始或者结束前的位置集中声明友元），仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，必须在友元声明之外再转名对函数进行一次声明。每个类负责控制自己的友元类或友元函数，友元关系不存在传递性。类与类之间的友元关系不能继承. 模板 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。 模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。 （十一）百度百度B2B后台开发c++/PHP实习 c++中构造函数或析构函数定义为protected 通常将拷贝构造函数和operator=(赋值操作符重载)声明成private，但是没有实现体。这个的目的是禁止一个类的外部用户对这个类的对象进行复制动作。 c++设计模式：参考 （1）工厂模式 简单工厂模式：switch 工厂方法模式：一个工厂抽象接口和多个具体生成对象的工厂。比简单工厂模式多的一点优点就是遵循了开放-封闭原则，使得模式的灵活性更强 抽象工厂模式：客户端要使用时必须知道是哪一个工厂并且是哪一组的产品抽象类。每一个工厂子类负责产生一族产品，而子类的一种方法产生一种类型的产品。在客户端看来只有AbstractProductA和AbstractProductB两种产品，使用的时候也是直接使用这两种产品。而通过工厂来识别是属于哪一族产品。 工厂模式和简单工厂模式要求产品子类必须要是同一类型的，拥有共同的方法，这就限制了产品子类的扩展。于是为了更加方便的扩展，抽象工厂模式就将同一类的产品子类归为一类，让他们继承同一个抽象子类，我们可以把他们一起视作一组，然后好几组产品构成一族。 （2）策略模式 直接通过参数指定，传入一个特定算法的指针（暴露了算法） 直接通过参数指定，只不过不是传入指针，而是一个标签（switch和简单工厂结合） 模板实现 （3）适配器模式：系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要适应于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。 （4）单例模式：由于构造函数是私有的，因此无法通过构造函数实例化，可以通过调用静态成员函数GetInstance在类内部构造实例。用户访问唯一实例的方法只有GetInstance()成员函数。GetInstance()使用懒惰初始化，也就是说它的返回值是当这个函数首次被访问时被创建的。这是一种防弹设计——所有GetInstance()之后的调用都返回相同实例的指针。单例模式通过类本身来管理其唯一实例，唯一的实例是类的一个普通对象，但设计这个类时，让它只能创建一个实例并提供对此实例的全局访问。唯一实例类Singleton在静态成员函数中隐藏创建实例的操作。习惯上把这个成员函数叫做Instance()，它的返回值是唯一实例的指针。参考 （5）原型模式：拷贝构造函数 （6）模板方法模式：定义操作的骨架，依次调用子类实现的函数 （7）建造者模式（直接传入特定类型对象作为参数） 最长回文子串 数组中未出现最小正整数 内存管理 udp为什么会丢包？如何减少丢包？ 1、接收端处理时间过长（接收端采用多线程回调机制或尽量简化处理数据包到重新回到监听状态的中间过程） 2、发送包过大，超过接收者缓存（使用setsocketopt修改接收端缓冲区大小） 3、发送包的频率过高（发送端sleep） 4、网络不稳定或拥塞（改善网络环境或实现丢包处理） TCP/UDP传输的应用 TCP流量控制 拥塞机制：慢启动 拥塞避免 快重传 快恢复 非递归快排 封装、继承、多态的目的 封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用，派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性。 最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种方法的目的了。 磁盘的随机读写和顺序读写 顺序读写：文件指针只能从头移动到尾，SAS机械硬盘主要是看顺序读写性能 随机读写：文件指针可以根据需要随意移动，寻道时间和旋转延迟，SSD固态盘主要看随机读写性能 对称密钥加密和非对称密钥加密的区别 对称密钥：又称私钥加密，即信息的发送方和接收方用一个密钥去加密和解密数据。它的最大优势是加/解密速度快，适合于对大数据量进行加密，但密钥管理困难，安全性低。 非对称密钥加密系统：又称公钥密钥加密，它需要使用一对密钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。公钥机制灵活，安全性高，但加密和解密速度却比对称密钥加密慢得多。 垃圾回收机制 Linux操作系统的主要组成部分：内核，shell,文件系统，应用程序 文件系统索引结构B+树 IO cache 用法 Buffer（缓冲区）是系统两端处理速度平衡（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到流量整形的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。Cache（缓存）则是系统两端处理速度不匹配时的一种折衷策略。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。 常规文件系统操作（调用read/fread/write等类函数）中，函数的调用过程： VFS所隐含的主要思想在于引入了一个通用的文件模型（common file model)，这个模型能够表示所有支持的文件系统。linux内核对每个文件读写操作都必须使用一个指针，指向要访问的具体文件系统的适当函数。换句话说，当应用程序对read()或是write()调用引起内核调用相应的sys_read()或是sys_write()服务例程，文件在内核内存中是由一个file数据结构来表示的。这种数据结构中包含一个称为f_op的字段，该字段中包含一个指向专对某一个文件系统(如sysfs虚拟文件系统)的读写函数指针，sys_read()或是sys_write()查找到指向该函数的指针，并调用它。这样一来，应用程序的read()或是write()就被转化为相对间接的调用： file-&gt;f_op-&gt;read() 或 file-&gt;f_op-&gt;write() 读文件1、进程调用库函数向内核发起读文件请求； 2、内核通过检查进程的文件描述符定位到虚拟文件系统VFS的已打开文件列表表项； 3、调用该文件可用的系统调用函数read() 3、read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode； 4、在inode中，通过文件内容偏移量计算出要读取的页； 5、通过inode找到文件对应的address_space； 6、在address_space中访问该文件的页缓存树，查找对应的页缓存结点： （1）如果页缓存命中，那么直接返回文件内容； （2）如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第6步查找页缓存； 7、文件内容读取成功。 写文件前5步和读文件一致，在address_space中查询对应页的页缓存是否存在： 6、如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。 7、如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。 8、一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘： （1）手动调用sync()或者fsync()系统调用把脏页写回 （2）pdflush进程会定时把脏页写回到磁盘 同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。 将磁盘上的数据缓存在内存中，加速文件的读写。实际上，在一般情况下，read/write是只跟缓存打交道的。read就直接从缓存读数据。如果要读的数据还不在缓存中，则触发一次读盘操作，然后等待磁盘上的数据被更新到磁盘高速缓存中；write也是直接写到缓存里去，然后就不用管了。后续内核会负责将数据写回磁盘。为了实现这样的缓存，每个文件的inode内嵌了一个address_space结构，通过inode-&gt;i_mapping来访问。address_space结构中维护了一棵radix树，用于磁盘高速缓存的内存页面就挂在这棵树上。而既然磁盘高速缓存是跟文件的inode关联上的，则打开这个文件的每个进程都共用同一份缓存。 bitmap 磁盘一亿个数查询target，内存4g linux创建管道命令 1mkfifo [options] NAME #创建有名管道 git命令行 12git branch &lt;name&gt; #创建分支git merge &lt;name&gt; #合并分支 动态链接库和静态链接库的区别:参考 （一）静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，lib中的指令都全部被直接包含在最终生成的exe文件中了（链接器从静态链接库获取所有被引用函数的二进制代码和库一起放到可执行文件中）。但是若使用dll动态链接库，该dll不必被包含在最终的exe文件中，它允许可执行模块（dll或exe文件）仅包含在运行时定位dll函数的可执行代码的所需信息，执行文件执行时可以动态地引用和卸载这个与exe独立的dll文件。如果某个目标文件需要的函数在参与链接的目标文件中找不到的话，链接器就报错了。目标文件中有两个重要的接口来提供这些信息：一个是符号表，另外一个是重定位表。 （二）静态链接库不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。 （三）动态链接库基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，当程序在运行到指定的代码时，去执行共享内存中已经加载的动态库可执行代码，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件,也就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果在当前工程中有多处对dll文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但是如果有多处对lib文件中同一个函数的调用，那么执行时，该函数将在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝。 静态链接的优点 (1) 代码装载速度快，执行速度略比动态链接库快，在程序发布的时候就不需要的依赖库（不需要带着库一块发布），程序可以独立执行； (2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 动态链接的优点 (1) DLL 节省内存，减少页面交换，节省磁盘空间，多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝； (2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性； (3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数； (4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。 静态链接和动态链接的不足之处 (1) 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；如果静态库有更新的话，所有可执行文件都得重新链接才能用上新的静态库，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统死掉 (2) 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。但是由于是运行时加载，可能会影响程序的前期执行性能。 从源程序到执行程序的过程（编译）:参考 预编译 编译：把预编译之后生成的xxx.i或xxx.ii文件，进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成和优化，生成相应的汇编代码文件.s。 汇编：将汇编代码转变成机器可以执行的指令(机器码文件)，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)，还有一个问题——变量a和数组arr的地址还没有确定。 链接：静态链接和动态链接，生成二进制可执行文件.out或.exe 运行：在控制台输入./可执行文件路径或在资源管理器中双击可执行文件就可运行可执行程序，程序实际上是操作系统装载运行的，操作系统能理解程序的二进制文件格式，然后分配程序执行所需的栈空间、代码段、静态存储区、映射堆空间地址等，操作系统会创建一个进程结构体来管理进程，然后将进程放入就绪队列，等待CPU调度运行。 编译器把一个cpp编译为目标文件的时候，除了要在目标文件里写入cpp里包含的数据和代码，还要至少提供3个表：未解决符号表，导出符号表和地址重定向表。 mysql怎么创建索引 （索引是一种高效获取数据库数据的数据结构） ？为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引？ MySQL 提供了三种创建索引的方法： （1）使用 CREATE INDEX 语句 （2）ALTER TABLE （3）CREATE TABLE 为什么B+树（有序数组+平衡多叉树）比B树（有序数组链表+平衡多叉树）更适合文件索引系统？扩展 （1）B+树空间利用率更高，因为B+树的内部节点只是作为索引使用，而不像B树那样每个节点都需要存储硬盘指针。 （2）增删文件（节点）时，效率更高，因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。 百度B2B后台开发c++/PHP提前批 项目整个框架流程 为什么使用音频而不是用上层http传输 技术难点 两道编程题 一道数学题 百度二面： 为什么四次挥手FIN和ACK不能合成一帧？ 因为TCP全双工通信，FIN表示关闭发送但是仍可以接受数据，当服务端收到客户端发的FIN时自己可能还有数据没发完，但是如果收到FIN后不立刻发送ACK，而是等FIN一块发送，客户端会一直超时重传，造成资源浪费。 线程和进程的错误返回码有什么不同 线程和进程的区别和优缺点 线程间通信 线程正确返回0 异常返回非0 进程正确返回非负数 异常返回负数 它们都能提高程序的并发度，提高程序运行效率和响应时间。线程和进程在使用上各有优缺点。 线程执行开销比较小，但不利于资源的管理和保护，而进程相反。 线程共享进程的公有数据，相当于全局变量，本质上就是“共享内存”式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。 线程间的通信方式 # 锁机制：包括互斥锁、条件变量、读写锁*互斥锁提供了以排他方式防止数据结构被并发修改的方法。*读写锁允许多个线程同时读共享数据，而对写操作是互斥的。*条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。# 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量# 信号机制(Signal)：类似进程间的信号处理线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 你必须定义一个 `main()` 函数入口。#include &lt;iostream&gt;using namespace std;class Mall&#123;public: Mall(int n):len(n)&#123; p= (int*)malloc(sizeof(int)*n); &#125; int* p; ~Mall()&#123; if(p!=nullptr)&#123; delete [] p; p=nullptr; &#125; &#125;private: int len; &#125;int main()&#123; Mall point(10); point.p[1] = 1; return 0;&#125;int main()&#123; cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl; return 0;&#125;2.对一个二叉树进行z型遍历，如以下二叉树 1 2 34 5 6 7输出的结果为：1 3 2 4 5 7 queue1 queue21 3 2 root vector&lt;int&gt; traverlse(TreeNode* root)&#123; if(root==nullptr) return vector&lt;int&gt;(); stack&lt;TreeNode*&gt; st1; stack&lt;TreeNode*&gt; st2 vector&lt;stack&lt;TreeNode*&gt;&gt; st&#123;st1,st2&#125;; int flag=0; st[flag].push(root); vector&lt;int&gt; res; while(!st[flag].empty()||!st[flag].empty())&#123; TreeNode* node=st[flag].top(); res.push_back(node.val); st[flag].pop(); if(flag==0)&#123; if(node-&gt;left!=nullptr) st[1-flag].push(node-&gt;left); if(node-&gt;right!=nullptr) st[1-flag].push(node-&gt;right); &#125;else&#123; if(node-&gt;right!=nullptr) st[1-flag].push(node-&gt;right); if(node-&gt;left!=nullptr) st[1-flag].push(node-&gt;left); &#125; if(st[flag].empty())&#123; flag=1-flag; &#125; &#125; return res;&#125;vector&lt;int&gt; traversal(TreeNode* root)&#123; if(root==nullptr)return vector&lt;int&gt;(); deque&lt;pair&lt;TreeNode*,int&gt;&gt; deq; deq.push_back(pair&lt;TreeNode*,int&gt;(root,0)); vector&lt;int&gt; res; vector&lt;int&gt; tmp; int pre=0; while(!deq.empty())&#123; auto node=deq.front(); deq.pop_front(); if(node.second==0)&#123; if(pre==1)&#123; res.resize(res.size()+tmp.size()); copy(tmp.begin(),tmp.end(),res.begin()+res.size()); tmp.clear(); pre=0; &#125; res.push_back(node.first-&gt;val); &#125; else&#123; tmp.insert(tmp.begin(),node.first-&gt;val); pre=1; &#125; if(node.first-&gt;left!=nullptr) deq.push_back(pair&lt;TreeNode*,int&gt;(node.first-&gt;left,1-node.second)); if(node.first-&gt;right!=nullptr) deq.push_back(pair&lt;TreeNode*,int&gt;(node.first-&gt;right,1-node.second)); &#125; return res;&#125; （十二）网易 海量数据找到最小的k个数 123456789101112131415161718//最大堆，时间复杂度O(nlgk),空间复杂度O(k)typedef multiset&lt;int,greater&lt;int&gt;&gt; inSet;void getLeastNumbers(const vector&lt;int&gt;&amp;data,inSet&amp; leastNumbers,int k)&#123; if(k&lt;1 || data.size()&lt;k) return; vector&lt;itn&gt;::const_iterator iter=data.begin(); for(;iter!=data.end();++iter)&#123; if(leastNumbers.size()&lt;k) leastNumbers.insert(*iter); else&#123; if(*iter&lt;*leastNumbers.begin())&#123; leastNumbers.erase(leastNumbers.begin()); leastNumbers.insert(*iter); &#125; &#125; &#125;&#125;//当我们可以修改输入数组时，可用partition函数，时间复杂度为O(n) 重载一个运算符原则： 1.不能改变运算符的初始意义。 2.不能改变运算符的参数数目。如重载运算符+时只用一个操作数是错误的。 3.运算符函数不能包括缺省的参数。 4.绝大部分C++运算符都可以重载，除以下的例外： . :: .* ? 5．除赋值运算符外，其它运算符函数都可以由派生类继承。 6.运算符重载不改变运算符的优先级和结合性，也不改变运算符的语法结构，即单目、双目运算符只能重载为单目、双目运算符。 7.运算符的重载实际上是函数的重载。编译程序对运算符重载的选择，遵循函数重载的选择原则。当遇到不很明显的运算符时，编译程序将去寻找参数匹配的运算符函数。 8.运算符重载可使程序更简洁，使表达式更直观，增强可读性。但使用不宜过多。 9.重载运算符含义必须清楚. 重载的形式:成员函数形式 和 友元函数形式 (1) 一般情况下，单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数。 (2) 以下双目运算符不能重载为类的友元函数：=、()、[]、-&gt;。 (3) 类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。 (4) 若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好。 (5) 若运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则只能选用友元函数。 (6) 当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一 个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部 类型的对象，该运算符函数必须作为一个友元函数来实现。 (7) 当需要重载运算符具有可交换性时，选择重载为友元函数。 二叉树的高度和节点数 具有n个结点的完全二叉树的高度为log(n+1)向上取整，或者(logn)向下取整+1 高度为h完全二叉树最后一层有n+1-2^(h-1)个结点;完全二叉树第k层至多有2^（k-1）个结点满二叉树深度为h，则有2^h-1个结点；第k层的节点数目为2^（k-1） （十三）腾讯腾讯测开实习 static变量？ static函数为什么只能用static变量？ （1）静态成员变量： 静态成员变量属于整个类所有，生命期不依赖于任何对象，为程序的生命周期 可以通过类名直接访问公有静态成员变量，也可以通过对象名访问公有静态成员变量 静态成员变量在类外单独分配空间,变量地址是指向其数据类型的指针 静态成员变量是静态存储的，在程序内部位于全局/静态存储区 static数据成员可以作为成员函数的默认实参。非static数据成员，不能用作成员函数的默认实参，因为它的值不能独立于所属对象而使用。分析：静态数据成员如果未初始化，系统自动会给它初始化为某个缺省值(如int初始化为0, 指针初始化为NULL等)。 所以一旦定义，其值已确定，可以作为类成员函数的缺省参数。当在类的外部定义static成员时，无须重复指定static关键字。static关键字只能用于类定义体内部的声明中，定义不能标示为static。static数据成员必须在类定义体的外部定义。不像普通的数据成员，static成员不是通过类构造函数进行初始化，而是应该在定义时初始化。一般将static数据成员的定义放在包含类的非内联成员函数定义的文件中。 一般的讲，static数据成员和普通数据成员一样，不能在类的定义体中初始化。static数据成员一般在定义时候初始化。这个规则的一个例外是，只要初始化式是一个常量表达式，const static 数据成员就可以在类的定义体中初始化 （2）静态成员函数: 类内使用static修饰的特殊成员函数，属于整个类所有，没有this指针（这就是它仅能访问类的静态数据和静态成员函数的原因）,函数地址类型是个“nonmember 函数指针” 只能直接访问静态成员变量和静态成员函数，调用这个函数不会访问或者修改任何对象非static数据成员 可以通过类名直接访问类的公有静态成员函数，也可以通过对象名访问类的公有静态成员函数 不能将静态成员函数声明为虚函数、const和volatile 其实很好理解，类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，函数地址类型是个“nonmember 函数指针”。static 并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。静态数据成员在&lt;定义或说明&gt;时前面加关键字 static。 静态成员初始化与一般数据成员初始化不同： 初始化在类体外进行，而前面不加 static，以免与一般静态变量或对象相混淆；初始化时不加该成员的访问权限控制符 private、public；初始化时使用作用域运算符来标明它所属类；所以我们得出静态数据成员初始化的格式： 1&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;&#x3D;&lt;值&gt; （3）为何static成员函数不能为virtual static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。 静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有this指针。 虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual.虚函数的调用关系：this -&gt; vptr -&gt; vtable -&gt;virtual function （4）为何static成员函数不能为const函数对于一个定义为const的函数，传递的是const的this指针，说明不能更改对象的属性，而对static成员的函数不需传递this指针，所有就不需要用const来修饰static的成员函数了！就说const属性的作用就是对被传递的this指针加以限定，而对static成员函数的调用根本不传递this指针，所有不需const来修饰static的成员函数~ 从对象模型上来说，类的非static成员函数在编译的时候都会扩展加上一个this参数，const的成员函数被要求不能修改this所指向的这个对象；而static函数编译的时候并不扩充加上this参数，自然无所谓const。 因为const成员函数的const是修饰this所指指物的也就是this将会被声明为const CLASSNAME*。 而static不存在this指针，所以const对static member function的修饰是无效的。 static member怎么看都是活在CLASSNAME NAMESPACE中的普通事物。 volatile的道理也是如此。volatile 与const类似 ，volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。 (9) 为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们又重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。 设置静态成员的目的，是为了将和某些类紧密相关的全局变量和全局函数写到类里面，形式上成为一个整体。使用 sizeof 运算符计算对象所占用的存储空间时，不会将静态成员变量计算在内。对上面的 CRectangle 类来说，sizeof(CRectangle) 的值是 8。 12345678class CRectangle&#123;private: int w,h; static int nTotalArea; //静态成员变量 static int nTotalNumber; //静态成员变量public: static void PrintTotal (); //静态成员函数&#125;; 主键索引和非主键索引的区别？ 非主键索引的叶子节点存放的是主键的值，而主键索引的叶子节点存放的是整行数据，其中非主键索引也被称为二级索引，而主键索引也被称为聚簇索引。 孤儿进程 僵尸进程 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。假如它的父进程没有安装SIGCHLD信号处理函数来处理子进程（也即使wait或者waitpid等待儿子结束），又没有显示忽略该信号，那子进程就会一直保持僵尸状态。只有在父进程结束之后，才由init进程接管子进程，为他收尸（好凄惨啊），这个时候才能说子进程才真正的消失在Linux内核中。 僵尸进程的避免 ⒈父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。 ⒉ 如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler，因为子进程结束后， 父进程会收到该信号，可以在handler中调用wait回收。 ⒊ 如果父进程不关心子进程什么时候结束，那么可以用signal（SIGCHLD,SIG_IGN） 通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收， 并不再给父进程发送信号。 ⒋ 还有一些技巧，就是fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做。 链表的选择排序 二叉树的最长路径和 数独 迷宫 printf函数是从右向左计算入栈，输出顺序从左往右；函数调用参数的时候，从右往左依次执行所有会改变变量数值的式子，遇到后置自增的式子则直接把此时的变量代入，得到该自增式的值。全部执行完成后再从左往右依次把改变后的变量值代入各个除后置自增式以外的所有式子，此时这些式子的值是最终要代入函数的参数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//// Created by anranzhai on 2020/4/17.//#include&lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int i = 3, j = 5; printf(\"%d %d\\n\", (i++) - (--j), j = (i += 2)); printf(\"%d %d\\n\", i, j); int k=1; printf(\"%d %d\\n\",(k++,k++),k); int l=1; printf(\"%d %d\\n\",l,(l++,l++)); int a = 1; printf(\"%d %d %d\\n\", a=11, a++, a++); a = 1; printf(\"%d %d %d\\n\", a, a + 1, a = 3); a = 1; printf(\"%d %d %d\\n\", a++, a++, a = 3); a = 1; printf(\"%d %d %d\\n\", a = 11, a = 22, a = 33); int b=1; printf(\"%d %d\\n\", ++b,++b); printf(\"%d %d\\n\", ++b,b++); vector&lt;int&gt; vec&#123;1,2&#125;; vector&lt;char&gt; v&#123;'a'&#125;; cout&lt;&lt; sizeof(vec)&lt;&lt;endl; cout&lt;&lt; sizeof(v)&lt;&lt;endl; cout&lt;&lt;sizeof(vector&lt;int&gt;)&lt;&lt;endl; cout&lt;&lt; sizeof(vector&lt;bool&gt;)&lt;&lt;endl; string s=\"hello\"; cout&lt;&lt; sizeof(s); return 0;&#125;//输出1 46 42 33 211 2 13 4 34 3 511 11 113 35 32424244032 int i=0;i++=1;//错误，后置源码定义函数返回const int右值++i=1;//正确,前置源码定义函数返回int&amp;左值 sizeof printf(\"%d %d\\n\",(k++,k++),k); //为什么带括号？ &lt;!--￼17--&gt; （十五）快手 容器的选择：vector/deque/list的差别 1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。 vector自定义类的要求 自定义的类必须有默认构造函数，因为vector会调用默认构造函数来初始化元素的对象。编译器隐式声明默认构造函数的条件： · 该类没有显式声明任何构造函数。 · 数据成员中没有const和reference。–因为要初始化，凡是有引用类型的成员变量或者常量类型的变量的类，不能有缺省构造函数。默认构造函数没有对引用成员提供默认的初始化机制，也因此造成引用未初始化的编译错误。并且必须使用初始化列表进行初始化const对象、引用对象。 满足则隐式生成默认构造函数。这里强调“任何”，是指即使用户自定义了复制构造函数或一个需要多个参数的构造函数，默认构造函数也不会被隐式声明了。在定义一个类时要保证有默认的构造函数。同时要求： 1、Copy构造函数：原理 2、赋值=操作符 3、能够销毁对象的析构函数 另外： 1、可用的缺省构造函数，序列型容器必须，用于初始化元素 2、==操作符定义，用于判断相等 3、&lt;操作符定义，关联型容器必须，用于缺省排序 程序状态字PSW(Program Status Word) 指在电脑中，一段包含被操作系统和潜在硬件使用的程序状态信息的内存或硬件区域。一般用一个专门的寄存器来指示处理器状态。在计算机系统中，表明系统运行状态的部件是程序状态字。 程序状态字PSW(Program Status Word)包括的状态位有进位标志位(CF)、结果为零标志位(ZF)、符号标志位(SF)、溢出标志位(OF)、陷阱标志位(TF)、中断使能(中断屏蔽)标志位(IF)、虚拟中断标志位(VIF)、虚拟中断待决标志位(VIP)、I0特权级别(IOPL)。 类型变量所占字节数 算术类型 32 64 bool 1 1 char 1 1 short 2 2 int 4 4 long 4 4 long long 8 8 char* 4 8 float 4 4 double 8 8 指针类型存储的是所指向变量的地址，所以32位机器只需要32bit，而64位机器需要64bit。数据类型占内存的位数实际上与操作系统的位数和编译器（不同编译器支持的位数可能有所不同）都有关，具体某种数据类型占字节数需要编译器根据操作系统位数间进行协调好后分配内存大小。 （十六）华为 字符串分隔符分隔和定义比较函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits/stdc++.h&gt;using namespace std;class Person&#123;public: Person(string s,int n):name(s),cnt(n)&#123;&#125;;public: string name; int cnt;//直接在类内重载&lt;运算符// bool operator&lt; (const Person&amp; two) const&#123;//一定要加const// if(cnt==two.cnt)&#123;// if(name.find(two.name)||two.name.find(name))// return name.length()&lt;two.name.length();// else// return name&lt;two.name;// &#125; else// return cnt&gt;two.cnt;// &#125;&#125;;//在类外设计比较函数类struct Isshort&#123;public://一定要加public，不然编译不过去 bool operator()(const Person&amp; one,const Person&amp; two)&#123; if(one.cnt==two.cnt)&#123; if(one.name.find(two.name)||two.name.find(one.name)) return one.name.length()&lt;two.name.length(); else return one.name&lt;two.name; &#125; else return one.cnt&gt;two.cnt; &#125;&#125;;string getStar(map&lt;string,int&gt; &amp;str)&#123; vector&lt;Person&gt; people; for(auto per:str)&#123; people.emplace_back(per.first,per.second); &#125; sort(people.begin(),people.end(),Isshort());//在函数上直接添加lamda表达式// [](const Person &amp;one,const Person&amp; p)&#123;// if(one.cnt==p.cnt)&#123;// if(one.name.find(p.name)||p.name.find(one.name))// return one.name.length()&lt;p.name.length();// else// return one.name&lt;p.name;// &#125; else// return one.cnt&gt;p.cnt;// &#125;); return (*people.cbegin()).name;&#125;int main() &#123; string s; map&lt;string,int&gt; str;//这样输入无法正常停止，遇见'.'或者换行符'\\n'或者结束符'EOF'才能停止// while(getline(cin,s,','))&#123;// if(s==\"\\n\")// break;// if(s[0]&lt;'A'||s[0]&gt;'Z')&#123;// cout&lt;&lt;00001&lt;&lt;endl;// return 0;// &#125;// for(int i=1;i&lt;s.size();i++)&#123;// if(s[i]&lt;'a'||s[i]&gt;'z')&#123;// cout&lt;&lt;00001&lt;&lt;endl;// return 0;// &#125;//// &#125;// if(str.count(s))// str[s]++;// else// str[s]=1;// &#125; cin&gt;&gt;s; //字符串分隔符的两种办法find和strtok const char* delim=new char(','); char* data=(char*)malloc(s.size()* sizeof(char)); copy(s.begin(),s.end(),data); char* per=strtok(data,delim); while(per!=NULL)&#123; if(*per&lt;'A'||*per&gt;'Z')&#123; cout&lt;&lt;00001&lt;&lt;endl; return 0; &#125; for(auto p=per+1;*p!='\\0';p++)&#123; if(*p&lt;'a'||*p&gt;'z')&#123; cout&lt;&lt;00001&lt;&lt;endl; return 0; &#125; &#125; if(str.count(per)) str[per]++; else str[per]=1; per=strtok(NULL,delim); &#125;// for(auto start=s.begin();start&lt;=s.end();)&#123;// auto it=find(start,s.end(),',');// auto per=s.substr(start-s.begin(),it-start);// if(per[0]&lt;'A'||per[0]&gt;'Z')&#123;// cout&lt;&lt;00001&lt;&lt;endl;// return 0;// &#125;// for(int i=1;i&lt;per.size();i++)&#123;// if(per[i]&lt;'a'||per[i]&gt;'z')&#123;// cout&lt;&lt;00001&lt;&lt;endl;// return 0;// &#125;//// &#125;// if(str.count(per))// str[per]++;// else// str[per]=1;// start=it+1;// &#125; int sum=0; for(auto p:str)&#123; sum+=p.second; &#125; if(sum&lt;=0||sum&gt;=100)&#123; cout&lt;&lt;00001&lt;&lt;endl; return 0; &#125; string star=getStar(str); std::cout &lt;&lt; star&lt;&lt;endl; return 0;&#125; （十七）阿里 可以用数据结构红黑树/哈希表存储五万个数查询是否存在x 数据量众多，哈希表地址冲突怎么办 可以直接添加链表等 c++新特性 虚函数 数组和链表的区别 单向链表 双向链表 析构函数 private 堆栈 二叉树的建立 存储结构 如何用vector实现队列 deque的内存模型：指针数组+vector 简易实现可以使用int值记录头和尾下标 static和const的区别 const定义的常量在超出其作用域之后其空间会被释放。存储在动态区，可以通过取址直接操作指向的内存的值，以绕过编译器对其只读的限制检查；而static定义的静态常量在函数执行后不会释放其存储空间。static修饰的变量作为程序运行时的静态变量，存储于内存的静态区，静态区的数据初始化工作由操作系统在加载完程序后执行main函数前进行。操作系统在加载完程序后，将常量区中存放的变量初值复制给静态变量，完成其初始化。static变量的内存只被分配一次，其值在下次调用时仍维持上次的值。 static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化；static关键字只能用于类定义体内部的声明中，定义时不能标示为static。 const成员变量也不能在类定义处初始化，只能通过 初始化列表进行，并且必须有构造函数，运行期间将不能再对const属性进行修改。 const成员函数主要目的是防止成员函数修改对象的内容。const成员函数不能修改成员变量的值，但可以访问成员变量。 static成员函数主要目的是作为类作用域的全局函数。不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致：1、不能直接存取类的非静态成员变量，调用非静态成员函数2、不能被声明为virtual *static const 和 const static *含义相同，有两种用法，一种是作为预编译声明，一种是作为类的静态常量属性。当作为预编译声明时，static const 属性必须在声明时即指定值，而且类型仅限基本数据类型，保证了程序的健壮性。const static常量存在于内存的常量区，有操作系统加载程序时，加载到内存的常量区。所以可以对其取址，但是不能对该区的内存进行写操作，因为这个区从操作系统级进行了只读限定，任何对该内存区的写操作会导致程序崩溃。 （十八）华为 std::thread 线程的启动 线程库 MySQL内联和外联 给定一个字符串 找出出现频率最高的字符 频率相同比较index小的 输出第一个值 单例的安全性 （十九）腾讯测开 多态用法示例 测试用例举例(测试边界) 用两个栈实现单向队列 TCP与UDP区别总结：1、TCP面向连接（要先通过三次握手建立连接）;UDP是无连接的，即发送数据之前不需要建立连接2、TCP提供可靠的服务，有拥塞控制和流量控制。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付， UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信5、TCP首部开销20字节;UDP的首部开销小，只有8个字节6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是全双工的不可靠信道 哈希算法 指针和引用的区别 指针可以为空，引用不可以为空，引用是对象的别名，定义一个引用的时候必须初始化。因此使用指针之前必须做判空操作，引用就不必，引用是类型安全的，而指针不是。 sizeof引用的大小是所指变量的大小；sizeof指针是指针本身的大小-四个字节。 指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名，引用不改变指向，指针可以，所以有常量指针没有常量引用。自增(++)操作对引用的操作是改变所指对象内容，对指针的操作是使指针指向下一个对象。 引用使用时无需解引用（*）,指针需要解引用。 指针传递和引用传递的区别：参考 传递方式 函数定义 函数调用 函数内对A修改 值传递 fun(int a) fun(x) 外部不变 指针传递 fun(int *a) fun(&amp;x) 外部同步更改 引用传递(c++) fun(int &amp;a) fun(x) 外部同步更改 指针传递本质上是值传递，传递的是一个地址值。被调函数的形参作为被调函数的局部变量处理，是实参指针复制构造的一个临时对象，会在栈中开辟内存空间存放由主调函数传进来的实参值，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行操作。如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。 引用传递，被调函数的形参也作为局部变量在栈中开辟内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。参数的处理是通过一个间接寻址的方式操作到主调函数中的相关变量。 从编译的角度讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后不会再更改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象则不能更改。 指针和引用的区别： （1）引用是别名，创建的同时必须被初始化，一旦被初始化就不能改变引用关系，不能为NULL；指针是变量，独立可变可空 （2）引用是间接寻址；指针是直接寻址 （3）引用有类型检查；指针无类型检查 （二十）美团测开 函数指针和指针函数的区别 函数指针其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。 12345678声明格式：类型说明符 (*函数名) (参数)函数指针是需要把一个函数的地址赋值给它，有两种写法：fun = &amp;Function；fun = Function;取地址运算符&amp;不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。调用函数指针的方式也有两种：x = (*fun)();x = fun(); 指针函数就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。 屏幕适配 屏幕尺寸：手机对角线的物理尺寸 单位：英寸（inch），1英寸=2.54cm Android手机常见的尺寸有5寸、5.5寸、6寸，6.5寸等等 屏幕分辨率：手机在横向、纵向上的像素点数总和 一般描述成屏幕的“宽x高”=AxB 含义：屏幕在横向方向（宽度）上有A个像素点，在纵向方向（高）有B个像素点 例子：1080x1920，即宽度方向上有1080个像素点，在高度方向上有1920个像素点。单位：px（pixel），1px=1像素点 UI设计师的设计图会以px作为统一的计量单位 Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920 屏幕像素密度:每英寸的像素点数 单位：dpi（dots per ich） 假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi 1dpi=(横向分辨率^2+纵向分辨率^2)^(1/2)/屏幕尺寸 屏幕适配的解决方案：参考 1、自定义像素适配：(屏幕真实横纵分辨率/默认横纵分辨率)*所设置的横纵长=适配横纵长 2、百分比适配（添加依赖） 3、修改density实现屏幕适配 4、限定符适配 SQL语句 微信登录测试内容 为什么选测开 支付宝咻咻咻原理 （二十一）中兴捧月模拟大赛 具体负责部分，项目难点 OFDM特性，使用的通信协议 static 静态常量数据成员可以在类内初始化(即类内声明的同时初始化)，也可以在类外，即类的实现文件中初始化，不能在构造函数中初始化，也不能在构造函数的初始化列表中初始化； 静态非常量数据成员只能在类外，即类的实现文件中初始化，也不能在构造函数中初始化，不能在构造函数的初始化列表中初始化； 非静态的常量数据成员不能在类内初始化，也不能在构造函数中初始化，而只能且必须在构造函数的初始化列表中初始化； 非静态的非常量数据成员不能在类内初始化，可以在构造函数中初始化，也可以在构造函数的初始化列表中初始化； inline inline和define的区别 英文自我介绍 （二十二）招银网络 项目线程池使用队列（b站线程池？） char数组构造初始化和strcpy和string转char自动加‘\\0’ 数据成员构造顺序 手撕复制构造函数深拷贝和sql增删改查 （二十三）字节 链表去重 数据结构： (1)单向链表去重 输入：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5 输出：1-&gt;2-&gt;3-&gt;4-&gt;5 (2) 单向链表删除重复项 输入：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5 输出：2-&gt;3-&gt;5 指针pre和cur，遇到重复的节点就直接删除 mysql优化 分区 慢查询优化 按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。对升序的栈进行排序 Stack= [1,4,3,5,2] —&gt; result= [5,4,3,2,1] 1234567891011121314151617181920void sort(stack&lt;int&gt;&amp; s1)&#123; stack&lt;int&gt; s2; s2.push(s1.top()); s1.pop(); while(s1.empty())&#123; if(s1.top()&gt;=s2.top())&#123; s2.push(s1.top()); s1.pop(); &#125;else&#123; int tmp=s1.top(); s1.pop(); while(!s2.empty()&amp;&amp;s2.top()&gt;tmp)&#123; s1.push(s2.top()); s2.pop(); &#125; s2.push(tmp); &#125; &#125;&#125; 给定元素全为非负整数的非空数组nums，数组的度等于出现最多的元素的次数。找到具有和nums相同度的连续子串的最小长度。数组的度 Input:[1,5,5,3,5,1] Output:4 12345678910111213141516171819202122int count(std::vector&lt;int&gt; nums)&#123; std::map&lt;int,vector&lt;int&gt;&gt; indexmap; std::map&lt;int,int&gt; cntmap; int max=INT32_MIN; for(int i=0;i&lt;nums.size();i++)&#123; if(!cntmap.count(nums[i]))&#123; indexmap[nums[i]].push_back(i); indexmap[nums[i]].push_back(i); &#125;else indexmap[nums[i]][1]=i; cntmap[nums[i]]++; max=std::max(max,cntmap[nums[i]]); &#125; int len=INT32_MAX; for(auto&amp; cnt:cntmap)&#123; if(cnt.second==max)&#123; len=std::min(len,indexmap[cnt.first][1]-indexmap[nums[cnt.first]][0]); &#125; &#125; return len;&#125; 项目介绍 技术难点 堆栈实现队列 push pop count 对字节的了解 对未来的规划 概率题：a赢2局结束；b赢3局结束。ab赢的概率都是0.5。求a,b赢的概率 （二十四）小米一面 智能指针 智能指针相对裸指针的优点 双重检验锁的必要性 c++内存管理 重点分区 堆（从低到高）栈（从高到低） 看过哪些书 面试官自己对部门的介绍 想在哪工作 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;//懒汉模式class MyInstance&#123;public: static shared_ptr&lt;MyInstance&gt; getInstance()&#123; if(myinstance==nullptr)&#123; lock_guard&lt;mutex&gt; lt(mutex); if(myinstance==nullptr)&#123; myinstance=make_shared&lt;MyInstance&gt;(); &#125; &#125; return myinstance; &#125; ~MyInstance()&#123; &#125;private: MyInstance()&#123;&#125; mutex mt; static shared_ptr&lt;MyInstance&gt; myinstance;&#125;int main() &#123; //int a; //cin &gt;&gt; a; cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;&#125; （二十五）知识点 linux内存管理 虚拟内存 物理内存：Linux内核管理物理内存是通过分页机制实现的 内置类型和复合类型 内置类型包括算术类型和空类型。算术类型分为整型和浮点型，其中整型包括字符型和布尔型。 复合类型主要包括：引用、指针、数组。 git log kill进程是进程通信：linux内核发送SIGKILL信号给进程 windows消息驱动机制和时间驱动机制 Linux设备驱动机制 字符设备 块设备 网络设备 同学分享的字节二面编程题：1、求36进制的和 2、判断树是否对称 堆排序是原地算法，空间复杂度O(1)。堆在逻辑上是特殊的完全二叉树，在存储结构上是顺序表。一般用数组实现。堆只分为大堆和小堆大堆：树的父亲节点必须比它的叶子节点大；小堆：树中父亲节点比它的叶子小，只有这两种特殊的情况下一个数组才能被称为堆。 自底向上构建堆时间复杂度O（n）：从最后一个非叶子结点开始循环遍历直到根结点 12345void createHeap(int n)&#123; for (int i = n/2; i != 0; i--) sink(n, i);&#125; 自顶向下构建堆时间复杂度O（nlogn）：从根结点开始 12345void createHeap(int n)&#123; for(int i=1;i&lt;=n;i++) swim(i);&#125; 常见数据结构的查找、插入、删除时间复杂度 数据结构 访问 查找 插入 删除 数组 O(1) O(n) O(n) O(n) 有序数组 O(1) O(logn) O(n) O(n) 链表 O(n) O(n) O(1) O(1) 有序链表 O(n) O(n) O(n) O(1) 二叉查找树 O(logn) O(logn) O(logn) O(logn) 哈希表 — O(1) O(1) O(1) 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出fact(1000)。 1234def fact(n): if n==1: return 1 return n * fact(n - 1) **尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。** 上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，主要是要把每一步的乘积传入到递归函数中： 1234567def fact(n): return fact_iter(n, 1)def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) **栈帧** 每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数的返回地址和局部变量。 栈帧也叫过程活动记录，是编译器用来实现过程/函数调用的一种数据结构。从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等。 栈是从高地址向低地址延伸的。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着所需要的各种信息。寄存器ebp指向当前的栈帧的底部（高地址），寄存器esp指向当前的栈帧的顶部（低地址）。 注意：EBP指向当前位于系统栈最上边一个栈帧的底部，而不是系统栈的底部。严格说来，“栈帧底部”和“栈底”是不同的概念;ESP所指的栈帧顶部和系统栈的顶部是同一个位置。 递归时间复杂度 master公式： T [n] = aT[n/b] + f (n)（直接记为T [n] = aT[n/b] + T (N^d)） 其中 a &gt;= 1 and b &gt; 1 是常量，其表示的意义是n表示问题的规模，a表示递归的次数也就是生成的子问题数，b表示每次递归是原来的1/b之一个规模，f（n）表示分解和合并所要花费的时间之和。 解法：①当d&lt;logb a时，时间复杂度为O(n^(logb a))②当d=logb a时，时间复杂度为O((n^d)*logn)③当d&gt;logb a时，时间复杂度为O(n^d) struct和class的区别 默认成员访问说明符：struct-public;class-private 默认派生访问说明符: struct-public;class-private 构造函数不同：（1）结构体不能包含显示地无参数构造函数，在自定义构造函数中必须为所有成员赋值。结构体成员将自动初始化为它们的默认值。（2）结构体不能包含以下形式的初始值设定类：base(argument-list) 关于使用大括号初始化 当struct和class中都定义了构造函数，就不能使用大括号对其进行初始化;若没有定义构造函数，struct可以使用{ }进行初始化，而只有当class的所有数据成员及函数为public时，可以使用{ }进行初始化;所以struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。 class能用于表示模板类型；struct不能 注意：c++ struct能包含成员函数；struct能继承；struct能实现多态 在面向c的过程中，struct是值类型，栈中创建（栈资源却很有限，因此struct常用来处理作为基类型对待的小对象）；class是引用类型，堆中创建;struct不能包含任何函数，无继承，无多态;对于结构体中的实例字段成员，不能在声明时赋值初始化;可以直接使用大括号对所有数据成员进行初始化 1234567struct test&#123; int a; int b;&#125;;//初始化test A=&#123;1,2&#125;;//完全可以 两种通用的遍历树的策略 深度优先搜索（DFS） 采用深度作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回根到达另一个分支。深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为前序遍历，中序遍历和后序遍历。 宽度优先搜索（BFS） 按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。 std::funtion和std::bind参考 函数对象：定义了调用操作符（）的类对象。 1234567891011121314151617181920212223242526272829303132class Sort &#123; public: bool operator() (const string &amp;str1, const string &amp;str2) const //带两个参数 &#123; return str1 &gt; str2; &#125; &#125;; 然后我们可以用这个类作为参数来初始化set容器：set&lt;string, Sort&gt; myset; //带比较函数的set构造函数,并用函数对象Sort初始化myset.insert(\"A\"); myset.insert(\"B\"); //输出为：B，A。class Upper &#123; public: Upper(int min = 0):m_min(min)&#123;&#125; bool operator() (int value) const &#123; return value &gt;= m_min; &#125; private: int m_min; &#125;; 从而这样调用 find_if 函数：find_if( dest.begin(), dest.end(), Upper(10) );首先生成类 Upper 的对象，并用 10 初始化，调用find_if 时将用该函数对象进行判断。 解决hash冲突的三种方法 哈希函数的构造方法很多，常用的有直接定址法、数字分析法、平方取中法、折叠法、除留余数法、随机数法等，一般常用除留余数法。 开放地址法：线性探测、二次探测 链地址法：又称拉链法，将所有具有相同哈希地址的而不同关键字的元素连接到同一个单链表中。如果选定的哈希表长度为m，则可以将哈希表定义为一个有m个头指针组成的指针数组。 再散列法：有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。 建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表 文件描述符、打开文件描述符表、文件表、inode节点 在内核中每一个打开的文件都需要由3种数据结构来进行维护： 1）每个进程对应一张打开文件描述符表，这是进程级数据结构，也就是每一个进程都各自有这样一个数据结构； 2）内核维持一张打开文件表，文件表由多个文件表项组成，这是系统级数据结构，也就是说这样的数据结构是针对于整个内核而言的，每个进程都可共享的； 3.每个打开的文件对应一个i节点（i-node）数据结构（Linux下只有i节点没有v节点），由于这是每一个打开的文件与之对应的，因此这也是一个系统级数据结构，存在于内核中，非进程所独有。 不同进程打开现存文件或新建文件时，内核会返回一个文件描述符（file descriptor），它是个非负整数。对于每一个进程，都会分配一个PCB数据结构，它其中包含了该进程的所有信息，而在代码实现上，这个数据结构名为task_struct， 在task_struct中，有一个成员变量名为files，这是一个描述打开文件信息的变量，其类型为struct files_struct *。在所有进程的PCB（Process Control Block）中均会保存一份打开文件描述符表，实际上就是files_struct 中的成员struct file * fd_array[NR_OPEN_DEFAULT]它是一个指针数组，数组每一个元素都是一个指向file类型的指针，可想而知，这些指针都会指向一个打开的文件，并且file这一数据结构就是用来描述一个打开的文件的，而我们所说的文件描述符，实际上就是这个指针数组的索引。这也是为什么文件描述符是非负整数。文件描述符就是这个表的索引（数组下标），每个表项都有一个指向已打开文件的指针（数组的内容），具体是指向文件表中该文件对应的表格项。 在Linux系统中，已打开的文件形成打开文件表（open file table），存放在内核空间（系统级）中，并由系统里的所有进程共享。该表中每个表格保存了一个打开文件的全部信息，如下所示： 当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）； 打开文件时所使用的状态标识（即，open()的flags参数）；文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）； 与信号驱动相关的设置； 对该文件i-node对象的引用； 文件类型（例如：常规文件、套接字或FIFO）和访问权限； 一个指针，指向该文件所持有的锁列表； 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳； 文件表项的数据结构就是file结构体，而在实际上内核中也并不存在这样一张文件表，只是每个打开的文件都对应一个file结构体，也就是一个文件表项，打开文件描述符表**struct file * fd_array[NR_OPEN_DEFAULT]**数组中的每一项都会指向这样一个文件表项。 文件描述符是一个POSIX标准下的概念，为系统调用接口，常见于Linux系统。Windows也是声称遵循POSIX标准的，所以Windows也有文件描述符等概念，但不常用。文件描述符的分配规则： 从当前未被分配的最小整数处分匹配，特别的有：标准输入（stdin）的文件描述符是 0；标准输出（stdout）的文件描述符是 1；标准错误（stderr）的文件描述符是 2。 通过inode结构，可以知道文件数据块的在磁盘上的位置以及文件大小等信息，这样才能使得进程能够通过file结构体来找到磁盘上相应文件的位置来进行文件读写。理解inode，要从文件储存说起。文件存储在硬盘上，硬盘的最小存储单位叫做“扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。操作系统读取硬盘的时候，不会一个个扇区的读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。这种由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的是4KB，即连续八个sector组成一个block。文件数据都储存在“块”中，那么很显然，我们还必须找到一个地方储存文件的“元信息”，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode即，即索引节点。 注意： 同一个进程的不同文件描述符可以指向同一个文件； 不同进程可以拥有相同的文件描述符； 不同进程的同一个文件描述符可以指向不同的文件（一般也是这样，除了 0、1、2 这三个特殊的文件）； 不同进程的不同文件描述符也可以指向同一个文件。 查找路由器地址 123netstatip routeroute const/static/inline默认内部链接（内部链接的符号不能在别的编译单元中使用），若要实现共享，则要定义于头文件；函数和变量默认外部链接（外部链接的符号在整个程序范围内都是可以使用的，这就要求其他编译单元不能导出相同的符号（不然就会报duplicated external symbols） read/write/fsync和fread/fwrite/fflush都是对文件进行操作，那她们有什么区别呢 read/write和fread/fwrite区别 fread是带缓冲的,read不带缓冲. fopen是标准c里定义的,open是POSIX中定义的. fread可以读一个结构.read在Linux/unix中读二进制与普通文件没有区别. fopen不能指定要创建文件的权限.open可以指定权限. fopen返回指针,open返回文件描述符(整数). linux/unix中任何设备都是文件,都可以用open,read. 如果文件的大小是8k。 你如果用read/write，且只分配了2k的缓存，则要将此文件读出需要做4次系统调用来实际从磁盘上读出。 如果你用fread/fwrite，则系统自动分配缓存，则读出此文件只要一次系统调用从磁盘上读出。 也就是用read/write要读4次磁盘，而用fread/fwrite则只要读1次磁盘。效率比read/write要高4倍。 如果程序对内存有限制，则用read/write比较好。 都用fread 和fwrite,它自动分配缓存,速度会很快,比自己来做要简单。如果要处理一些特殊的描述符,用read 和write,如套接口,管道之类的 系统调用write的效率取决于你buf的大小和你要写入的总数量，如果buf太小，你进入内核空间的次数大增，效率就低下。而fwrite会替你做缓存，减少了实际出现的系统调用，所以效率比较高。 read/write/fsync： linux底层操作； 内核调用， 涉及到进程上下文的切换，即用户态到核心态的转换，这是个比较消耗性能的操作。 fread/fwrite/fflush： c语言标准规定的io流操作，建立在read/write/fsync之上 在用户层， 又增加了一层缓冲机制，用于减少内核调用次数，但是增加了一次内存拷贝。 fflush和fsync的联系和区别 1.提供者fflush是libc.a中提供的方法，fsync是系统提供的系统调用。 2.原形fflush接受一个参数FILE *.fflush(FILE *);fsync接受的时一个Int型的文件描述符。fsync(int fd); 3.功能fflush:是把C库中的缓冲调用write函数写到磁盘[其实是写到内核的缓冲区]。fsync：是把内核缓冲刷到磁盘上。 c库缓冲—–fflush———〉内核缓冲——–fsync—–〉磁盘 补充： 对于输入设备，调用fsync/fflush将清空相应的缓冲区，其内数据将被丢弃; 对于输出设备或磁盘文件，fflush只能保证数据到达内核缓冲区，并不能保证数据到达物理设备, 因此应该在调用fflush后，调用fsync(fileno(stream))，确保数据存入磁盘。","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"C++易混点","slug":"C-易混点","date":"2020-03-24T06:44:02.000Z","updated":"2020-08-22T16:48:53.460Z","comments":true,"path":"2020/03/24/C-易混点/","link":"","permalink":"http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/","excerpt":"（一）虚函数表指针、虚基类表指针 非虚继承时，不需要额外增加虚函数表指针。单继承：一个虚函数表，一个虚表指针；多继承：子类的虚表指针数=父类数。 虚继承时：无论是单虚继承还是多虚继承，需要有一个虚基类表来记录虚继承关系，所以此时子类有且仅有一个虚基类表指针；多虚继承时子类可能持有多个虚函数表：如果子类没有构造函数和析构函数，且子类中的虚函数都是在父类中出现的虚函数，这个时候不需要增加任何虚表指针，只需要像多继承那个持有父类个数的虚函数表指针来标识即可。","text":"（一）虚函数表指针、虚基类表指针 非虚继承时，不需要额外增加虚函数表指针。单继承：一个虚函数表，一个虚表指针；多继承：子类的虚表指针数=父类数。 虚继承时：无论是单虚继承还是多虚继承，需要有一个虚基类表来记录虚继承关系，所以此时子类有且仅有一个虚基类表指针；多虚继承时子类可能持有多个虚函数表：如果子类没有构造函数和析构函数，且子类中的虚函数都是在父类中出现的虚函数，这个时候不需要增加任何虚表指针，只需要像多继承那个持有父类个数的虚函数表指针来标识即可。 如果子类中含有构造函数或者析构函数或二者都有，则在子类中只要出现一个父类中的虚函数则需要增加一个虚函数表指针来标识此类的虚函数表；无论是否含有构造函数或者虚构函数，只要继承都是虚继承且出现了父类中没有出现的虚函数，则在子类中需要再增加一个虚函数表指针；如果其中有一个是非虚继承，则按照最省空间的原则，不需要增加虚函数表指针，因为这个时候可以和非虚基类共享一个虚函数表指针。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//32位系统指针占四字节 64位系统指针占8字节，本题按32位系统class Base1&#123;int a;public:virtual void fun1()&#123;cout &lt;&lt; \"Base1::fun1\" &lt;&lt; endl;&#125;&#125;;class Base2&#123;int b;public:virtual void fun1()&#123;cout &lt;&lt; \"Base2::fun1\" &lt;&lt; endl;&#125;virtual void fun2()&#123;cout &lt;&lt; \"Base2::fun2\" &lt;&lt; endl;&#125;&#125;;class Derive1 : public Base1&#123;int d1;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive1::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive1::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive2 : virtual public Base1&#123;int d2;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive2::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive2::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive3 : virtual public Base2&#123;int d3;int add;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive3::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive3::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive4 : public Derive2, public Derive3&#123;int d4;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive4::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive4::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive5 : public Base1, public Base2&#123;virtual void d_fun()&#123;cout &lt;&lt; \"Derive5::d_fun\" &lt;&lt; endl;&#125;&#125;;//输出结果为：pstr1为虚函数表指针，vpstr为虚基类表指针sizeof(Base1):8 //sizeof(int) + sizeof(pstr) = 4+4sizeof(Base2):8 //同上sizeof(Derive1):12 //sizeof(int) + sizeof(pstr) + sizeof(int)= 4+4+4sizeof(Derive2):20 //sizeof(int) + sizeof(Base1的pstr) +sizeof(Derive2的pstr) + sizeof(vpstr)+ sizeof(int)= 4+4+4+4+4sizeof(Derive3):24 //sizeof(int) + sizeof(int) + sizeof(Base1的pstr) +sizeof(Derive2的pstr) + sizeof(vpstr)+ sizeof(int)= 4+4+4+4+4+4sizeof(Derive4):44 //sizeof(Derive2) + sizeof(Derive3) + sizeof(int)sizeof(Derive5):16 //sizeof(Base1) + sizeof(Base2) （二）万能头文件基本上所有的代码只要用了这个头文件就不再写其他头文件了。 #include&lt;bits/stdc++.h&gt;包含了目前c++所包含的所有头文件。 （三）加速c++123456static const auto _ = []()&#123; `std :: ios_base :: sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr;&#125;(); ​ iostream默认是与stdio关联在一起的，以使两者同步，因此消耗了iostream不少性能。C++中的std :: cin和std :: cout为了兼容C，保证在代码中同时出现std :: cin和scanf或std :: cout和printf时输出不发生混乱，所以C++用一个流缓冲区来同步C的标准流。通过std :: ios_base :: sync_with_stdio函数设置为false后可以解除这种同步，让std :: cin和std :: cout不再经过缓冲区，iostream的性能就会提高了很多倍。因此，当解除同步之后，注意不要与scanf和printf混用以免出现问题 ​ tie是将两个stream绑定的函数，空参数的话返回当前的输出流指针。std :: cin默认是与std :: cout绑定的，所以每次操作的时候都要调用flush，这样增加了IO的负担，通过tie(nullptr)来解除std :: cin和std :: cout之间的绑定，进一步加快执行效率。 （四）运算符优先级 ！= 优于 &amp; 。 （五）c++11新特性：参考1、nullptr关键字 解决二义性问题，专门用来区分空指针和0。 2、auto关键字 用于从初始化表达式中推断出变量的数据类型。 auto定义变量时必须初始化（类似引用） auto作为函数返回值时，只能用于定义函数，不能用于声明函数 不允许使用auto定义函数参数 不允许使用auto定义struct/class的成员变量 不允许使用auto定义数组 不允许使用auto作为模板参数传递 12auto i = 5; // i 被推导为 intauto arr = new auto(10) // arr 被推导为 int * 3、decltype 关键字decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。编译器分析表达式并得到它的类型，却不实际计算表达式的值。如果给变量加上了一层括号，编译器会把它当作一个表达式，得到的则是引用类型。 123456int i = 10;float j = 5.1;decltype(i) a; // a的类型是intdecltype((i)) b = i; // b的类型是int&amp;，必须为其初始化，否则会编译报错decltype(i+j) c; // c的类型是int+float =&gt; float 4、新式函数声明C++11 引入了一个叫做拖尾返回类型（trailing return type），利用 auto 关键字将返回类型后置。 1234template&lt;typename T, typename U&gt;auto add(T x, U y) -&gt; decltype(x+y) &#123; return x+y;&#125; 5、基于范围的 for 循环 123for(auto &amp;i : arr) &#123; std::cout &lt;&lt; i &lt;&lt; std::endl;&#125; 6、Lambda表达式 如果mutable,exception,attribute,return type四者只要一种出现，小括号()不可省略，均不出现则可省略。 1234567891011121314151617181920212223[capture] (parameters) opt-&gt; return-type &#123; body&#125;;void noreturnfun() __attribute__((noreturn));//函数不会返回。1. capture是捕获列表； 1).[]不捕获任何变量 2).[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获） 3).[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获) 4).[=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量 5).[bar]按值捕获bar变量，同时不捕获其他变量 6).[this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限 如果已经使用了&amp;或者=，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量2. parameters是参数表；(选填) 3. opt是函数选项；可以填mutable,exception,attribute（选填） 1).mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法 2).exception说明lambda表达式是否抛出异常以及何种异常 3).attribute用来声明属性，GCC使用__attribute__关键字来描述函数，变量和数据类型的属性，用于编译器对源代码的优化。attribute语法格式为：_attribute_ ((attribute-list))4. return-type是返回值类型（拖尾返回类型）(选填) 5. body是函数体 7、std::function/std::bind封装可执行对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Test.hclass Test&#123;public: void Add(std::function&lt;int(int, int)&gt; fun, int a, int b) &#123; int sum = fun(a, b); std::cout &lt;&lt; \"sum:\" &lt;&lt; sum &lt;&lt; std::endl; &#125;&#125;;main.cppint add(int a, int b)&#123; std::cout &lt;&lt; \"add\" &lt;&lt; std::endl; return a + b;&#125;class TestAdd&#123;public: int Add(int a, int b) &#123; std::cout &lt;&lt; \"TestAdd::Add\" &lt;&lt; std::endl; return a + b; &#125;&#125;;int main()&#123; Test test; test.Add(add, 1, 2); TestAdd testAdd; test.Add(std::bind(&amp;TestAdd::Add, testAdd, std::placeholders::_1, std::placeholders::_2), 1, 2); return 0;&#125;运行结果：addsum:3TestAdd::Addsum:3解释：std::bind第一个参数为对象函数指针，表示函数相对于类的首地址的偏移量；testAdd为对象指针；std::placeholders::_1和std::placeholders::_2为参数占位符，表示std::bind封装的可执行对象可以接受两个参数。我们的Test函数在函数指针和类对象函数中，两种情况下都完美运行。 8、初始化列表 123456789#include &lt;initializer_list&gt;class Magic &#123;public: Magic(std::initializer_list&lt;int&gt; list) &#123;&#125;&#125;;Magic magic = &#123;1,2,3,4,5&#125;;std::vector&lt;int&gt; v = &#123;1, 2, 3, 4&#125;; 9、STL容器 std::array&lt;类型，容量&gt;，相对于数组增加了迭代器 std::forward_list单向链表，链表在对数据进行插入和删除是比顺序存储的线性表有优势，因此在插入和删除操作频繁的应用场景中，使用list和forward_list比使用array、vector和deque效率要高很多。 std::unordered_map与std::map用法基本差不多，但STL在内部实现上有很大不同，std::map使用的数据结构为红黑树，而std::unordered_map内部是哈希表的实现方式，哈希map理论上查找效率为O(1)。但在存储效率上，哈希map需要增加哈希表的内存开销。 std::unordered_set的数据存储结构也是哈希表的方式结构，除此之外，std::unordered_set在插入时不会自动排序，这都是std::set表现不同的地方。 10、多线程 std::thread为C++11的线程类，使用方法和boost接口一样非常方便，同时得益于C++11的可变参数的设计风格，C++11的std::thread还解决了boost::thread中构成参数限制的问题：如果线程需要绑定的函数有参数则需要使用boost::bind。比如想使用 boost::thread创建一个线程来执行函数：void f(int i)，如果这样写：boost::thread thrd(f)是不对的，因为thread构造函数声明接受的是一个没有参数且返回类型为void的型别，而且不提供参数i的值f也无法运行，这时就可以写：boost::thread thrd(boost::bind(f,1))。涉及到有参函数的绑定问题基本上都是boost::thread、boost::function、boost::bind结合起来使用。 std::atomic为C++11封装的原子数据类型，在多线程中用户不必对其添加互斥资源锁的类型，其内部已自己加了锁。 C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到被唤醒再从新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。 11、智能指针内存管理 12345678910111213shared_ptr&lt;Foo&gt; factory(T arg)&#123; return make_shared&lt;Foo&gt;(arg);&#125;void use_factory(T arg)&#123; shared_ptr&lt;Foo&gt; p=factory(arg); //使用p&#125;//p离开了作用域，它指向的内存会被自动释放掉auto use_factory(T arg)&#123; shared_ptr&lt;Foo&gt; p=factory(arg); //使用p return p;//当我们返回p时，引用计数进行了递增操作&#125;//p离开了作用域，它指向的内存不会被自动释放掉 C++11新增了std::shared_ptr（共享）、std::weak_ptr（弱引用，指向管理的对象，不会增加引用计数）、std::unique_tr(独占)等类型的智能指针，用于解决内存管理的问题，更容易安全的使用动态内存。 12、右值引用于std::move 右值引用 (Rvalue Referene) 是 C++ 新标准 中引入的新特性 , 它实现了移动语义 (Move Sementics) 和完美转发 (Perfect Forwarding)。它的主要目的有两个方面： 1）消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 2）能够更简洁明确地定义泛型函数。 左值持久；右值短暂 左值：非临时对象，要么是字面常量，要么是在表达式求值过程中创建的临时对象右值：临时的对象， 右值引用的转移语义和完美转发 13、模板增强 外部模板扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化。 类型别名模板 在传统 C++中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效。 12345template &lt;typename T&gt;using NewType = SuckType&lt;int, T, 1&gt;; // 合法template&lt; typename U&gt;typedef SuckType&lt;std::vector&lt;int&gt;, U, 1&gt; NewType; // 不合法 默认模板参数 1234template&lt;typename T = int, typename U = int&gt;auto add(T x, U y) -&gt; decltype(x+y) &#123; return x+y;&#125; 14、构造函数 委托构造 C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的 1234567891011class Base &#123;public: int value1; int value2; Base() &#123; value1 = 1; &#125; Base(int value) : Base() &#123; // 委托 Base() 构造函数 value2 = 2; &#125;&#125;; 继承构造 在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明 123456789101112131415161718192021222324252627282930struct A&#123; A(int i) &#123;&#125; A(double d,int i)&#123;&#125; A(float f,int i,const char* c)&#123;&#125; //...等等系列的构造函数版本&#125;；struct B:A&#123; B(int i):A(i)&#123;&#125; B(double d,int i):A(d,i)&#123;&#125; B(folat f,int i,const char* c):A(f,i,e)&#123;&#125; //......等等好多个和基类构造函数对应的构造函数&#125;； //c++11的继承构造struct A&#123; A(int i) &#123;&#125; A(double d,int i)&#123;&#125; A(float f,int i,const char* c)&#123;&#125; //...等等系列的构造函数版本&#125;；struct B:A&#123; using A::A; //关于基类各构造函数的继承一句话搞定 //......&#125;； 15、虚函数的 override 和 final 指示符 override，表示函数应当重写基类中的虚函数 final，表示派生类不应当重写这个虚函数 16、static_assert() 静态断言 C提供的assert()只能在运行时断言 C++11/14 提供的static_assert()可以在编译期断言 （六）十大经典排序算法：参考 冒泡排序 123456789template&lt;typename T&gt; //整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符void bubble_sort(T arr[], int len) &#123; int i, j; for (i = 0; i &lt; len - 1; i++) //注意限制条件j&lt;len-1-i for (j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) swap(arr[j], arr[j + 1]);&#125; 快速排序 插入排序 选择排序 堆排序 归并排序 自顶向下 自底向上：注意底层达不到整数倍length的数据部分 （七）重点知识点 printf 从右向左计算，从左向右输出，符合栈模型 类中变量赋值顺序是变量声明顺序，所以赋值时先执行a(b)，再执行b(i+1)。a赋值为随机数 1234567891011121314class base1&#123; private: int a,b; public: base1 ( int i ) : b(i+1),a(b)&#123;&#125; base1():b(0),a(b)&#123;&#125; int get_a()&#123;return a;&#125; int get_b()&#123;return b;&#125;&#125;;int main()&#123; base1 obj1(11); cout&lt;&lt;obj1.get_a()&lt;&lt;endl&lt;&lt;obj1.get_b()&lt;&lt;endl; return 0;&#125; static 与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。Static修饰的成员函数，在代码区分配内存。 C++多态分为静态多态和动态多态 静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。 C++里面‘/’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。 派生访问说明符 public继承 公有继承时，对基类的公有成员和保护成员的访问属性不变，派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员。派生类的对象只能访问派生类的公有成员（包括继承的公有成员），不能访问派生类和继承基类的保护成员和私有成员。 protected继承 保护继承中，基类的公有成员和保护成员被派生类继承后变成保护成员，派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员。派生类的对象只能访问派生类的公有成员，不能访问继承基类的公有成员、保护成员和私有成员。 private继承 私有继承时，基类的公有成员和保护成员都被派生类继承下来之后变成私有成员，派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员。派生类的对象只能访问派生类的公有成员，不能访问继承基类的公有成员、保护成员和私有成员。 C++枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别 限定作用域的枚举类型的一般形式和不限范围的枚举类型不同 1234567891011121314151617//非限定作用域enum color&#123; red, green, blue&#125;;color b=green;int c=blue; //正确//限定作用域enum class color:char&#123; red, green, blue&#125;;color a=color::green;char d=color:blue; //错误，限定作用域的枚举类型不能用于初始化int类型的实体 限定作用域的枚举类型不能再作用域外访问枚举成员,必须显示地访问枚举成员，限定作用域的枚举型别带来的名字空间污染降低；不限范围的枚举型别可以 从限定作用域枚举型别到任何其他型别都不存在隐式转换路径（可实施强制型别转换）；不限范围的枚举型别可以 限定作用域的枚举型别和不限范围的枚举型别都支持底层型别指定。限定作用域的枚举型别的默认底层型别是int，而不限范围的枚举型别没有默认底层型别。 限定作用域的枚举型别总是可以进行前置声明，而不限范围的枚举型别却只有在指定了默认底层型别的前提下才可以进行前置声明。 类型转换函数 类型转换函数的语法格式为： 1234operator type()&#123; //TODO: return data;&#125; 1) type 可以是内置类型、类类型以及由 typedef 定义的类型别名，任何可作为函数返回类型的类型（void 除外）都能够被支持。一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的。 2) 类型转换函数一般不会更改被转换的对象，所以通常被定义为 const 成员。 3) 类型转换函数可以被继承，可以是虚函数。 4) 一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性。 5) 转换函数必须是成员函数，它的声明不能指定返回类型和参数列表。 通常一个参数的构造函数在non-explicit的情况下同样能实现类型转换 内存泄漏 内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。三种类型的内存泄漏： （1）堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc,new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。 （2）系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。 （3）没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露。 安全的代码 123int* p=new int(1);delete p;p = NULL; （1）delete 一次以后，p成了野指针，但是它作为地址的值还是有效的，还可以访问它以前指向的内存，不过那片内存被重新格式化了；（2）指针非空时，delete运算只释放指针所指的地址空间，不会判断空间是否被占用，delete结束后不会将指针赋值为空，释放后别的指针变量也可以得到这片空间，该空间的值并不一定是NULL，所以delete后不能用是否为NULL来判断。用 if(p) 语句不能判断它指向的内存是否有效（此时它指向的内存无效，p本身有效）；（3）delete 一次以后，不能再次delete，否则会报错；（4）如果p指向的空间再次被new函数分配，即使是分配给别的指针，即使分配大小与原来不一样，此时如果误用p指针，仍然可以修改内存的值和从该处取出数值，甚至可以重新被delete，p的作用与新分配的指针一样；对同一非空指针delete多次，只有第一次delete被正确执行，之后的delete全部发生异常。对空指针delete多次可以正常执行。良好的习惯是，delete运算后手动将指针赋值为空。 野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）,野指针的成因： 1、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的默认值是随机的，它会乱指一气。2、指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。3、指针操作超越了变量的作用范围。这种情况让人防不胜防。 悬空指针指指针正常初始化，曾指向过一个正常的对象，但是对象销毁了，该指针未置空，就成了悬空指针。例如指针p1、p2均指向对象a，delete p1后p2就是悬空指针，p1是野指针。 sizeof 在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，结构体变量所占空间的大小必定是最宽数据类型大小的整数倍。如有需要会在最后一个成员末尾填充若干字节使得所占空间大小是最宽数据类型大小的整数倍。内存对齐的原因： 某些平台只能在特定的地址处访问特定类型的数据； 提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量 大端小端 大端模式（Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。 小端模式（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。 口诀：大相反（低位存高位），小相同（低位存低位）。 联合体变量共享同一空间，可以通过联合体来判断大端小端。联合体同样存在内存对齐，所以联合长度至少可以容纳最大的成员。但是当最大成员大小不是最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍。 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std; int checkcpu()&#123; union w &#123; int a; char b; &#125;c; c.a = 1; return (c.b == 1);&#125; int main()&#123; if(checkcpu() == 1) printf(\"这是小端\\n\"); else printf(\"这是大端\\n\"); return 0;&#125; 为什么析构函数可以virtual，构造函数不能呢？ 在公有继承中，基类的虚构函数如果不声明成为虚函数，delete p调用的是声明类型(即基类)的析构函数，所以只能销毁基类对象而无法销毁派生类对象，会发生销毁不完全的情况，那么销毁派生类时有可能造成资源泄漏。当基类的析构函数声明为虚函数，那么派生类的析构函数也是虚函数，此时调用delete p时发生动态绑定，运行时会根据实际类型调用该对象的虚函数。并不是要把所有类的析构函数都写成虚函数。只有当一个类是基类(即希望被继承)的时候才需要声明成虚函数，因为虚函数的作用是实现多态，而多态是建立在继承的基础上。单一类不能把析构函数写成虚函数，因为会产生额外的开销，比如虚表的创建和虚指针的定义。 （1）虚函数采用一种虚调用的办法。虚调用是一种可以在只有部分信息的情况下工作的机制，特别运行我们调用一个只知道接口而不知道其准确对象类型的函数。但是构造函数本身就是要初始化实例，要创建一个对象，构造函数肯定要知道对象的准确类型，因此构造函数不能为虚。 （2）虚函数对应虚函数表，虚函数表存储在对象的内存空间，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。 （3）虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。 （4）构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。 （5）当一个构造函数被调用时，它做的首要的事情之一是初始化它的V P T R。因此，它只能知道它是“当前”类的，而完全忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码- -既不是为基类，也不是为它的派生类（因为类不知道谁继承它）。所以它使用的V P T R必须是对于这个类的V TA B L E。而且，只要它是最后的构造函数调用，那么在这个对象的生命期内， V P T R将保持被初始化为指向这个V TA B L E, 但如果接着还有一个更晚派生的构造函数被调用，这个构造函数又将设置V P T R指向它的 V TA B L E，等直到最后的构造函数结束。V P T R的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类（most-derived）顺序的另一个理由。但是，当这一系列构造函数调用正发生时，每个构造函数都已经设置V P T R指向它自己的 V TA B L E。如果函数调用使用虚机制，它将只产生通过它自己的V TA B L E的调用，而不是最后的V TA B L E（所有构造函数被调用后才会有最后的V TA B L E）。 （八）友元函数1）必须在类的说明中说明友元函数，说明时以关键字friend开头，后跟友元函数的函数原型，友元函数的说明可以出现在类的任何地方，包括在private和public部分；2）注意友元函数不是类的成员函数，所以友元函数的实现和普通函数一样，在实现时不用”::”指示属于哪个类，只有成员函数才使用”::”作用域符号；3）友元函数不能直接访问类的成员，只能访问对象成员，4）友元函数可以访问对象的私有成员，但普通函数不行；5）调用友元函数时，在实际参数中需要指出要访问的对象，6）友元的声明只能出现在类定义的内部（最好在类定义开始或者结束前的位置集中声明友元），仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，必须在友元声明之外再对函数进行一次声明。每个类负责控制自己的友元类或友元函数，友元关系不存在传递性。类与类之间的友元关系不能继承. （九）外部排序详见外部排序算法总结 （十）字符数组初始化1234567891011121314151617181920//char *strcpy(char *dest, const char *src)//void *memset(void *str, int c, size_t n)//void *memcpy(void *str1, const void *str2, size_t n)//遇到char s[15]这条语句时, 编译程序会在内存的某处留//出连续15个字节的区域, 并将第一个字节的地址赋给s。//当遇到strcpy时, 首先在目标文件的某处建立一个\"I am a students\\0\" 的字符串,不加'\\0'编译器会自动补全，其中\\0表示字符串终止, 终止符是编译时自动加上的, 然后一个字符一个字符地复制到s所指的内存区域。因此定义字符串数组时, 其元素个数至少应该比字符串的长度多1。//注意://1. 字符串数组不能用\"=\"直接赋值, 即s=\"Good News!\"是不合法的。所以应分//清字符串数组和字符串指针的不同赋值方法。char st[15];strcpy(st,\"I am a students\");char* st=new char(15);strcpy(st,\"I am a students\");char* st=new char[15];strcpy(st,\"I am a students\");char* st=(char*)malloc(15);strcpy(st,\"I am a students\"); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//反转字符串#include &lt;bits/stdc++.h&gt;using namespace std;void reverseWord(char* begin,char* end)&#123; while(begin&lt;end)&#123; char tmp=*begin; *begin=*end; *end=tmp; begin++; end--; &#125; return;&#125;void reverse(char* str)&#123; int n=strlen(str); if(n==0||n==1) return; char* begin=str; char* end=str; while(*begin!='\\0')&#123; if(*begin==' ')&#123; begin++; end++; &#125;else if(*end==' '|| *end=='\\0')&#123; reverseWord(begin,--end); begin=++end; &#125;else end++; &#125; reverseWord(str,str+n-1); return;&#125;int main()&#123;// char* st=(char*)malloc(15);// strcpy(st,\"I am a students\");// char* st=new char[15];// memcpy(st,\"I am a students\",15);// char st[]=\"I am a students\";// char st[16]=\"I am a students\"; char st[16]; memcpy(st,\"I am a students\",15); reverse(st); cout&lt;&lt;st&lt;&lt;endl; char str1[]=&#123;'1','2','3','\\0'&#125;; cout&lt;&lt;strlen(str1)&lt;&lt;\" str1=\"&lt;&lt;str1&lt;&lt;endl; //入栈方向从右向左，str2[]没有长度规定，所以输出的时候连带str1也输出了出来 char str2[]=&#123;'1','2','3','4','5','6'&#125;; cout&lt;&lt;strlen(str2)&lt;&lt;\" str2=\"&lt;&lt;str2&lt;&lt;endl; char str3[3]=&#123;'5'&#125;; cout&lt;&lt;strlen(str3)&lt;&lt;\" str3=\"&lt;&lt;str3&lt;&lt;endl; char str4[4]=\"abc\"; cout&lt;&lt;strlen(str4)&lt;&lt;\" str4=\"&lt;&lt;str4&lt;&lt;endl;&#125;//输出：students a am I3 str1=1239 str2=1234561231 str3=53 str4=abc","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"MySQL","slug":"MySQL","date":"2020-03-24T06:17:11.000Z","updated":"2020-08-20T09:33:21.000Z","comments":true,"path":"2020/03/24/MySQL/","link":"","permalink":"http://yoursite.com/2020/03/24/MySQL/","excerpt":"[TOC] MySQL事务实现原理首先了解什么是事务，事务是执行一系列数据库操作构成的单个逻辑工作单元，要么完全地执行，要么完全地不执行。 简单的说，事务就是并发控制的单位，是用户定义的一个操作序列。 （1）事务四大特性（ACID） 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务前后数据的完整性必须保持一致。 隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。","text":"[TOC] MySQL事务实现原理首先了解什么是事务，事务是执行一系列数据库操作构成的单个逻辑工作单元，要么完全地执行，要么完全地不执行。 简单的说，事务就是并发控制的单位，是用户定义的一个操作序列。 （1）事务四大特性（ACID） 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务前后数据的完整性必须保持一致。 隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 （2）事务并发问题 脏读：读到了别的事务回滚前的脏数据,即当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。 丢失修改 不可重复读：当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配. 幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据，产生幻读，即当前事务读第一次取到的数据比后来读取到数据条目少。 不可重复读和幻读比较：两者有些相似，但是前者针对的是update或delete，后者针对的insert。 （3）事务的隔离级别 事务的隔离级别 描述 Serializable（串行化） 可避免脏读、不可重复读、幻读情况的发生 Repeatable read（可重复读） 可避免脏读、不可重复读的发生 Read committed（读已提交） 可避免脏读的发生 Read uncommitted（读未提交） 最低级别，以上情况均无法保证 MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation;命令来查看，MySQL 8.0 该命令改为SELECT @@transaction_isolation; 123456mysql&gt; SELECT @@tx_isolation;+-----------------+| @@tx_isolation |+-----------------+| REPEATABLE-READ |+-----------------+Copy to clipboardErrorCopied 这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) ，但是你要知道的是InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读） 并不会有任何性能损失。 InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。 91道面试题](https://mp.weixin.qq.com/s/9pfCkm2bX01XLIeJv9ngLw)是否所有的视图都可以更新？为什么？不是所有的视图都可以更新，视图更新必须遵循以下规则： （1）若视图的字段是来自字段表达式或常数，则不允许对此视图执行INSERT、UPDATE操作，允许执行DELETE操作； （2）若视图的字段是来自库函数，则此视图不允许更新； （3）若视图的定义中有GROUP BY子句或聚集函数时，则此视图不允许更新； （4）若视图的定义中有DISTINCT任选项，则此视图不允许更新； （5）若视图的定义中有嵌套查询，并且嵌套查询的FROM子句中涉及的表也是导出该视图的基表，则此视图不允许更新； （6）若视图是由两个以上的基表导出的，此视图不允许更新； （7）一个不允许更新的视图上定义的视图也不允许更新； （8）由一个基表定义的视图，只含有基表的主键或候补键，并且视图中没有用表达式或函数定义的属性，才允许更新。 什么是MySQL索引，什么时候该用索引什么时候不该用？ 索引(Index)是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。Mysql索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特别指明，一般都是指B树结构组织的索引(B+Tree索引)。 优点： 1、索引大大减少了服务器需要扫描的数据量 2、索引可以帮助服务器避免排序和临时表 3、索引可以将随机I/O变为顺序I/O 4、索引可以让查询锁定更少的行，减少加锁开销和锁争用并增加并发性 缺点： 1、虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。随着数据量的增加，创建索引和维护索引的时间也会增加 2、建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。 3、如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。 4、对于非常小的表，大部分情况下简单的全表扫描更高效； 使用原则：（并不是每个字段度设置索引就好，也不是索引越多越好，而是需要自己合理的使用） （1）对经常修改的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引 （2）数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。 （3）在一不同值少的列上(字段上)不要建立索引(即选择性低的列或字段上)，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。 索引类型 索引我们分为四类来讲 单列索引(普通索引，唯一索引，主键索引)、组合索引、全文索引、空间索引、 单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。 唯一索引：索引列中的值必须是唯一的，但是允许为空值， 主键索引：是一种特殊的唯一索引，不允许有空值。 组合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀原则。 全文索引：全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行。 空间索引：空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。在创建空间索引时，使用SPATIAL关键字。要求引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。 参照： 数据库中的索引 MySQL索引原理及BTree B+树B+树实现范围查询 B+树比B树更适合范围索引: 1)B+树的磁盘读写代价更低 B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了； 2）B+树查询效率更加稳定 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当； 3）B+树便于范围查询（最重要的原因，范围查找是数据库的常态） B树的范围查找用的是中序遍历，而B+树用的是在链表上遍历。B树在提高了IO性能的同时并没有解决元素遍历的效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。 InnoDB和MyISAM的区别（1）InnoDB支持事务，MyISAM不支持。 （2）InnoDB支持外键，MyISAM不支持。 （3）InnoDB支持聚簇索引，使用B+树作为索引结构，行数据是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），主键索引的叶子结点就是数据文件，辅助索引的叶子结点是主键的值，所以InnoDB必须有主键。主键索引效率很高，但是辅助索引（二级索引，非聚簇索引）需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大；MyISAM不支持聚簇索引，是非聚簇索引，使用B+树作为索引结构，索引和数据文件是分离的，主键索引和辅助索引的叶子结点都是数据文件的地址指针（MyISAM的主键索引和辅助索引没有区别，主键索引仅仅只是一个叫做PRIMARY的唯一非空的索引，且MyISAM可以不设主键。参考 （4） InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）。 （5）MyISAM表格和索引可以被压缩后进行查询操作。 （6）InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁。 （7）Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI ​ Innodb：frm是表定义文件，ibd是数据文件 ​ Myisam：frm是表定义文件，myd是数据文件，myi是索引文件 注：InnoDB对主键建立聚簇索引，如果没有显示指定主键，InnoDB会用一个具有唯一且非空值的索引来代替，如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引，如果你用InnoDB而且不需要特殊的聚簇索引的做法就是使用代理主键（surrogate key）-独立于你的应用中的数据。最简单的做法就是使用一个AUTO_INCREMENT的列，这会保证记录按照顺序插入，而且能提高使用primary key进行连接的查询性能.应该尽量避免随机的聚簇主键，例如字符串主键就不是一个好的选择，它使得插入操作变得随机。 行级锁和表级索的区别（1）表级锁 table-level locking，锁住整个表 开销小，加锁快 不会死锁(一次性加载所需的所有表：MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待（破坏请求条件）) 锁粒度大，发生锁冲突概率大，并发效率低 适合查询 （2）行级锁 row-level locking，锁住一行记录 开销大，加锁慢 会死锁 锁粒度小，发生锁冲突概率小，并发效率高 适合并发写，事务控制 并不是直接给记录行加锁，而是对行对应的索引加锁： 如果sql 语句操作了主键索引，Mysql 就会锁定这条主键索引 如果sql语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引 在InnoDB中，如果SQL语句不涉及索引，则会通过隐藏的聚簇索引来对记录加锁 行级锁并不是直接锁记录，而是锁索引，对聚簇索引加锁，实际效果跟表锁一样，因为找到某一条记录就得扫描全表，要扫描全表，就得锁定表 主键索引和非主键索引的区别InnoDB中，非主键索引的叶子节点的data域存放的是主键的值，而主键索引的叶子节点存放的是数据记录。非主键索引也被称为二级索引、辅助索引，而主键索引也被称为聚簇索引。 MyISAM中，主键索引和非主键索引的叶子节点的data域存放的都是数据记录的地址。如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。MyISAM的索引方式也叫做非聚簇索引。 聚簇索引和非聚簇索引的区别 聚集索引：索引项的顺序与表中记录的物理顺序一致，叶子结点存储真实的数据记录，不再有另外单独的数据页。 在一张表上最多只能创建一个聚簇索引，因为真实数据的物理顺序只能有一种。 非聚簇索引：表数据存储顺序与索引顺序无关，叶结点包含索引字段值即指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。 总结一下：聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。与非聚集索引相比，聚集索引有着更快的检索速度。 共享锁排他锁悲观锁和乐观锁 共享锁： S锁、读锁。当前线程对共享资源加共享锁，其他线程可以读取此资源、可以继续追加共享锁，但是不能修改此资源、不能追加排他锁。语法：select id from t_table in share mode;多个共享锁可以共存，共享锁与排他锁不能共存. 排他锁： X锁、写锁。当前线程对共享资源加排他锁，其他线程不允许读取此资源，不允许追加共享锁，不允许修改此资源，不允许追加排他锁。语法：update t_table set a =1; // 数据库的增删改操作默认都会加排他锁select * from t_table for update;// for update也是一种增删改。排他锁是独占的，不会与其他锁共存。 乐观锁（乐观锁与悲观锁是逻辑上的锁） 乐观地认为，并发问题很难发生。乐观锁虽然认为并发问题很难发生，但并不是不会发生，所以也会有措施防止问题真的产生：每次数据修改都自增版本号version。进行数据读取时，并不加锁，而是同时读取当前的版本号version1；在对数据进行修改时，要判断当前的版本号version2是否等于之前的版本号version1。版本号不匹配，则代表着并发问题已产生，所以需要回滚此次操作。实现方式：版本号机制、CAS。 悲观锁 悲观地认为，并发问题极易发生。悲观锁认为并发问题极易发生，所以每次操作，无论读写，都会对记录加锁，以防止其他线程对数据进行修改。实现方式：数据库的行锁、读锁和写锁。 覆盖索引一个包含查询所需字段的索引称为“覆盖索引”，覆盖索引只是特定于具体select语句而言的联合索引。也就是说一个联合索引对于某个select语句，通过索引可以直接获取查询结果，而不再需要回表查询，就称该联合索引覆盖了这条select语句。覆盖索引是sql性能提升的关键，减少IO，提高了效率。 SQL语句SQL语句不区分大小写，习惯上SQL关键字使用大写，而对所有列和表名使用小写；有些情况下需要完全限定表名（数据库.表）/列名（表.列） SELECTFROMDISTINCT不能部分使用DISTINCT DISTINCT关键字应用于所有列而 不仅是前置它的列。如果给出SELECT DISTINCT id,name检索出来的所有行的列组合都不同。 LIMIT行0 检索出来的第一行为行0而不是行1。因此，LIMIT 1, 1 将检索出第二行而不是第一行。 在行数不够时 LIMIT中指定要检索的行数为检索的最大行数。如果没有足够的行（例如，给出LIMIT 10, 5，但只有13 行） ORDER BY默认升序 ASC（ASCENDING）；降序DESC。ASC/DESC关键字只应用到直接位于其前面的列名,如果想在多个列上进行降序排序，必须 对每个列指定DESC关键字。 多个列排序：下面的例子以id降序排序产品 （最贵的在最前面），然后再对产品名升序排序 123456SELECT DESTINCT id,nameFROM productsWHERE (price BETWEEN 2 AND 6 OR price IS NOT NULL) AND vend_id NOT IN (1002,1003) AND vend_id &lt;&gt; ' ' AND pre_name LIKE 'j_t%'；ORDER BY id DESC,name；LIMIT 2,4; -- LIMIT 5, 5指示MySQL返回从行5开始的5行 WHERE 在同时使用ORDER BY和WHERE子句时，应 该让ORDER BY位于WHERE之后，否则将会产生错误。 WHERE可包含任意数目的AND和OR操作符。允许两者结合以进行复杂 和高级的过滤。 AND在计算次序中优先级更高。 任何时候使用具有AND和OR操作 符的WHERE子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序，即使它确实是你想要的东西也是如 此。使用圆括号没有什么坏处，它能消除歧义。 IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN取合法值的由逗号分隔的清单，全都括在圆括号中。 为IN操作符完成与OR相同的功能。 MySQL支持使用NOT对IN、BETWEEN和 EXISTS子句取反，这与多数其他DBMS允许使用NOT对各种条件 取反有很大的差别。 WHERE子句操作符： &lt;&gt; 不等于 != 不等于 BETWEEN 在指定的两个值之间 INNOTLIKE操作符LIKE指示MySQL， 后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。 百分号（%）通配符 根据MySQL的配置方式，搜索可以是区分大小 写的。如果区分大小写，’jet%’与JetPack 1000将不匹配。似乎%通配符可以匹配任何东西，但有一个例外，即NULL。即使是WHERE prod_name LIKE ‘%’也不能匹配 用值NULL作为产品名的行。 全文索引全文索引,通过建立倒排索引,可以极大的提升检索效率,解决判断字段是否包含的问题. 例如: 有title字段,需要查询所有包含 “政府”的记录. 需要 like “%政府%”方式查询,查询速度慢,当查询包含”政府” OR “中国”的需要是,sql难以简单满足.全文索引就可以实现这个功能. 1倒排索引（英语：Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。 下划线（_）通配符下划线的用途与%一样，但下划线只匹配单个字符而不是多个字符。 REGEXP 使用正则表达式进行搜索注意：regexp和正则表达式详看MYSQL必知必会第9章：用正则表达式进行搜索 LIKE与REGEXP 在LIKE和REGEXP之间有一个重要的差别。请 看以下两条语句： 如果执行上述两条语句，会发现第一条语句不返回数据，而第 二条语句返回一行。为什么？ 正如第8章所述，LIKE匹配整个列。如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回（除非使用通配符）。而REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回。这是一 个非常重要的差别。 那么，REGEXP能不能用来匹配整个列值（从而起与LIKE相同的作用）？答案是肯定的，使用^和$定位符（anchor）即可。解析：like ‘%1000%’=regexp ‘1000’ 计算字段123select Concat(RTrim(vend_name),'(',vend_country,')') as vend_titlefrom vendorsorder by vend_name; 别名（alias）是一个字段或值 的替换名。别名用AS关键字赋予。 Concat()拼接串，即把多个串连接起来形成一个较长的串。 Concat()需要一个或多个指定的串，各个串之间用逗号分隔。 Trim函数 MySQL除了支持RTrim()（正如刚才所见，它去掉 串右边的空格），还支持LTrim()（去掉串左边的空格）以及 Trim()（去掉串左右两边的空格） 使用数据处理函数大多数SQL实现支持以下类型的函数： 用于处理文本串（如删除或填充值，转换值为大写或小写）的文本函数。 用于在数值数据上进行算术操作（如返回绝对值，进行代数运算） 的数值函数。 用于处理日期和时间值并从这些值中提取特定成分（例如，返回 两个日期之差，检查日期有效性等）的日期和时间函数。 返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本 细节）的系统函数 聚集函数聚集函数（aggregate function） 运行在行组上，计算和返回单个值的函数。 COUNT(column) 返回某列的行数（不包括NULL值） COUNT(*) 返回被选行数 MIN()函数与MAX()函数类似， MySQL允许将它用来返回任意列中的最小值，包括返回文本 列中的最小值。在用于文本数据时，如果数据按相应的列排序， 则MIN()返回最前面的行。MAX()、MIN()、SUM()函数均忽略列值为NULL的行。 SELECT 语句可根据需要包含多个聚集函数，逗号隔开即可。 GROUP BY在具体使用GROUP BY子句前，需要知道一些重要的规定: GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套， 为数据分组提供更细致的控制 如果在GROUP BY子句中嵌套了分组，数据将在后规定的分组上 进行汇总。换句话说，在建立分组时，指定的所有列都一起计算 （所以不能从个别的列取回数据） GROUP BY子句中列出的每个列都必须是检索列或有效的表达式 （但不能是聚集函数）。如果在SELECT中使用表达式，则必须在 GROUP BY子句中指定相同的表达式。不能使用别名 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子 句中给出 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列 中有多行NULL值，它们将分为一组 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 HAVING过滤分组HAVING支持所有WHERE操作符（包括通配符条件和带多个操作符的子 句），它们的句法是相同的，唯一差别就是WHERE过滤行，而HAVING过滤分组。 1234567SELECT id,SUM(quantity*price) AS ordertotalFROM ordersWHERE price &gt;= 10GROUP BY idHAVING SUM(quantity*price)&gt;=50;-- 过滤SUM(quantity*price)&gt;=50的分组ORDER BY ordertotal ORDER BY和GROUP BY的区别 ORDER BY GROUP BY 排序产生的输出 分组行。但输出可能不是分组的顺序 任意列都可以使用(甚至非选择的列也可以使用) 只能使用选择列或表达式列，而且必须使用每个选择列表达式 不一定需要 如果与聚集函数一起使用列(或表达式)，则必须使用 SELECT子句顺序 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表中选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的行数 否 临时表-视图如果视图中包含GROUP BY 、DISTINCT、任何聚合函数、UNION、子查询等，只要无法在原表记录和视图记录中建立一一映射的场景中，MYSQL都将使用临时表算法来实现视图。 所有使用临时表算法实现的视图都无法被更新；更新视图的查询也可以是一个关联语句，但是有一个限制，更新的列必须来自同一个表中。 on、where、group by、having数据库在通过连接两张表或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。 join on:on后边写条件，以后边的条件为准生成一个临时表存储数据。 join where ：不会生成中间表。 on和where的区别： 对于left join，不管on后面跟什么条件，左表的数据全部查出来，因此要想过滤需把条件放到where后面 对于inner join，满足on后面的条件表的数据才能查出，可以起到过滤作用。也可以把条件放到where后面。 这三个都可以加条件的子句中，on是最先执行，where次之，然后是group by ，having最后。有时候如果这先后顺序不影响中间结果的话，那最终结果是相同的。但因为on是先把不符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的。 如果要涉及到计算的字段，就表示在没计算之前，这个字段的值是不确定的，where的作用时间是在计算之前就完成的，WHERE排除的行不包括在分组中,这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。而having就是在计算后才起作用的，所以having是最慢的，在这种情况下，两者的结果会不同。 在多表联接查询时，on比where更早起作用。系统首先根据各个表之间的联接条件，把多个表合成一个临时表后，再由where进行过滤，然后再计算，计算完后再由having进行过滤。由此可见，要想过滤条件起到正确的作用，首先要明白这个条件应该在什么时候起作用，然后再决定放在那里。 子查询任何SQL语句都是查询。但此术语一般指SELECT 语句。 SQL还允许创建子查询（subquery），即嵌套在其他查询中的查询。 1234567SELECT idfrom orderswhere order_num IN ( select order_num from orderitems where itemid='INT2'); 相关子查询（correlated subquery） ：涉及外部查询的子查询。 作为计算字段使用子查询： 1234567SELECT name, state, (SELECT COUNT(*) FROM orders WHERE orders.id=customers.id) AS orderitemsFROM customersORDER BY name; 联结内部联结12345678910-- 等值联结-- （1）使用where联结select vend_name,pro_name,prod_pricefrom vendors,productswhere vendors.vend_id=products.vend_idorder by vend_name,prod_name;-- （2）使用 INNER JOIN联结（内部联结）SELECT vend_name,prod_name,prod_priceFROM vendors INNER JOIN productsON vendors.vend_id=products.vend_id 这里，两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE 子句给出。传递给ON的实际条件与传递给WHERE的相同。 ANSI SQL规范首选INNER JOIN语法。此外， 尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，有时候这样做也能影响性能。 自联结用自联结而不用子查询 自联结通常作为外部语句用来替代 从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。 1234567891011-- 子查询，这是第一种解决方案。内部的SELECT语句做 了一个简单的检索，返回生产ID为DTNTR的物品供应商的vend_id。该ID用于外部查询的WHERE子句中，以便检索出这个供应商生产的所有物品。SELECT prod_name,prod_idFrom productsWhere vend_id=(SELECT vend_id FROM products WHERE prod_id='DTNTR') ;-- 等价于使用自联结，此查询中需要的两个表实际上是相同的表，因此products表在FROM子句中出现了两次。虽然这是完全合法的，但对products 的引用具有二义性，因为MySQL不知道你引用的是products表中的哪个实例。为解决此问题，使用了表别名。products的第一次出现为别名p1， 第二次出现为别名p2。现在可以将这些别名用作表名。例如，SELECT语句使用p1前缀明确地给出所需列的全名。如果不这样，MySQL将返回错误，因为分别存在两个名为prod_id、prod_name的列。MySQL不知道想 要的是哪一个列（即使它们事实上是同一个列）。WHERE（通过匹配p1中 的vend_id和p2中的vend_id）首先联结两个表，然后按第二个表中的 prod_id过滤数据，返回所需的数据。 SELECT p1.prod_id,p1.prod_nameFrom products AS pa,products as p2where p1.vend_id=p2.vend_id AND p2.prod_id = 'DTNTR'; 自然联结无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被 联结的列）。标准的联结（内部联结）返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。 123456SELECT c.*,o.order.num,o.oreder_date,oi.prod_id, oi.quantity,OI.item_priceFROM customers AS c,orders AS o,orderitems AS oiwhere c.cust_id=o.cust_id AND oi.order_num=o.order_num AND prod_id='FB'; 在这个例子中，通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。 事实上，迄今为止我们建立的每个内部联结都是自然联结，很可能我们永远都不会用到不是自然联结的内部联结。 外部联结 存在三种基本的外部联结形式：左外部联结（LEFT （OUTER） JOIN）、右外部联结（RIGHT （OUTER） JOIN）和全外联结（FULL （OUTER） JOIN，mySQL不支持）。它们之间的唯一差别是所关联的表的顺序不 同。 左联结左向外联接的结果集包括 LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。 右联结右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。 下面的SELECT语句给出一个简单的内部联结。它检索所有客户及其订单： 123select customers.cust_id,orders.order_numFROM customers INNER JOIN ordersON customers.cust_id = orders.cust_id; 外部联结语法类似。为了检索所有客户，包括那些没有订单的客户，可如下进行: 123select customers.cust.id,orders.order_numFrom customers LEFT OUTER JOIN ordersON customers.cust_id = orders.cust_id; 类似于上一章中所看到的内部联结，这条SELECT语句使用了关 键字OUTER JOIN来指定联结的类型（而不是在WHERE子句中指 定）。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没 有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字 指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT 指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM 子句的左边表（customers表）中选择所有行。为了从右边的表中选择所 有行，应该使用RIGHT OUTER JOIN，左外部联结可通过颠倒FROM或WHERE子句中表的顺序转换为右外部联结。因此，两种类型的外部联结可互 换使用，而究竟使用哪一种纯粹是根据方便而定。 全外联结完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 交叉联结交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。 使用带聚集函数的联结 使用联结和联结条件 注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。 保证使用正确的联结条件，否则将返回不正确的数据。 应该总是提供联结条件，否则会得出笛卡儿积。 在一个联结中可以包含多个表，甚至对于每个联结可以采用不同 的联结类型。虽然这样做是合法的，一般也很有用，但应该在一 起测试它们前，分别测试每个联结。这将使故障排除更为简单。 IDENTITY在 “Persons” 表中插入新记录，我们不必为 “P_Id” 列规定值（会自动添加一个唯一的值）： 12INSERT INTO Persons (FirstName,LastName)VALUES ('Bill','Gates') TRUNCATE除去表内的数据，但并不删除表本身，使用 TRUNCATE TABLE 命令（仅仅删除表格中的数据）： 1TRUNCATE TABLE 表名称 DROP COLUMN删除 “Person” 表中的 “Birthday” 列： 12ALTER TABLE PersonDROP COLUMN Birthday SQL 语句快速参考-&gt;详解 语句 语法 AND / OR SELECT column_name(s) FROM table_name WHERE condition AND|OR condition ALTER TABLE (add column) ALTER TABLE table_name ADD column_name datatype ALTER TABLE (drop column) ALTER TABLE table_name DROP COLUMN column_name AS (alias for column) SELECT column_name AS column_alias FROM table_name AS (alias for table) SELECT column_name FROM table_name AS table_alias BETWEEN SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2 CREATE DATABASE CREATE DATABASE database_name CREATE INDEX CREATE INDEX index_name ON table_name (column_name) CREATE TABLE CREATE TABLE table_name ( column_name1 data_type, column_name2 data_type, ……. ) CREATE UNIQUE INDEX CREATE UNIQUE INDEX index_name ON table_name (column_name) CREATE VIEW CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition DELETE FROM DELETE FROM table_name (Note: Deletes the entire table!!)orDELETE FROM table_name WHERE condition DROP DATABASE DROP DATABASE database_name DROP INDEX DROP INDEX table_name.index_name DROP TABLE DROP TABLE table_name GROUP BY SELECT column_name1,SUM(column_name2) FROM table_name GROUP BY column_name1 HAVING SELECT column_name1,SUM(column_name2) FROM table_name GROUP BY column_name1 HAVING SUM(column_name2) condition value IN SELECT column_name(s) FROM table_name WHERE column_name IN (value1,value2,..) INSERT INTO INSERT INTO table_name VALUES (value1, value2,….)orINSERT INTO table_name (column_name1, column_name2,…) VALUES (value1, value2,….) LIKE SELECT column_name(s) FROM table_name WHERE column_name LIKE pattern ORDER BY SELECT column_name(s) FROM table_name ORDER BY column_name [ASC|DESC] SELECT SELECT column_name(s) FROM table_name SELECT * SELECT * FROM table_name SELECT DISTINCT SELECT DISTINCT column_name(s) FROM table_name SELECT INTO (used to create backup copies of tables) SELECT * INTO new_table_name FROM original_table_nameorSELECT column_name(s) INTO new_table_name FROM original_table_name TRUNCATE TABLE (deletes only the data inside the table) TRUNCATE TABLE table_name UPDATE UPDATE table_name SET column_name=new_value [, column_name=new_value] WHERE column_name=some_value WHERE SELECT column_name(s) FROM table_name WHERE condition","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"C++ primer重点记录","slug":"C-primer重点记录","date":"2020-03-24T05:43:26.000Z","updated":"2020-08-22T08:10:10.475Z","comments":true,"path":"2020/03/24/C-primer重点记录/","link":"","permalink":"http://yoursite.com/2020/03/24/C-primer%E9%87%8D%E7%82%B9%E8%AE%B0%E5%BD%95/","excerpt":"第一章 开始 windows或unix编译程序使用命令 cc hello.cc windows输出a.exe unix输出a.out 输入a.exe或者./a.out执行程序 运行GNU编译器的命令是g++","text":"第一章 开始 windows或unix编译程序使用命令 cc hello.cc windows输出a.exe unix输出a.out 输入a.exe或者./a.out执行程序 运行GNU编译器的命令是g++ g++ -o hello hello.cc (-o hello给执行文件命名) cerr 输出警告和错误消息 clog输出程序运行时的一般信息 命名空间可以避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突 使用一个istream对象作为条件，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符(EOF)，或遇到一个无效的输入时(例如读入的值不是一个整数)，istream对象的状态会变成无效，处于无效状态的istream对象会使条件变假。 1while(std::cin&gt;&gt;value) main函数返回值类型必须为int类型，为0表示成功，非0由系统定义，通常指出错误类型 编译为addItems.exe的可执行文件(UNIX中是addItems.out)，从一个名为infile的文件读取销售记录，并将结果输出写入一个名为outfile的文件中，两个文件都位于当前目录。 addItems outfile 第二章 变量和基本类型 一个字节：8bit 一个字：4或8个字节 float：一个字 double：两个字 long double：3或4个字 char与其他整型（整型包括字符、布尔和整数）不同，字符型被分为三种：char /signed char/unsigned char。char实际上表现为哪种类型由编译器决定。 c++算术类型分为两类：整型和浮点型 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8位 short 短整型 16 int 整型 16 long 长整型 32 long long 长整型 64 类型转换 赋值给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。eg:8比特大小的usigned char可以表示0至255区间内的值，如果赋了一个区间以外的值，则实际结果是该值对256取模后所得的余数。因此把-1赋给8比特大小的usigned char所得的结果是255（即256+（-1）=255）。 赋值给带符号类型一个超出它表示范围的值时，结果是未定义的。此时程序可能继续工作、可能崩溃、也可能生成垃圾数据。 如果两个运算符的运算对象类型不一致，首先把这些运算对象执行整型提升，如果结果类型匹配，无须进行进一步的转换。如果两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型运算对象转换成较大的类型。 123ival + ulval; //ival转换成usigned long，无符号类型不小于带符号类型usval + ival; //根据usigned short 和 int 所占空间的大小进行转换uival + lval; //根据usigned int 和 long 所占空间的大小进行转换 表达式里带符号类型不大于无符号类型，带符号类型会自动转换成无符号类型；带符号类型大于无符号类型时转换结果依赖于机器，eg,如果两个运算对象的类型分别是long类型和usigned int类型，long占用的空间比int更多，则usigned int 类型的运算对象转换成long类型；当带符号类型取值为负时会出现异常结果。 转义序列 \\x 后紧跟1个或多个十六进制数字，eg:“\\1234”表示一个16位的字符 \\后紧跟1、2或3个八进制数字，eg:“\\1234”表示两个字符即八进制123对应的字符和字符4 列表初始化 初始化！=赋值 1234567int a=1;int a=&#123;1&#125;;int a&#123;1&#125;;int a(1);long double ld=3.143;int a&#123;ld&#125;,b=&#123;ld&#125;;//错误：窄化转换，转换未执行，因为存在丢失信息的危险int a(ld),b=ld;//正确：转换执行，且确实丢失了部分值 变量能且仅能被定义一次，但是可以被多次声明。如果在多个文件中使用同一个变量，就必须将声明和定义分离，变量的定义必须出现在也只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，但是绝对不能重复定义。 标识符 标识符必须以字母或者下画线开头，要能体现实际含义。 变量名一般要用小写字母，如index,不要使用Index或INDEX。 用户自定义的类名一般以大写字母开头，如Sales_item。 如果标识符由多个单词组成，则单词间应有明显的区分，如student_loan或studentLoan,不要使用studentloan。 用户自定义标识符不能连续出现两个下画线，也不同以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。 按位与&amp; 或者 bitand 按位或 | 或者 bitor 异或^或者xor and_eq与=（赋值） or_eq或=（赋值） compl或者~非 not_eq不等于（赋值） xor_eq异或等于 在块作用域中使用“：：a”,因为全局作用域本身并没有名字，所以作用域左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量（即全局变量）。 引用必须被初始化，且不能更改指向值，而指针无须初始化且可以先后指向几个不同的对象。指针必须初始化，得到空指针的办法就是用字面值nullptr来初始化指针，新标准下，初始化指针最好使用nullptr,同时尽量避免NULL(在头文件cstdlib中定义的值为0的预处理器）和 0（使用NULL和0初始化指针是一样的）；把int变量直接赋值给指针是错误的操作，即使int变量值恰好等于0也不行。 123int zero=0；int *p=zero;//错误：不能直接把int变量赋值给指针（更不能把字面值常量直接赋值给指针）int *p=&amp;zero; void*是一种特殊的指针类型，可用于存放任意对象的指针，但是没办法访问内存空间的对象，因为无法确定这个对象到底是什么类型。 引用本身不是一个对象，因此不能定义指向引用的指针，但指针是对象，所以存在对指针的引用： 123456int i=42;int a=3;int *p;int *&amp;r=p;//r是一个引用，r引用的是一个指针，r引用的是一个int指针（面对一条比较复杂的指针或引用的声明语句时从右向左阅读有助于弄清它的真实含义）r=&amp;i;//r引用了一个指针，因此给r赋值就是零p指向i*r=a;或者*r=3;//解引用r得到i，也就是p指向的对象，将i的值改为3 默认状态下，const对象仅在文件内有效，如果想在多个文件之间共享const对象，必须在每个文件中变量的定义之前添加extern关键字。 1234//file1.cc定义并初始化了一个常量，该常量能被其他文件访问extern const int bugSize=fcn();//file2.cc头文件extern const int bufSize;//与file1.cc中定义的bufSize是同一个 可以利用const对象初始化非常量，但是对const的引用必须是const，且引用及其对应的对象都不能更改，指向常量的指针也必须是const。但是指向常量的指针或者引用可以绑定到一个非常量上。 1234567int i=42;const int ci=i;//正确：i的值被拷贝给了ciint j=ci;//正确：ci的值被拷贝给了jconst int &amp;r1=ci;//正确：引用及其对应的对象都是常量r1=42;//错误：r1是对常量的引用int &amp;r2=ci;//错误：试图让一个非常量引用指向一个常量const int &amp;r3=i;//正确：const int&amp; 可以绑定到一个普通int上 const引用一个非const对象，不允许通过const引用修改非const对象的值，但是允许通过其他途径改变它的值。 12345double i=42;int &amp;r1=i;const int &amp;r2=i;//实际实现过程是：（1）const int tmp=i;//由双精度浮点数生成一个临时的整型变量 （2）const int &amp;r2=tmp;//让r2绑定这个变量 r1=0;//r1非常量，i的值修改为0r2=0;//错误：r2是一个常量引用不允许修改i的值 指向常量的指针！=常量指针，常量指针必须初始化化，且一旦初始化则它的值（存放在指针中的地址）不再改变，但是如果常量指针指向的是一个一般的非常量整数，就能通过常量指针修改这个非常量整数。 1234567int i=0;int *const p=&amp;i;//p将一直指向iconst double pi=3.14159;const double *const pip=&amp;pi;//pip是一个指向常量对象的常量指针*p=3;//把i的值改为3*pip=4;//错误：pip指向的是一个常量对象p=&amp;pi;//p是一个常量指针 顶层const可以表示任意的对象是常量。 底层const则是与指针和引用等符合类型的基本类型部分有关。指针类型既可以是顶层const（表示指针本身是一个常量）也可以是底层const（表示所指的对象是一个常量）。 123456int i=0;int *const p1=&amp;i;//不能改变p1的值，这是一个顶层constconst int ci=42;//不能改变ci的值，这是一个顶层constconst int *p2=&amp;ci;//允许改变p2的值，这是一个底层constconst int *const p3=p2;//靠右的const是顶层const,靠左的是底层const(从你的右手到左手)const int &amp;r=ci;//用于声明引用的const都是底层const(指针是对象而引用不是) 字面值是常量表达式（字面值类型：算术类型、引用、指针；自定义类型如string、Sales_item则不属于字面值类型,也就不能被定义成constexpr），用常量表达式初始化的const对象也是常量表达式，应声明成constexpr(由它的数据类型和初始值共同决定)。尽管指针和引用都可以被定义成constexpr，但它们的初始值却受到严格限制，一个constexpr指针的初始值必须是nullptr或0，或者是存储于某个固定地址中的对象。 constexpr仅对指针有效，与指针所指的对象无关： 12345constexpr int *np=nullptr;//np是一个指向整数的常量指针，其值为空int j=0;constexpr int i=42;//i的类型是整型常量constexpr const int *p=&amp;i;//p是常量指针，指向整数常量iconsterxpr int *p1=&amp;j;//p1是常量指针，指向整数j 类型别名，不能把类型别名替换成它原来的样子 1234typedef char *pstring;const pstring cstr=0;//cstr是指向char的常量指针，顶层constconst pstring *ps;//ps是一个指针，它的对象时指向char的常量指针const char *cs=0;//cs是一个指向const char的指针，底层const auto一般会忽略顶层const,保留底层const。 decltype返回操作数的数据类型（包括顶层const和引用）。变量加上一层或多层括号，编译器就会把它当成给一个表达式，decltype的表达式如果是加上了括号的变量，结果是引用。 12345int i=42,*p=&amp;i,&amp;r=i;decltype(r+0) b;//正确：加法的结果是int，因此b是一个未初始化的intdecltype(*p) c;//错误c是int&amp;，必须初始化decltype((i)) d;//错误：d是一个int&amp;,必须初始化decltype(i) e;//正确：e是一个未初始化的int 第三章 字符串、向量和数组 cin读入字符串遇到空白符停止，getline遇到换行符停止（换行符也被读进来但是不保留）。 字符串字面值与string是不同类型。 可以用列表中元素的拷贝替换v1中的元素或初始化vector，但是列表不能作为形参vector直接使用。 1v1=&#123;a,b,c&#125;; 范围for语句体内不应该改变其所遍历序列的大小。 迭代器不同于指针，获取迭代器不是取地址符。begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，返回const_iterator（能读不能修改它所指的元素值或直接使用cbegin cend）,否则返回iterator（能读能写）。如果对象不是常量，均可。end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用。数组也可以使用begin（arr）和end（arr）获取指向数组首元素的指针和指向数组尾元素的下一位置的指针。 12*iter 返回迭代器iter所指元素的引用iter-&gt;mem 解引用iter并获取该元素的名为mem的成员，等价于（*iter）.mem different_type由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离。使用迭代器可进行二分查找。ptrdiff_t是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离。指针和迭代器都可进行算术运算。允许给空指针加上或者减去一个值为0的整型常量表达式，两个空指针也允许彼此相减，结果为0。 123456789usigned cnt=42;constexpr usigned sz=42;int *parr[sz];//含有42个整型指针的数组string bad[cnt];//错误：cnt不是常量表达式string strs[get_size()];//当get_size是constexpr时正确；否则错误auto n=end(arr)-begin(arr);//auto是ptrdiff_t类型，n=arr中元素的数量int *ip=arr;//等价于int *ip=&amp;arr[0];int *p=arr+sz;//正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置；使用警告：不要解引用！int *pz=arr+sz+1;//错误：arr只有sz个元素，pz的值未定义 如果函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。不允许使用一个数组为另一个内置类型的数组赋初值，但是允许使用数组来初始化vector对象。 1234vector&lt;int&gt; vec(begin(arr)+1,end(arr));//等价于vector&lt;int&gt; vec(arr+1,end(arr))int a[]=&#123;0,1,2&#125;;int a2[]=a; //错误：不允许使用一个数组初始化另一个数组a2=a; //错误：不能把一个数组直接赋值给另一个数组 字符串字面值会自动添加表示字符串结束的空字符。strcpy/strcmp/strlen/strcat此类函数可以传入字符串或者指向以空字符作为结束的数组的指针。比较标准库string对象的时候用的是普通的关系运算符合相等性运算符，把这些运算符用在比较两个C风格字符串上，实际比较的将是指针而非字符串本身。不能用string对象初始化char*，但是可以使用c_str，如果执行完c_str()函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。 12345678910111213141516char a1[]=&#123;'c','+','+'&#125;;//列表初始化,没有空字符char a2[]=&#123;'c','+','+','\\0'&#125;;//列表初始化,含有显式的空字符char a3[]=\"c++\";//自动添加表示字符串结束的空字符const char a4[6]=\"daniel\";//错误：没有空间可存放空字符int &amp;refs[10]=/*?*/;//错误：不存在引用的数组char (&amp;arrRef)[3]=a1;//arrRef引用一个含有3个字符的数组int *(&amp;arry)[42]=parr;//arry是数组的引用，该数组含有42个指针cout&lt;&lt;strlen(a1)&lt;&lt;endl;//错误：啊没有以空字符结束string s1=\"abcd\";string s2=\"cdr\";if(s1&lt;s2)//trueconst char c1[]=\"abcd\";const char c2[]=\"bcde\";if(c1&lt;c2)//未定义：试图比较两个无关地址char *str=s1;//错误const char *str=s1.c_str;//正确，用const char*保证字符数组内容不改变；如果后续操作改变了s1的值就可能让之前返回的数组失去效用 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组；当使用decltype()时上述转换不会发生。 123456int ia[]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;auto ia2(ia);//ia2是一个整型指针，指向ia的第一个元素ia2=42;//错误：ia2是一个指针，不能用整数给指针赋值decltype(ia) ia3=&#123;0,1,2,3,4,5,6,7,8,9&#125;；ia3=p;//错误：不能用整型指针给数组赋值ia3[4]=i;//正确：把i的值赋给ia3的一个元素 数组内置的下标运算符所用的索引值不是无符号类型，这一点与string和vector不同。 123int *p=&amp;a[2];int j=p[1];//等价于*（p+1)，就是a[3]int k=p[-2];//p[-2]是a[0]表示的那个元素 多维数组的初始化和下标引用 123456789int a[2][3]=&#123; &#123;0,1,2&#125;, &#123;3,4,5&#125;&#125;;int a[2][3]=&#123;0,1,2,3,4,5&#125;;//内层嵌套着的花括号并非完全必要int a[2][3]=&#123;&#123;0&#125;,&#123;3&#125;&#125;;//显示初始化每行的首元素int （&amp;row)[3]=a[1];把row绑定到a的第二个3元素数组上int (*p)[3]=a;//p指向含有3个整数的数组p=&amp;a[1];//p指向a的尾元素 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型，因为数组名会被自动地转换成指向该数组首元素的指针。 1234567891011121314151617181920212223242526272829303132//正确for(const auto &amp;row:a)&#123; for(auto clo:row)&#123; cout&lt;&lt;col&lt;&lt;endl; &#125;&#125;//错误：row的类型是int*,显然内层循环不合法for(const auto row:a)&#123; for(auto clo:row)&#123; cout&lt;&lt;col&lt;&lt;endl; &#125;&#125;//p指向含有3个整数的数组，*p解引p得到指向内层数组首元素的指针for(auto p=a;p!=a+2;++p)&#123; for(auto q=*p;q!=*p+3;q++)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125;//简洁版for(auto p=begin(a);p!=end(a);p++)&#123; for(auto q=begin(*p);q!=end(*p);q++)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125;//类型别名简化多维数组的指针using int_arr=int[4];typedef int int_arr[4];//等价的typedegf声明for(int_arr *p=a;p!=a+2;++p)&#123; for(int *q=*p;q!=*p+3;++q)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125; 第四章 表达式 当一个对象被用作右值时，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。使用关键字decltype的时候左值右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。eg.假定p的类型是int，因为解引用运算符生成左值，所以decltype(\\p)的结果是int&amp;。另一方面，因为取地址符生成右值，所以decltype(&amp;p)的结果是int**,也就是说，结果是一个指向整型指针的指针。 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。 123cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;++i&lt;&lt;endl; //产生未定义的行为，可能先计算i再计算i++，或者先计算i++再计算i,或其他不可预知行为，所以编译器生成什么样的代码程序都是错的*beg=toupper(*beg++); //产生未定义的行为，可能先求左侧的值或先求右侧的值，也可能采取别的什么方式处理它*++iter; //正确：先递增再解引用 后置递增运算符的优先级高于解引用运算符，因此pbeg++等价于\\（pbeg++)，先自增，然后返回初始值的副本作为其求值结果，此时解引用运算符的运算对象是pbeg未增加之前得值，最终这条语句输出pbeg开始时指向的那个元素，并将指针向前移动一个位置。 解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号，如果没有括号，代码的含义就大不相同了。 12(*p).size(); //正确*p.size(); //错误：p是一个指针，它没有名为size成员 左移运算符（&lt;&lt;）在右侧插入值为0的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。 sizeof运算符返回一条表达式或一个类型名字所占的字节数，满足右结合律，其所得值是一个size_t类型的常量表达式。在sizeof的运算对象中解引用一个无效指针仍然是一种安全行为，因为指针实际上并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。sizeof运算不会把数组转换成指针来处理，对string和vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中元素的个数。 123sizeof *p; //p所指空间类型的大小，即sizeof(Sales_data),等价于sizeof(*p)，即使p是一个无效（即未初始化）的指针constexpr size_t sz=sizeof(ia)/sizeof(*ia); //返回数组ia的元素数量int arr[sz]; //sizeof返回一个常量表达式 指向任意非常量的指针能转换成void；指向任意对象的指针能转换成const void\\。 123if(cp) //如果指针cp不是0，条件为真while(*cp) //如果*cp不是空字符，条件为真while(cin&gt;&gt;s) //布尔值决定于输入流的状态，最后一次读入成功，true;反之，false 显式转换：cast_name(expression)，cast-name是static_cast（任何具有明确定义的类型转换，只要不包含底层const）/dynamic_cast（支持运行时类型识别）/const_cast（只能改变运算对象的底层const）/reinterpret_cast（通常为运算对象的位模式提供较低层次上的重新解释）中的一种。除了在有重载函数的上下文中使用const_cast无可厚非，其他强制类型转换都不应该频繁使用。 12345678int i,j;double slope=static_cast&lt;double&gt;(j)/i; //进行强制类型转换以便执行浮点数除法void* p=&amp;d; //任何非常量对象的地址都能存入void*double *dp=static_cast&lt;double*&gt;(p); //正确：将void*转换回初始的指针类型const char *pc;char *P=const_cast&lt;char*&gt;(pc); //正确：但是通过p写值时未定义的行为int *ip;char *pc=reinterpret_cast&lt;char*&gt;(ip); //牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误，eg:string str(pc)，具有高危性 第五章 语句 一般不要省略case分支的break语句，否则，程序将跨越case标签的边界；如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧跟在default标签后面的语句。 如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是违法行为。因此c++语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域的另一个位置。 for语句头能省略掉init-statement、condition和expression中的任何一个（或全部）。省略condition的效果等价于在条件部分写了一个true，则循环体内必须有语句负责退出循环。 123vector&lt;int&gt; v;for(int i;cin&gt;&gt;i;/*表达式为空*/) //条件部分能改变i值，所以这个循环无须表达式部分 v.push_back(i); 尽量不要使用goto语句，因为它使得程序既难理解又难修改。 try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问。 12345678910111213141516while(cin&gt;&gt;item1&gt;&gt;item2)&#123; try&#123; //执行添加两个Sales_item对象的代码 //如果添加失败，代码抛出一个runtime_error异常 &#125;catch(runtime_error err)&#123; cout&lt;&lt;err.what() &lt;&lt;\"\\nTry Again? Enter y or n\"&lt;&lt;endl; char c; cin&gt;&gt;c; if(!cin || c=='n') break;跳出while循环 &#125;&#125;//类型runtime_error是标准库异常类型的一种，必须提供一个string对象或者C风格的字符串初始化runtime_error的对象if(item1.isbn()!=item2.isbn()) throw runtime_error(\"Data must refer to same ISBN\"); 标准库异常类只定义了几种运算，包括创建或拷贝异常类型对象，以及为异常类型的对象赋值。异常类型只定义了一个名为what的成员函数，该函数没有参数，返回值是一个指向C风格字符串的const char*。该字符串的目的是提供关于异常的一些文本信息。如果异常类型有一个字符串初始值，则what返回该字符串。对于其他无初始值的异常类型来说，what返回的内容由编译器决定。 寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果最终还是没找到任何匹配的catch子句，程序转到名为terminate的标准函数库。对于那些没有任何try语句块定义的异常，系统同样会调用terminate函数并终止当前程序的执行。 第六章 函数 局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。 参数传递包括值传递和引用传递（引用传递直接传入对象而无须传递对象的地址，eg.可以给函数传入一个额外的引用实参，令其保存字符出现的次数）。指针传递属于值传递，当执行指针拷贝操作时，拷贝的是指针的值，拷贝之后两个指针是不同的指针，因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指的对象，但是改变局部拷贝的值并不能改变实参以及实参所指对象。 顶层const可以初始化非const,非const可以初始化顶层const,所以实参初始化形参时就会忽略掉顶层const.想调用引用版本的reset(int &amp;i)只能使用int类型的对象，而不能使用字面值、求值结果为int的表达式、需要转换的对象或者const int类型的对象，类似的，想要调用指针版本的reset(int p)只能使用int\\。 12345678910111213141516171819void fcn(const int i)&#123;/*fcn能读取i,但是不能向i写值*/&#125;void fcn(int i)&#123;/*值传递本身写值就没有意义*/&#125; //错误：重复定义了fcn(int)Record lookup(Acount*);Record lookup(Acount* const); //错误：重复声明Record lookup(Acount*);Record lookup(const Acount*); //新函数，作用于常量引用Record lookup(Acount&amp;);Record lookup(const Acount&amp;); //新函数，作用于指向常量的指针int i=1;const int ci=42; //不能改变ci的值这是一个顶层constconst int *p2=&amp;ci; //允许改变p2的值，这是一个底层constconst int *const p3=p2; //靠右的是顶层const，靠左的是底层constconst int &amp;r=ci; //用于声明引用的const都是底层const（从这里也说明不能使用指向const int对象的指针初始化int*因为int*没有底层const,eg.void reset(int *p);reset(&amp;ci)错误）int *p=p3; //错误：p3包含底层const的定义，而p没有p2=p3; //正确：p2和p3都是底层constp2=&amp;i; //正确：int*能转换成const int*int &amp;r=ci; //错误：普通的int&amp;不能绑定到int常量上const int &amp;r2=i; //正确：const int&amp;可以绑定到一个普通的int上reset(42)； //不能把普通引用绑定到字面值上，只能把const引用绑定到字面值上 数组不能拷贝所以无法以值传递的方式传递数组,因为数组会被转换成指针，所以我们为函数传递一个数组时实际上传递的是指向数组元素的指针。 1234567//尽管形式不同，但是三个print函数是等价的，每个函数都有一个const int*类型的唯一形参void print(const int*);void print(const int[]); //可以看出了，函数的意图是作用于一个数组void print(const int[10]); //这里的维度表示我们期望数组含有多少元素，实际不一定int i=0,j[2]=&#123;0,1&#125;;print(&amp;i); //正确：&amp;i的类型是int*print(j); //正确：j转换成int*并指向j[0] c++允许将变量定义成数组的引用，同理，形参也可以是数组的引用（维度是类型的一部分）。因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。 123456f(int &amp;arr[10])&#123;/*...*/&#125;; //错误：将arr声明成了引用的数组f(int (&amp;arr)[10])&#123;/*...*/&#125;; //正确：arr是具有10个整数的整型数组的引用int k[10]=&#123;0,1,2,3,4,5,6,9&#125;;print(&amp;i); //错误：实参不是含有10个整数的数组print(j); //错误：实参不是含有10个整数的数组print(k); //正确：实参是含有10个整数的数组 多维数组实际上是数组的数组，所以由多维数组名转换得到的指针实际上是指向第一个内层数组的指针。和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，由于首元素本身就是一个数组，指针就是一个指向数组的指针，数组第二维（以及后面所有的维度）的大小都是数组类型的一部分，不能省略。 123456int a[3][4];int (*p)[4]=ia; //p指向含有4个整数的数组p=&amp;a[2]; //p指向a的尾元素int *matrix[10]; //错误：10个指针构成的数组int (*matrix)[10]; //正确：指向含有10个整数的数组指针void print(int matrix[][10],int rowSize)&#123;/*...*/&#125;; //matrix的声明看起来是一个二维数组，实际上形参是一个指向含有10个整数的数组指针，等价于int (*matrix)[10] 如果函数的实参数量未知，但是全部实参的类型都相同，可以采用initializer_list类型的形参，initializer_list是一种标准库类型，用于表示某种特定类型的值的数组，initializer_list类型定义在同名的头文件中，拷贝或者赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 1234initializer_list&lt;T&gt; lst2; //默认初始化：T类型元素的空列表initializer_list&lt;T&gt; lst&#123;a,b,c...&#125; //lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是constlst2(lst);lst2=lst; 返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。不要返回局部对象的引用或指针，局部变量在函数结束后所占用的存储空间也随之被释放掉，函数终止意味着局部变量的引用将指向不再有效的内存区域。 1234567891011121314151617181920212223const string &amp;mainp()&#123; string ret; //以某种方式改变一下ret if(ret.empty())&#123; return ret; //错误：返回局部对象的引用 else return \"Empty\"; //错误：\"Empty\"是一个局部临时量 &#125;&#125;//引用返回左值：调用一个返回引用的函数得到左值，其他类型得到右值可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值char &amp;get_val(string &amp;str,string::size_type ix)&#123; return str[ix]; //get_val假定索引值是有效的&#125;int main()&#123; string a(\"a value\"); get_val(s,0)='A'; cout&lt;&lt;s&lt;&lt;endl; //输出A value&#125;//c++11规定函数可以返回花括号包围的值的列表vector&lt;string&gt; process()&#123; return &#123;&#125;; //返回一个空vector return &#123;\"functionX\",\"okay\"&#125;; //返回列表初始化的vector对象&#125; type (*function(parameter_list))[dimension]声明一个返回数组指针的函数 1234567typedef int arrT[10];using arrT=int[10];//func返回一个指向含有10个整数的数组指针arrT* func(int i); auto func(int i)-&gt;int(*)[10];int odd[]=&#123;1,2,3,4,5,6,7,8,9,0&#125;decltype(odd) *func(int i); //decltype不负责把数组类型转换成对应的指针 不允许两个函数除了返回类型外其他所有的要素都相同，对于重载函数来说，应该在形参数量或者形参类型上有所不同。 一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 123456789sz wd=80;char def=' ';sz ht();string screen(sz=ht(),sz=wd,char def);void f()&#123; def='*'; //改变默认参数值 sz wd=100; //隐藏了外层定义的wd,但是没有改变默认值，该局部变量与传递给screen的默认实参没有任何关系 window=screen(); //调用screen(ht(),80,'*')&#125; constexpr函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。内联函数和constexpr函数可以在程序中多次定义，通常定义在头文件中。 123456constexpr int new_sz()&#123;return 42;&#125; //编译器能在程序编译时验证new_sz函数返回的是常量表达式，所以可以用new_sz函数初始化constexpr类型的变量fooconstexpr int foo = new_sz();constexpr size_t scale(size_t cnt)&#123;return new_sz()*cnt;&#125; //允许constexpr函数的返回值并非一个常量，当scale的实参是常量表达式时，它的返回值也是常量表达式；反之，则不然int arr[scale(2)]; //正确：scale（2）是常量表达式int i=2; //i不是常量表达式int a2[scale(i)]; //错误：scale(i)不是常量表达式 编译器会因为函数调用具有二义性而拒绝其请求；为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下所示： 精确匹配，包括以下情况： 实参类型和形参类型相同。 实参从数组类型或函数类型转换成对应的指针类型 向实参添加顶层const或者从实参中删除顶层const 通过const转换实现的匹配 通过类型提升实现的匹配 通过算术类型转换或指针转换实现的匹配（所有算术类型转换的级别都一样，例如,从int向usigned int的转换并不比从int向double的转换级别高） 通过类类型转换实现的匹配 当我们把函数名作为一个值使用时，该函数自动转换成指针。 123456789bool lengthCompare(const string &amp;,const string &amp;);bool (*pf)(const string &amp;,const string &amp;); //未初始化pf=lengthCompare; //pf指向名为lengthCompare的函数（返回类型和形参列表要精确匹配）pf=&amp;lengthCompare; //等价的赋值语句：取地址符是可选的//调用lengthCompare函数bool b1=pf(\"hello\",\"good\");bool b2=(*pf)(\"hello\",\"goodbye\");bool b3=lengthCompare(\"hello\",\"goodbye\");pf=0; //正确：pf不指向任何函数 函数的形参：和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用。 12345678910void useBigger(const string &amp;s,bool pf(const string &amp;,const string &amp;)); //第三个形参是函数类型，它会自动地转换成指向函数的指针void useBigger(const string &amp;s,bool (*pf)(const string &amp;,const string &amp;)); //等价的声明：显式地将形参定义成指向函数的指针//Func和Func2是函数类型typedef bool Func(const string &amp;,const string &amp;);typedef decltype(lengthCompare) Func2;//FuncP和FuncP2是指向函数的指针typedef bool (*FuncP)(const string&amp;,const string&amp;);typedef decltype(lengthCompare) *FuncP2; //decltype不会将函数类型自动转换成指针类型void useBigger(const string&amp;,Func); //编译器自动地将Func表示的函数类型转换成指针void useBigger(const string&amp;,FuncP); 返回指向函数的指针：和函数类型的形参不一样，返回类型不会自动地转换成指针，我们必须显式地将返回类型指定为指针。 1234567using F=int(int*,int); //F是函数类型，不是指针using PF=int(*)(int*,int); //PF是指针类型PF f(int); //正确：PF是指向函数的指针，f返回指向函数的指针F f(int); //错误：F是函数类型，f不能返回一个函数F *f(int); //正确：显式地指定返回类型是指向函数的指针int (*f(int))(int*,int); //可以直接声明f,按照由内向外的顺序阅读这条声明：f有形参列表，所以f是个函数；f前面有*，所以f返回一个指针；指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int.auto f(int)-&gt;int(*)(int*,int); //使用尾置返回类型的方式声明一个返回函数指针的函数 编译器将所有.cpp文件编译为.obj或.o文件再把对象文件链接在一起形成可执行文件.exe或.out。如果.cpp中有#include X.h文件，那么第一步预处理会把X.h代码粘贴到.cpp中代替#include语句。 如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件。 12345678g++ factMain.cc fact.cc //生成 factMain.exe or a.outg++ factMain.cc fact.cc -o main //生成 main or main.exe//分离式编译g++ -c factMain.cc //生成factMain.og++ -c fact.cc //生成fact.og++ fact.o factMain.o //生成factMain.exe or a.outg++ factMain.o fact.o -o main //生成 main or main.exe 第七章 类 只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数；当既需要其他形式的构造函数，也需要默认的构造函数时使用 Sales_data() = defalut;来要求编译器生成构造函数。 如果类包含内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。 使用class和struct定义类唯一的区别就是默认的访问权限。struct关键字在第一个访问说明符之前的成员是public；class关键字在第一个访问说明符之前的成员是private。 class默认的继承访问权是private,struct默认的是public。 class关键字可用于定义模板参数，就像typename，但struct关键字不能。 友元的声明只能出现在类定义的内部（最好在类定义开始或者结束前的位置集中声明友元）仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，必须在友元声明之外再转名对函数进行一次声明。每个类负责控制自己的友元类或友元函数，友元关系不存在传递性。 12345678910111213141516class Screen&#123; //首先定义Window_mgr类，其中声明cleat函数，但不能定义它。在 //clear使用Screen的成员之前必须先声明Screen。 friend void Window_mgr::clear(ScreenIndex); //Screen类的剩余部分&#125;//最后定义clear，此时它才可以使用Screen的成员struct X&#123; friend void f()(/*友元函数可以定义在类的内部＊/&#125; X()｛f();｝ //错误:还没有被声明 void g(); void h();&#125;;void X::g()( return f();&#125; //错误:f还没有被声明void f(); //声明那个定义在X中的函数void X::h()&#123;return f();&#125; //正确:现在王的声明在作用域 使用类型别名等价地声明一个类型名字 12typedef std::string::size_type pos;using pos=std::string::size_type; 在变量声明中加入mutable关键字能修改类的某个数据成员，即使是在一个const函数内。 常量引用不能修改对象。常量对象不能调用非常量函数，但是非常量对象能调用常量函数。 12345怎么选择使用哪种返回传值方式-&gt;拷贝开销大吗 -&gt;不大-&gt;按值返回return-by-value(拷贝，c++11自动转化为移动来节省拷贝开销) -&gt;很大-&gt;希望对返回值的内部数据进行修改吗(引用避免拷贝开销) -&gt;不需要-&gt;按常量引用返回return-by-constant-reference -&gt;需要-&gt;按引用返回return-by-reference 即使两个类的成员列表完全一致，它们也是不同的类型。我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类名跟在关键字class或struct后面。 12Sales_data item; //默认初始化Sales_data类型的对象class Sales_data item; //一条等价的声明 只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被人为是声明过了(但尚未定义)，因此类允许包含指向它自身类型的引用或指针。 12345class Link_screen&#123; Screen window; Link_screen *next; Link_screen &amp;other;&#125;; 类内初始化，必须使用=的初始化形式(初始化Screen的数据成员时所用的)或者花括号括起来的直接初始化形式(初始化screens所用的)。Screen的构造函数接受两个尺寸参数和一个字符值，创建了一个给定大小的空白屏幕对象。 12private: std::vector&lt;Screen&gt; screens&#123;Screen(24,80,' ')&#125;; 第十章 泛型算法 泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作，所以算法容器中保存的元素，也可能在容器中移动元素，但永远不会直接添加或删除元素。 replace_copy保持原序列不变，接受额外第三个迭代器参数，之处调整后序列的保存位置；back_inserter按需要增长目标序列。 1replace_copy(ilst.cbegin(),ilst.cend,back_inserter(ivec),0,42); //ilst未改变，ivec包含ilst的一份拷贝，不过原来ilst中值为0的元素在ivec中都变为42 第十二章 动态内存、智能指针和动态数组 常量指针：指针指向的地址能改变，只能指向的内容不能改变 指针常量：指针地址不能改变，指针指向的内容可以改变 new后必须delete（传递给delete的指针必须指向动态分配的内存或者是一个空指针）；智能指针可以自动销毁 内存泄漏：内存永远不可能被归还给自由空间 不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化的形式 12shared_ptr&lt;int&gt; p1=new int(1024);//错误，隐式转换shared_ptr&lt;int&gt; p12(new int(1024));//正确，直接初始化 当将shared_ptr绑定到一个普通指针时，内存管理就交给了这个shared_ptr，就不能使用那个内置指针来访问shared_ptr指向的内存了。 unique_ptr通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique_ptr 1auto p=p2.release();//p2放弃对指针的控制权，返回指针，并将p2置空；必须记得delete(p)，此时auto代表普通指针 当创建weak_ptr时要用shared_ptr来初始化 12auto p=make_shared&lt;int&gt;(42);weak_ptr&lt;int&gt; wp(p);//wp弱共享p；p的引用计数不变 weak_ptr的lock()如果expired()为true（表示use_count==0），返回一个空shared_ptr；否则返回一个指向对象的shared_ptr 销毁动态数组时数组中的元素按逆序销毁 1delete [] p；//p必须指向一个动态分配的数组或为空 动态分配一个空数组是合法的 12char arr[0];//错误：不能定义长度为0的数组char *cp=new char[0];//正确：但cp不能解引用 unique_ptr支持管理动态数组，shared_ptr不支持除非提供自己定义的删除器 12unique_ptr&lt;int[]&gt; up(new int[10]());//up指向一个包含10个初始化为0的int的数组share_ptr&lt;int&gt; sp(new int[10]，[](int *p)&#123;delete [] p;&#125;);//sp指向一个包含10个未初始化的int数组，并提供一个删除器 make_shared函数构造shared_ptr对象时在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，使用一次内存分配；shared_ptr构造shared_ptr对象时需要进行两次内存分配 new：没有默认构造函数的类不能动态分配数组 allocator:定义在memory中，将内存分配和对象构造分离开来 管理“动态数组”时，需要制定Deleter以使用delete[]操作符销毁内存，因为shared_ptr并没有针对数组的特化版本，而unique_ptr有针对数组的特化版本。我们常常需要对动态数组中的某一个元素进行操作，但shared_ptr没有提供[]操作符，不过我们可以使用 sp.get()先获取原始指针，再对原始指针进行下标操作。而unique_ptr对动态数组提供了支持，指定删除器是一个可选项。也可以直接使用下标操作 make_unique完美传递了参数给对象的构造函数，从一个原始指针构造出一个std::unique_ptr，返回创建的std::unique_ptr。这个形式的函数不支持数组和定制删除器（见条款18） 要解决环形引用的问题，没有特别好的办法，一般都是在可能出现环形引用的地方使用weak_ptr来代替shared_ptr。weak_ptr指向shared_ptr指针指向的对象的内存，却并不拥有该内存。 但是，使用weak_ptr成员lock，则可返回其指向内存的一个shared_ptr对象，且在所指对象内存已经无效时，返回指针空值（nullptr）。由于weak_ptr是指向shared_ptr所指向的内存的，所以，weak_ptr并不能独立存在 文本查询程序——优质程序 第十五章 面向对象程序设计 类型转换与继承 虚函数：通常情况下，如果我们不使用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到，因为连编译器也无法确定到底会使用哪个虚函数。virtual函数意味着“接口必须被继承”，non-virtual函数意味着“接口和实现都必须被继承”。 抽象基类 访问控制与继承 继承中的类作用域 构造函数与拷贝控制 虚析构函数：虚析构函数阻止合成移动操作 合成拷贝控制与继承 派生类的拷贝控制成员 继承的构造函数 容器与继承 一般在容器中放置（智能）指针而非对象 Basket 文本查询程序再探 第十六章 模板与泛型编程 模板实参推断 重载与模板 可变参数模板 模板特例化","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Hexo+GitHub+NexT搭建博客","slug":"Hexo-GitHub-nexT搭建博客","date":"2020-03-23T14:26:43.000Z","updated":"2020-05-20T14:25:45.931Z","comments":true,"path":"2020/03/23/Hexo-GitHub-nexT搭建博客/","link":"","permalink":"http://yoursite.com/2020/03/23/Hexo-GitHub-nexT%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask on GitHub. （一）搭建博客操作过程 安装 Node.js 和 Git。 Node.js：https://nodejs.org/zh-cn Git：https://git-scm.com/downloads","text":"Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask on GitHub. （一）搭建博客操作过程 安装 Node.js 和 Git。 Node.js：https://nodejs.org/zh-cn Git：https://git-scm.com/downloads 下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。 安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git --version出现版本号说明安装成功。 创建GitHub Pages仓库 GitHub 主页右上角加号 -&gt; New repository： Repository name 中输入 用户名.github.io 勾选 “Initialize this repository with a README” 勾选public Description 选填 填好后点击 Create repository 创建。创建后默认自动启用 HTTPS，博客地址为：https://用户名.github.io,浏览器输入博客地址正常显示用户名.github.io。 本地安装Hexo博客程序 新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。打开该文件夹，右键 -&gt; Git Bash Here。 使用 npm 一键安装 Hexo 博客程序： 1npm install -g hexo-cli Mac 用户需要管理员权限（sudo），运行这条命令： 1sudo npm install -g hexo-cli 安装时间有点久（真的很慢！），界面也没任何反应，耐心等待 Hexo初始化和本地预览 初始化并安装所需组件： 12hexo init # 初始化npm install # 安装组件 完成后依次输入下面命令，启动本地服务器进行预览： 12hexo g # 生成页面hexo s # 启动预览 访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功！ 部署Hexo到GitHub Pages 本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。 首先安装 hexo-deployer-git： 1npm install hexo-deployer-git --save 然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下： 1234deploy: type: git repository: https:&#x2F;&#x2F;github.com&#x2F;用户名&#x2F;用户名.github.io branch: master 完成后运行 hexo d 将网站上传部署到 GitHub Pages,访问我们的 GitHub 域名 https://用户名.github.io 就可以看到 Hexo 网站了。 更换主题 在 Themes | Hexo 选择一个喜欢的主题，比如 NexT，进入网站目录打开 Git Bash Here 下载主题： 1git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next 然后修改 _config.yml 中的 theme 为新主题名称 next，发布。 （二）Hexo常用命令123456789101112131415161718192021222324252627hexo n &quot;name&quot; # 新建文章&#x3D;hexo new &quot;name&quot; hexo new page &quot;name&quot; # 新建页面hexo g # 生成页面&#x3D;hexo generatehexo d # 部署&#x3D;hexo deployhexo g -d # 生成页面并部署hexo s --debug # 调试模式下本地预览localhost:4000，可也用非调试模式hexo serverhexo clean # 清除缓存和已生成的静态文件hexo help # 帮助npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP&#x2F;&#x2F;新建文章三连hexo n &quot;name&quot; hexo g hexo s --debug&#x2F;&#x2F;预览效果满意则推到git上hexo d&#x2F;&#x2F;部署网站三连hexo clean hexo g hexo d （三）常见问题和注意事项1、Hexo 设置显示文章摘要，首页不显示全文 Hexo 主页文章列表默认会显示文章全文，浏览时很不方便，可以在文章中插入 `` 进行分段。该代码前面的内容会作为摘要显示，而后面的内容会替换为 “Read More” 隐藏起来。 2、设置网站图标 进入 themes/主题 文件夹，打开 _config.yml 配置文件，找到 favicon 修改，一般格式为：favicon: 图标地址。（不同主题可能略有差别） 3、修改并部署后没有效果 使用 hexo clean 清理后重新部署。 4、开启 HTTPS 后访问网站显示连接不安全？ 证书还未部署生效，等待一会儿，清除浏览器缓存再试。 5、Mac 安装 Hexo 报错无法安装 Mac 用户需要管理员权限运行，使用 sudo npm install -g hexo-cli 命令安装。 6、npm 下载速度慢，甚至完全没反应 使用 npm 安装程序等待很久也没反应，或者下载速度很慢，可以更换 npm 源为国内 npm 镜像。 临时更换方法：在 npm 安装命令后面加上： 1--registry https:&#x2F;&#x2F;registry.npm.taobao.org 7、注意格式标准 123title:(有空格)[文件名]tag:#标签-（有空格）c++ 8、设置SSH或HTTPS实现免密hexo deploy 方案一：如下图#号注释掉的代码，填写https：//账号:密码@github.com/账号/博客仓库名，实现HTTPS免密执行hexo d 方案二： 设置user.name和user.email配置信息，打开git bash输入： 12git config --global user.name \"你的GitHub用户名\"git config --global user.email \"你的GitHub注册邮箱\" 生成ssh密钥文件： 1ssh-keygen -t rsa -C \"你的GitHub注册邮箱\" 然后直接三个回车即可，默认不需要设置密码然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制。 打开GitHub_Settings_keys 页面，新建new SSH Key，随便填title,把刚复制的密钥粘贴到key,最后点击Add SSH key。 验证ssh是否设置成功： 1ssh git@github.com 配置站点的_config.yml文件，修改或添加repository值为ssh地址,填写git@github.com:账号/博客仓库名.git 9、hexo引用本地图片上传 安装一个图片路径转换的插件，这个插件名字是hexo-asset-image 1npm install https://github.com/CodeFalling/hexo-asset-image --save 打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For \"about\" page, the first part of \"src\" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info(\"update link as:--&gt;\"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(\"no src attr, skipped...\"); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 打开_config.yml文件，修改下述内容 1post_asset_folder: true 在md所在文件内新建一个同名文件，把图片放在该文件内 10、hexo+nexT的标签页面不显示 步骤按NexT主题配置操作 _config.yml中menu下||前面的空格删掉（||前面是链接，后面是图标） 11、用Hexo搭了个Gitpage的博客，翻页按钮不正常显示，显示为的HTML编码如下图：这是一个Font Awesome的字体图标，按道理来说这个图标应该可以正常显示的，现在这个图标不能显示了显示成了html源码。解决办法:最简单的办法就是将这个不能正常显示的字体图标改成一般的字符，我这里就是改成正常的一般左右键字符“&gt;”，“&lt;”。在 themes\\hexo-theme-next-master\\layout\\_partials\\pagination.swig下找到hexo-theme-next的翻页组件，就是将 12345678&#123;% if page.prev or page.next %&#125; &lt;nav class=\"pagination\"&gt; &#123;&#123; paginator(&#123; prev_text: '&lt;i class=\"fa fa-angle-left\"&gt;&lt;/i&gt;', next_text: '&lt;i class=\"fa fa-angle-right\"&gt;&lt;/i&gt;', mid_size: 1 &#125;) &#125;&#125; &lt;/nav&gt;&#123;% endif %&#125; 改成 12345678910&#123;% if page.prev or page.next %&#125; &lt;nav class=\"pagination\"&gt; &#123;&#123; paginator(&#123; prev_text: '&lt;', next_text: '&gt;', mid_size: 1 &#125;) &#125;&#125; &lt;/nav&gt;&#123;% endif %&#125; More info: HexoDoc MarkDown","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"NexT","slug":"NexT","permalink":"http://yoursite.com/tags/NexT/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}],"categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"常用技巧","slug":"常用技巧","permalink":"http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"安装编译","slug":"安装编译","permalink":"http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"},{"name":"搭建博客","slug":"搭建博客","permalink":"http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"effective","slug":"effective","permalink":"http://yoursite.com/tags/effective/"},{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"},{"name":"截屏","slug":"截屏","permalink":"http://yoursite.com/tags/%E6%88%AA%E5%B1%8F/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"素数筛","slug":"素数筛","permalink":"http://yoursite.com/tags/%E7%B4%A0%E6%95%B0%E7%AD%9B/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"Clion","slug":"Clion","permalink":"http://yoursite.com/tags/Clion/"},{"name":"Boost","slug":"Boost","permalink":"http://yoursite.com/tags/Boost/"},{"name":"Opencv","slug":"Opencv","permalink":"http://yoursite.com/tags/Opencv/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"NexT","slug":"NexT","permalink":"http://yoursite.com/tags/NexT/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}