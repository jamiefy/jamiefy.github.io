{"meta":{"title":"翟安然's Blog","subtitle":"","description":"","author":"翟安然","url":"http://yoursite.com","root":"/"},"pages":[{"title":"archives","date":"2020-03-25T10:42:40.000Z","updated":"2020-03-25T13:48:56.355Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-25T10:37:44.000Z","updated":"2020-03-25T15:00:42.002Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-03-25T10:41:58.000Z","updated":"2020-03-25T14:54:20.795Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-25T10:41:44.000Z","updated":"2020-03-25T13:49:16.049Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"日常常用技巧","slug":"日常常用技巧","date":"2020-03-27T06:11:04.000Z","updated":"2020-03-27T06:26:06.780Z","comments":true,"path":"2020/03/27/日常常用技巧/","link":"","permalink":"http://yoursite.com/2020/03/27/%E6%97%A5%E5%B8%B8%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"1、windows+chrome长截屏 原生长截屏 123Fn+F12Ctrl+Shift+p搜索capture full size screenshot","text":"1、windows+chrome长截屏 原生长截屏 123Fn+F12Ctrl+Shift+p搜索capture full size screenshot 安装插件Fireshot","categories":[{"name":"常用技巧","slug":"常用技巧","permalink":"http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"},{"name":"截屏","slug":"截屏","permalink":"http://yoursite.com/tags/%E6%88%AA%E5%B1%8F/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"高效算法","slug":"高效算法","date":"2020-03-25T16:51:01.000Z","updated":"2020-03-27T06:25:56.532Z","comments":true,"path":"2020/03/26/高效算法/","link":"","permalink":"http://yoursite.com/2020/03/26/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95/","excerpt":"（一）素数筛（埃拉托斯特尼sieve of Eratosthenes ）埃拉托斯特尼筛法–后续继续整理…… 素数的性质： 任意一个合数都可以表示几个质数的乘积-&gt;任意一个合数都可以表示成一个质数和另一个数的乘积 一个合数和一个质数的乘积=一个更大的合数和一个更小的质数的乘积","text":"（一）素数筛（埃拉托斯特尼sieve of Eratosthenes ）埃拉托斯特尼筛法–后续继续整理…… 素数的性质： 任意一个合数都可以表示几个质数的乘积-&gt;任意一个合数都可以表示成一个质数和另一个数的乘积 一个合数和一个质数的乘积=一个更大的合数和一个更小的质数的乘积 知识点扩展：判断互质数的五种方法 概念判断法。公约数只有1的两个数叫做互质数。根据互质数的概念可以对一组数是否互质进行判断。如：9和11的公约数只有1，则它们是互质数。 规律判断法。根据互质数的定义，可总结出一些规律，利用这些规律能迅速判断一组数是否互质。 （1）两个不相同的质数一定是互质数。如：7和11、17和31是互质数。 （2）两个连续的自然数一定是互质数。如：4和5、13和14是互质数。 （3）相邻的两个奇数一定是互质数。如：5和7、75和77是互质数。 （4）1和其他所有的自然数一定是互质数。如：1和4、1和13是互质数。 （5）两个数中的较大一个是质数，这两个数一定是互质数。如：3和19、16和97是互质数。 （6）两个数中的较小一个是质数，而较大数是合数且不是较小数的倍数，这两个数一定是互质数。如：2和15、7和54是互质数。 （7）较大数比较小数的2倍多1或少1，这两个数一定是互质数。如：13和27、13和25是互质数。 分解判断法。如果两个数都是合数，可先将两个数分别分解质因数，再看两个数是否含有相同的质因数。如果没有，这两个数是互质数。如：130和231，先将它们分解质因数：130＝2×5×13，231＝3×7×11。分解后，发现它们没有相同的质因数，则130和231是互质数。 求差判断法。如果两个数相差不大，可先求出它们的差，再看差与其中较小数是否互质。如果互质，则原来两个数一定是互质数。如：194和201，先求出它们的差，201－194＝7，因7和194互质，则194和201是互质数。 求商判断法用大数除以小数，如果除得的余数与其中较小数互质，则原来两个数是互质数。如：317和52，317÷52＝6……5，因余数5与52互质，则317和52是互质数。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"素数筛","slug":"素数筛","permalink":"http://yoursite.com/tags/%E7%B4%A0%E6%95%B0%E7%AD%9B/"}]},{"title":"Linux安装Qt/Clion编译Boost/Opencv","slug":"Linux安装Qt-Clion编译Boost-Opencv","date":"2020-03-25T16:35:36.000Z","updated":"2020-03-25T16:59:55.697Z","comments":true,"path":"2020/03/26/Linux安装Qt-Clion编译Boost-Opencv/","link":"","permalink":"http://yoursite.com/2020/03/26/Linux%E5%AE%89%E8%A3%85Qt-Clion%E7%BC%96%E8%AF%91Boost-Opencv/","excerpt":"（一）qt 安装: 首先从Qt官网上下载安装包，下载网址 给.run文件添加执行权限 1sudo chmod +x qt-opensource-linux-x64-5.12.0.run","text":"（一）qt 安装: 首先从Qt官网上下载安装包，下载网址 给.run文件添加执行权限 1sudo chmod +x qt-opensource-linux-x64-5.12.0.run 执行.run进行qt的安装 1sudo ./qt-opensource-linux-x64-5.12.0.run (二)clion安装: 官网下载 解压 1tar -zxvf CLion-2016.2.2.tar.gz 运行脚本 12cd clion-2016.2.2/bin/ ./clion.sh (三)boost编译: 官网下载压缩包.tar.gz tar -xvf boost(tab) cd boost_1_71_0 chmod 777 bootstrap.sh ./bootstrap.sh --with-libraries=all --with-toolset=gcc 指定编译boost的哪些库,all是全编译,只想编译部分库的话就把库名写上用逗号分隔开(在这步之前保证gcc g++至少为version 7),编译器用gcc 提示:to build,run:./b2 sudo ./b2 install 编译大约十分钟，提示…failed updating 60… (四)opencv编译： 到官网下载opencv4.1.0点击此处，选择source进行下载(opencv4.1.2会出错) 解压缩包unzip opencv-4.1.0.zip 对解压的文件夹进行重命名mv opencv-4.1.0 opencv sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev cd ~/opencv mkdir build cd build cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. make -j n # n为你的CPU线程数（几核就填几，电脑能力范围内的最大值） sudo make install","categories":[{"name":"安装编译","slug":"安装编译","permalink":"http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"Clion","slug":"Clion","permalink":"http://yoursite.com/tags/Clion/"},{"name":"Boost","slug":"Boost","permalink":"http://yoursite.com/tags/Boost/"},{"name":"Opencv","slug":"Opencv","permalink":"http://yoursite.com/tags/Opencv/"}]},{"title":"操作系统","slug":"操作系统","date":"2020-03-25T16:23:38.000Z","updated":"2020-04-02T10:07:49.083Z","comments":true,"path":"2020/03/26/操作系统/","link":"","permalink":"http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"1. sizeof在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，结构体变量所占空间的大小必定是最宽数据类型大小的整数倍。如有需要会在最后一个成员末尾填充若干字节使得所占空间大小是最宽数据类型大小的整数倍。内存对齐的原因： 某些平台只能在特定的地址处访问特定类型的数据； 提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量","text":"1. sizeof在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，结构体变量所占空间的大小必定是最宽数据类型大小的整数倍。如有需要会在最后一个成员末尾填充若干字节使得所占空间大小是最宽数据类型大小的整数倍。内存对齐的原因： 某些平台只能在特定的地址处访问特定类型的数据； 提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量 2. static与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。Static修饰的成员函数，在代码区分配内存。 3. C++多态分为静态多态和动态多态静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。 4. 大端小端 大端模式（Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。 小端模式（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。 口诀：大相反（低位存高位），小相同（低位存低位）。 联合体变量共享同一空间，可以通过联合体来判断大端小端。联合体同样存在内存对齐，所以联合长度至少可以容纳最大的成员。但是当最大成员大小不是** 最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍。 5.内存泄漏内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏的分类： 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc,new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。 6. 程序内存区域分配 一个程序本质上都是由 bss段、data段、text段三个组成的。bss段通常是指用来存放程序中未初始化的全局变量的一块内存区域，一般在初始化时bss 段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。比如，在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，未初始化的全局变量保存在.bss 段中。text和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化。bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小；bss段的大小从可执行文件中得到 ，然后链接器得到这个大小的内存块，紧跟在数据段后面。data段（已手动初始化的数据）则为数据分配空间，数据保存在目标文件中；data段包含经过初始化的全局变量以及它们的值。当这个内存区进入程序的地址空间后全部清零。包含data段和bss段的整个区段此时通常称为数据区。 同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Linux或windows安装Matlab注意事项","slug":"Linux安装Matlab","date":"2020-03-25T15:59:41.000Z","updated":"2020-03-25T17:00:55.060Z","comments":true,"path":"2020/03/25/Linux安装Matlab/","link":"","permalink":"http://yoursite.com/2020/03/25/Linux%E5%AE%89%E8%A3%85Matlab/","excerpt":"1、一定要把iso挂载的文件复制到home目录下，使用完整路径启动install,而不能直接进入挂载的dvd中sudo ./install","text":"1、一定要把iso挂载的文件复制到home目录下，使用完整路径启动install,而不能直接进入挂载的dvd中sudo ./install 2、windows安装注意事项： 如果之前安装过即使没安装成功，要彻底删除安装过程中产生的所有文件 安装路径不能存在中文 防火墙等杀毒软件要关闭","categories":[{"name":"安装编译","slug":"安装编译","permalink":"http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"}]},{"title":"Git操作注意事项","slug":"Git操作注意事项","date":"2020-03-25T15:53:25.000Z","updated":"2020-03-25T17:00:45.990Z","comments":true,"path":"2020/03/25/Git操作注意事项/","link":"","permalink":"http://yoursite.com/2020/03/25/Git%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"Git常规笔记及注意事项 切换到历史版本(要求此时本地项目没有未提交的修改)：git checkout &lt;版本号&gt; 查看文件的历史记录、查看某个文件在某次提交中的修改参照：使用git查看版本记录","text":"Git常规笔记及注意事项 切换到历史版本(要求此时本地项目没有未提交的修改)：git checkout &lt;版本号&gt; 查看文件的历史记录、查看某个文件在某次提交中的修改参照：使用git查看版本记录 从缓存中删除的文件git rm -r . –cached可以采用git reset HEAD .进行恢复 git reset --mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息git reset --soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git reset --hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，此命令 慎用！","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"面试要点记录","slug":"面试要点记录","date":"2020-03-25T14:33:40.116Z","updated":"2020-04-06T10:42:32.910Z","comments":true,"path":"2020/03/25/面试要点记录/","link":"","permalink":"http://yoursite.com/2020/03/25/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/","excerpt":"title: 面试要点记录date: 2020-03-24 21:59:01tags: 面试 C++ shellcategories: 面试 （一）面向对象的三个基本特征：封装、继承、多态 继承 子类对象可以直接调用父类中的成员函数 子类对象可以直接赋值给父类对象。 子类对象可以直接初始化父类对象。 父类引用可以直接引用子类对象。 父类指针可以直接指向子类对象。","text":"title: 面试要点记录date: 2020-03-24 21:59:01tags: 面试 C++ shellcategories: 面试 （一）面向对象的三个基本特征：封装、继承、多态 继承 子类对象可以直接调用父类中的成员函数 子类对象可以直接赋值给父类对象。 子类对象可以直接初始化父类对象。 父类引用可以直接引用子类对象。 父类指针可以直接指向子类对象。 子类初始化一定会先初始化父类，析构顺序相反。 虚继承对构造函数的影响：指南。构造函数的调用可能内带大量的隐藏码，因为编译器会对构造函数进行扩充，一般而言编译器所作的扩充规则如下： （1）记录在成员初始化列表中的数据成员的初始化操作会被放到构造函数本身中，按照数据成员声明的顺序 （2）如果有一个数据成员没有出现在初始化列表中，但是它有一个默认构造函数，那么这个默认构造函数会被调用 （3）在那之前，如果有虚函数表，会调整虚函数表指针 （4）在那之前，会对上一层基类的构造函数进行调用 （5）在那之前，所有虚基类的构造函数必须被调用，按照声明的继承顺序从左往右，从最深到最浅的顺序 多态 多态发生的三个必要条件： 要有继承。 要有虚函数重写。 父类指针或引用 指向 子类对象。 虚析构函数：在多态时，要调用析构函数时，注意在父类的析构成员函数前加virtual。 重载/重写（覆盖）/重定义（隐藏） 重载（overload）-编译时的多态性 （1）重载只能通过不同的参数样式（参数类型、个数、顺序至少有一个不相同），不能通过访问权限、返回类型、抛出的异常进行重载。 重写（override）-运行时的多态性 （1）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 （2）被定义为final的方法不能被重写。 重定义（隐藏hiding） （1）隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt; using namespace std; class Base &#123; private: virtual void display() &#123; cout&lt;&lt;\"Base display()\"&lt;&lt;endl; &#125; void show()&#123; cout&lt;&lt;\"Base show()\"&lt;&lt;endl; &#125; public: void exec()&#123; display(); show(); &#125; void fun(string s) &#123; cout&lt;&lt;\"Base fun(string)\"&lt;&lt;endl; &#125; void fun(int a) &#123; cout&lt;&lt;\"Base fun(int)\"&lt;&lt;endl; &#125;//overload:两个fun函数在Base类的内部被重载 virtual int function()&#123;&#125; &#125;; class ClassA:public Base &#123; public: void display() &#123; cout&lt;&lt;\"ClassA display()\"&lt;&lt;endl; &#125;//override:基类中display为虚函数，且参数列表一直，故此处为重写 void fun(int a,int b) &#123; cout&lt;&lt;\"ClassA fun(int,int)\"&lt;&lt;endl; &#125;//redefining:fun函数在Base类中不为虚函数，故此处为重定义 void show() &#123; cout&lt;&lt;\"ClassA show()\"&lt;&lt;endl; &#125;//redefining:理由同上 int function(int a)&#123;&#125;//overload:注意这是重载而不是重写，因为参数列表不同，在编译时ClassA中其实还有个编译器自己偷偷加上的从Base继承来的int function()&#123;&#125;; &#125;; int main()&#123; ClassA a; Base *base=&amp;a; base-&gt;exec();//display()是ClassA的，因为覆盖了，show()是Base自己的 a.exec();//结果同上,子类对象可以直接调用父类中的成员函数 a.show();//show()是ClassA重定义的 base-&gt;fun(1);//fun()是Base自己的，因为直接从对象base调用 a.fun(1, 1);//fun()是ClassA重定义的 return 0; &#125; //输出结果ClassA display()Base show()ClassA display()Base show()//父类中的成员函数直接调用自身的Base show()ClassA show()Base fun(int)ClassA fun(int,int) 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual void f(float x)&#123; cout &lt;&lt; \"Base::f(float) \" &lt;&lt; x &lt;&lt; endl; &#125; void g(float x)&#123; cout &lt;&lt; \"Base::g(float) \" &lt;&lt; x &lt;&lt; endl; &#125; void h(float x)&#123; cout &lt;&lt; \"Base::h(float) \" &lt;&lt; x &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: virtual void f(float x)&#123; cout &lt;&lt; \"Derived::f(float) \" &lt;&lt; x &lt;&lt; endl; &#125; void g(int x)&#123; cout &lt;&lt; \"Derived::g(int) \" &lt;&lt; x &lt;&lt; endl; &#125; void h(float x)&#123; cout &lt;&lt; \"Derived::h(float) \" &lt;&lt; x &lt;&lt; endl; &#125;&#125;;int main(void)&#123; Derived d; Base *pb = &amp;d; Derived *pd = &amp;d; // Good : behavior depends solely on type of the object pb-&gt;f(3.14f); //Derived::f(float) 3.14 pd-&gt;f(3.14f); //Derived::f(float) 3.14 // Bad : behavior depends on type of the pointer pb-&gt;g(3.14f); //Base::g(float) 3.14 pd-&gt;g(3.14f); //Derived::g(int) 3 // Bad : behavior depends on type of the pointer pb-&gt;h(3.14f); //Base::h(float) 3.14 pd-&gt;h(3.14f); //Derived::h(float) 3.14 system(\"pause\"); return 0;&#125;//函数Derived::f(float)覆盖了Base::f(float)。//函数Derived::g(int)隐藏了Base::g(float)，而不是重载。//函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。 三者 作用域 有无virtual 函数名 参数列表 返回类型 重载 相同 可有可无 相同 不同 可同可不同 重写 不同 必有 相同 相同 相同（协变） 隐藏 不同 可有可无 相同 可同可不同 可同可不同 （二）bash shell bash是borne again shell的缩写，是shell的一种,Linux上默认采用的是bash。 Shell 是一个 C 语言编写的程序，一般都是放在/bin或者/user/bin目录下，当前 Linux 系统可用的 Shell 都记录在/etc/shells文件中。/etc/shells是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令查看它。 123$ cat /etc/shells #通过 cat 命令来查看当前 Linux 系统的可用 Shell$ echo $SHELL #查看当前Linux默认的shell，输出 SHELL 环境变量$ echo $BASH_VERSION #查看shell版本 设置取消alias：指南 PHP即“超文本预处理器”，是一种通用开源脚本语言。PHP是一种在服务器端执行的嵌入HTML文档的脚本语言。PHP 独特的语法混合了C、Java、Perl 以及 PHP 自创新的语法，它可以比 CGI 或者 Perl 更快速的执行动态网页，主要适用于Web开发领域。 （三）图 拓扑排序 一个有向无环图可以有一个或多个拓扑排序序列。 判断有向图是否有环的两种方法：(1)拓扑排序 (2)DFS 五大常用算法 分冶法 分治法所能解决的问题一般具有以下几个特征： 1) 该问题的规模缩小到一定的程度就可以容易地解决 2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。 3) 利用该问题分解出的子问题的解可以合并为该问题的解； 4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加； 第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用； 第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。 第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。可用分冶法求解的一些经典问题：二分查找；快速排序。 动态规划 (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 (3) 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。 递归常常用于分冶算法和动态规划算法中。 贪心算法 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。 从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的地求得更好的解。当达到算法中的某一步不能再继续前进时，算法停止。该算法存在问题： 不能保证求得的最后解是最佳的； 不能用来求最大或最小解问题； 只能求满足某些约束条件的可行解的范围。 贪心策略适用的前提是：局部最优策略能导致产生全局最优解。贪心算法和动态规划的区别： 贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解则不作保留；动态规划：全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有的局部最优解 。求一个问题的最优解相当于遍历所有的子集来找最优解，但是这样解随着解空间的维度成指数增长，动态规划其实就是一种遍历，但是他是带备忘录的遍历，我前面算到的子问题，到这儿我不在计算，我直接调用之前保存的值，这样就节省了大量的时间。 动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常自顶向下的方式进行。 根据以上两条可以知道，贪心不能保证求得的最后解是最佳的，一般复杂度低；而动态规划本质是穷举法，可以保证结果是最佳的，复杂度高。 回溯法 在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。 分支界限法 回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。 分支限界法的搜索策略是：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。 最小生成树-Prim算法和Kruskal算法 a. 最小生成树 生成树是连通图的\\最小连通子图**。所谓最小是指：若在树中任意增加一条边，则将出现一个回路；若去掉一条边，将会使之变成非连通图。按照该定义，n个顶点的连通网络的生成树有n个顶点，n-1条边。生成树各边的权值总和称为生成树的权，\\权最小的生成树称为最小生成树**。常见的构造最小生成树的方法有Prim算法和Kruskal算法。 b. Prim算法：选取与当前节点连接的权值最小边 c. Kruskal算法：所有边按权值从小到大排序，依次选取不使最小生成树存在回路的最小权值边 最短路径-Dijkstra算法和Floyd算法：具体代码参考 a. Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。注意该算法要求图中不存在负权边。 主要思想：通过“边”来松弛v1顶点到其余各个顶点的路程。 b. Floyd算法 Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd算法是一个经典的动态规划算法。 （四）IO库 当操作符改变流的格式状态时，通常改变后的状态对所以后续IO都生效。setw类似endl不改变输出流的内部状态，只决定下一个输出的大小。 操作符hex(0x)、oct(0)、dec只影响整型运算对象，浮点型的表示形式不受影响。使用nouppercase、noshoubase和dec来重置流状态。 showbase:当打印整型值时显示进制 ios::internal:数值的符号位在域宽内左对齐,数值右对齐,中间由填充字符填充 setfill()：允许一个字符替代默认的字符填补空白 setbase：将整数设置为b进制 cout.setf()的作用是通过设置格式标志来控制输出形式；cin&gt;&gt;noskipws设置cin读取空白符; cin&gt;&gt;skipws将cin恢复到默认状态，丢弃空白符 12345std::cout.setf ( std::ios::hex, std::ios::basefield );//set hex as the basefieldstd::cout.setf ( std::ios::showbase ); //activate showbasestd::cout &lt;&lt; 100 &lt;&lt; '\\n'; //输出0x100std::cout.unsetf ( std::ios::showbase ); //deactivate showbasestd::cout &lt;&lt; 100 &lt;&lt; '\\n'; //输出100 未格式化输出中is.get()将is的下一个字节作为int返回，头文件cstdio定义了一个名为EOF的const，用来检测返回的值是否是文件末尾，而不必记忆表示文件尾的实际数值。 1234int ch;//使用一个int,而不是char来保存get()的返回值,否则循环可能永远不会停止，循环也可能会在遇见'\\377'的字符提前终止（-1转换为一个singed char会得到'\\377'）//循环读取并输出输入中的所有数据while((ch=cin.get())!=EOF) cout.put(ch); istream和ostream类通常不支持随机访问，只有fstream、sstream支持。 STL : std::map/std::set std::unordered_map/std::unordered_set结构 std::map:红黑树，自动排序，稳定查找插入删除时间复杂度O(lgn)，空间占用低，(但是因为红黑树每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间） std::unordered_map:哈希表，无序，快速查找插入删除，insert/find/erase的平均时间复杂度是O(1)，但是最坏复杂度是O(N)，空间占用高，哈希表建立比较耗费时间，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表地址顺序从前往后依次遍历的 存储小对象，内存消耗从小到大依次是：vector &gt;&gt; map &gt;&gt; unordered_map;当存储的对象增大时，vector的优势变得并不明显。因为随着对象增大，用于存储对象的空间所占的比例越来越大。因此单从内存消耗的角度来看，当存储的是小对象时，vector占很大的优势。但是，当存储的对象本身大小增大时，它的优势变得不再那么明显。 顺序容器 vector:可变大小数组，支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢，vector插入insert删除erase时间复杂度均是O(n) deque:双端队列，支持快速随机访问。在头尾部位置插入/删除速度很快 list:双向链表。支持双向顺序访问，在链表任何位置进行插入/删除操作速度都很快 forward_list:单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快 array:固定大小数组，支持快速随机访问。不能添加或删除元素 string:与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快 除固定大小的array外，其他容器都提供高效、灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器大小。string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入和删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。而且添加一个元素有时可能还需要分配额外的存储空间。在这种情况下，每个元素必须都移动到新的存储空间中。 list和forward_list两个容器添加和删除操作都很快，但是不支持元素的随机访问，为了访问一个元素，只能遍历整个容器，与vector、deque、array相比，这两个容器的额外内存开销很大。 指针大小由当前CPU运行模式的寻址位数决定 32位处理器上32位操作系统的32位编译器，指针大小4字节。32位处理器上32位操作系统的16位编译器，指针大小2字节。32位处理器上16位操作系统的16位编译器，指针大小2字节。16位处理器上16位操作系统的16位编译器，指针大小2字节。 这从结果看起来指针的大小和编译器有关？？ 实际不是这样的，有这样的结果是因为以上几种情况，处理器当前运行模式的寻址位数是不一样的，如下： Intel 32位处理器32位运行模式，逻辑寻址位数32，指针也就是32位，即4个字节 Intel 32位处理器16位虚拟机运行模式，逻辑寻址位数16，指针也就是16位，即2个字节 编译器的作用是根据目标硬件（即CPU）的特性将源程序编译为可在该硬件上运行的目标文件。如果一个编译器支持某32位的CPU，那么它就可以将源程序编译为可以在该CPU上运行的目标文件。该源程序中指针大小也会被编译器根据该CPU的寻址位数（如32位）编译选择为4字节。 访问一个网页的全过程：参考 域名解析成IP地址（搜索浏览器自身缓存，没有的话向DNS服务器发出解析请求）； 与目的主机进行TCP连接（三次握手）； 发送与收取数据（浏览器与目的主机开始HTTP访问过程）； 与目的主机断开TCP连接（TCP四次挥手）； OSI模型：应用层（HTTP） 表示层（SSL握手协议：加密） 会话层（SSL记录协议） 传输层（TCP/UDP端到端 段Segment 数据报文） 网络层 (IP数据包Packet) 数据链路层(逻辑链路控制子层（LLC）媒体访问控制子层（MAC）数据帧Frame) 物理层(物理介质Bit) 消息（message）：是指起始点和目的地都在网络层以上（经常在应用层）的信息单元。 TCP/UDP五层模型：应用层 传输层 网络层 数据链路层 物理层 编程内存的基本构成（堆、存储区别） 1.内存 （1）静态内存（静态分配）：发生在程序编译和链接阶段，存在于程序的整个生命周期，内存大小固定，不占用CPU资源 .bss段：存放未初始化的全局变量和static静态变量 .data段（全局初始化区）：存放初始化的全局变量 常量存储区 .txt段（代码区）：存放程序代码 注意： ​ 代码区：存放函数体的二进制代码 ​ 常量存储区：常量字符串就是放在这里的。 程序结束后由系统释放 ​ 函数指针指向Code区，是程序运行的指令代码，数据指针指向Data,Heap,Stack 区，是程序依赖以运行的各种数据 ​ 在文件作用域声明inline函数默认为static存储类型,const常量默认为static存储， 如果加上extern，则为外部存储类型 （2）动态内存（动态分配）：发生在程序调入和执行阶段，根据程序的需要分配和释放，其大小可变，占用CPU资源 堆：链表结构，程序通过调用malloc和new分配，调用free和delete释放；堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。堆中的存储内容一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 栈：线性结构，由编译器分配与释放（当我们要通过某种手段在堆内存上分配一段空间后，我们需要一个变量作为左值来接受这块内存，这个作为左值的变量就是分配在栈空间的）；函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放，函数退出时，其占用内存被收回；进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。一个堆栈可以通过“基地址”和“栈顶”地址来描述。栈是向低地址扩展的数据结构，是一块连续的内存的区域。栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。栈中的存储内容在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 12345678910111213141516171819202122//main.cpp int a = 0; //a存储在全局初始化区 ，静态内存，0存储在常量区随程序结束而释放char *p1; //全局未初始化区 ，静态内存int* p=new int(4); //p存储在全局初始化区，静态内存，分配得来的4存储在堆区main() &#123; int b; //栈 char s[] = \"abc\"; //栈 char *p2; // 栈 char *p3 = \"123456\"; //\"123456\\0\"在常量区（不同于数组数据可存储在数组里），静态内存，p3在栈上。 static int c =0； //全局（静态）初始化区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); //分配得来的10和20字节的区域就在堆区。 strcpy(p1, \"123456\"); //\"123456\\0\"放在常量区，编译器可能会将它与p3所指向的\"123456\"优化成一个地方。 char* p = \"Hello World1\";char a[] = \"Hello World2\";p[2] = 'A';a[2] = 'A';char* p1 = \"Hello World1\"; //这个程序是有错误的，错误发生在p[2] = 'A'这行代码处，为什么呢，是变量p和变量数组a都存在于栈区的（任何临时变量都是处于栈区的，包括在main（）函数中定义的变量）。但是，数据“Hello World1”和数据“Hello World2”是存储于不同的区域的。因为数据“Hello World2”存在于数组中，所以，此数据存储于栈区，对它修改是没有任何问题的。因为指针变量p仅仅能够存储某个存储空间的地址，数据“Hello World1”为字符串常量，所以存储在静态存储区。虽然通过p[2]可以访问到静态存储区中的第三个数据单元，即字符‘l’所在的存储的单元。但是因为数据“Hello World1”为字符串常量，不可以改变，所以在程序运行时，会报告内存错误。并且，如果此时对p和p1输出的时候会发现p和p1里面保存的地址是完全相同的。换句话说，在数据区只保留一份相同的数据。 2.malloc malloc calloc realloc的区别 123void* malloc(unsigned size);void* realloc(void* ptr, unsigned newsize); void* calloc(size_t numElements, size_t sizeOfElement); 都在stdlib.h函数库内，它们的返回值都是请求系统分配的地址,如果请求失败就返回NULL. (1)函数malloc() 在内存的动态存储区中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度，返回该区域的首地址. (2)函数calloc() 与malloc相似,参数sizeOfElement为申请地址的单位元素长度,numElements为元素个数，即在内存中申请numElements*sizeOfElement字节大小的连续地址空间. (3)函数realloc()给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度.如果在该存储区后有足够的空间可供扩充，则可在原存储区位置上向高地址方向扩充，并返回传送给它的同样的指针值。如果在原存储区后没有足够的空间，则realloc分配另一个足够大的存储区，将现存的512个元素数组的内容复制到新分配的存储区。因为这种存储区可能会移动位置，所以不应当使用任何指针指在该区中。注意，realloc的最后一个参数是存储区的newsize(新长度)，不是新、旧长度之差。作为一个特例，若ptr是一个空指针，则realloc的功能与malloc相同，用于分配一个指定长度newsize的存储区。 malloc和free的操作原则 1) 配对使用，配对使用，避免内存泄漏和多重释放（C语言提供了malloc和free两个系统函数，完成对堆内存的申请和释放。而C++则提供了两个关键字new和delete）。 2) 尽量在同一层上使用，不要像上面那种，malloc在函数中，而free在函数外。最好在同一调用层上使用这两个函数。 3) malloc分配的内存一定要初始化。free后的指针一定要设置为NULL。 注意： new/delete是关键字，效率高于malloc和free。new/delete 主要是用在类对象的申请和释放。申请的时候会调用构造器完成初始化，释放的时候，会调用析构器完成内存清理。 new和malloc的区别 属性 new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持。 参数 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。 返回类型 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。 自定义类型 new做两件事：分配内存和调用类的构造函数，new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。 delete：调用类的析构函数和释放内存。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。 而malloc和free只是分配和释放内存。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。 - 重载 C++允许重载new/delete操作符，malloc不允许重载。 - **内存区域** new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。 **PS:** 在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区； 在C中，C内存区分为4个区堆、栈、全局/静态存储区、常量存储区 - 分配失败 new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。 - 内存泄漏 内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc确不可以。 快速排序 堆排序 给你100个数找出最大的前五十个 partition 时间复杂度O(n) 最大堆 时间复杂度O(nlgk) (海量数据) mutiset 时间复杂度O(n)空间复杂度O(n) 笔试题： 123456789101112131415161718192021222324252627282930提示：优先写源码，源码有难度可以写伪代码 或 思路。要求：c或c++, 尽量使得时间复杂度较低，写出完整代码。题目：查找元素element在非降序正整数数组a中的最左下标位置,数组大小为size.例子：元素2在数组a[1,1,2,2,4,6,21]的最左位置为2.int searchRange(int *a, int left,int right,int target)&#123;while(left&lt;right)&#123;int middle=(right-left)/2+left;if(a[middle]==target)&#123;middle-=1;while(a[middle]==target)midlle--;return middle+1;&#125;if(a[middle]&lt;target)left=middle+1;elseright=middle-1;&#125;return left;&#125;int find_pos(int* a, int size, int element)&#123;if(size==0)return -1; int leftIndex=searchBoundEqual(a,0,size-1,element); if(leftIndex==size||a[leftIndex]!=target) return -1; return leftIndex;&#125;std::find(a,a+size,target); 手写代码 一个数组中有多个整数， 其中有两个重复的数字，如何找出来，考虑一下时间复杂度和空间复杂度 给两个字符串A和B，找出A对于B的最长前缀。 单链表逆序 一个链表的连续区间和最大值，及其对应区 数组中，连续和最大的区间 判断一个链表是否有环，并确定环的位置，如何确定两个链表是否有相同的部分 写个小程序，一个数组，长100，里边乱序分布数字1-100，在数组中随机挑选一个位置的数字，将其替换为-1，如何判断，被替换掉的数字是多少？ 跳台阶，一次跳1个，也可以跳2个，问，n个台阶有多少种跳法 dfs bfs dp迷宫 linux命令 查找 vi 保存 修改权限 C语言和c++的区别 c++兼容c。区块（blocks）、语句（statements）、预处理器（preprocessors）、内置数据类型（build-in data types）、数组（arrays）、指针（pointers）等统统来源于c。 c仅支持面向过程，c++还支持面向对象：包含封装、继承、多态三大特性和虚函数、虚函数表指针、虚基类表指针等。 c++包含泛型编程、模板元编程。 c++包含STL。 进程间的通信方式（IPC,inter-Process Communication） 同一主机中两个进程间的通信由操作系统决定，不同主机间的通信进程通过网络交换报文进行。 信号：用于通知进程某个事件已经发生 管道：读写操作符合先进先出原则，对于两端的进程而言就是文件，向管道中写入数据时,linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。 无名管道pipe:半双工的通信方式，数据单向流动，只能在具有亲缘关系的进程间使用，从结构上看，无名管道没有文件路径名，不占用文件目录项，因此文件目录结构中的链表不适用于这种文件，它只是存在于打开文件结构中的一个临时文件，依附于进程临时存在。 命名管道FIFO:半双工，数据单向流动，允许无亲缘关系进程间的通信，FIFO是一种永久性的机制，它具有普通的UNIX系统文件名。在系统下可利用MKNOD命令建立永久的管道，除非刻意删除它，否则它将一直保持在系统中。 联系： 1) 通信数据只存在于内存缓冲页面中； 2) 都是半双工通信； 区别： 无名管道是无名的，有名管道是有名的； 无名管道只能用于父子进程或兄弟进程之间的通信，而有名管道可用于任意两进程之间通信； 无名管道是无形的，即无名管道的 inode 结构不是在磁盘上存储的，而是临时生成的，而有名管道的 inode 结点在磁盘上。 消息队列：消息的链表存放在内核中并由消息队列标识符标识，克服了信号传递信息少，管道只能承载无格式字节流以及缓冲器大小受限等缺点，但只有在内核重启时才能删除一个消息队列，内核重启也就是系统重启。 共享内存：最快的IPC方式，映射一段能被其他进程所访问的内存。往往与其他通信机制如信号两两配合使用，来实现进程间的同步和通信。 信号量Semaphore:信号量是一个计数器，可以用来控制多个进程对共享资源的访问。常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 套接字Socket:套接字也是一种进程间通信机制，包括IPC 套接字（即 Unix 套接字）给予进程在相同设备（主机）上基于通道的通信能力；而网络套接字给予进程运行在不同主机的能力，因此也带来了网络通信的能力。IPC 套接字依赖于本地系统内核的支持来进行通信。网络套接字需要底层协议的支持，例如 TCP（传输控制协议）或 UDP（用户数据报协议），包括流套接字（TCP/IP）和数据报套接字（UDP/IP），利用三元组（ip地址，协议，端口）构成套接字；传输层实现端到端的通信，传输层连接的端点叫做套接字。 进程和线程 进程识别信息：表示哪台主机上的哪一个进程 主机名称或地址：网络中的哪一个主机。因特网中，用IP地址标识（32位，全球唯一）。 进程的标识：主机中的哪一个进程。因特网中，采用端口号标识。创建一个新的网络应用程序时，必须分配一个新的端口号。不得重复。 fork后操作系统会复制一个与父进程完全相同的子进程，两个进程共享代码空间，但数据空间相互独立，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别作不同的工作，也就是分岔了。这也是fork为什么叫fork的原因至于那一个最先运行，可能与操作系统（调度算法）有关，而且这个问题在实际应用中并不重要，如果需要父子进程协同，可以通过原语的办法解决。 fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别： fork （）：子进程拷贝父进程的数据段，代码段vfork （ ）：子进程与父进程共享数据段，子进程中对父进程变量的修改，会影响父进程 fork （）父子进程的执行次序不确定vfork 保证子进程先运行，在调用exec() 或_exit() 之前与父进程数据是共享的,在它调用exec()或_exit()之后父进程才可能被调度运行。 若vfork （）调用exec 或_exit() 之前子进程依赖于父进程的进一步动作，会导致死锁。 进程和线程的区别 ​ （1）进程是资源分配和调度的一个独立单元，而线程是CPU调度和分派的基本单元​ （2）一个进程至少包括一个线程，并且同一个进程的所有线程共享整个进程的资源，因此线程执行时一般都要进行同步和互斥​ （3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束​ （4）线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的​ （5）进程间通信IPC需要特别的方法，线程间可以直接读写进程数据段（如全局变量）来进行通信。 线程有什么是共享的什么是私有的 线程共享的环境包括： 1.进程代码段 2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯) 3.进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。 线程独立的资源包括： 1.线程ID 2.寄存器组的值 由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。 3.线程的堆栈 堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。 4.线程的错误返回码 由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。 5.线程的信号屏蔽码 6.线程的优先级 注：线程有自己的私有属性线程控制块TCB，进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志。 线程同步 用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。 内核模式下的方法有：事件，信号量，互斥量。 1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。2、互斥量:为协调共同对一个共享资源的单独访问而设计的。3、信号量:为控制一个具有有限数量用户资源而设计。4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。 进程的几种状态？ （1）run（运行状态）：正在运行的进程或在等待队列中等待的进程，等待的进程只要一得到cpu就可以运行 （2）Sleep（可中断休眠状态）：相当于阻塞或在等待的状态 （3）D（不可中断休眠状态）：在磁盘上的进程 （4）T（停止状态）：这种状态无法直观的看见，因为是进程停止后就释放了资源，所以不会留在linux中 （5）Z（僵尸状态）：子进程先于父进程结束，但父进程没有调用wait或waitpid来回收子进程的资源，所以子进程就成了僵尸进程，如果父进程结束后仍然没有回收子进程的资源，那么1号进程将回收 线程间通信：由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）。 进程间的通信则不同，它的数据空间的独立性决定了它的通信相对比较复杂，需要通过操作系统。以前进程间的通信只能是单机版的，现在操作系统都继承了基于套接字（socket）的进程间的通信机制。这样进程间的通信就不局限于单台计算机了，也可以实现不同操作系统间的网络通信，eg.windows和Linux操作系统通过Socket进行进程间通信。 windows进程通信 标准的Windows进程间通信方法有三种：匿名管道、命名管道（又叫FIFO，命名管道可以控制读消息的长度，一个命名管道可以有多个实例，具体通信还是一对一）、邮槽（MailSlot）。共享内存也可用于windows进程通信，但因为其实是Windows“内存映射文件”的一个特殊用法，所以不算作标准的windows进程间通信方法。 对比点 匿名管道 命名管道 邮槽 共享内存 消息格式 字符 二进制 数据包 - 工作模式 半双工 全双工 单向 双向 访问模式 只能在一台机器上 可以跨网络 可以跨网络 只能在一台机器上 通信模式 一对一，父子进程用 一对多，不同进程均可用 广播机制 - windows命名管道和Linux命名管道的区别 对比点 Linux命名管道 Windows命名管道 备注 消息格式 字节流 二进制 windows更牛 工作模式 半双工 全双工 windows更牛 访问模式 只能在一台机器上 可以跨网络 windows更牛 windows线程通信 windows下，一个典型的线程拥有自己的堆栈、寄存器（包括程序计数器PC，用于指向下一条应该执行的指令在内存中的位置），而代码段、数据段、打开文件这些进程级资源是同一进程内多个线程所共享的。因此同一进程的不同线程可以很方便的通过全局变量（数据段）进行通信，使用多线程相对于多进程来说有很多优点： ① 无需跨进程边界； ② 程序逻辑和控制方式简单； ③ 所有线程可以直接共享内存和变量等； ④ 线程方式消耗的总资源比进程方式好； windows多线程通信的方法主要有三种： 1.全局变量 由于同一进程下的线程之间共享数据空间。当需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，来告诉编译器这个全局变量是“易变”（更直接的讲是“直接存取原始内存地址”，更明确的说是不要编辑器去读缓存中的数据，而是直接从内存中获取变量的值）的，让编译器不要对这个变量进行优化。 2.Message消息机制常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。 3.CEvent对象 CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。 Linux线程通信 线程间无需特别的手段进行通信，因为线程间可以共享数据结构，也就是一个全局变量可以被两个线程同时使用。不过要注意的是线程间需要做好同步，一般用mutex。 死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？ （1）相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态 （2）系统资源不足、相互竞争资源、请求资源顺序不当 （3）互斥、不可抢占、循环等待、请求与保持 （4）因为互斥是不可改变的，所以只能破坏其他三个条件中的一个来解除死锁，方法：剥夺资源、杀死其中一个线程 Windows内存管理方式：段存储、页存储、段页存储 什么是虚拟内存？ 虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还可以通过覆盖或者把处于不活动状态的程序以及它们的数据全部交换到外部磁盘存储器上临时存储。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。 对于32位的Linux操作系统，系统为每个进程分配4G的虚拟内存。 虚拟内存中，允许将一个作业分多次调入内存。釆用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式： 请求分页存储管理。 请求分段存储管理。 请求段页式存储管理。 不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面： 一定容量的内存和外存。 页表机制（或段表机制），作为主要的数据结构。 中断机制，当用户程序要访问的部分尚未调入内存，则产生中断。 地址变换机制，逻辑地址到物理地址的变换。 最小圆覆盖 1）任意选取距离最远两点p1、p2，以p1p2做直径画圆； 2）如果所有点都在圆内，则该圆即为包括所有点的最小圆；否则选取圆外一点距离圆心最远点pi,寻找覆盖pi和集合Di-1的最小圆Di=MiniDiskWithPoints({p1，p2，p3......pi-1}，pi)，循环第（2）步直到Di包括所有点，即得到最小包围圆。 123456789101112131415161718Function MiniDiskWithPoints（P，q）Input：由平面上n个点构成的一个集合P，以及另外一个点qOutput：在满足“边界穿过q”的前提下，P的最小包围圆 1.令D1为对应于&#123;p1，q&#125;的最小包围圆 2.for j ← 2 to n 3. do if pj ∈Dj-1 4. then Dj ← Dj-1 5. else Dj ← MiniDiskWithPoints&#123;&#123;p1，p2,p3......pj-1&#125;，pj，pi&#125; 6.return DnFunction MiniDiskWithPoints（P，q1，q2）Input：由平面上n个点构成的一个集合P，以及另外两个点q1，q2Output：在满足“边界穿过q1，q2”的前提下，P的最小包围圆1. 令D0为对应于q1，q2的最小包围圆2. for k ← 1 to n3. do if pk∈Dk-14. then Dk ← Dk-15. else Dk ← q1，q2和pk确定的圆6. return Dn 给定一个无序数组，求这个数组变为有序后相邻元素之差的最大值是多少，要求时间复杂度是O(n) 方法一：排序，计算。时间复杂度O(nlgn)，空间复杂度O(1) 方法二：std::multiset，计算。时间复杂度O(n),空间复杂度O(n) 方法三：桶排序。时间复杂度O(n),空间复杂度O(n) 一致性哈希？渐进性哈希？ 一致性哈希是一种特殊的哈希算法，目的是解决分布式缓存的问题。在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表( Distributed Hash Table，DHT) 中存在的动态伸缩等问题。 首先，对存储节点的哈希值进行计算，其将存储空间抽象为一个环，将存储节点配置到环上。环上所有的节点都有一个值。其次，对数据进行哈希计算，按顺时针方向将其映射到离其最近的节点上去。当有节点出现故障离线时，按照算法的映射方法，受影响的仅仅为环上故障节点开始逆时针方向至下一个节点之间区间的数据对象，而这些对象本身就是映射到故障节点之上的。当有节点增加时，比如，在节点A和B之间重新添加一个节点H，受影响的也仅仅是节点H逆时针遍历直到B之间的数据对象，将这些重新映射到H上即可，因此，当有节点出现变动时，不会使得整个存储空间上的数据都进行重新映射，解决了简单哈希算法增删节点，重新映射所有数据带来的效率低下的问题。 渐进性哈希 当hash表满员时（或负载因子高于阈值时）会进行rehash,也就是重新调整空间大小，并拷贝原来的数据。这里rehash就是优化效率的关键。例如假设有1w个元素，rehash时要拷贝1w元素到新的空间，这样势必会成为很大的负担。 redis的数据库使用字典来作为底层实现的，对数据库的增删查改操作也是构建在对字典的操作之上。redis的字典使用hash表作为底层实现。 redis作为一个广泛使用的内存数据库，时间和空间效率都是至关重要的。（redis的根本就是一个大的hashmap，所以对hashmap的优化十分重视） redis采用渐进式rehash来解决这个问题。 何为渐进式rehash？就是把拷贝节点数据的过程平摊到后续的操作中，而不是一次性拷贝。所谓平摊到后续的操作中，就是对节点操作，例如再次插入，查找，删除，修改时都会进行拷贝。 算法题给定一个长字符串zesfjjk和一个短字符串xsfjx，求短字符串在长字符串中出现的最长部分是什么？sfj 最长公共子字符串 友元函数注意事项 1）必须在类的说明中说明友元函数，说明时以关键字friend开头，后跟友元函数的函数原型，友元函数的说明可以出现在类的任何地方，包括在private和public部分；2）注意友元函数不是类的成员函数，所以友元函数的实现和普通函数一样，在实现时不用”::”指示属于哪个类，只有成员函数才使用”::”作用域符号；3）友元函数不能直接访问类的成员，只能访问对象成员，4）友元函数可以访问对象的私有成员，但普通函数不行；5）调用友元函数时，在实际参数中需要指出要访问的对象，6）友元的声明只能出现在类定义的内部（最好在类定义开始或者结束前的位置集中声明友元），仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，必须在友元声明之外再转名对函数进行一次声明。每个类负责控制自己的友元类或友元函数，友元关系不存在传递性。类与类之间的友元关系不能继承. 模板 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。 模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。 HTTP 与 HTTPS 区别 http是超文本传输协议，信息是明文传输，未加密；https则是具有安全性的ssl加密传输协议。 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 根证书，一般免费证书较少，因而需要一定费用。 HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。 http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。 HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。 客户端在使用HTTPS方式与Web服务器通信步骤 （1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。 （2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。 （3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。 （4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 （5）Web服务器利用自己的私钥解密出会话密钥。 （6）Web服务器利用会话密钥加密与客户端之间的通信。 怎么理解http协议的无连接无状态 HTTP协议又称超文本传输协议；是OSI模型中的第七层应用程中协议；具有以下特点： 1、支持客户/服务器模式; 2、简单快速; 3、灵活; 4、无连接; 5、无状态； 无连接：指的是每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接；这种方式有利于节省传输时间；然后随着互联网的发展，一台服务器同一时间处理的请求越来越多，如果依然采用原来的方式，将会在建立和断开连接上花费大部分时间。为了避免这一劣势，针对http无连接，人们设计了非持久连接和持久连接。实际上关于http协议非持久连接和持久连接是针对tcp协议的。 非持久连接：请求一个HTTP请求/响应需要的总时间为客户端发出建立连接和发生请求报文+服务器传输HTML文件的时间。 持久连接：服务器在发送响应后，保持该TCP连接打开。在相同的客户机与服务器之间的后续请求和响应报文通过相同的连接进行传送。不需要再次建立tcp连接 ，但是由于所有的连接都是串行的，当某一个请求阻塞时就会导致同一条连接的后续请求被阻塞。为了解决这一问题：提出了pipellining的概念；客户端发起一次请求时不必等待响应便直接发起第二个请求；服务端按照请求的顺序一次返回结果；SPDY和HTTP/2:multiplexing：多路复用技术出现；能够让多个请求和响应的传输完全混杂在一起进行；通过streamID来互相区别； PS:HTTP借助于底层的TCP虚拟连接，HTTP协议本身无需连接；就好比A和B打电话，A和B是借助于底层的简化先连接交换信息；但是A和B本身无需连接； 无状态：是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。言外之意是说http协议没法保存客户机信息，也就没法区分每次请求的不同之处。关于http无状态阻碍了交互式应用程序的实现。比如记录用户浏览哪些网页、判断用户是否拥有权限访问等。于是，两种用于保持HTTP状态的技术就应运而生了，一个是Cookie，而另一个则是Session。 cookie和session的区别 1、Cookie和Session都是会话技术，Session是运行在服务器端，用来跟踪用户的状态，数据可以保存在集群、数据库、文件中；Cookie是运行在客户端，用来记录用户的一些信息，也是实现Session的一种方式。 2、Cookie有大小限制以及浏览器存储cookie的个数也有限制，Session是没有大小限制和存储个数与服务器的内存大小有关。 3、Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。 4、Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。 共享session 基于数据库的Session共享 基于NFS共享文件系统 基于memcached 的session，如何保证 memcached 本身的高可用性？ 基于cookie 进行session共享 基于resin/tomcat web容器本身的session复制机制 基于TT/Redis 或 jbosscache 进行 session 共享。 http状态码分类 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务端错误，服务器在处理请求的过程中发生了错误 http 客户端发送一个HTTP请求到服务器的请求消息包括请求行（request line）、请求头部（header）、空行和请求数据四个部分 HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文 URL由4部分组成：协议、主机、端口、路径;一般语法格式为(带方括号[]的为可选项,参考)： protocol :// hostname[:port] / path / [;parameters] [?query] [#fragment] get和post的区别 TCP/UDP传输的应用 TCP/UDP拥塞机制 拥塞窗口 多继承 续继承 多态的目的 gooletest 栈的大小 10MB linux管道 grep 无序数组 寻找不在该数组范围内的最小正整数 最长回文子 垃圾回收机制 重点网络 和 linux","categories":[],"tags":[]},{"title":"C++易混点","slug":"C-易混点","date":"2020-03-24T06:44:02.000Z","updated":"2020-04-06T05:25:54.577Z","comments":true,"path":"2020/03/24/C-易混点/","link":"","permalink":"http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/","excerpt":"（一）虚函数表指针、虚基类表指针 非虚继承时，不需要额外增加虚函数表指针。单继承：一个虚函数表，一个虚表指针；多继承：子类的虚表指针数=父类数。 虚继承时：无论是单虚继承还是多虚继承，需要有一个虚基类表来记录虚继承关系，所以此时子类有且仅有一个虚基类表指针；多虚继承时子类可能持有多个虚函数表：如果子类没有构造函数和析构函数，且子类中的虚函数都是在父类中出现的虚函数，这个时候不需要增加任何虚表指针，只需要像多继承那个持有父类个数的虚函数表指针来标识即可。","text":"（一）虚函数表指针、虚基类表指针 非虚继承时，不需要额外增加虚函数表指针。单继承：一个虚函数表，一个虚表指针；多继承：子类的虚表指针数=父类数。 虚继承时：无论是单虚继承还是多虚继承，需要有一个虚基类表来记录虚继承关系，所以此时子类有且仅有一个虚基类表指针；多虚继承时子类可能持有多个虚函数表：如果子类没有构造函数和析构函数，且子类中的虚函数都是在父类中出现的虚函数，这个时候不需要增加任何虚表指针，只需要像多继承那个持有父类个数的虚函数表指针来标识即可。 如果子类中含有构造函数或者析构函数或二者都有，则在子类中只要出现一个父类中的虚函数则需要增加一个虚函数表指针来标识此类的虚函数表；无论是否含有构造函数或者虚构函数，只要继承都是虚继承且出现了父类中没有出现的虚函数，则在子类中需要再增加一个虚函数表指针；如果其中有一个是非虚继承，则按照最省空间的原则，不需要增加虚函数表指针，因为这个时候可以和非虚基类共享一个虚函数表指针。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class Base1&#123;int a;public:virtual void fun1()&#123;cout &lt;&lt; \"Base1::fun1\" &lt;&lt; endl;&#125;&#125;;class Base2&#123;int b;public:virtual void fun1()&#123;cout &lt;&lt; \"Base2::fun1\" &lt;&lt; endl;&#125;virtual void fun2()&#123;cout &lt;&lt; \"Base2::fun2\" &lt;&lt; endl;&#125;&#125;;class Derive1 : public Base1&#123;int d1;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive1::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive1::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive2 : virtual public Base1&#123;int d2;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive2::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive2::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive3 : virtual public Base2&#123;int d3;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive3::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive3::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive4 : public Derive2, public Derive3&#123;int d4;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive4::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive4::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive5 : public Base1, public Base2&#123;virtual void d_fun()&#123;cout &lt;&lt; \"Derive5::d_fun\" &lt;&lt; endl;&#125;&#125;;//输出结果为：pstr1为虚函数表指针，vpstr为虚基类表指针sizeof(Base1):8 //sizeof(int) + sizeof(pstr) = 4+4sizeof(Base2):8 //同上sizeof(Derive1):12 //sizeof(int) + sizeof(pstr) + sizeof(int)= 4+4+4sizeof(Derive2):20 //sizeof(int) + sizeof(Base1的pstr) +sizeof(Derive2的pstr) + sizeof(vpstr)+ sizeof(int)= 4+4+4+4+4sizeof(Derive3):20 //同上sizeof(Derive4):44 //sizeof(Derive2) + sizeof(Derive3) + sizeof(int)sizeof(Derive5):16 //sizeof(Base1) + sizeof(Base2) （二）万能头文件基本上所有的代码只要用了这个头文件就不再写其他头文件了。 #include&lt;bits/stdc++.h&gt;包含了目前c++所包含的所有头文件。 （三）加速c++12345static const auto _ = []()&#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return nullptr;&#125;(); ​ iostream默认是与stdio关联在一起的，以使两者同步，因此消耗了iostream不少性能。C++中的std :: cin和std :: cout为了兼容C，保证在代码中同时出现std :: cin和scanf或std :: cout和printf时输出不发生混乱，所以C++用一个流缓冲区来同步C的标准流。通过std :: ios_base :: sync_with_stdio函数设置为false后可以解除这种同步，让std :: cin和std :: cout不再经过缓冲区，iostream的性能就会提高了很多倍。因此，当解除同步之后，注意不要与scanf和printf混用以免出现问题 ​ tie是将两个stream绑定的函数，空参数的话返回当前的输出流指针。std :: cin默认是与std :: cout绑定的，所以每次操作的时候都要调用flush，这样增加了IO的负担，通过tie(nullptr)来解除std :: cin和std :: cout之间的绑定，进一步加快执行效率。 （四）运算符优先级 ！= 优于 &amp; 。 （五）c++11新特性：参考1、nullptr关键字 解决二义性问题，专门用来区分空指针和0。 2、auto关键字 用于从初始化表达式中推断出变量的数据类型。 auto定义变量时必须初始化（类似引用） auto作为函数返回值时，只能用于定义函数，不能用于声明函数 不允许使用auto定义函数参数 不允许使用auto定义struct/class的成员变量 不允许使用auto定义数组 不允许使用auto作为模板参数传递 12auto i = 5; // i 被推导为 intauto arr = new auto(10) // arr 被推导为 int * 3、decltype 关键字decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。编译器分析表达式并得到它的类型，却不实际计算表达式的值。如果给变量加上了一层括号，编译器会把它当作一个表达式，得到的则是引用类型。 123456int i = 10;float j = 5.1;decltype(i) a; // a的类型是intdecltype((i)) b = i; // b的类型是int&amp;，必须为其初始化，否则会编译报错decltype(i+j) c; // c的类型是int+float =&gt; float 4、新式函数声明C++11 引入了一个叫做拖尾返回类型（trailing return type），利用 auto 关键字将返回类型后置。 1234template&lt;typename T, typename U&gt;auto add(T x, U y) -&gt; decltype(x+y) &#123; return x+y;&#125; 5、基于范围的 for 循环 123for(auto &amp;i : arr) &#123; std::cout &lt;&lt; i &lt;&lt; std::endl;&#125; 6、Lambda表达式 如果mutable,exception,attribute,return type四者只要一种出现，小括号()不可省略，均不出现则可省略。 1234567891011121314151617181920212223[capture] (parameters) opt-&gt; return-type &#123; body&#125;;void noreturnfun() __attribute__((noreturn));//函数不会返回。1. capture是捕获列表； 1).[]不捕获任何变量 2).[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获） 3).[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获) 4).[=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量 5).[bar]按值捕获bar变量，同时不捕获其他变量 6).[this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限 如果已经使用了&amp;或者=，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量2. parameters是参数表；(选填) 3. opt是函数选项；可以填mutable,exception,attribute（选填） 1).mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法 2).exception说明lambda表达式是否抛出异常以及何种异常 3).attribute用来声明属性，GCC使用__attribute__关键字来描述函数，变量和数据类型的属性，用于编译器对源代码的优化。attribute语法格式为：_attribute_ ((attribute-list))4. return-type是返回值类型（拖尾返回类型）(选填) 5. body是函数体 7、std::function/std::bind封装可执行对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Test.hclass Test&#123;public: void Add(std::function&lt;int(int, int)&gt; fun, int a, int b) &#123; int sum = fun(a, b); std::cout &lt;&lt; \"sum:\" &lt;&lt; sum &lt;&lt; std::endl; &#125;&#125;;main.cppint add(int a, int b)&#123; std::cout &lt;&lt; \"add\" &lt;&lt; std::endl; return a + b;&#125;class TestAdd&#123;public: int Add(int a, int b) &#123; std::cout &lt;&lt; \"TestAdd::Add\" &lt;&lt; std::endl; return a + b; &#125;&#125;;int main()&#123; Test test; test.Add(add, 1, 2); TestAdd testAdd; test.Add(std::bind(&amp;TestAdd::Add, testAdd, std::placeholders::_1, std::placeholders::_2), 1, 2); return 0;&#125;运行结果：addsum:3TestAdd::Addsum:3解释：std::bind第一个参数为对象函数指针，表示函数相对于类的首地址的偏移量；testAdd为对象指针；std::placeholders::_1和std::placeholders::_2为参数占位符，表示std::bind封装的可执行对象可以接受两个参数。我们的Test函数在函数指针和类对象函数中，两种情况下都完美运行。 8、初始化列表 123456789#include &lt;initializer_list&gt;class Magic &#123;public: Magic(std::initializer_list&lt;int&gt; list) &#123;&#125;&#125;;Magic magic = &#123;1,2,3,4,5&#125;;std::vector&lt;int&gt; v = &#123;1, 2, 3, 4&#125;; 9、STL容器 std::array&lt;类型，容量&gt;，相对于数组增加了迭代器 std::forward_list单向链表，链表在对数据进行插入和删除是比顺序存储的线性表有优势，因此在插入和删除操作频繁的应用场景中，使用list和forward_list比使用array、vector和deque效率要高很多。 std::unordered_map与std::map用法基本差不多，但STL在内部实现上有很大不同，std::map使用的数据结构为红黑树，而std::unordered_map内部是哈希表的实现方式，哈希map理论上查找效率为O(1)。但在存储效率上，哈希map需要增加哈希表的内存开销。 std::unordered_set的数据存储结构也是哈希表的方式结构，除此之外，std::unordered_set在插入时不会自动排序，这都是std::set表现不同的地方。 10、多线程 std::thread为C++11的线程类，使用方法和boost接口一样非常方便，同时得益于C++11的可变参数的设计风格，C++11的std::thread还解决了boost::thread中构成参数限制的问题：如果线程需要绑定的函数有参数则需要使用boost::bind。比如想使用 boost::thread创建一个线程来执行函数：void f(int i)，如果这样写：boost::thread thrd(f)是不对的，因为thread构造函数声明接受的是一个没有参数且返回类型为void的型别，而且不提供参数i的值f也无法运行，这时就可以写：boost::thread thrd(boost::bind(f,1))。涉及到有参函数的绑定问题基本上都是boost::thread、boost::function、boost::bind结合起来使用。 std::atomic为C++11封装的原子数据类型，在多线程中用户不必对其添加互斥资源锁的类型，其内部已自己加了锁。 C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到被唤醒再从新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。 11、智能指针内存管理 12345678910111213shared_ptr&lt;Foo&gt; factory(T arg)&#123; return make_shared&lt;Foo&gt;(arg);&#125;void use_factory(T arg)&#123; shared_ptr&lt;Foo&gt; p=factory(arg); //使用p&#125;//p离开了作用域，它指向的内存会被自动释放掉auto use_factory(T arg)&#123; shared_ptr&lt;Foo&gt; p=factory(arg); //使用p return p;//当我们返回p时，引用计数进行了递增操作&#125;//p离开了作用域，它指向的内存不会被自动释放掉 C++11新增了std::shared_ptr（共享）、std::weak_ptr（弱引用，指向管理的对象，不会增加引用计数）、std::unique_str(独占)等类型的智能指针，用于解决内存管理的问题，更容易安全的使用动态内存。 12、右值引用于std::move 右值引用 (Rvalue Referene) 是 C++ 新标准 中引入的新特性 , 它实现了移动语义 (Move Sementics) 和完美转发 (Perfect Forwarding)。它的主要目的有两个方面： 1）消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 2）能够更简洁明确地定义泛型函数。 左值持久；右值短暂 左值：非临时对象，要么是字面常量，要么是在表达式求值过程中创建的临时对象右值：临时的对象， 右值引用的转移语义和完美转发 13、模板增强 外部模板扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化。 类型别名模板 在传统 C++中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效。 12345template &lt;typename T&gt;using NewType = SuckType&lt;int, T, 1&gt;; // 合法template&lt; typename U&gt;typedef SuckType&lt;std::vector&lt;int&gt;, U, 1&gt; NewType; // 不合法 默认模板参数 1234template&lt;typename T = int, typename U = int&gt;auto add(T x, U y) -&gt; decltype(x+y) &#123; return x+y;&#125; 14、构造函数 委托构造 C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的 1234567891011class Base &#123;public: int value1; int value2; Base() &#123; value1 = 1; &#125; Base(int value) : Base() &#123; // 委托 Base() 构造函数 value2 = 2; &#125;&#125;; 继承构造 在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明 123456789101112131415161718192021222324252627282930struct A&#123; A(int i) &#123;&#125; A(double d,int i)&#123;&#125; A(float f,int i,const char* c)&#123;&#125; //...等等系列的构造函数版本&#125;；struct B:A&#123; B(int i):A(i)&#123;&#125; B(double d,int i):A(d,i)&#123;&#125; B(folat f,int i,const char* c):A(f,i,e)&#123;&#125; //......等等好多个和基类构造函数对应的构造函数&#125;； //c++11的继承构造struct A&#123; A(int i) &#123;&#125; A(double d,int i)&#123;&#125; A(float f,int i,const char* c)&#123;&#125; //...等等系列的构造函数版本&#125;；struct B:A&#123; using A::A; //关于基类各构造函数的继承一句话搞定 //......&#125;； 15、虚函数的 override 和 final 指示符 override，表示函数应当重写基类中的虚函数 final，表示派生类不应当重写这个虚函数 16、static_assert() 静态断言 C提供的assert()只能在运行时断言 C++11/14 提供的static_assert()可以在编译期断言 （六）十大经典排序算法：参考 冒泡排序 123456789template&lt;typename T&gt; //整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符void bubble_sort(T arr[], int len) &#123; int i, j; for (i = 0; i &lt; len - 1; i++) //注意限制条件j&lt;len-1-i for (j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) swap(arr[j], arr[j + 1]);&#125; 快速排序 插入排序 选择排序 堆排序 归并排序 自顶向下 自底向上：注意底层达不到整数倍length的数据部分","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"MySQL","slug":"MySQL","date":"2020-03-24T06:17:11.000Z","updated":"2020-04-06T01:58:42.069Z","comments":true,"path":"2020/03/24/MySQL/","link":"","permalink":"http://yoursite.com/2020/03/24/MySQL/","excerpt":"MySQL事务实现原理 首先了解什么是事务，事务是执行一系列数据库操作构成的单个逻辑工作单元，要么完全地执行，要么完全地不执行。 简单的说，事务就是并发控制的单位，是用户定义的一个操作序列。 （1）事务四大特性（ACID） 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务前后数据的完整性必须保持一致。 隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。","text":"MySQL事务实现原理 首先了解什么是事务，事务是执行一系列数据库操作构成的单个逻辑工作单元，要么完全地执行，要么完全地不执行。 简单的说，事务就是并发控制的单位，是用户定义的一个操作序列。 （1）事务四大特性（ACID） 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务前后数据的完整性必须保持一致。 隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 （2）事务并发问题 脏读：读到了别的事务回滚前的脏数据,即当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。 不可重复读：当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配. 幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据，产生幻读，即当前事务读第一次取到的数据比后来读取到数据条目少。 不可重复读和幻读比较：两者有些相似，但是前者针对的是update或delete，后者针对的insert。 （3）事务的隔离级别 事务的隔离级别 描述 Serializable（串行化） 可避免脏读、不可重复读、虚读情况的发生 Repeatable read（可重复读） 可避免脏读、不可重复读的发生 Read committed（读已提交） 可避免脏读的发生 Read uncommitted（读未提交） 最低级别，以上情况均无法保证 91道面试题](https://mp.weixin.qq.com/s/9pfCkm2bX01XLIeJv9ngLw) 什么是MySQL索引，什么时候该用索引什么时候不该用？ 索引(Index)是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。Mysql索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特别指明，一般都是指B树结构组织的索引(B+Tree索引)。 优点：所有的MySql列类型(字段类型)都可以被索引，也就是可以给任意字段设置索引；大大加快数据的查询速度 缺点： 1、创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加 2、索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值 3、当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。 使用原则：（并不是每个字段度设置索引就好，也不是索引越多越好，而是需要自己合理的使用） （1）对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引， （2）数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。 （3）在一同值少的列上(字段上)不要建立索引，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。 索引类型 索引我们分为四类来讲 单列索引(普通索引，唯一索引，主键索引)、组合索引、全文索引、空间索引、 单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。 唯一索引：索引列中的值必须是唯一的，但是允许为空值， 主键索引：是一种特殊的唯一索引，不允许有空值。 组合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀原则。 全文索引：全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行。 空间索引：空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。在创建空间索引时，使用SPATIAL关键字。要求引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。 InnoDB和MyISAM的区别 数据库的行级锁和表级索共享锁和排他锁悲观锁和乐观锁 覆盖索引 ‘Using Index’的意思是“覆盖索引”，它是使上面sql性能提升的关键 一个包含查询所需字段的索引称为“覆盖索引” MySQL只需要通过索引就可以返回查询所需要的数据，而不必在查到索引之后进行回表操作，减少IO，提高了效率。例如上面的sql，查询条件是user_id，可以使用联合索引，要查询的字段是picname smallimg，这两个字段也在联合索引中，这就实现了“覆盖索引”，可以根据这个联合索引一次性完成查询工作，所以提升了性能。 聚类索引和非聚类索引的区别 聚集索引是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。如果某索引不是聚集索引，则表中的行物理顺序与索引顺序不匹配，与非聚集索引相比，聚集索引有着更快的检索速度。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"C++ primer重点记录","slug":"C-primer重点记录","date":"2020-03-24T05:43:26.000Z","updated":"2020-04-03T12:20:28.145Z","comments":true,"path":"2020/03/24/C-primer重点记录/","link":"","permalink":"http://yoursite.com/2020/03/24/C-primer%E9%87%8D%E7%82%B9%E8%AE%B0%E5%BD%95/","excerpt":"第一章 开始 windows或unix编译程序使用命令 cc hello.cc windows输出a.exe unix输出a.out 输入a.exe或者./a.out执行程序 运行GNU编译器的命令是g++","text":"第一章 开始 windows或unix编译程序使用命令 cc hello.cc windows输出a.exe unix输出a.out 输入a.exe或者./a.out执行程序 运行GNU编译器的命令是g++ g++ -o hello hello.cc (-o hello给执行文件命名) cerr 输出警告和错误消息 clog输出程序运行时的一般信息 命名空间可以避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突 使用一个istream对象作为条件，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符(EOF)，或遇到一个无效的输入时(例如读入的值不是一个整数)，istream对象的状态会变成无效，处于无效状态的istream对象会使条件变假。 1while(std::cin&gt;&gt;value) main函数返回值类型必须为int类型，为0表示成功，非0由系统定义，通常指出错误类型 编译为addItems.exe的可执行文件(UNIX中是addItems.out)，从一个名为infile的文件读取销售记录，并将结果输出写入一个名为outfile的文件中，两个文件都位于当前目录。 addItems outfile 第二章 变量和基本类型 一个字节：8bit 一个字：4或8个字节 float：一个字 double：两个字 long double：3或4个字 char与其他整型（整型包括字符、布尔和整数）不同，字符型被分为三种：char /signed char/unsigned char。char实际上表现为哪种类型由编译器决定。 c++算术类型分为两类：整型和浮点型 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8位 short 短整型 16 int 整型 16 long 长整型 32 long long 长整型 64 类型转换 赋值给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。eg:8比特大小的usigned char可以表示0至255区间内的值，如果赋了一个区间以外的值，则实际结果是该值对256取模后所得的余数。因此把-1赋给8比特大小的usigned char所得的结果是255（即256+（-1）=255）。 赋值给带符号类型一个超出它表示范围的值时，结果是未定义的。此时程序可能继续工作、可能崩溃、也可能生成垃圾数据。 如果两个运算符的运算对象类型不一致，首先把这些运算对象执行整型提升，如果结果类型匹配，无须进行进一步的转换。如果两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型运算对象转换成较大的类型。 123ival + ulval; //ival转换成usigned long，无符号类型不小于带符号类型usval + ival; //根据usigned short 和 int 所占空间的大小进行转换uival + lval; //根据usigned int 和 long 所占空间的大小进行转换 表达式里带符号类型不大于无符号类型，带符号类型会自动转换成无符号类型；带符号类型大于无符号类型时转换结果依赖于机器，eg,如果两个运算对象的类型分别是long类型和usigned int类型，long占用的空间比int更多，则usigned int 类型的运算对象转换成long类型；当带符号类型取值为负时会出现异常结果。 转义序列 \\x 后紧跟1个或多个十六进制数字，eg:“\\1234”表示一个16位的字符 \\后紧跟1、2或3个八进制数字，eg:“\\1234”表示两个字符即八进制123对应的字符和字符4 列表初始化 初始化！=赋值 1234567int a=1;int a=&#123;1&#125;;int a&#123;1&#125;;int a(1);long double ld=3.143;int a&#123;ld&#125;,b=&#123;ld&#125;;//错误：窄化转换，转换未执行，因为存在丢失信息的危险int a(ld),b=ld;//正确：转换执行，且确实丢失了部分值 变量能且仅能被定义一次，但是可以被多次声明。如果在多个文件中使用同一个变量，就必须将声明和定义分离，变量的定义必须出现在也只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，但是绝对不能重复定义。 标识符 标识符必须以字母或者下画线开头，要能体现实际含义。 变量名一般要用小写字母，如index,不要使用Index或INDEX。 用户自定义的类名一般以大写字母开头，如Sales_item。 如果标识符由多个单词组成，则单词间应有明显的区分，如student_loan或studentLoan,不要使用studentloan。 用户自定义标识符不能连续出现两个下画线，也不同以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。 按位与&amp; 或者 bitand 按位或 | 或者 bitor 异或^或者xor and_eq与=（赋值） or_eq或=（赋值） compl或者~非 not_eq不等于（赋值） xor_eq异或等于 在块作用域中使用“：：a”,因为全局作用域本身并没有名字，所以作用域左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量（即全局变量）。 引用必须被初始化，且不能更改指向值，而指针无须初始化且可以先后指向几个不同的对象。指针必须初始化，得到空指针的办法就是用字面值nullptr来初始化指针，新标准下，初始化指针最好使用nullptr,同时尽量避免NULL(在头文件cstdlib中定义的值为0的预处理器）和 0（使用NULL和0初始化指针是一样的）；把int变量直接赋值给指针是错误的操作，即使int变量值恰好等于0也不行。 123int zero=0；int *p=zero;//错误：不能直接把int变量赋值给指针（更不能把字面值常量直接赋值给指针）int *p=&amp;zero; void*是一种特殊的指针类型，可用于存放任意对象的指针，但是没办法访问内存空间的对象，因为无法确定这个对象到底是什么类型。 引用本身不是一个对象，因此不能定义指向引用的指针，但指针是对象，所以存在对指针的引用： 123456int i=42;int a=3;int *p;int *&amp;r=p;//r是一个引用，r引用的是一个指针，r引用的是一个int指针（面对一条比较复杂的指针或引用的声明语句时从右向左阅读有助于弄清它的真实含义）r=&amp;i;//r引用了一个指针，因此给r赋值就是零p指向i*r=a;或者*r=3;//解引用r得到i，也就是p指向的对象，将i的值改为3 默认状态下，const对象仅在文件内有效，如果想在多个文件之间共享const对象，必须在每个文件中变量的定义之前添加extern关键字。 1234//file1.cc定义并初始化了一个常量，该常量能被其他文件访问extern const int bugSize=fcn();//file2.cc头文件extern const int bufSize;//与file1.cc中定义的bufSize是同一个 可以利用const对象初始化非常量，但是对const的引用必须是const，且引用及其对应的对象都不能更改，指向常量的指针也必须是const。但是指向常量的指针或者引用可以绑定到一个非常量上。 1234567int i=42;const int ci=i;//正确：i的值被拷贝给了ciint j=ci;//正确：ci的值被拷贝给了jconst int &amp;r1=ci;//正确：引用及其对应的对象都是常量r1=42;//错误：r1是对常量的引用int &amp;r2=ci;//错误：试图让一个非常量引用指向一个常量const int &amp;r3=i;//正确：const int&amp; 可以绑定到一个普通int上 const引用一个非const对象，不允许通过const引用修改非const对象的值，但是允许通过其他途径改变它的值。 12345double i=42;int &amp;r1=i;const int &amp;r2=i;//实际实现过程是：（1）const int tmp=i;//由双精度浮点数生成一个临时的整型变量 （2）const int &amp;r2=tmp;//让r2绑定这个变量 r1=0;//r1非常量，i的值修改为0r2=0;//错误：r2是一个常量引用不允许修改i的值 指向常量的指针！=常量指针，常量指针必须初始化化，且一旦初始化则它的值（存放在指针中的地址）不再改变，但是如果常量指针指向的是一个一般的非常量整数，就能通过常量指针修改这个非常量整数。 1234567int i=0;int *const p=&amp;i;//p将一直指向iconst double pi=3.14159;const double *const pip=&amp;pi;//pip是一个指向常量对象的常量指针*p=3;//把i的值改为3*pip=4;//错误：pip指向的是一个常量对象p=&amp;pi;//p是一个常量指针 顶层const可以表示任意的对象是常量。 底层const则是与指针和引用等符合类型的基本类型部分有关。指针类型既可以是顶层const（表示指针本身是一个常量）也可以是底层const（表示所指的对象是一个常量）。 123456int i=0;int *const p1=&amp;i;//不能改变p1的值，这是一个顶层constconst int ci=42;//不能改变ci的值，这是一个顶层constconst int *p2=&amp;ci;//允许改变p2的值，这是一个底层constconst int *const p3=p2;//靠右的const是顶层const,靠左的是底层const(从你的右手到左手)const int &amp;r=ci;//用于声明引用的const都是底层const(指针是对象而引用不是) 字面值是常量表达式（字面值类型：算术类型、引用、指针；自定义类型如string、Sales_item则不属于字面值类型,也就不能被定义成constexpr），用常量表达式初始化的const对象也是常量表达式，应声明成constexpr(由它的数据类型和初始值共同决定)。尽管指针和引用都可以被定义成constexpr，但它们的初始值却受到严格限制，一个constexpr指针的初始值必须是nullptr或0，或者是存储于某个固定地址中的对象。 constexpr仅对指针有效，与指针所指的对象无关： 12345constexpr int *np=nullptr;//np是一个指向整数的常量指针，其值为空int j=0;constexpr int i=42;//i的类型是整型常量constexpr const int *p=&amp;i;//p是常量指针，指向整数常量iconsterxpr int *p1=&amp;j;//p1是常量指针，指向整数j 类型别名，不能把类型别名替换成它原来的样子 1234typedef char *pstring;const pstring cstr=0;//cstr是指向char的常量指针，顶层constconst pstring *ps;//ps是一个指针，它的对象时指向char的常量指针const char *cs=0;//cs是一个指向const char的指针，底层const auto一般会忽略顶层const,保留底层const。 decltype返回操作数的数据类型（包括顶层const和引用）。变量加上一层或多层括号，编译器就会把它当成给一个表达式，decltype的表达式如果是加上了括号的变量，结果是引用。 12345int i=42,*p=&amp;i,&amp;r=i;decltype(r+0) b;//正确：加法的结果是int，因此b是一个未初始化的intdecltype(*p) c;//错误c是int&amp;，必须初始化decltype((i)) d;//错误：d是一个int&amp;,必须初始化decltype(i) e;//正确：e是一个未初始化的int 第三章 字符串、向量和数组 cin读入字符串遇到空白符停止，getline遇到换行符停止（换行符也被读进来但是不保留）。 字符串字面值与string是不同类型。 可以用列表中元素的拷贝替换v1中的元素或初始化vector，但是列表不能作为形参vector直接使用。 1v1=&#123;a,b,c&#125;; 范围for语句体内不应该改变其所遍历序列的大小。 迭代器不同于指针，获取迭代器不是取地址符。begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，返回const_iterator（能读不能修改它所指的元素值或直接使用cbegin cend）,否则返回iterator（能读能写）。如果对象不是常量，均可。end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用。数组也可以使用begin（arr）和end（arr）获取指向数组首元素的指针和指向数组尾元素的下一位置的指针。 12*iter 返回迭代器iter所指元素的引用iter-&gt;mem 解引用iter并获取该元素的名为mem的成员，等价于（*iter）.mem different_type由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离。使用迭代器可进行二分查找。ptrdiff_t是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离。指针和迭代器都可进行算术运算。允许给空指针加上或者减去一个值为0的整型常量表达式，两个空指针也允许彼此相减，结果为0。 123456789usigned cnt=42;constexpr usigned sz=42;int *parr[sz];//含有42个整型指针的数组string bad[cnt];//错误：cnt不是常量表达式string strs[get_size()];//当get_size是constexpr时正确；否则错误auto n=end(arr)-begin(arr);//auto是ptrdiff_t类型，n=arr中元素的数量int *ip=arr;//等价于int *ip=&amp;arr[0];int *p=arr+sz;//正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置；使用警告：不要解引用！int *pz=arr+sz+1;//错误：arr只有sz个元素，pz的值未定义 如果函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。不允许使用一个数组为另一个内置类型的数组赋初值，但是允许使用数组来初始化vector对象。 1234vector&lt;int&gt; vec(begin(arr)+1,end(arr));//等价于vector&lt;int&gt; vec(arr+1,end(arr))int a[]=&#123;0,1,2&#125;;int a2[]=a; //错误：不允许使用一个数组初始化另一个数组a2=a; //错误：不能把一个数组直接赋值给另一个数组 字符串字面值会自动添加表示字符串结束的空字符。strcpy/strcmp/strlen/strcat此类函数可以传入字符串或者指向以空字符作为结束的数组的指针。比较标准库string对象的时候用的是普通的关系运算符合相等性运算符，把这些运算符用在比较两个C风格字符串上，实际比较的将是指针而非字符串本身。不能用string对象初始化char*，但是可以使用c_str，如果执行完c_str()函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。 12345678910111213141516char a1[]=&#123;'c','+','+'&#125;;//列表初始化,没有空字符char a2[]=&#123;'c','+','+','\\0'&#125;;//列表初始化,含有显式的空字符char a3[]=\"c++\";//自动添加表示字符串结束的空字符const char a4[6]=\"daniel\";//错误：没有空间可存放空字符int &amp;refs[10]=/*?*/;//错误：不存在引用的数组char (&amp;arrRef)[3]=a1;//arrRef引用一个含有3个字符的数组int *(&amp;arry)[42]=parr;//arry是数组的引用，该数组含有42个指针cout&lt;&lt;strlen(a1)&lt;&lt;endl;//错误：啊没有以空字符结束string s1=\"abcd\";string s2=\"cdr\";if(s1&lt;s2)//trueconst char c1[]=\"abcd\";const char c2[]=\"bcde\";if(c1&lt;c2)//未定义：试图比较两个无关地址char *str=s1;//错误const char *str=s1.c_str;//正确，用const char*保证字符数组内容不改变；如果后续操作改变了s1的值就可能让之前返回的数组失去效用 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组；当使用decltype()时上述转换不会发生。 123456int ia[]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;auto ia2(ia);//ia2是一个整型指针，指向ia的第一个元素ia2=42;//错误：ia2是一个指针，不能用整数给指针赋值decltype(ia) ia3=&#123;0,1,2,3,4,5,6,7,8,9&#125;；ia3=p;//错误：不能用整型指针给数组赋值ia3[4]=i;//正确：把i的值赋给ia3的一个元素 数组内置的下标运算符所用的索引值不是无符号类型，这一点与string和vector不同。 123int *p=&amp;a[2];int j=p[1];//等价于*（p+1)，就是a[3]int k=p[-2];//p[-2]是a[0]表示的那个元素 多维数组的初始化和下标引用 123456789int a[2][3]=&#123; &#123;0,1,2&#125;, &#123;3,4,5&#125;&#125;;int a[2][3]=&#123;0,1,2,3,4,5&#125;;//内层嵌套着的花括号并非完全必要int a[2][3]=&#123;&#123;0&#125;,&#123;3&#125;&#125;;//显示初始化每行的首元素int （&amp;row)[3]=a[1];把row绑定到a的第二个3元素数组上int (*p)[3]=a;//p指向含有3个整数的数组p=&amp;a[1];//p指向a的尾元素 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型，因为数组名会被自动地转换成指向该数组首元素的指针。 1234567891011121314151617181920212223242526272829303132//正确for(const auto &amp;row:a)&#123; for(auto clo:row)&#123; cout&lt;&lt;col&lt;&lt;endl; &#125;&#125;//错误：row的类型是int*,显然内层循环不合法for(const auto row:a)&#123; for(auto clo:row)&#123; cout&lt;&lt;col&lt;&lt;endl; &#125;&#125;//p指向含有3个整数的数组，*p解引p得到指向内层数组首元素的指针for(auto p=a;p!=a+2;++p)&#123; for(auto q=*p;q!=*p+3;q++)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125;//简洁版for(auto p=begin(a);p!=end(a);p++)&#123; for(auto q=begin(*p);q!=end(*p);q++)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125;//类型别名简化多维数组的指针using int_arr=int[4];typedef int int_arr[4];//等价的typedegf声明for(int_arr *p=a;p!=a+2;++p)&#123; for(int *q=*p;q!=*p+3;++q)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125; 第四章 表达式 当一个对象被用作右值时，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。使用关键字decltype的时候左值右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。eg.假定p的类型是int，因为解引用运算符生成左值，所以decltype(\\p)的结果是int&amp;。另一方面，因为取地址符生成右值，所以decltype(&amp;p)的结果是int**,也就是说，结果是一个指向整型指针的指针。 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。 123cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;++i&lt;&lt;endl; //产生未定义的行为，可能先计算i再计算i++，或者先计算i++再计算i,或其他不可预知行为，所以编译器生成什么样的代码程序都是错的*beg=toupper(*beg++); //产生未定义的行为，可能先求左侧的值或先求右侧的值，也可能采取别的什么方式处理它*++iter; //正确：先递增再解引用 后置递增运算符的优先级高于解引用运算符，因此pbeg++等价于\\（pbeg++)，先自增，然后返回初始值的副本作为其求值结果，此时解引用运算符的运算对象是pbeg未增加之前得值，最终这条语句输出pbeg开始时指向的那个元素，并将指针向前移动一个位置。 解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号，如果没有括号，代码的含义就大不相同了。 12(*p).size(); //正确*p.size(); //错误：p是一个指针，它没有名为size成员 左移运算符（&lt;&lt;）在右侧插入值为0的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。 sizeof运算符返回一条表达式或一个类型名字所占的字节数，满足右结合律，其所得值是一个size_t类型的常量表达式。在sizeof的运算对象中解引用一个无效指针仍然是一种安全行为，因为指针实际上并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。sizeof运算不会把数组转换成指针来处理，对string和vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中元素的个数。 123sizeof *p; //p所指空间类型的大小，即sizeof(Sales_data),等价于sizeof(*p)，即使p是一个无效（即未初始化）的指针constexpr size_t sz=sizeof(ia)/sizeof(*ia); //返回数组ia的元素数量int arr[sz]; //sizeof返回一个常量表达式 指向任意非常量的指针能转换成void；指向任意对象的指针能转换成const void\\。 123if(cp) //如果指针cp不是0，条件为真while(*cp) //如果*cp不是空字符，条件为真while(cin&gt;&gt;s) //布尔值决定于输入流的状态，最后一次读入成功，true;反之，false 显式转换：cast_name(expression)，cast-name是static_cast（任何具有明确定义的类型转换，只要不包含底层const）/dynamic_cast（支持运行时类型识别）/const_cast（只能改变运算对象的底层const）/reinterpret_cast（通常为运算对象的位模式提供较低层次上的重新解释）中的一种。除了在有重载函数的上下文中使用const_cast无可厚非，其他强制类型转换都不应该频繁使用。 12345678int i,j;double slope=static_cast&lt;double&gt;(j)/i; //进行强制类型转换以便执行浮点数除法void* p=&amp;d; //任何非常量对象的地址都能存入void*double *dp=static_cast&lt;double*&gt;(p); //正确：将void*转换回初始的指针类型const char *pc;char *P=const_cast&lt;char*&gt;(pc); //正确：但是通过p写值时未定义的行为int *ip;char *pc=reinterpret_cast&lt;char*&gt;(ip); //牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误，eg:string str(pc)，具有高危性 第五章 语句 一般不要省略case分支的break语句，否则，程序将跨越case标签的边界；如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧跟在default标签后面的语句。 如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是违法行为。因此c++语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域的另一个位置。 for语句头能省略掉init-statement、condition和expression中的任何一个（或全部）。省略condition的效果等价于在条件部分写了一个true，则循环体内必须有语句负责退出循环。 123vector&lt;int&gt; v;for(int i;cin&gt;&gt;i;/*表达式为空*/) //条件部分能改变i值，所以这个循环无须表达式部分 v.push_back(i); 尽量不要使用goto语句，因为它使得程序既难理解又难修改。 try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问。 12345678910111213141516while(cin&gt;&gt;item1&gt;&gt;item2)&#123; try&#123; //执行添加两个Sales_item对象的代码 //如果添加失败，代码抛出一个runtime_error异常 &#125;catch(runtime_error err)&#123; cout&lt;&lt;err.what() &lt;&lt;\"\\nTry Again? Enter y or n\"&lt;&lt;endl; char c; cin&gt;&gt;c; if(!cin || c=='n') break;跳出while循环 &#125;&#125;//类型runtime_error是标准库异常类型的一种，必须提供一个string对象或者C风格的字符串初始化runtime_error的对象if(item1.isbn()!=item2.isbn()) throw runtime_error(\"Data must refer to same ISBN\"); 标准库异常类只定义了几种运算，包括创建或拷贝异常类型对象，以及为异常类型的对象赋值。异常类型只定义了一个名为what的成员函数，该函数没有参数，返回值是一个指向C风格字符串的const char*。该字符串的目的是提供关于异常的一些文本信息。如果异常类型有一个字符串初始值，则what返回该字符串。对于其他无初始值的异常类型来说，what返回的内容由编译器决定。 寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果最终还是没找到任何匹配的catch子句，程序转到名为terminate的标准函数库。对于那些没有任何try语句块定义的异常，系统同样会调用terminate函数并终止当前程序的执行。 第六章 函数 局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。 参数传递包括值传递和引用传递（引用传递直接传入对象而无须传递对象的地址，eg.可以给函数传入一个额外的引用实参，令其保存字符出现的次数）。指针传递属于值传递，当执行指针拷贝操作时，拷贝的是指针的值，拷贝之后两个指针是不同的指针，因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指的对象，但是改变局部拷贝的值并不能改变实参以及实参所指对象。 顶层const可以初始化非const,非const可以初始化顶层const,所以实参初始化形参时就会忽略掉顶层const.想调用引用版本的reset(int &amp;i)只能使用int类型的对象，而不能使用字面值、求值结果为int的表达式、需要转换的对象或者const int类型的对象，类似的，想要调用指针版本的reset(int p)只能使用int\\。 12345678910111213141516171819void fcn(const int i)&#123;/*fcn能读取i,但是不能向i写值*/&#125;void fcn(int i)&#123;/*值传递本身写值就没有意义*/&#125; //错误：重复定义了fcn(int)Record lookup(Acount*);Record lookup(Acount* const); //错误：重复声明Record lookup(Acount*);Record lookup(const Acount*); //新函数，作用于常量引用Record lookup(Acount&amp;);Record lookup(const Acount&amp;); //新函数，作用于指向常量的指针int i=1;const int ci=42; //不能改变ci的值这是一个顶层constconst int *p2=&amp;ci; //允许改变p2的值，这是一个底层constconst int *const p3=p2; //靠右的是顶层const，靠左的是底层constconst int &amp;r=ci; //用于声明引用的const都是底层const（从这里也说明不能使用指向const int对象的指针初始化int*因为int*没有底层const,eg.void reset(int *p);reset(&amp;ci)错误）int *p=p3; //错误：p3包含底层const的定义，而p没有p2=p3; //正确：p2和p3都是底层constp2=&amp;i; //正确：int*能转换成const int*int &amp;r=ci; //错误：普通的int&amp;不能绑定到int常量上const int &amp;r2=i; //正确：const int&amp;可以绑定到一个普通的int上reset(42)； //不能把普通引用绑定到字面值上，只能把const引用绑定到字面值上 数组不能拷贝所以无法以值传递的方式传递数组,因为数组会被转换成指针，所以我们为函数传递一个数组时实际上传递的是指向数组元素的指针。 1234567//尽管形式不同，但是三个print函数是等价的，每个函数都有一个const int*类型的唯一形参void print(const int*);void print(const int[]); //可以看出了，函数的意图是作用于一个数组void print(const int[10]); //这里的维度表示我们期望数组含有多少元素，实际不一定int i=0,j[2]=&#123;0,1&#125;;print(&amp;i); //正确：&amp;i的类型是int*print(j); //正确：j转换成int*并指向j[0] c++允许将变量定义成数组的引用，同理，形参也可以是数组的引用（维度是类型的一部分）。因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。 123456f(int &amp;arr[10])&#123;/*...*/&#125;; //错误：将arr声明成了引用的数组f(int (&amp;arr)[10])&#123;/*...*/&#125;; //正确：arr是具有10个整数的整型数组的引用int k[10]=&#123;0,1,2,3,4,5,6,9&#125;;print(&amp;i); //错误：实参不是含有10个整数的数组print(j); //错误：实参不是含有10个整数的数组print(k); //正确：实参是含有10个整数的数组 多维数组实际上是数组的数组，所以由多维数组名转换得到的指针实际上是指向第一个内层数组的指针。和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，由于首元素本身就是一个数组，指针就是一个指向数组的指针，数组第二维（以及后面所有的维度）的大小都是数组类型的一部分，不能省略。 123456int a[3][4];int (*p)[4]=ia; //p指向含有4个整数的数组p=&amp;a[2]; //p指向a的尾元素int *matrix[10]; //错误：10个指针构成的数组int (*matrix)[10]; //正确：指向含有10个整数的数组指针void print(int matrix[][10],int rowSize)&#123;/*...*/&#125;; //matrix的声明看起来是一个二维数组，实际上形参是一个指向含有10个整数的数组指针，等价于int (*matrix)[10] 如果函数的实参数量未知，但是全部实参的类型都相同，可以采用initializer_list类型的形参，initializer_list是一种标准库类型，用于表示某种特定类型的值的数组，initializer_list类型定义在同名的头文件中，拷贝或者赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 1234initializer_list&lt;T&gt; lst2; //默认初始化：T类型元素的空列表initializer_list&lt;T&gt; lst&#123;a,b,c...&#125; //lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是constlst2(lst);lst2=lst; 返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。不要返回局部对象的引用或指针，局部变量在函数结束后所占用的存储空间也随之被释放掉，函数终止意味着局部变量的引用将指向不再有效的内存区域。 1234567891011121314151617181920212223const string &amp;mainp()&#123; string ret; //以某种方式改变一下ret if(ret.empty())&#123; return ret; //错误：返回局部对象的引用 else return \"Empty\"; //错误：\"Empty\"是一个局部临时量 &#125;&#125;//引用返回左值：调用一个返回引用的函数得到左值，其他类型得到右值可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值char &amp;get_val(string &amp;str,string::size_type ix)&#123; return str[ix]; //get_val假定索引值是有效的&#125;int main()&#123; string a(\"a value\"); get_val(s,0)='A'; cout&lt;&lt;s&lt;&lt;endl; //输出A value&#125;//c++11规定函数可以返回花括号包围的值的列表vector&lt;string&gt; process()&#123; return &#123;&#125;; //返回一个空vector return &#123;\"functionX\",\"okay\"&#125;; //返回列表初始化的vector对象&#125; type (*function(parameter_list))[dimension]声明一个返回数组指针的函数 1234567typedef int arrT[10];using arrT=int[10];//func返回一个指向含有10个整数的数组指针arrT* func(int i); auto func(int i)-&gt;int(*)[10];int odd[]=&#123;1,2,3,4,5,6,7,8,9,0&#125;decltype(odd) *func(int i); //decltype不负责把数组类型转换成对应的指针 不允许两个函数除了返回类型外其他所有的要素都相同，对于重载函数来说，应该在形参数量或者形参类型上有所不同。 一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 123456789sz wd=80;char def=' ';sz ht();string screen(sz=ht(),sz=wd,char def);void f()&#123; def='*'; //改变默认参数值 sz wd=100; //隐藏了外层定义的wd,但是没有改变默认值，该局部变量与传递给screen的默认实参没有任何关系 window=screen(); //调用screen(ht(),80,'*')&#125; constexpr函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。内联函数和constexpr函数可以在程序中多次定义，通常定义在头文件中。 123456constexpr int new_sz()&#123;return 42;&#125; //编译器能在程序编译时验证new_sz函数返回的是常量表达式，所以可以用new_sz函数初始化constexpr类型的变量fooconstexpr int foo = new_sz();constexpr size_t scale(size_t cnt)&#123;return new_sz()*cnt;&#125; //允许constexpr函数的返回值并非一个常量，当scale的实参是常量表达式时，它的返回值也是常量表达式；反之，则不然int arr[scale(2)]; //正确：scale（2）是常量表达式int i=2; //i不是常量表达式int a2[scale(i)]; //错误：scale(i)不是常量表达式 编译器会因为函数调用具有二义性而拒绝其请求；为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下所示： 精确匹配，包括以下情况： 实参类型和形参类型相同。 实参从数组类型或函数类型转换成对应的指针类型 向实参添加顶层const或者从实参中删除顶层const 通过const转换实现的匹配 通过类型提升实现的匹配 通过算术类型转换或指针转换实现的匹配（所有算术类型转换的级别都一样，例如,从int向usigned int的转换并不比从int向double的转换级别高） 通过类类型转换实现的匹配 当我们把函数名作为一个值使用时，该函数自动转换成指针。 123456789bool lengthCompare(const string &amp;,const string &amp;);bool (*pf)(const string &amp;,const string &amp;); //未初始化pf=lengthCompare; //pf指向名为lengthCompare的函数（返回类型和形参列表要精确匹配）pf=&amp;lengthCompare; //等价的赋值语句：取地址符是可选的//调用lengthCompare函数bool b1=pf(\"hello\",\"good\");bool b2=(*pf)(\"hello\",\"goodbye\");bool b3=lengthCompare(\"hello\",\"goodbye\");pf=0; //正确：pf不指向任何函数 函数的形参：和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用。 12345678910void useBigger(const string &amp;s,bool pf(const string &amp;,const string &amp;)); //第三个形参是函数类型，它会自动地转换成指向函数的指针void useBigger(const string &amp;s,bool (*pf)(const string &amp;,const string &amp;)); //等价的声明：显式地将形参定义成指向函数的指针//Func和Func2是函数类型typedef bool Func(const string &amp;,const string &amp;);typedef decltype(lengthCompare) Func2;//FuncP和FuncP2是指向函数的指针typedef bool (*FuncP)(const string&amp;,const string&amp;);typedef decltype(lengthCompare) *FuncP2; //decltype不会将函数类型自动转换成指针类型void useBigger(const string&amp;,Func); //编译器自动地将Func表示的函数类型转换成指针void useBigger(const string&amp;,FuncP); 返回指向函数的指针：和函数类型的形参不一样，返回类型不会自动地转换成指针，我们必须显式地将返回类型指定为指针。 1234567using F=int(int*,int); //F是函数类型，不是指针using PF=int(*)(int*,int); //PF是指针类型PF f(int); //正确：PF是指向函数的指针，f返回指向函数的指针F f(int); //错误：F是函数类型，f不能返回一个函数F *f(int); //正确：显式地指定返回类型是指向函数的指针int (*f(int))(int*,int); //可以直接声明f,按照由内向外的顺序阅读这条声明：f有形参列表，所以f是个函数；f前面有*，所以f返回一个指针；指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int.auto f(int)-&gt;int(*)(int*,int); //使用尾置返回类型的方式声明一个返回函数指针的函数 编译器将所有.cpp文件编译为.obj或.o文件再把对象文件链接在一起形成可执行文件.exe或.out。如果.cpp中有#include X.h文件，那么第一步预处理会把X.h代码粘贴到.cpp中代替#include语句。 如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件。 12345678g++ factMain.cc fact.cc //生成 factMain.exe or a.outg++ factMain.cc fact.cc -o main //生成 main or main.exe//分离式编译g++ -c factMain.cc //生成factMain.og++ -c fact.cc //生成fact.og++ fact.o factMain.o //生成factMain.exe or a.outg++ factMain.o fact.o -o main //生成 main or main.exe 第七章 类 只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数；当既需要其他形式的构造函数，也需要默认的构造函数时使用 Sales_data() = defalut;来要求编译器生成构造函数。 如果类包含内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。 使用class和struct定义类唯一的区别就是默认的访问权限。struct关键字在第一个访问说明符之前的成员是public；class关键字在第一个访问说明符之前的成员是private。 class默认的继承访问权是private,struct默认的是public。 class关键字可用于定义模板参数，就像typename，但struct关键字不能。 友元的声明只能出现在类定义的内部（最好在类定义开始或者结束前的位置集中声明友元）仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，必须在友元声明之外再转名对函数进行一次声明。每个类负责控制自己的友元类或友元函数，友元关系不存在传递性。 12345678910111213141516class Screen&#123; //首先定义Window_mgr类，其中声明cleat函数，但不能定义它。在 //clear使用Screen的成员之前必须先声明Screen。 friend void Window_mgr::clear(ScreenIndex); //Screen类的剩余部分&#125;//最后定义clear，此时它才可以使用Screen的成员struct X&#123; friend void f()(/*友元函数可以定义在类的内部＊/&#125; X()｛f();｝ //错误:还没有被声明 void g(); void h();&#125;;void X::g()( return f();&#125; //错误:f还没有被声明void f(); //声明那个定义在X中的函数void X::h()&#123;return f();&#125; //正确:现在王的声明在作用域 使用类型别名等价地声明一个类型名字 12typedef std::string::size_type pos;using pos=std::string::size_type; 在变量声明中加入mutable关键字能修改类的某个数据成员，即使是在一个const函数内。 常量引用不能修改对象。常量对象不能调用非常量函数，但是非常量对象能调用常量函数。 12345怎么选择使用哪种返回传值方式-&gt;拷贝开销大吗 -&gt;不大-&gt;按值返回return-by-value(拷贝，c++11自动转化为移动来节省拷贝开销) -&gt;很大-&gt;希望对返回值的内部数据进行修改吗(引用避免拷贝开销) -&gt;不需要-&gt;按常量引用返回return-by-constant-reference -&gt;需要-&gt;按引用返回return-by-reference 即使两个类的成员列表完全一致，它们也是不同的类型。我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类名跟在关键字class或struct后面。 12Sales_data item; //默认初始化Sales_data类型的对象class Sales_data item; //一条等价的声明 只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被人为是声明过了(但尚未定义)，因此类允许包含指向它自身类型的引用或指针。 12345class Link_screen&#123; Screen window; Link_screen *next; Link_screen &amp;other;&#125;; 类内初始化，必须使用=的初始化形式(初始化Screen的数据成员时所用的)或者花括号括起来的直接初始化形式(初始化screens所用的)。Screen的构造函数接受两个尺寸参数和一个字符值，创建了一个给定大小的空白屏幕对象。 12private: std::vector&lt;Screen&gt; screens&#123;Screen(24,80,' ')&#125;; 第十章 泛型算法 泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作，所以算法容器中保存的元素，也可能在容器中移动元素，但永远不会直接添加或删除元素。 replace_copy保持原序列不变，接受额外第三个迭代器参数，之处调整后序列的保存位置；back_inserter按需要增长目标序列。 1replace_copy(ilst.cbegin(),ilst.cend,back_inserter(ivec),0,42); //ilst未改变，ivec包含ilst的一份拷贝，不过原来ilst中值为0的元素在ivec中都变为42 第十二章 动态内存、智能指针和动态数组 常量指针：指针指向的地址能改变，只能指向的内容不能改变 指针常量：指针地址不能改变，指针指向的内容可以改变 new后必须delete（传递给delete的指针必须指向动态分配的内存或者是一个空指针）；智能指针可以自动销毁 内存泄漏：内存永远不可能被归还给自由空间 不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化的形式 12shared_ptr&lt;int&gt; p1=new int(1024);//错误，隐式转换shared_ptr&lt;int&gt; p12(new int(1024));//正确，直接初始化 当将shared_ptr绑定到一个普通指针时，内存管理就交给了这个shared_ptr，就不能使用那个内置指针来访问shared_ptr指向的内存了。 unique_ptr通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique_ptr 1auto p=p2.release();//p2放弃对指针的控制权，返回指针，并将p2置空；必须记得delete(p)，此时auto代表普通指针 当创建weak_ptr时要用shared_ptr来初始化 12auto p=make_shared&lt;int&gt;(42);weak_ptr&lt;int&gt; wp(p);//wp弱共享p；p的引用计数不变 weak_ptr的lock()如果expired()为true（表示use_count==0），返回一个空shared_ptr；否则返回一个指向对象的shared_ptr 销毁动态数组时数组中的元素按逆序销毁 1delete [] p；//p必须指向一个动态分配的数组或为空 动态分配一个空数组是合法的 12char arr[0];//错误：不能定义长度为0的数组char *cp=new char[0];//正确：但cp不能解引用 unique_ptr支持管理动态数组，shared_ptr不支持除非提供自己定义的删除器 12unique_ptr&lt;int[]&gt; up(new int[10]());//up指向一个包含10个初始化为0的int的数组share_ptr&lt;int&gt; sp(new int[10]，[](int *p)&#123;delete [] p;&#125;);//sp指向一个包含10个未初始化的int数组，并提供一个删除器 make_shared函数构造shared_ptr对象时在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，使用一次内存分配；shared_ptr构造shared_ptr对象时需要进行两次内存分配 new：没有默认构造函数的类不能动态分配数组 allocator:定义在memory中，将内存分配和对象构造分离开来 管理“动态数组”时，需要制定Deleter以使用delete[]操作符销毁内存，因为shared_ptr并没有针对数组的特化版本，而unique_ptr有针对数组的特化版本。我们常常需要对动态数组中的某一个元素进行操作，但shared_ptr没有提供[]操作符，不过我们可以使用 sp.get()先获取原始指针，再对原始指针进行下标操作。而unique_ptr对动态数组提供了支持，指定删除器是一个可选项。也可以直接使用下标操作 make_unique完美传递了参数给对象的构造函数，从一个原始指针构造出一个std::unique_ptr，返回创建的std::unique_ptr。这个形式的函数不支持数组和定制删除器（见条款18） 要解决环形引用的问题，没有特别好的办法，一般都是在可能出现环形引用的地方使用weak_ptr来代替shared_ptr。weak_ptr指向shared_ptr指针指向的对象的内存，却并不拥有该内存。 但是，使用weak_ptr成员lock，则可返回其指向内存的一个shared_ptr对象，且在所指对象内存已经无效时，返回指针空值（nullptr）。由于weak_ptr是指向shared_ptr所指向的内存的，所以，weak_ptr并不能独立存在 文本查询程序——优质程序","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Hexo+GitHub+NexT搭建博客","slug":"Hexo-GitHub-nexT搭建博客","date":"2020-03-23T14:26:43.000Z","updated":"2020-03-25T17:04:36.109Z","comments":true,"path":"2020/03/23/Hexo-GitHub-nexT搭建博客/","link":"","permalink":"http://yoursite.com/2020/03/23/Hexo-GitHub-nexT%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask on GitHub. （一）搭建博客操作过程 安装 Node.js 和 Git。 Node.js：https://nodejs.org/zh-cn Git：https://git-scm.com/downloads","text":"Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask on GitHub. （一）搭建博客操作过程 安装 Node.js 和 Git。 Node.js：https://nodejs.org/zh-cn Git：https://git-scm.com/downloads 下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。 安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git --version出现版本号说明安装成功。 创建GitHub Pages仓库 GitHub 主页右上角加号 -&gt; New repository： Repository name 中输入 用户名.github.io 勾选 “Initialize this repository with a README” 勾选public Description 选填 填好后点击 Create repository 创建。创建后默认自动启用 HTTPS，博客地址为：https://用户名.github.io,浏览器输入博客地址正常显示用户名.github.io。 本地安装Hexo博客程序 新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。打开该文件夹，右键 -&gt; Git Bash Here。 使用 npm 一键安装 Hexo 博客程序： 1npm install -g hexo-cli Mac 用户需要管理员权限（sudo），运行这条命令： 1sudo npm install -g hexo-cli 安装时间有点久（真的很慢！），界面也没任何反应，耐心等待 Hexo初始化和本地预览 初始化并安装所需组件： 12hexo init # 初始化npm install # 安装组件 完成后依次输入下面命令，启动本地服务器进行预览： 12hexo g # 生成页面hexo s # 启动预览 访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功！ 部署Hexo到GitHub Pages 本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。 首先安装 hexo-deployer-git： 1npm install hexo-deployer-git --save 然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下： 1234deploy: type: git repository: https:&#x2F;&#x2F;github.com&#x2F;用户名&#x2F;用户名.github.io branch: master 完成后运行 hexo d 将网站上传部署到 GitHub Pages,访问我们的 GitHub 域名 https://用户名.github.io 就可以看到 Hexo 网站了。 更换主题 在 Themes | Hexo 选择一个喜欢的主题，比如 NexT，进入网站目录打开 Git Bash Here 下载主题： 1git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next 然后修改 _config.yml 中的 theme 为新主题名称 next，发布。 （二）Hexo常用命令123456789101112131415161718192021222324252627hexo n &quot;name&quot; # 新建文章&#x3D;hexo new &quot;name&quot; hexo new page &quot;name&quot; # 新建页面hexo g # 生成页面&#x3D;hexo generatehexo d # 部署&#x3D;hexo deployhexo g -d # 生成页面并部署hexo s --debug # 调试模式下本地预览，可也用非调试模式hexo serverhexo clean # 清除缓存和已生成的静态文件hexo help # 帮助npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP&#x2F;&#x2F;新建文章三连hexo n &quot;name&quot; hexo g hexo s --debug&#x2F;&#x2F;预览效果满意则推到git上hexo d&#x2F;&#x2F;部署网站三连hexo clean hexo g hexo d （三）常见问题和注意事项1、Hexo 设置显示文章摘要，首页不显示全文 Hexo 主页文章列表默认会显示文章全文，浏览时很不方便，可以在文章中插入 `` 进行分段。该代码前面的内容会作为摘要显示，而后面的内容会替换为 “Read More” 隐藏起来。 2、设置网站图标 进入 themes/主题 文件夹，打开 _config.yml 配置文件，找到 favicon 修改，一般格式为：favicon: 图标地址。（不同主题可能略有差别） 3、修改并部署后没有效果 使用 hexo clean 清理后重新部署。 4、开启 HTTPS 后访问网站显示连接不安全？ 证书还未部署生效，等待一会儿，清除浏览器缓存再试。 5、Mac 安装 Hexo 报错无法安装 Mac 用户需要管理员权限运行，使用 sudo npm install -g hexo-cli 命令安装。 6、npm 下载速度慢，甚至完全没反应 使用 npm 安装程序等待很久也没反应，或者下载速度很慢，可以更换 npm 源为国内 npm 镜像。 临时更换方法：在 npm 安装命令后面加上： 1--registry https:&#x2F;&#x2F;registry.npm.taobao.org 7、注意格式标准 123title:(有空格)[文件名]tag:#标签-（有空格）c++ 8、设置SSH或HTTPS实现免密hexo deploy 方案一：如下图#号注释掉的代码，填写https：//账号:密码@github.com/账号/博客仓库名，实现HTTPS免密执行hexo d 方案二： 设置user.name和user.email配置信息，打开git bash输入： 12git config --global user.name \"你的GitHub用户名\"git config --global user.email \"你的GitHub注册邮箱\" 生成ssh密钥文件： 1ssh-keygen -t rsa -C \"你的GitHub注册邮箱\" 然后直接三个回车即可，默认不需要设置密码然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制。 打开GitHub_Settings_keys 页面，新建new SSH Key，随便填title,把刚复制的密钥粘贴到key,最后点击Add SSH key。 验证ssh是否设置成功： 1ssh git@github.com 配置站点的_config.yml文件，修改或添加repository值为ssh地址,填写git@github.com:账号/博客仓库名.git 9、hexo引用本地图片上传 安装一个图片路径转换的插件，这个插件名字是hexo-asset-image 1npm install https://github.com/CodeFalling/hexo-asset-image --save 打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For \"about\" page, the first part of \"src\" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info(\"update link as:--&gt;\"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(\"no src attr, skipped...\"); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 打开_config.yml文件，修改下述内容 1post_asset_folder: true 在md所在文件内新建一个同名文件，把图片放在该文件内 10、hexo+nexT的标签页面不显示 步骤按NexT主题配置操作 _config.yml中menu下||前面的空格删掉（||前面是链接，后面是图标） More info: HexoDoc MarkDown","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"NexT","slug":"NexT","permalink":"http://yoursite.com/tags/NexT/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}],"categories":[{"name":"常用技巧","slug":"常用技巧","permalink":"http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"安装编译","slug":"安装编译","permalink":"http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"},{"name":"搭建博客","slug":"搭建博客","permalink":"http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"},{"name":"截屏","slug":"截屏","permalink":"http://yoursite.com/tags/%E6%88%AA%E5%B1%8F/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"素数筛","slug":"素数筛","permalink":"http://yoursite.com/tags/%E7%B4%A0%E6%95%B0%E7%AD%9B/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"Clion","slug":"Clion","permalink":"http://yoursite.com/tags/Clion/"},{"name":"Boost","slug":"Boost","permalink":"http://yoursite.com/tags/Boost/"},{"name":"Opencv","slug":"Opencv","permalink":"http://yoursite.com/tags/Opencv/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"NexT","slug":"NexT","permalink":"http://yoursite.com/tags/NexT/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}