{"meta":{"title":"翟安然's Blog","subtitle":"","description":"","author":"翟安然","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2020-03-25T10:37:44.000Z","updated":"2020-03-25T15:00:42.002Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-25T10:41:44.000Z","updated":"2020-03-25T13:49:16.049Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-03-25T10:41:58.000Z","updated":"2020-03-25T14:54:20.795Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-03-25T10:42:40.000Z","updated":"2020-03-25T13:48:56.355Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux","slug":"Linux","date":"2020-05-13T03:18:40.000Z","updated":"2020-05-13T10:23:43.098Z","comments":true,"path":"2020/05/13/Linux/","link":"","permalink":"http://yoursite.com/2020/05/13/Linux/","excerpt":"Linux面试常考命令 chmod 1、文字设定用法： 1chmod [who] [+ | - | =] [mode] 文件名 命令中各选项的含义为（1）操作对象 who可以是下述字母中的任一个或者它们的组合u 表示用户(user) 即文件或目录的所有者g 表示同组(group)用户 即与文件属主有相同组 ID 的所有用户o 表示其他(others)用户a 表示所有(all)用户 它是系统默认值（2）操作符号可以是 123+添加某个权限 -取消某个权限 =赋予给定权限,并取消其他所有权限","text":"Linux面试常考命令 chmod 1、文字设定用法： 1chmod [who] [+ | - | =] [mode] 文件名 命令中各选项的含义为（1）操作对象 who可以是下述字母中的任一个或者它们的组合u 表示用户(user) 即文件或目录的所有者g 表示同组(group)用户 即与文件属主有相同组 ID 的所有用户o 表示其他(others)用户a 表示所有(all)用户 它是系统默认值（2）操作符号可以是 123+添加某个权限 -取消某个权限 =赋予给定权限,并取消其他所有权限 （3）mode表示权限 常用的参数有 123r 可读 4w 可写 2x 可执行 1 （4）举例 将文件 text的权限设为可执行 chmod =rx text 执行成功后 用 ls -l tex命令查看文件属性的结果如下 12345-r-xr-xr-x 1 user group 0 Feb 10 09:42 script #文件属主权限r-x#同组用户权限r-x#其他用户权限r-x#等同于执行chmod 555 text 将文件 text 的权限设为 文件属主可读 可写 可执行 与文件属主同组 的用户可读 其他用户不可读 命令如下chmod u=rwx,g=r,o= text 注意,后无空格 o=后有空格执行成功后用ls –l text命令查看文件属性的结果如下-rwxr----- 1 user group 0 Feb 10 09:42 text chown chown 用于更改某个文件或目录的属主和属组 如 root用户把自己的一个文件拷贝给用户 oracle 为了让用户oracle能够存 取这个文件 root用户应该把这个文件的属主设为oracle 否则用户oracle 无法存取这个文件 chown 的基本用法为 12chown [用户:组] 文件 #例如$chown oracle:dba text 该命令将 text 文件的属主和属组分别改为 oracle和dba 文件查看cat head tail more less的区别 cat 命令是将整个文件的内容从上到下显示在屏幕上。 more 命令会一页一页的显示，方便使用者逐页阅读，而最基本的指令就是按空白键（space）往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more 命令从前向后读取文件，因此在启动时就加载整个文件。 主要是用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行；tail 命令主要用于显示指定文件末尾内容。常用查看日志文件。 less可以按键盘上下方向键显示上下内容,more不能通过上下方向键控制显示； less不必读整个文件，加载速度会比more更快； less退出后shell不会留下刚显示的内容,而more退出后会在shell上留下刚显示的内容 静态显示系统当前的进程和其他状况ps 动态显示系统当前的进程和其他状况top 压缩tar 终止后台进程kill 文件编辑：vi命令行模式、文本输入模式、末行模式-插入附加打开查找替换 文件拷贝cp ifconfig查看和配置网络接口（通常是网卡）信息，包括网络接口设备的IP地址、掩码等 route管理Linux系统内核中的路由表，最大用途就是设定静态的路由表项 Linux提供了一组强有力的网络命令来为用户服务 这些工具能够帮助用户登 录到远程计算机上 传输文件和执行远程命令等 主要包括Linux提供了一组强有力的网络命令来为用户服务 这些工具能够帮助用户登 录到远程计算机上 传输文件和执行远程命令等 。主要包括ftp传输文件和telnet 登录到远程计算机上 Linux系统常用的网络操作命令包括 netstat nslookup host finger和 ping netstat命令的功能是显示网络连接路由表和网络接口信息,可以让用户得知目前都有哪些网络连接正在运作 ; nslookup命令的功能是查询一台机器的 IP 地址和其对应的域名它通常需要一台域名服务器来提供域名服务 如果用户已经设置好域名服务器就可以用这个命令查看不同主机的 IP地址对应的域名; host命令可根据主机名查询主机的 IP 地址或根据主机 IP地址查询主机名; finger命令的功能是查询用户的信息通常会显示系统中某个用户的用户名 主目录 停滞时间 登录时间 登录 shell等信息; ping命令用于查看网络上的主机是否在工作 文件查找find 1. ps是什么？ 要对进程进行监测和控制，首先必须要了解当前进程的情况,也就是需要查看当前进程，ps命令就是最基本进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等等.总之大部分信息都是可以通过执行该命令得到。 ps是显示瞬间进程的状态，并不动态连续；如果想对进程进行实时监控应该用top命令。 **基本参数：** - -A ：所有的进程均显示出来，与 -e 具有同样的效用； - -a ：显示现行终端机下的所有进程，包括其他用户的进程； - -u ：以用户为主的进程状态 ； - x ：通常与 a 这个参数一起使用，可列出较完整信息。 **输出格式规划：** - l ：较长、较详细的将该PID 的的信息列出； - j ：工作的格式 (jobs format) - -f ：做一个更为完整的输出。 下面我们就来一个命令进行实践，看看不同的参数都有些什么效果。 #### **2. 不加参数执行ps命令会输出什么？** 这是一个基本的 **ps** 使用，我们来看看控制台中执行这个命令并查看结果。 ![img](https://mmbiz.qpic.cn/mmbiz_png/QFzRdz9libEYfddXS8Cz7VaS8CMuO9et7ZXaQLQicCX8yuMe3IiaJZWHiaJNz2IZPtjr8fl6aLlIgTP7OKZ8SXhg0w/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) 结果默认会显示4列信息： - PID: 运行着的命令(CMD)的进程编号 - TTY: 命令所运行的位置（终端） - TIME: 运行着的该命令所占用的CPU处理时间 - CMD: 该进程所运行的命令 这些信息在显示时未排序。 #### **3. 如何显示所有当前进程？** 使用 **-a** 参数，**-a 代表 all**。同时加上x参数会显示没有控制终端的进程。 123$ ps -ax# 这个命令的结果或许会很长。为了便于查看，可以结合less命令和管道来使用。$ ps -ax | less ![img](https://mmbiz.qpic.cn/mmbiz_png/QFzRdz9libEYfddXS8Cz7VaS8CMuO9et7HEv4ppaziacIqB6cLOibic1bbTHnBmiaJQLBD2avtryqfqoriayRmBKm57Q/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) #### **4. 如何根据进程的用户进行信息过滤呢？** 在需要查看特定用户进程的情况下，我们可以使用 **-u** 参数。比如我们要查看用户&apos;pungki&apos;的进程，可以通过下面的命令： 1$ ps -u pungki ![img](https://mmbiz.qpic.cn/mmbiz_png/QFzRdz9libEYfddXS8Cz7VaS8CMuO9et7b8RqXeSxo7e9x1v20icEyvR6IZtIzB49WlQgsqqQeBia1xF3P8fOxnjg/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) #### **5. 如何通过cpu和内存使用来过滤进程？** 也许你希望把结果按照 CPU 或者内存用量来筛选，这样你就找到哪个进程占用了你的资源。要做到这一点，我们可以使用 **aux** 参数，来显示全面的信息: 1$ ps -aux | less ![img](https://mmbiz.qpic.cn/mmbiz_png/QFzRdz9libEYfddXS8Cz7VaS8CMuO9et74asPxeJxonhGjtnzph8feqicKlCtVwyLz6icXMRqaiabFW16jU5l4Xwnw/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) 当结果很长时，我们可以使用管道和less命令来筛选。 默认的结果集是未排好序的。可以通过 **--sort**命令来排序。 #### **5.1 根据CPU使用率来升序排序** 1$ ps -aux --sort -pcpu | less #### **5.2 根据内存使用率来升序排序** 1$ ps -aux --sort -pmem | less ![img](https://mmbiz.qpic.cn/mmbiz_png/QFzRdz9libEYfddXS8Cz7VaS8CMuO9et7vTiaQCgtYHReWo1mfPUWsiaJBrUqwjy3XNqP2clfrHa9N1UbuBrnybAw/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) #### **5.3 我们也可以将它们合并到一个命令，并通过管道显示前10个结果：** 1$ ps -aux --sort -pcpu,+pmem | head -n 10 #### **6. 如何通过进程名和PID进行过滤呢？** 使用 **-C** 参数，后面跟你要找的进程的名字。比如想显示一个名为getty的进程的信息，就可以使用下面的命令： 1$ ps -C getty 如果想要看到更多的细节，我们可以使用-f参数来查看格式化的信息列表： 1$ ps -f -C getty ![img](https://mmbiz.qpic.cn/mmbiz/QFzRdz9libEYfddXS8Cz7VaS8CMuO9et7Yx8qqmjiaexudSYG7A93djdPpYygoXhFb5befMYibsDcnRUHg3b3XoAA/640?wx_fmt=other&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) #### **7. 如何根据线程来过滤进程呢？** 如果我们想知道特定进程的线程，可以使用 **-L** 参数，后面加上特定的PID。 1$ ps -L 1213 ![img](https://mmbiz.qpic.cn/mmbiz/QFzRdz9libEYfddXS8Cz7VaS8CMuO9et7wibmuEjkciazstzib8S86qV8UwEAsuO7eqwZermrVNEGics4PKgYDEmTXw/640?wx_fmt=other&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) #### **8. 如何树形的显示进程？** 有时候我们希望以树形结构显示进程，可以使用 **-axjf** 参数。 1$ ps -axjf ![img](https://mmbiz.qpic.cn/mmbiz/QFzRdz9libEYfddXS8Cz7VaS8CMuO9et77diawWtoeE5Iniby2tf49qJgaiaWm1Cs7lB5GljMXjjXHLk2ibxla6MVjg/640?wx_fmt=other&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) 或者可以使用另一个命令。 1$ pstree ![img](https://mmbiz.qpic.cn/mmbiz/QFzRdz9libEYfddXS8Cz7VaS8CMuO9et7PAFfVxmNGgzz9ZKpXnq5LP8fq8Gx9qI08hIicyBBrf68lpk8AnsLfaw/640?wx_fmt=other&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) #### **9. 如何显示安全信息？** 如果想要查看现在有谁登入了你的服务器。可以使用ps命令加上相关参数: 1$ ps -eo pid,user,args 参数 **-e** 显示所有进程信息，**-o** 参数控制输出。**Pid**,**User** 和 **Args**参数显示PID，**运行应用的用户**和**该应用**。 ![img](https://mmbiz.qpic.cn/mmbiz_png/QFzRdz9libEYfddXS8Cz7VaS8CMuO9et79YpfJYjNHpzoT33GzvBcwmCBVvibKLLIReSosNm5WicG6fb2yY0TNUfQ/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) 能够与 **-e** 参数 一起使用的关键字是**args, cmd, comm, command, fname, ucmd, ucomm, lstart, bsdstart 和 start**。 #### **10. 如何格式化输出root用户（真实的或有效的UID）创建的进程？** 系统管理员想要查看由root用户运行的进程和这个进程的其他相关信息时，可以通过下面的命令: 1$ ps -U root -u root u **-U** 参数按真实用户ID(RUID)筛选进程，它会从用户列表中选择真实用户名或 ID。真实用户即实际创建该进程的用户。 **-u** 参数用来筛选有效用户ID（EUID）。 最后的 **u** 参数用来决定以针对用户的格式输出，由**User, PID, %CPU, %MEM, VSZ, RSS, TTY, STAT, START, TIME 和 COMMAND**这几列组成。 这里有上面的命令的输出结果： ![img](https://mmbiz.qpic.cn/mmbiz_png/QFzRdz9libEYfddXS8Cz7VaS8CMuO9et77m2ydG87MaLOFgtiaH39fEeqmrL4C3hvqJdFESLRHh982qiaNXiasobCg/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) #### **11. 如何使用PS实时监控进程状态？** ps 命令会显示你系统当前的进程状态，但是这个结果是静态的。 当有一种情况，我们需要像上面第四点中提到的通过CPU和内存的使用率来筛选进程，并且我们希望结果能够每秒刷新一次。为此，我们可以**将ps命令和watch命令结合起来**。 1$ watch -n 1 ‘ps -aux --sort -pmem, -pcpu’ ![img](https://mmbiz.qpic.cn/mmbiz/QFzRdz9libEYfddXS8Cz7VaS8CMuO9et7cpp0QavUZ8vh0zVMXP8KmKhrcbL88cnWyACO5JpS3UiaHQkLhjiaoZMA/640?wx_fmt=other&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) 如果输出太长，我们也可以限制它，比如前20条，我们可以使用 **head** 命令来做到。 1$ watch -n 1 ‘ps -aux --sort -pmem, -pcpu | head 20’ 这里的动态查看并不像top或者htop命令一样。但是使用ps的好处是你能够定义显示的字段，你能够选择你想查看的字段。 举个例子，如果你只需要看名为&apos;pungki&apos;用户的信息，你可以使用下面的命令： 1$ watch -n 1 ‘ps -aux -U pungki u --sort -pmem, -pcpu | head 20’ ![img](https://mmbiz.qpic.cn/mmbiz_png/QFzRdz9libEYfddXS8Cz7VaS8CMuO9et7zDRn9B1uDXXS0UGcU98R2pOYWFyxbar16EWTrbyg462SBuWAqMvAUA/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1) 你也许每天都会使用ps命令来监控你的Linux系统。但是事实上，你可以通过ps命令的参数来生成各种你需要的报表。 ps命令的另一个优势是ps是各种 Linux系统都默认安装的，因此你只要用就行了。不要忘了通过 man ps来查看更多的参数。 文件内容查找grep Linux系统中的grep命令是一种功能强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。 1、语法参数 123456789101112grep [options][options]主要参数：-c：只输出匹配行的计数。-i：表示不区分大小写。-h：查询多文件时不显示文件名。-l：查询多文件时只输出包含匹配字符的文件名。-n：显示匹配行及行号。-s：不显示不存在或无匹配文本的错误信息。-v：显示不包含匹配文本的所有行，表示反向查找。--color=auto ：可以将找到的关键词部分加上颜色的显示 2、实例： 1）查找包含“png”的行 1[linuxmi@linux:~/linuxmi迷]$ grep -n 'png' linuxmi.py 2）查找不包含“png”的行 1[linuxmi@linux:~/linuxmi迷]$ grep -vn 'png' linuxmi.py 3）查询na前面不是v的字符串 1[linuxmi@linux:~/linuxmi迷]$ grep -n '[^v]na' linuxmi.py 4）查询na前面不是小写字母的字符串 1[linuxmi@linux:~/linuxmi迷]$ grep -n '[^a-z]na' linuxmi.py 5）^匹配以某个字符开头的行。查询以ba开头的字符串 1[linuxmi@linux:~/linuxmi迷]$ grep -n '^ba' linuxmi.py 6）[^]匹配未包含的一个任意字符。查询不以字母开头的字符串 1[linuxmi@linux:~/linuxmi迷]$ grep -n '^[^a-zA-Z]' linuxmi.py 7）$匹配以某个字符结尾的行。查询以:结尾的字符串 1[linuxmi@linux:~/linuxmi迷]$ grep -n '\\.$' linuxmi.py //其中小数点“.”具有特殊意义，所以需要使用转义字符“\\”将具有特殊意义的字符转化为普通字符 8）“.”匹配除\\r\\n外的任意一个字符。查询l与k之间包含两个字符的行 1[linuxmi@linux:~/linuxmi迷]$ grep -n 'l..k' linuxmi.py 9）查询包含连续e字母的行 1[linuxmi@linux:~/linuxmi迷]$ grep -n 'eee*' linuxmi.py //“*”表示的是重复零个或多个前面的单字符 10）查询以l开头以e结尾中间至少包含一个x的行 1[linuxmi@linux:~/linuxmi迷]$ grep -n 'lxx*e' linuxmi.py 11）查询以l开头k结尾，中间的字符可有可无的行 1[linuxmi@linux:~/linuxmi迷]$ grep -n 'l.*k' linuxmi.py 12）{n}匹配确定的n次。查询包含两个e的行 1[linuxmi@linux:~/linuxmi迷]$ grep -n 'e\\&#123;2\\&#125;' linuxmi.py //“{}”是特殊字符需要用“\\”转义","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"effectiveC++","slug":"effectiveC","date":"2020-04-22T05:16:45.000Z","updated":"2020-04-22T08:34:42.813Z","comments":true,"path":"2020/04/22/effectiveC/","link":"","permalink":"http://yoursite.com/2020/04/22/effectiveC/","excerpt":"一、让自己习惯C++条款01:视C++为一个语言联邦条款02：尽量以const,enums,and inlines to #defines条款03：尽可能使用const条款04：确定对象使用前已先被初始化 如果内置类型（初始化与赋值成本相同）的变量未被显示地初始化，它的值将由定义的位置决定。 （1）定义在函数体之外的变量将被初始化为0。","text":"一、让自己习惯C++条款01:视C++为一个语言联邦条款02：尽量以const,enums,and inlines to #defines条款03：尽可能使用const条款04：确定对象使用前已先被初始化 如果内置类型（初始化与赋值成本相同）的变量未被显示地初始化，它的值将由定义的位置决定。 （1）定义在函数体之外的变量将被初始化为0。 （2）定义在函数体内部的变量将不被初始化，它的值时任意的。 对于无任何成员的内置类型，手工初始化；内置类型以外，确保每一个构造函数都将对象的每一个成员在成员初始列进行初始化。 为免除“跨编译单元值初始化次序”问题，以local static对象替代non-local static对象。 二、构造/析构/赋值运算条款05：","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"effective","slug":"effective","permalink":"http://yoursite.com/tags/effective/"}]},{"title":"日常常用技巧","slug":"日常常用技巧","date":"2020-03-27T06:11:04.000Z","updated":"2020-03-27T06:26:06.780Z","comments":true,"path":"2020/03/27/日常常用技巧/","link":"","permalink":"http://yoursite.com/2020/03/27/%E6%97%A5%E5%B8%B8%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"1、windows+chrome长截屏 原生长截屏 123Fn+F12Ctrl+Shift+p搜索capture full size screenshot","text":"1、windows+chrome长截屏 原生长截屏 123Fn+F12Ctrl+Shift+p搜索capture full size screenshot 安装插件Fireshot","categories":[{"name":"常用技巧","slug":"常用技巧","permalink":"http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"},{"name":"截屏","slug":"截屏","permalink":"http://yoursite.com/tags/%E6%88%AA%E5%B1%8F/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"高效算法","slug":"高效算法","date":"2020-03-25T16:51:01.000Z","updated":"2020-05-10T15:53:54.504Z","comments":true,"path":"2020/03/26/高效算法/","link":"","permalink":"http://yoursite.com/2020/03/26/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95/","excerpt":"（一）素数筛 素数的性质： 定义：一个大于1的自然数，除了1和它本身以外，不能被任何自然数整除。所以2是最小的素数，0和1不是质数也不是合数。 任意一个合数都可以表示几个质数的乘积-&gt;任意一个合数都可以表示成一个质数和另一个数的乘积 一个合数和一个质数的乘积=一个更大的合数和一个更小的质数的乘积","text":"（一）素数筛 素数的性质： 定义：一个大于1的自然数，除了1和它本身以外，不能被任何自然数整除。所以2是最小的素数，0和1不是质数也不是合数。 任意一个合数都可以表示几个质数的乘积-&gt;任意一个合数都可以表示成一个质数和另一个数的乘积 一个合数和一个质数的乘积=一个更大的合数和一个更小的质数的乘积 知识点扩展：判断互质数的五种方法 概念判断法。公约数只有1的两个数叫做互质数。根据互质数的概念可以对一组数是否互质进行判断。如：9和11的公约数只有1，则它们是互质数。 规律判断法。根据互质数的定义，可总结出一些规律，利用这些规律能迅速判断一组数是否互质。 （1）两个不相同的质数一定是互质数。如：7和11、17和31是互质数。 （2）两个连续的自然数一定是互质数。如：4和5、13和14是互质数。 （3）相邻的两个奇数一定是互质数。如：5和7、75和77是互质数。 （4）1和其他所有的自然数一定是互质数。如：1和4、1和13是互质数。 （5）两个数中的较大一个是质数，这两个数一定是互质数。如：3和19、16和97是互质数。 （6）两个数中的较小一个是质数，而较大数是合数且不是较小数的倍数，这两个数一定是互质数。如：2和15、7和54是互质数。 （7）较大数比较小数的2倍多1或少1，这两个数一定是互质数。如：13和27、13和25是互质数。 分解判断法。如果两个数都是合数，可先将两个数分别分解质因数，再看两个数是否含有相同的质因数。如果没有，这两个数是互质数。如：130和231，先将它们分解质因数：130＝2×5×13，231＝3×7×11。分解后，发现它们没有相同的质因数，则130和231是互质数。 求差判断法。如果两个数相差不大，可先求出它们的差，再看差与其中较小数是否互质。如果互质，则原来两个数一定是互质数。如：194和201，先求出它们的差，201－194＝7，因7和194互质，则194和201是互质数。 求商判断法用大数除以小数，如果除得的余数与其中较小数互质，则原来两个数是互质数。如：317和52，317÷52＝6……5，因余数5与52互质，则317和52是互质数。 实现 123456789101112131415161718192021222324252627282930313233//普通筛-埃拉托斯特尼sieve of Eratosthenes 时间复杂度O(nlogn)#include &lt;vector&gt;auto eratosthenes(int upperbound)&#123; std::vector&lt;bool&gt; flag(upperbound+1, true); flag[0]=flag[1]=false; //exclude 0 and 1 //二次筛选法:i是素数，则下一个起点是i*i(比i小的数在前面已经乘过i了),把后面的所有的i*i+2*n*i筛掉 for(int i=2; i&lt;=sqrt(upperbound); ++i) if(flag[i]) // if i is prime number for(int j=i*i; j&lt;=upperbound; j+=i) flag[j] = false; return flag;&#125;//线性筛-欧拉筛//prime数组中的素数是递增的,当i能整除prime[j]，那么i*prime[j+1]这个合数肯定被prime[j]乘以某个数筛掉。因为i中含有prime[j],prime[j]比prime[j+1]小，即i=k*prime[j]，那么i*prime[j+1]=(k*prime[j])*prime[j+1]=k’*prime[j]，接下去的素数同理。所以不用筛下去了。因此，在满足i%prime[j]==0这个条件之前以及第一次满足该条件时,prime[j]必定是prime[j]*i的最小因子#include &lt;vector&gt;auto eratosthenes(int upperbound)&#123; std::vector&lt;bool&gt; flag(upperbound+1, true); std::vector&lt;bool&gt; prime; flag[0]=flag[1]=false; //exclude 0 and 1 for(int i=2;i&lt;upperbound;i++)&#123; if(flag[i]) prime.emplace_back(i); for(int j=0;j&lt;primer.size()&amp;&amp;prime[j]*i&lt;=upperbound;j++)&#123; flag[prime[j]*i]=false; if(i%prime[j]==0)//保证每个合数只会被它的最小质因数筛去，因此每个数只会被标记一次 break; &#125; &#125; return prime;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"素数筛","slug":"素数筛","permalink":"http://yoursite.com/tags/%E7%B4%A0%E6%95%B0%E7%AD%9B/"}]},{"title":"Linux安装Qt/Clion编译Boost/Opencv","slug":"Linux安装Qt-Clion编译Boost-Opencv","date":"2020-03-25T16:35:36.000Z","updated":"2020-03-25T16:59:55.697Z","comments":true,"path":"2020/03/26/Linux安装Qt-Clion编译Boost-Opencv/","link":"","permalink":"http://yoursite.com/2020/03/26/Linux%E5%AE%89%E8%A3%85Qt-Clion%E7%BC%96%E8%AF%91Boost-Opencv/","excerpt":"（一）qt 安装: 首先从Qt官网上下载安装包，下载网址 给.run文件添加执行权限 1sudo chmod +x qt-opensource-linux-x64-5.12.0.run","text":"（一）qt 安装: 首先从Qt官网上下载安装包，下载网址 给.run文件添加执行权限 1sudo chmod +x qt-opensource-linux-x64-5.12.0.run 执行.run进行qt的安装 1sudo ./qt-opensource-linux-x64-5.12.0.run (二)clion安装: 官网下载 解压 1tar -zxvf CLion-2016.2.2.tar.gz 运行脚本 12cd clion-2016.2.2/bin/ ./clion.sh (三)boost编译: 官网下载压缩包.tar.gz tar -xvf boost(tab) cd boost_1_71_0 chmod 777 bootstrap.sh ./bootstrap.sh --with-libraries=all --with-toolset=gcc 指定编译boost的哪些库,all是全编译,只想编译部分库的话就把库名写上用逗号分隔开(在这步之前保证gcc g++至少为version 7),编译器用gcc 提示:to build,run:./b2 sudo ./b2 install 编译大约十分钟，提示…failed updating 60… (四)opencv编译： 到官网下载opencv4.1.0点击此处，选择source进行下载(opencv4.1.2会出错) 解压缩包unzip opencv-4.1.0.zip 对解压的文件夹进行重命名mv opencv-4.1.0 opencv sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev cd ~/opencv mkdir build cd build cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. make -j n # n为你的CPU线程数（几核就填几，电脑能力范围内的最大值） sudo make install","categories":[{"name":"安装编译","slug":"安装编译","permalink":"http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"Clion","slug":"Clion","permalink":"http://yoursite.com/tags/Clion/"},{"name":"Boost","slug":"Boost","permalink":"http://yoursite.com/tags/Boost/"},{"name":"Opencv","slug":"Opencv","permalink":"http://yoursite.com/tags/Opencv/"}]},{"title":"操作系统","slug":"操作系统","date":"2020-03-25T16:23:38.000Z","updated":"2020-05-17T02:15:14.704Z","comments":true,"path":"2020/03/26/操作系统/","link":"","permalink":"http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"1、程序内存区域分配 一个程序本质上都是由 bss段、data段、text段三个组成的。bss段通常是指用来存放程序中静态变量和未初始化的全局变量一块内存区域，一般在初始化时bss 段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。比如，在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，静态变量和未初始化的全局变量保存在.bss 段中。text和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化。bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小；bss段的大小从可执行文件中得到 ，然后链接器得到这个大小的内存块，紧跟在数据段后面。data段（已手动初始化的数据）则为数据分配空间，数据保存在目标文件中；data段包含经过初始化的全局变量以及它们的值。当这个内存区进入程序的地址空间后全部清零。包含data段和bss段的整个区段此时通常称为数据区。","text":"1、程序内存区域分配 一个程序本质上都是由 bss段、data段、text段三个组成的。bss段通常是指用来存放程序中静态变量和未初始化的全局变量一块内存区域，一般在初始化时bss 段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。比如，在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，静态变量和未初始化的全局变量保存在.bss 段中。text和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化。bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小；bss段的大小从可执行文件中得到 ，然后链接器得到这个大小的内存块，紧跟在数据段后面。data段（已手动初始化的数据）则为数据分配空间，数据保存在目标文件中；data段包含经过初始化的全局变量以及它们的值。当这个内存区进入程序的地址空间后全部清零。包含data段和bss段的整个区段此时通常称为数据区。 同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。 2、进程的三种基本状态 就绪状态 当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态就称为就绪状态； 执行状态： 当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态； 阻塞状态： 正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而进入阻塞状态。引起进程阻塞的事件有很多种，例如，等待I/O完成、申请缓冲区不能满足、等待信号等。 进程三种状态间的转换 执行–&gt;就绪：时间片完； 就绪–&gt;执行：被调度； 执行–&gt;阻塞：等待事件，io请求； 阻塞-&gt;就绪：io完成 一个进程在运行期间，不断地从一种状态转换到另一种状态，它可以多次处于就绪状态和执行状态，也可以多次处于阻塞状态。A. 就绪—&gt;执行处于就绪状态的进程，当进程调度程序为之分配好了处理机后，该进程便由就绪状态转换为执行状态；B. 执行—&gt;就绪处于执行状态的进程在其执行过程中，因分配给它的一个时间片已经用完而不得不让出处理机，于是进程从执行状态转换为就绪状态；C. 执行—&gt;阻塞正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态；D. 阻塞—&gt;就绪处于阻塞状态的进程，若其等待的事件已经发生，于是进程便从阻塞状态转变为就绪状态。 3、Linux系统结构详解 Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。 内核空间和用户空间： 由于操作系统都包括内核空间和用户空间（或者说内核态和用户态），内核空间主要存放的是内核代码和数据，是供系统进程使用的空间。而用户空间主要存放的是用户代码和数据，是供用户进程使用的空间。目前Linux系统简化了分段机制，使得虚拟地址与线性地址总是保持一致，因此，Linux系统的虚拟地址也是0~4G。Linux系统将这4G空间分为了两个部分：将最高的1G空间（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，即为“内核空间”，而将较低的3G空间（从虚拟地址 0x00000000到0xBFFFFFFF）供用户进程使用，即为“用户空间”。同时由于每个用户进程都可以通过系统调用进入到内核空间，因此Linux的内核空间可以认为是被所有用户进程所共享的，因此对于一个具体用户进程来说，它可以访问的虚拟内存地址就是0~4G。另外Linux系统分为了四种特权级：0～3，主要是用来保护资源。0级特权最高，而3级则为最低，系统进程主要运行在0级，用户进程主要运行在3级。 Linux的五种IO模型： 1）阻塞IO 2）非阻塞IO 3）IO复用（select和poll） 4）信号驱动IO（sigio） 5）异步IO（aio_） 一般来说，IO操作都分为两个阶段，就拿套接口的输入操作来说，它的两个阶段主要是： 1）等待网络数据到来，当分组到来时，将其拷贝到内核空间的临时缓冲区中 2）将内核空间临时缓冲区中的数据拷贝到用户空间缓冲区中 1、阻塞IO 默认情况下，所有套接口都是阻塞的。 例如recvfrom函数是一个系统调用： 说明：任何一个系统调用都会产生一个由用户态到内核态切换，再从内核态到用户态切换的过程，而进程上下文切换是通过系统中断程序来实现的，需要保存当前进程的上下文状态，这是一个极其费力的过程。 2、非阻塞IO 当我们把套接口设置成非阻塞时，就是由用户进程不停地询问内核某种操作是否准备就绪，这就是我们常说的“轮询”。这同样是一件比较浪费CPU的方式。 3、IO复用 我们常用到的IO复用，主要是select和poll。这里同样是会阻塞进程的，但是这里进程是阻塞在select或者poll这两个系统调用上，而不是阻塞在真正的IO操作上。 看起来它与blocking I/O很相似，两个阶段都阻塞。但它与blocking I/O的一个重要区别就是它可以等待多个数据报就绪（datagram ready），即可以处理多个连接，而阻塞IO一次性只能监听一个套接口。这里的select相当于一个“代理”，调用select以后进程会被select阻塞，这时候在内核空间内select会监听指定的多个datagram (如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。 在select模型中每个socket一般都设置成non-blocking，虽然等待数据阶段仍然是阻塞状态，但是它是被select调用阻塞的，而不是直接被I/O阻塞的。select底层通过轮询机制来判断每个socket读写是否就绪。 当然select也有一些缺点，比如底层轮询机制会增加开销、支持的文件描述符数量过少等。为此，Linux引入了epoll作为select的改进版本。 4、信号驱动IO 信号驱动IO就是说我们可以通过sigaction系统调用注册一个信号处理程序，然后主程序可以继续向下执行，当我们所监控的套接口有IO操作准备就绪时，由内核通知触发前面注册的信号处理程序执行，然后将我们所需要的数据从内核空间拷贝到用户空间。 5、异步IO 异步IO与信号驱动IO最主要的区别就是信号驱动IO是由内核通知我们何时可以进行IO操作了，而异步IO则是由内核告诉我们IO操作何时完成了。具体来说就是，信号驱动IO当内核通知触发信号处理程序时，信号处理程序还需要阻塞在从内核空间缓冲区拷贝数据到用户空间缓冲区这个阶段，而异步IO直接是在第二个阶段完成后内核直接通知可以进程后续操作了。 综上所述，我们发现 前四种IO模型的主要区别是在第一阶段，因为它们的第二阶段都是在阻塞等待数据由内核空间拷贝到用户空间；而异步IO很明显与前面四种有所不同，它在第一阶段和第二阶段都不会阻塞。具体参考如下： 最后，总结下同步IO与异步IO的区别： 1）同步IO操作会引起进程阻塞直到IO操作完成。 2）异步IO操作不引起进程阻塞。 因此，由上面定义可以看出，阻塞IO、非阻塞IO、IO复用、信号驱动IO都是属于同步IO，而异步IO模型才与异步IO定义所匹配。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Linux或windows安装Matlab注意事项","slug":"Linux安装Matlab","date":"2020-03-25T15:59:41.000Z","updated":"2020-03-25T17:00:55.060Z","comments":true,"path":"2020/03/25/Linux安装Matlab/","link":"","permalink":"http://yoursite.com/2020/03/25/Linux%E5%AE%89%E8%A3%85Matlab/","excerpt":"1、一定要把iso挂载的文件复制到home目录下，使用完整路径启动install,而不能直接进入挂载的dvd中sudo ./install","text":"1、一定要把iso挂载的文件复制到home目录下，使用完整路径启动install,而不能直接进入挂载的dvd中sudo ./install 2、windows安装注意事项： 如果之前安装过即使没安装成功，要彻底删除安装过程中产生的所有文件 安装路径不能存在中文 防火墙等杀毒软件要关闭","categories":[{"name":"安装编译","slug":"安装编译","permalink":"http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"}]},{"title":"Git操作注意事项","slug":"Git操作注意事项","date":"2020-03-25T15:53:25.000Z","updated":"2020-03-25T17:00:45.990Z","comments":true,"path":"2020/03/25/Git操作注意事项/","link":"","permalink":"http://yoursite.com/2020/03/25/Git%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"Git常规笔记及注意事项 切换到历史版本(要求此时本地项目没有未提交的修改)：git checkout &lt;版本号&gt; 查看文件的历史记录、查看某个文件在某次提交中的修改参照：使用git查看版本记录","text":"Git常规笔记及注意事项 切换到历史版本(要求此时本地项目没有未提交的修改)：git checkout &lt;版本号&gt; 查看文件的历史记录、查看某个文件在某次提交中的修改参照：使用git查看版本记录 从缓存中删除的文件git rm -r . –cached可以采用git reset HEAD .进行恢复 git reset --mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息git reset --soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git reset --hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，此命令 慎用！","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"面试要点记录","slug":"面试要点记录","date":"2020-03-24T13:59:01.000Z","updated":"2020-05-16T16:16:56.292Z","comments":true,"path":"2020/03/24/面试要点记录/","link":"","permalink":"http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/","excerpt":"[TOC] （一）面向对象的三个基本特征：封装、继承、多态 继承 子类对象可以直接调用父类中的成员函数 子类对象可以直接赋值给父类对象。 子类对象可以直接初始化父类对象。 父类引用可以直接引用子类对象。 父类指针可以直接指向子类对象。","text":"[TOC] （一）面向对象的三个基本特征：封装、继承、多态 继承 子类对象可以直接调用父类中的成员函数 子类对象可以直接赋值给父类对象。 子类对象可以直接初始化父类对象。 父类引用可以直接引用子类对象。 父类指针可以直接指向子类对象。 子类初始化一定会先初始化父类，析构顺序相反。 虚继承对构造函数的影响：指南。构造函数的调用可能内带大量的隐藏码，因为编译器会对构造函数进行扩充，一般而言编译器所作的扩充规则如下： （1）记录在成员初始化列表中的数据成员的初始化操作会被放到构造函数本身中，按照数据成员声明的顺序 （2）如果有一个数据成员没有出现在初始化列表中，但是它有一个默认构造函数，那么这个默认构造函数会被调用 （3）在那之前，如果有虚函数表，会调整虚函数表指针 （4）在那之前，会对上一层基类的构造函数进行调用 （5）在那之前，所有虚基类的构造函数必须被调用，按照声明的继承顺序从左往右，从最深到最浅的顺序 多态 多态发生的三个必要条件： 要有继承。 要有虚函数重写。 父类指针或引用 指向 子类对象。 虚析构函数：在多态时，要调用析构函数时，注意在父类的析构成员函数前加virtual。 动态绑定必须使用指针或者引用，不能使用. 虚函数表指针在内存中的分布:参考 重载/重写（覆盖）/重定义（隐藏） 重载（overload）-编译时的多态性 （1）重载只能通过不同的参数样式（参数类型、个数、顺序至少有一个不相同），不能通过访问权限、返回类型、抛出的异常进行重载。 重写（override）-运行时的多态性 （1）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 （2）被定义为final的方法不能被重写。 重定义（隐藏hiding） （1）隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt; using namespace std; class Base &#123; private: virtual void display() &#123; cout&lt;&lt;\"Base display()\"&lt;&lt;endl; &#125; void show()&#123; cout&lt;&lt;\"Base show()\"&lt;&lt;endl; &#125; public: void exec()&#123; display(); show(); &#125; void fun(string s) &#123; cout&lt;&lt;\"Base fun(string)\"&lt;&lt;endl; &#125; void fun(int a) &#123; cout&lt;&lt;\"Base fun(int)\"&lt;&lt;endl; &#125;//overload:两个fun函数在Base类的内部被重载 virtual int function()&#123;&#125; &#125;; class ClassA:public Base &#123; public: void display() &#123; cout&lt;&lt;\"ClassA display()\"&lt;&lt;endl; &#125;//override:基类中display为虚函数，且参数列表一直，故此处为重写 void fun(int a,int b) &#123; cout&lt;&lt;\"ClassA fun(int,int)\"&lt;&lt;endl; &#125;//redefining:fun函数在Base类中不为虚函数，故此处为重定义 void show() &#123; cout&lt;&lt;\"ClassA show()\"&lt;&lt;endl; &#125;//redefining:理由同上 int function(int a)&#123;&#125;//overload:注意这是重载而不是重写，因为参数列表不同，在编译时ClassA中其实还有个编译器自己偷偷加上的从Base继承来的int function()&#123;&#125;; &#125;; int main()&#123; ClassA a; Base *base=&amp;a; base-&gt;exec();//display()是ClassA的，因为覆盖了，show()是Base自己的 a.exec();//结果同上,子类对象可以直接调用父类中的成员函数 a.show();//show()是ClassA重定义的 base-&gt;fun(1);//fun()是Base自己的，因为直接从对象base调用 a.fun(1, 1);//fun()是ClassA重定义的 return 0; &#125; //输出结果ClassA display()Base show()ClassA display()Base show()//父类中的成员函数直接调用自身的Base show()ClassA show()Base fun(int)ClassA fun(int,int) 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual void f(float x)&#123; cout &lt;&lt; \"Base::f(float) \" &lt;&lt; x &lt;&lt; endl; &#125; void g(float x)&#123; cout &lt;&lt; \"Base::g(float) \" &lt;&lt; x &lt;&lt; endl; &#125; void h(float x)&#123; cout &lt;&lt; \"Base::h(float) \" &lt;&lt; x &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: virtual void f(float x)&#123; cout &lt;&lt; \"Derived::f(float) \" &lt;&lt; x &lt;&lt; endl; &#125; void g(int x)&#123; cout &lt;&lt; \"Derived::g(int) \" &lt;&lt; x &lt;&lt; endl; &#125; void h(float x)&#123; cout &lt;&lt; \"Derived::h(float) \" &lt;&lt; x &lt;&lt; endl; &#125;&#125;;int main(void)&#123; Derived d; Base *pb = &amp;d; Derived *pd = &amp;d; // Good : behavior depends solely on type of the object pb-&gt;f(3.14f); //Derived::f(float) 3.14 pd-&gt;f(3.14f); //Derived::f(float) 3.14 // Bad : behavior depends on type of the pointer pb-&gt;g(3.14f); //Base::g(float) 3.14 pd-&gt;g(3.14f); //Derived::g(int) 3 // Bad : behavior depends on type of the pointer pb-&gt;h(3.14f); //Base::h(float) 3.14 pd-&gt;h(3.14f); //Derived::h(float) 3.14 system(\"pause\"); return 0;&#125;//函数Derived::f(float)覆盖了Base::f(float)。//函数Derived::g(int)隐藏了Base::g(float)，而不是重载。//函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。 三者 作用域 有无virtual 函数名 参数列表 返回类型 重载 相同 可有可无 相同 不同 可同可不同 重写 不同 必有 相同 相同 相同（协变） 隐藏 不同 可有可无 相同 可同可不同 可同可不同 （二）bash shell bash是borne again shell的缩写，是shell的一种,Linux上默认采用的是bash。 Shell 是一个 C 语言编写的程序，一般都是放在/bin或者/user/bin目录下，当前 Linux 系统可用的 Shell 都记录在/etc/shells文件中。/etc/shells是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令查看它。 123$ cat /etc/shells #通过 cat 命令来查看当前 Linux 系统的可用 Shell$ echo $SHELL #查看当前Linux默认的shell，输出 SHELL 环境变量$ echo $BASH_VERSION #查看shell版本 设置取消alias：指南 PHP即“超文本预处理器”，是一种通用开源脚本语言。PHP是一种在服务器端执行的嵌入HTML文档的脚本语言。PHP 独特的语法混合了C、Java、Perl 以及 PHP 自创新的语法，它可以比 CGI 或者 Perl 更快速的执行动态网页，主要适用于Web开发领域。 （三）图 拓扑排序 一个有向无环图可以有一个或多个拓扑排序序列。 判断有向图是否有环的两种方法：(1)拓扑排序 (2)DFS 五大常用算法 分冶法 分治法所能解决的问题一般具有以下几个特征： 1) 该问题的规模缩小到一定的程度就可以容易地解决 2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。 3) 利用该问题分解出的子问题的解可以合并为该问题的解； 4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加； 第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用； 第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。 第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。可用分冶法求解的一些经典问题：二分查找；快速排序。 动态规划 (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 (3) 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。 递归常常用于分冶算法和动态规划算法中。 贪心算法 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。 从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的地求得更好的解。当达到算法中的某一步不能再继续前进时，算法停止。该算法存在问题： 不能保证求得的最后解是最佳的； 不能用来求最大或最小解问题； 只能求满足某些约束条件的可行解的范围。 贪心策略适用的前提是：局部最优策略能导致产生全局最优解。贪心算法和动态规划的区别： 贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解则不作保留；动态规划：全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有的局部最优解 。求一个问题的最优解相当于遍历所有的子集来找最优解，但是这样解随着解空间的维度成指数增长，动态规划其实就是一种遍历，但是他是带备忘录的遍历，我前面算到的子问题，到这儿我不在计算，我直接调用之前保存的值，这样就节省了大量的时间。 动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常自顶向下的方式进行。 根据以上两条可以知道，贪心不能保证求得的最后解是最佳的，一般复杂度低；而动态规划本质是穷举法，可以保证结果是最佳的，复杂度高。 回溯法 在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。 分支界限法 回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。 分支限界法的搜索策略是：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。 最小生成树-Prim算法和Kruskal算法 a. 最小生成树 生成树是连通图的\\最小连通子图**。所谓最小是指：若在树中任意增加一条边，则将出现一个回路；若去掉一条边，将会使之变成非连通图。按照该定义，n个顶点的连通网络的生成树有n个顶点，n-1条边。生成树各边的权值总和称为生成树的权，\\权最小的生成树称为最小生成树**。常见的构造最小生成树的方法有Prim算法和Kruskal算法。 b. Prim算法：选取与当前节点连接的权值最小边 c. Kruskal算法：所有边按权值从小到大排序，依次选取不使最小生成树存在回路的最小权值边 最短路径-Dijkstra算法和Floyd算法：具体代码参考 a. Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。注意该算法要求图中不存在负权边。 主要思想：通过“边”来松弛v1顶点到其余各个顶点的路程。 b. Floyd算法 Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd算法是一个经典的动态规划算法。 （四）IO库 当操作符改变流的格式状态时，通常改变后的状态对所以后续IO都生效。setw类似endl不改变输出流的内部状态，只决定下一个输出的大小。 操作符hex(0x)、oct(0)、dec只影响整型运算对象，浮点型的表示形式不受影响。使用nouppercase、noshoubase和dec来重置流状态。 showbase:当打印整型值时显示进制 ios::internal:数值的符号位在域宽内左对齐,数值右对齐,中间由填充字符填充 setfill()：允许一个字符替代默认的字符填补空白 setbase：将整数设置为b进制 cout.setf()的作用是通过设置格式标志来控制输出形式；cin&gt;&gt;noskipws设置cin读取空白符; cin&gt;&gt;skipws将cin恢复到默认状态，丢弃空白符 12345std::cout.setf ( std::ios::hex, std::ios::basefield );//set hex as the basefieldstd::cout.setf ( std::ios::showbase ); //activate showbasestd::cout &lt;&lt; 100 &lt;&lt; '\\n'; //输出0x100std::cout.unsetf ( std::ios::showbase ); //deactivate showbasestd::cout &lt;&lt; 100 &lt;&lt; '\\n'; //输出100 未格式化输出中is.get()将is的下一个字节作为int返回，头文件cstdio定义了一个名为EOF的const，用来检测返回的值是否是文件末尾，而不必记忆表示文件尾的实际数值。 1234int ch;//使用一个int,而不是char来保存get()的返回值,否则循环可能永远不会停止，循环也可能会在遇见'\\377'的字符提前终止（-1转换为一个singed char会得到'\\377'）//循环读取并输出输入中的所有数据while((ch=cin.get())!=EOF) cout.put(ch); istream和ostream类通常不支持随机访问，只有fstream、sstream支持。 （五）搜狗 STL : std::map/std::set std::unordered_map/std::unordered_set结构 std::map:红黑树，自动排序，稳定查找插入删除时间复杂度O(lgn)，空间占用高，因为红黑树每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间 std::unordered_map:哈希表，无序，快速查找插入删除，insert/find/erase的平均时间复杂度是O(1)，但是最坏复杂度是O(N)，相比于map空间占用更高，哈希表建立比较耗费时间，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表地址顺序从前往后依次遍历的 存储小对象，内存消耗依次是：vector &lt;&lt;map &lt;&lt;unordered_map;当存储的对象增大时，vector的优势变得并不明显。因为随着对象增大，用于存储对象的空间所占的比例越来越大。因此单从内存消耗的角度来看，当存储的是小对象时，vector占很大的优势。但是，当存储的对象本身大小增大时，它的优势变得不再那么明显。 hash表：（1）插入删除接近常量，大o表示法最快的方式（2）哈希表查询也快,但是底层存储结构是数组，一旦创建无法改变大小（3）哈希表无法用来有序遍历 顺序容器 vector:可变大小数组，支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢，vector插入insert删除erase时间复杂度均是O(n) deque:双端队列，支持快速随机访问。在头尾部位置插入/删除速度很快 list:双向链表。支持双向顺序访问，在链表任何位置进行插入/删除操作速度都很快 forward_list:单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快 array:固定大小数组，支持快速随机访问。不能添加或删除元素 string:与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快 除固定大小的array外，其他容器都提供高效、灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器大小。string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入和删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。而且添加一个元素有时可能还需要分配额外的存储空间。在这种情况下，每个元素必须都移动到新的存储空间中。 list和forward_list两个容器添加和删除操作都很快，但是不支持元素的随机访问，为了访问一个元素，只能遍历整个容器，与vector、deque、array相比，这两个容器的额外内存开销很大。 指针大小由当前CPU运行模式的寻址位数决定 32位处理器上32位操作系统的32位编译器，指针大小4字节。32位处理器上32位操作系统的16位编译器，指针大小2字节。32位处理器上16位操作系统的16位编译器，指针大小2字节。16位处理器上16位操作系统的16位编译器，指针大小2字节。 这从结果看起来指针的大小和编译器有关？？ 实际不是这样的，有这样的结果是因为以上几种情况，处理器当前运行模式的寻址位数是不一样的，如下： Intel 32位处理器32位运行模式，逻辑寻址位数32，指针也就是32位，即4个字节 Intel 32位处理器16位虚拟机运行模式，逻辑寻址位数16，指针也就是16位，即2个字节 编译器的作用是根据目标硬件（即CPU）的特性将源程序编译为可在该硬件上运行的目标文件。如果一个编译器支持某32位的CPU，那么它就可以将源程序编译为可以在该CPU上运行的目标文件。该源程序中指针大小也会被编译器根据该CPU的寻址位数（如32位）编译选择为4字节。 访问一个网页的全过程：参考 域名解析成IP地址（搜索浏览器自身缓存，没有的话向DNS服务器发出解析请求）； 与目的主机进行TCP连接（三次握手）； 发送与收取数据（浏览器与目的主机开始HTTP访问过程）； 与目的主机断开TCP连接（TCP四次挥手）； OSI模型：应用层（HTTP） 表示层（加密 SSL握手协议） 会话层（建立和维持会话，并能使会话获得同步 SSL记录协议） 传输层（TCP/UDP端到端 段Segment 数据报文） 网络层 (IP数据包Packet) 数据链路层(逻辑链路控制子层（LLC）媒体访问控制子层（MAC）数据帧Frame) 物理层(物理介质Bit) 消息（message）：是指起始点和目的地都在网络层以上（经常在应用层）的信息单元。 TCP/UDP五层模型：应用层 传输层 网络层 数据链路层 物理层 编程内存的基本构成（堆、存储区别） 1、内存 （1）静态内存（静态分配）：发生在程序编译和链接阶段，存在于程序的整个生命周期，内存大小固定，不占用CPU资源 .bss段：存放未初始化的全局变量和static静态变量 .data段（全局初始化区）：存放初始化的全局变量和static静态变量 常量存储区 .txt段（代码区）：存放程序代码 注意： ​ 代码区：存放函数体的二进制代码，虚函数存放在代码区。 ​ 常量存储区：常量字符串就是放在这里的。 程序结束后由系统释放。虚函数表在常量存储区。 ​ 函数指针指向Code区，是程序运行的指令代码，数据指针指向Data,Heap,Stack 区，是程序依赖以运行的各种数据。 ​ 在文件作用域声明inline函数默认为static存储类型,const常量默认为static存储， 如果加上extern，则为外部存储类型 （2）动态内存（动态分配）：发生在程序调入和执行阶段，根据程序的需要分配和释放，其大小可变，占用CPU资源 堆：链表结构，程序通过调用malloc和new分配，调用free和delete释放；堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。堆中的存储内容一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 栈：线性结构，由编译器自动分配与释放，速度较快，是一块连续的内存的区域，存储函数（包括main函数）的方法调用、函数参数、内部局部变量、返回地址和CPU系统提供的两个特殊的寄存器用于标识位于系统栈顶端的栈帧（(1)ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈地上面-个栈帧的栈顶。(2) EBP：基址指针寄存器(extended base pointer)-其内存放着一个指针，该指针永远指向系统栈展上面一个栈帧的底部），存储地址由高地址向低地址，栈顶的地址和栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，提示Stack Overflow，出现溢出现象。栈中的存储内容在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。函数退出时，其占用内存被收回；进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。 堆栈的区别： 1、管理方式不同（堆手动分配new/delete；栈编译器自动分配和释放） 2、空间大小不同（堆32位系统可达4G;栈Linux 10M,Windows 1M） 3、能否产生碎片不同（堆能；栈不能） 4、生长方向不同（堆从低地址到高地址；栈从高地址到低地址） 5、分配方式不同（堆动态分配；栈动静分配都可以，栈的动态使用alloc分配） 6、分配效率不同（堆效率低；栈效率高） 堆栈数据的写入跟读出不需要提供地址，而是根据写入的顺序决定读出的顺序。通用寄存器、主存储器、输入输出设备存储数据时均需要编址。 12345678910111213141516171819202122//main.cpp int a = 0; //a存储在全局初始化区 ，静态内存，0存储在常量区随程序结束而释放char *p1; //全局未初始化区 ，静态内存int* p=new int(4); //p存储在全局初始化区，静态内存，分配得来的4存储在堆区main() &#123; int b; //栈 ，编译时char s[] = \"abc\"; //栈 ，运行时赋值char *p2; // 栈 char *p3 = \"123456\"; //\"123456\\0\"在常量区（不同于数组数据可存储在数组里），编译时就确定下来，静态内存，p3在栈上。 static int c =0； //全局（静态）初始化区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); //分配得来的10和20字节的区域就在堆区。 strcpy(p1, \"123456\"); //\"123456\\0\"放在常量区，编译器可能会将它与p3所指向的\"123456\"优化成一个地方。 char* p = \"Hello World1\";char a[] = \"Hello World2\";p[2] = 'A';a[2] = 'A';char* p1 = \"Hello World1\"; //这个程序是有错误的，错误发生在p[2] = 'A'这行代码处，为什么呢，是变量p和变量数组a都存在于栈区的（任何临时变量都是处于栈区的，包括在main（）函数中定义的变量）。但是，数据“Hello World1”和数据“Hello World2”是存储于不同的区域的。因为数据“Hello World2”存在于数组中，所以，此数据存储于栈区，对它修改是没有任何问题的。因为指针变量p仅仅能够存储某个存储空间的地址，数据“Hello World1”为字符串常量，所以存储在静态存储区。虽然通过p[2]可以访问到静态存储区中的第三个数据单元，即字符‘l’所在的存储的单元。但是因为数据“Hello World1”为字符串常量，不可以改变，所以在程序运行时，会报告内存错误。并且，如果此时对p和p1输出的时候会发现p和p1里面保存的地址是完全相同的。换句话说，在数据区只保留一份相同的数据。 2、内存申请函数 malloc calloc realloc的区别 123456void* malloc(unsigned size);void* realloc(void* ptr, unsigned newsize); void* calloc(size_t numElements, size_t sizeOfElement); void * __cdecl alloca(size_t);free将malloc申请的内存最终需要通过该函数进行释放. sbrk则是增加数据段的大小; 都在stdlib.h函数库内，它们的返回值都是请求系统分配的地址,如果请求失败就返回NULL. (1)函数malloc() 在内存的动态存储区中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度，返回该区域的首地址。由于没有初始化内存的内容，所以调用malloc后一般调用函数memset来初始化这部分内存空间。 (2)函数calloc() 与malloc相似,参数sizeOfElement为申请地址的单位元素长度,numElements为元素个数，即在内存中申请numElements*sizeOfElement字节大小的连续地址空间，返回该区域的首地址。初始化所分配的内存空间，设置为0。 malloc() 函数和calloc ()函数的主要区别是前者不能初始化所分配的内存空间，而后者能。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是 0；反之，如果这部分内存空间曾经被分配、释放和重新分配，则其中可能遗留各种各样的数据。也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常运行，但经过一段时间后(内存空间已被重新分配)可能会出现问题。 calloc() 函数会将所分配的内存空间中的每一位都初始化为零，也就是说，如果你是为字符类型或整数类型的元素分配内存，那么这些元素将保证会被初始化为零；如果你是为指针类型的元素分配内存，那么这些元素通常(但无法保证)会被初始化为空指针；如果你是为实数类型的元素分配内存，那么这些元素可能(只在某些计算机中)会被初始化为浮点型的零。 (3)函数realloc()给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度.如果在该存储区后有足够的空间可供扩充，则可在原存储区位置上向高地址方向扩充，并返回传送给它的同样的指针值。如果在原存储区后没有足够的空间，则realloc分配另一个足够大的存储区，将现存的512个元素数组的内容复制到新分配的存储区。因为这种存储区可能会移动位置，所以不应当使用任何指针指在该区中。注意，realloc的最后一个参数是存储区的newsize(新长度)，不是新、旧长度之差。作为一个特例，若ptr是一个空指针，则realloc的功能与malloc相同，用于分配一个指定长度newsize的存储区。 （4）alloca()是在栈(stack)上申请空间的，而栈内存一般可以由编译器自动释放。既然是在栈内申请内存，这就决定了其固有的局限性。其一是不适用于那些比创建它们的函数生命周期更长的结构；其二是不具可移植性，而且在没有传统堆栈的机器上很难高效地实现。这是因为当它的返回值直接传入另一个函数时会带来问题。这就决定了alloca()不宜使用在需要广泛移植的程序中，这也是很多人不太提倡使用alloca()的一个原因。 malloc和free的操作原则 1) 配对使用，配对使用，避免内存泄漏和多重释放（C语言提供了malloc和free两个系统函数，完成对堆内存的申请和释放。而C++则提供了两个关键字new和delete）。 2) 尽量在同一层上使用，不要像上面那种，malloc在函数中，而free在函数外。最好在同一调用层上使用这两个函数。 3) malloc分配的内存一定要初始化。free后的指针一定要设置为NULL。 注意：new/delete是关键字，效率高于malloc和free。new/delete 主要是用在类对象的申请和释放。申请的时候会调用构造器完成初始化，释放的时候，会调用析构器完成内存清理。 3、new和malloc的区别 属性 new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持。 参数 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。 返回类型 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。 自定义类型 new做两件事：分配内存和调用类的构造函数，new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。 1234//为什么有了malloc还要设计newdelete：调用类的析构函数和释放内存。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。而malloc和free只是分配和释放内存。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。 重载 C++允许重载new/delete操作符，malloc不允许重载。 内存区域 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。 4、delete和free的区别 new/delete是关键字，而free/malloc是库函数，需要头文件支持free对应的是malloc；delete对应的是new；free用来释放malloc出来动态内存，delete用来释放new出来的动态内存空间。 无论释放几个空间大小，free只传递指针，多个对象时delete需加[]。数组的时候int* p=(int)malloc(10*sizeof(int)) 释放的时候 free(p)即可；这是因为编译器对malloc做了一些特殊的处理，以保证可以正确释放内存。而当int *p=new int[10]释放的时候应为delete []p，注意[]的作用说明释放的是一个数组的内存，如果delete p则只是释放的p[0]，其余9个int的内存没有释放；这是因为当指明为[]的时候，编译器实际上是做了一个循环来释放这个数组的所有内存。 在类和对象的时候会有很大区别。在使用malloc和free来处理动态内存的时候，仅仅是释放了这个对象所占的内存，而不会调用这个对象的析构函数；使用new和delete就可以既释放对象的内存的同时，调用这个对象的析构函数。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。 共同之处： 它们都是只把指针所指向的内存释放掉了，并没有把指针本身干掉。在free和delete之后，都需要把指向清理内存的指针置为空，即p=NULL，否则指针指向的内存空间虽然释放了，但是指针p的值还是记录的那块地址，该地址对应的内存是垃圾，p就成了“野指针”。同样会使人认为p是个合法的指针，如果程序较长，我们通常在使用一个指针前会检查p！=NULL，这样就起不到作用了。此时如果再释放p指向的空间，编译器就会报错，因为释放一个已经被释放过的空间是不合法的。而将其置为NULL之后再重复释放就不会产生问题，因为delete一个0指针是安全的。 指针和动态申请的内存空间总结如下： 1. 指针消亡了，并不表示它指示的动态内存会自动释放； 2. 动态内存释放掉了，如果这个内存是一个动态对象，则并不表示一定会调用这个对象的析构函数； 3. 动态内存释放掉了，并且调用了析构函数，并不表示指针会消亡或者自动变成了NULL。 PS: 在C++中，内存区分为6个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区、代码区； 在C中，C内存区分为5个区堆、栈、全局/静态存储区、常量存储区、代码区 为什么栈生长方向是从高地址到低地址？最大程度地共用剩余的地址空间，达到利用率的最大化。如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。 分配失败 new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。 内存泄漏 内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc确不可以。 快速排序 堆排序 给你100个数找出最大的前五十个 partition 时间复杂度O(n) 最大堆 时间复杂度O(nlgk) (海量数据) mutiset 时间复杂度O(n)空间复杂度O(n) 笔试题： 123456789101112131415161718192021222324252627282930提示：优先写源码，源码有难度可以写伪代码 或 思路。要求：c或c++, 尽量使得时间复杂度较低，写出完整代码。题目：查找元素element在非降序正整数数组a中的最左下标位置,数组大小为size.例子：元素2在数组a[1,1,2,2,4,6,21]的最左位置为2.int searchRange(int *a, int left,int right,int target)&#123;while(left&lt;right)&#123;int middle=(right-left)/2+left;if(a[middle]==target)&#123;middle-=1;while(a[middle]==target)midlle--;return middle+1;&#125;if(a[middle]&lt;target)left=middle+1;elseright=middle-1;&#125;return left;&#125;int find_pos(int* a, int size, int element)&#123;if(size==0)return -1; int leftIndex=searchBoundEqual(a,0,size-1,element); if(leftIndex==size||a[leftIndex]!=target) return -1; return leftIndex;&#125;std::find(a,a+size,target); （六）手写代码一个数组中有多个整数， 其中有两个重复的数字，如何找出来，考虑一下时间复杂度和空间复杂度 给两个字符串A和B，找出A对于B的最长前缀。 单链表逆序 一个链表的连续区间和最大值，及其对应区 数组中，连续和最大的区间 判断一个链表是否有环，并确定环的位置，如何确定两个链表是否有相同的部分 写个小程序，一个数组，长100，里边乱序分布数字1-100，在数组中随机挑选一个位置的数字，将其替换为-1，如何判断，被替换掉的数字是多少？ 跳台阶，一次跳1个，也可以跳2个，问，n个台阶有多少种跳法 dfs bfs dp迷宫 最小圆覆盖 1）任意选取距离最远两点p1、p2，以p1p2做直径画圆； 2）如果所有点都在圆内，则该圆即为包括所有点的最小圆；否则选取圆外一点距离圆心最远点pi,寻找覆盖pi和集合Di-1的最小圆Di=MiniDiskWithPoints({p1，p2，p3......pi-1}，pi)，循环第（2）步直到Di包括所有点，即得到最小包围圆。 123456789101112131415161718Function MiniDiskWithPoints（P，q）Input：由平面上n个点构成的一个集合P，以及另外一个点qOutput：在满足“边界穿过q”的前提下，P的最小包围圆 1.令D1为对应于&#123;p1，q&#125;的最小包围圆 2.for j ← 2 to n 3. do if pj ∈Dj-1 4. then Dj ← Dj-1 5. else Dj ← MiniDiskWithPoints&#123;&#123;p1，p2,p3......pj-1&#125;，pj，pi&#125; 6.return DnFunction MiniDiskWithPoints（P，q1，q2）Input：由平面上n个点构成的一个集合P，以及另外两个点q1，q2Output：在满足“边界穿过q1，q2”的前提下，P的最小包围圆1. 令D0为对应于q1，q2的最小包围圆2. for k ← 1 to n3. do if pk∈Dk-14. then Dk ← Dk-15. else Dk ← q1，q2和pk确定的圆6. return Dn 给定一个无序数组，求这个数组变为有序后相邻元素之差的最大值是多少，要求时间复杂度是O(n) 方法一：排序，计算。时间复杂度O(nlgn)，空间复杂度O(1) 方法二：std::multiset，计算。时间复杂度O(n),空间复杂度O(n) 方法三：桶排序。时间复杂度O(n),空间复杂度O(n) 算法题给定一个长字符串zesfjjk和一个短字符串xsfjx，求短字符串在长字符串中出现的最长部分是什么？sfj 最长公共子字符串 （七）SAP linux命令 查找 vi 保存 修改权限 C语言和c++的区别 c++兼容c。区块（blocks）、语句（statements）、预处理器（preprocessors）、内置数据类型（build-in data types）、数组（arrays）、指针（pointers）等统统来源于c。 c仅支持面向过程，c++还支持面向对象：包含封装、继承、多态三大特性和虚函数、虚函数表指针、虚基类表指针等。 c++包含泛型编程、模板元编程。 c++包含STL。 （八）进程间的通信方式（IPC,inter-Process Communication）同一主机中两个进程间的通信由操作系统决定，不同主机间的通信进程通过网络交换报文进行。 信号：用于通知进程某个事件已经发生 管道：读写操作符合先进先出原则，对于两端的进程而言就是文件，向管道中写入数据时,linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。 无名管道pipe:半双工的通信方式，数据单向流动，只能在具有亲缘关系的进程间使用，从结构上看，无名管道没有文件路径名，不占用文件目录项，因此文件目录结构中的链表不适用于这种文件，它只是存在于打开文件结构中的一个临时文件，依附于进程临时存在。 命名管道FIFO:半双工，数据单向流动，允许无亲缘关系进程间的通信，FIFO是一种永久性的机制，它具有普通的UNIX系统文件名。在系统下可利用MKNOD命令建立永久的管道，除非刻意删除它，否则它将一直保持在系统中。 联系： 1) 通信数据只存在于内存缓冲页面中； 2) 都是半双工通信； 区别： 无名管道是无名的，有名管道是有名的； 无名管道只能用于父子进程或兄弟进程之间的通信，而有名管道可用于任意两进程之间通信； 无名管道是无形的，即无名管道的 inode 结构不是在磁盘上存储的，而是临时生成的，而有名管道的 inode 结点在磁盘上。 消息队列：消息的链表存放在内核中并由消息队列标识符标识，克服了信号传递信息少，管道只能承载无格式字节流以及缓冲器大小受限等缺点，但只有在内核重启时才能删除一个消息队列，内核重启也就是系统重启。 共享内存：最快的IPC方式，映射一段能被其他进程所访问的内存。往往与其他通信机制如信号两两配合使用，来实现进程间的同步和通信。 信号量Semaphore:信号量是一个计数器，可以用来控制多个进程对共享资源的访问。常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 套接字Socket:套接字也是一种进程间通信机制，包括IPC 套接字（即 Unix 套接字）给予进程在相同设备（主机）上基于通道的通信能力；而网络套接字给予进程运行在不同主机的能力，因此也带来了网络通信的能力。IPC 套接字依赖于本地系统内核的支持来进行通信。网络套接字需要底层协议的支持，例如 TCP（传输控制协议）或 UDP（用户数据报协议），包括流套接字（TCP/IP）和数据报套接字（UDP/IP），利用三元组（ip地址，协议，端口）构成套接字；传输层实现端到端的通信，传输层连接的端点叫做套接字。 进程和线程 进程识别信息：表示哪台主机上的哪一个进程 主机名称或地址：网络中的哪一个主机。因特网中，用IP地址标识（32位，全球唯一）。 进程的标识：主机中的哪一个进程。因特网中，采用端口号标识。创建一个新的网络应用程序时，必须分配一个新的端口号。不得重复。 fork后操作系统会复制一个与父进程完全相同的子进程，两个进程共享代码空间，但数据空间相互独立，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别作不同的工作，也就是分岔了。这也是fork为什么叫fork的原因至于那一个最先运行，可能与操作系统（调度算法）有关，而且这个问题在实际应用中并不重要，如果需要父子进程协同，可以通过原语的办法解决。 fork（）与vfock（）都是创建一个进程，那他们有什么区别呢？总结有以下三点区别： fork （）：子进程拷贝父进程的数据段，代码段vfork （ ）：子进程与父进程共享数据段，子进程中对父进程变量的修改，会影响父进程 fork （）父子进程的执行次序不确定vfork 保证子进程先运行，在调用exec() 或_exit() 之前与父进程数据是共享的,在它调用exec()或_exit()之后父进程才可能被调度运行。 若vfork （）调用exec 或_exit() 之前子进程依赖于父进程的进一步动作，会导致死锁。 进程和线程的区别 ​ （1）进程是资源分配和调度的一个独立单元，而线程是CPU调度和分派的基本单元​ （2）一个进程至少包括一个线程，并且同一个进程的所有线程共享整个进程的资源，因此线程执行时一般都要进行同步和互斥​ （3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束​ （4）线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的​ （5）进程间通信IPC需要特别的方法，线程间可以直接读写进程数据段（如全局变量）来进行通信。 线程有什么是共享的什么是私有的 线程共享的环境包括： 1.进程代码段 2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯) 3.进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。 线程独立的资源包括： 1.线程ID 2.寄存器组的值 由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。 3.线程的堆栈 堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。 4.线程的错误返回码 由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。 5.线程的信号屏蔽码 6.线程的优先级 注：线程有自己的私有属性线程控制块TCB，进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志。 线程同步 用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。 内核模式下的方法有：事件，信号量，互斥量。 1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。2、互斥量:为协调共同对一个共享资源的单独访问而设计的。3、信号量:为控制一个具有有限数量用户资源而设计。4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。 进程的几种状态？ （1）run（运行状态）：正在运行的进程或在等待队列中等待的进程，等待的进程只要一得到cpu就可以运行 （2）Sleep（可中断休眠状态）：相当于阻塞或在等待的状态 （3）D（不可中断休眠状态）：在磁盘上的进程 （4）T（停止状态）：这种状态无法直观的看见，因为是进程停止后就释放了资源，所以不会留在linux中 （5）Z（僵尸状态）：子进程先于父进程结束，但父进程没有调用wait或waitpid来回收子进程的资源，所以子进程就成了僵尸进程，如果父进程结束后仍然没有回收子进程的资源，那么1号进程将回收 线程间通信：由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）。 进程间的通信则不同，它的数据空间的独立性决定了它的通信相对比较复杂，需要通过操作系统。以前进程间的通信只能是单机版的，现在操作系统都继承了基于套接字（socket）的进程间的通信机制。这样进程间的通信就不局限于单台计算机了，也可以实现不同操作系统间的网络通信，eg.windows和Linux操作系统通过Socket进行进程间通信。 windows进程通信 标准的Windows进程间通信方法有三种：匿名管道、命名管道（又叫FIFO，命名管道可以控制读消息的长度，一个命名管道可以有多个实例，具体通信还是一对一）、邮槽（MailSlot）。共享内存也可用于windows进程通信，但因为其实是Windows“内存映射文件”的一个特殊用法，所以不算作标准的windows进程间通信方法。 对比点 匿名管道 命名管道 邮槽 共享内存 消息格式 字符 二进制 数据包 - 工作模式 半双工 全双工 单向 双向 访问模式 只能在一台机器上 可以跨网络 可以跨网络 只能在一台机器上 通信模式 一对一，父子进程用 一对多，不同进程均可用 广播机制 - windows命名管道和Linux命名管道的区别 对比点 Linux命名管道 Windows命名管道 备注 消息格式 字节流 二进制 windows更牛 工作模式 半双工 全双工 windows更牛 访问模式 只能在一台机器上 可以跨网络 windows更牛 windows线程通信 windows下，一个典型的线程拥有自己的堆栈、寄存器（包括程序计数器PC，用于指向下一条应该执行的指令在内存中的位置），而代码段、数据段、打开文件这些进程级资源是同一进程内多个线程所共享的。因此同一进程的不同线程可以很方便的通过全局变量（数据段）进行通信，使用多线程相对于多进程来说有很多优点： ① 无需跨进程边界； ② 程序逻辑和控制方式简单； ③ 所有线程可以直接共享内存和变量等； ④ 线程方式消耗的总资源比进程方式好； windows多线程通信的方法主要有三种： 1.全局变量 由于同一进程下的线程之间共享数据空间。当需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，来告诉编译器这个全局变量是“易变”（更直接的讲是“直接存取原始内存地址”，更明确的说是不要编辑器去读缓存中的数据，而是直接从内存中获取变量的值）的，让编译器不要对这个变量进行优化。 2.Message消息机制常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。 3.CEvent对象 CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。 Linux线程通信 线程间无需特别的手段进行通信，因为线程间可以共享数据结构，也就是一个全局变量可以被两个线程同时使用。不过要注意的是线程间需要做好同步，一般用mutex。 死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？ （1）相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态 （2）系统资源不足、相互竞争资源、请求资源顺序不当 （3）互斥、不可剥夺、循环等待、请求与保持 （4）因为互斥是不可改变的，所以只能破坏其他三个条件中的一个来解除死锁，方法： 破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中。 破坏”请求与保持条件“：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。 破坏“循环等待”条件：资源有序分配（将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程） （九）Windows内存管理方式：段存储、页存储、段页存储 什么是虚拟内存？ 虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还可以通过覆盖或者把处于不活动状态的程序以及它们的数据全部交换到外部磁盘存储器上临时存储。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。 对于32位的Linux操作系统，系统为每个进程分配4G的虚拟内存。 虚拟内存中，允许将一个作业分多次调入内存。釆用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式： 请求分页存储管理。 请求分段存储管理。 请求段页式存储管理。 不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面： 一定容量的内存和外存。 页表机制（或段表机制），作为主要的数据结构。 中断机制，当用户程序要访问的部分尚未调入内存，则产生中断。 地址变换机制，逻辑地址到物理地址的变换。 一致性哈希？渐进性哈希？ 一致性哈希是一种特殊的哈希算法，目的是解决分布式缓存的问题。在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表( Distributed Hash Table，DHT) 中存在的动态伸缩等问题。 首先，对存储节点的哈希值进行计算，其将存储空间抽象为一个环，将存储节点配置到环上。环上所有的节点都有一个值。其次，对数据进行哈希计算，按顺时针方向将其映射到离其最近的节点上去。当有节点出现故障离线时，按照算法的映射方法，受影响的仅仅为环上故障节点开始逆时针方向至下一个节点之间区间的数据对象，而这些对象本身就是映射到故障节点之上的。当有节点增加时，比如，在节点A和B之间重新添加一个节点H，受影响的也仅仅是节点H逆时针遍历直到B之间的数据对象，将这些重新映射到H上即可，因此，当有节点出现变动时，不会使得整个存储空间上的数据都进行重新映射，解决了简单哈希算法增删节点，重新映射所有数据带来的效率低下的问题。 渐进性哈希 当hash表满员时（或负载因子高于阈值时）会进行rehash,也就是重新调整空间大小，并拷贝原来的数据。这里rehash就是优化效率的关键。例如假设有1w个元素，rehash时要拷贝1w元素到新的空间，这样势必会成为很大的负担。 redis的数据库使用字典来作为底层实现的，对数据库的增删查改操作也是构建在对字典的操作之上。redis的字典使用hash表作为底层实现。 redis作为一个广泛使用的内存数据库，时间和空间效率都是至关重要的。（redis的根本就是一个大的hashmap，所以对hashmap的优化十分重视） redis采用渐进式rehash来解决这个问题。 何为渐进式rehash？就是把拷贝节点数据的过程平摊到后续的操作中，而不是一次性拷贝。所谓平摊到后续的操作中，就是对节点操作，例如再次插入，查找，删除，修改时都会进行拷贝。 友元函数注意事项 1）必须在类的说明中说明友元函数，说明时以关键字friend开头，后跟友元函数的函数原型，友元函数的说明可以出现在类的任何地方，包括在private和public部分；2）注意友元函数不是类的成员函数，所以友元函数的实现和普通函数一样，在实现时不用”::”指示属于哪个类，只有成员函数才使用”::”作用域符号；3）友元函数不能直接访问类的成员，只能访问对象成员，4）友元函数可以访问对象的私有成员，但普通函数不行；5）调用友元函数时，在实际参数中需要指出要访问的对象，6）友元的声明只能出现在类定义的内部（最好在类定义开始或者结束前的位置集中声明友元），仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，必须在友元声明之外再转名对函数进行一次声明。每个类负责控制自己的友元类或友元函数，友元关系不存在传递性。类与类之间的友元关系不能继承. 模板 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。 模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。 （十）计算机网络 HTTP 与 HTTPS 区别 http是超文本传输协议，信息是明文传输，未加密；https则是具有安全性的ssl加密传输协议。 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 根证书，一般免费证书较少，因而需要一定费用。 HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。 http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。 HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。 客户端在使用HTTPS方式与Web服务器通信步骤 （1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。 （2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。 （3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。 （4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 （5）Web服务器利用自己的私钥解密出会话密钥。 （6）Web服务器利用会话密钥加密与客户端之间的通信。 怎么理解http协议的无连接无状态 HTTP协议又称超文本传输协议；是OSI模型中的第七层应用程中协议；具有以下特点： 1、支持客户/服务器模式; 2、简单快速; 3、灵活; 4、无连接; 5、无状态； 无连接：指的是每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接；这种方式有利于节省传输时间；然后随着互联网的发展，一台服务器同一时间处理的请求越来越多，如果依然采用原来的方式，将会在建立和断开连接上花费大部分时间。为了避免这一劣势，针对http无连接，人们设计了非持久连接和持久连接。实际上关于http协议非持久连接和持久连接是针对tcp协议的。 非持久连接：请求一个HTTP请求/响应需要的总时间为客户端发出建立连接和发生请求报文+服务器传输HTML文件的时间。 持久连接：服务器在发送响应后，保持该TCP连接打开。在相同的客户机与服务器之间的后续请求和响应报文通过相同的连接进行传送。不需要再次建立tcp连接 ，但是由于所有的连接都是串行的，当某一个请求阻塞时就会导致同一条连接的后续请求被阻塞。为了解决这一问题：提出了pipellining的概念；客户端发起一次请求时不必等待响应便直接发起第二个请求；服务端按照请求的顺序一次返回结果；SPDY和HTTP/2:multiplexing：多路复用技术出现；能够让多个请求和响应的传输完全混杂在一起进行；通过streamID来互相区别； PS:HTTP借助于底层的TCP虚拟连接，HTTP协议本身无需连接；就好比A和B打电话，A和B是借助于底层的简化先连接交换信息；但是A和B本身无需连接； 无状态：是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。言外之意是说http协议没法保存客户机信息，也就没法区分每次请求的不同之处。关于http无状态阻碍了交互式应用程序的实现。比如记录用户浏览哪些网页、判断用户是否拥有权限访问等。于是，两种用于保持HTTP状态的技术就应运而生了，一个是Cookie，而另一个则是Session。 cookie和session的区别 1、Cookie和Session都是会话技术，Session是运行在服务器端，用来跟踪用户的状态，数据可以保存在集群、数据库、文件中；Cookie是运行在客户端，用来记录用户的一些信息，也是实现Session的一种方式。 2、Cookie有大小限制以及浏览器存储cookie的个数也有限制，Session是没有大小限制和存储个数与服务器的内存大小有关。 3、Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。 4、有效期不同。cookie长期有效；Session有效时间短，假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。 共享session 基于数据库的Session共享 基于NFS共享文件系统 基于memcached 的session，如何保证 memcached 本身的高可用性？ 基于cookie 进行session共享 基于resin/tomcat web容器本身的session复制机制 基于TT/Redis 或 jbosscache 进行 session 共享。 http状态码分类 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务端错误，服务器在处理请求的过程中发生了错误 200，请求成功 301，资源（网页等）被永久转移到其它URL 302，资源临时移动 403，forbidden，服务器理解请求客户端的请求，但是拒绝执行此请求。请求资源被拒绝，通常原因是服务器上某些文件或目录设置了权限，客户端权限不够 404，not found，用户输入错误的链接，该链接指向的网页不存在。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 500，internal server error 服务器内部错误（比如浏览器代理除了问题，ip，端口不对等）该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。 502，Bad Gateway，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503，服务器超载或停机维护 504，Gateway Timeout网关超时服务器作为网关或代理，未及时从上游服务器接收请求 http 客户端发送一个HTTP请求到服务器的请求消息包括请求行（request line）、请求头部（header）、空行和请求数据四个部分 HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文 URL由4部分组成：协议、主机、端口、路径;一般语法格式为(带方括号[]的为可选项,参考)： protocol :// hostname[:port] / path / [;parameters] [?query] [#fragment] get和post的区别：参考 它们的本质都是 TCP 链接，并无区别，在网络环境好的情况下发送时间也几乎一样。但是由于 HTTP 的规定以及浏览器/服务器的限制，导致它们在应用过程中可能会有所不同。 get post 后退按钮/刷新 无害 数据会被重新提交（浏览器会告知用户数据会被重新提交） 书签 可收藏为书签 不可收藏为书签 缓存 浏览器自动缓存 不能被缓存 历史 参数能保留在浏览器历史中 参数不会保存在浏览器历史中 对数据长度的限制 数据在URL中，因此URL长度受限（最大长度2048个字符，不同浏览器和服务器限制不同） 没有限制 对数据类型的限制 只允许ASCLL字符 没有限制，也允许二进制数据。 安全性 安全性较差，因为所发送数据时URL的一部分，发送密码或者其他敏感信息时绝不要使用get 更安全，因为参数不会被保存在浏览历史或web服务器 可见性 数据在URL中对所有人可见 数据不会显示在URL中 TCP数据包 一个，把头部和数据一并发出去 两个，浏览器先发送请求行和请求头，服务器响应100 continue,浏览器再发送data，服务器响应200 ok (返回数据) TCP和UDP的区别 TCP 面向连接，建立连接进行三次握手，一对一传输；UDP 面向无连接，不会建立连接，一对一、一对多、多对一传输，可以应用于广播 UDP程序结构较简单，包头8字节；TCP包头20字节，还有一个可选项长度不确定 TCP 是面向字节流的，UDP 是基于数据报的 TCP 保证数据正确性，有流量控制拥塞控制累计确认和超时重传机制；UDP 可能丢包，没有流量控制和拥塞控制 TCP 保证数据顺序，UDP 不保证 （十一）百度 c++中构造函数或析构函数定义为protected 通常将拷贝构造函数和operator=(赋值操作符重载)声明成private，但是没有实现体。这个的目的是禁止一个类的外部用户对这个类的对象进行复制动作。 c++设计模式：参考 （1）工厂模式 简单工厂模式：switch 工厂方法模式：一个工厂抽象接口和多个具体生成对象的工厂。比简单工厂模式多的一点优点就是遵循了开放-封闭原则，使得模式的灵活性更强 抽象工厂模式：客户端要使用时必须知道是哪一个工厂并且是哪一组的产品抽象类。每一个工厂子类负责产生一族产品，而子类的一种方法产生一种类型的产品。在客户端看来只有AbstractProductA和AbstractProductB两种产品，使用的时候也是直接使用这两种产品。而通过工厂来识别是属于哪一族产品。 工厂模式和简单工厂模式要求产品子类必须要是同一类型的，拥有共同的方法，这就限制了产品子类的扩展。于是为了更加方便的扩展，抽象工厂模式就将同一类的产品子类归为一类，让他们继承同一个抽象子类，我们可以把他们一起视作一组，然后好几组产品构成一族。 （2）策略模式 直接通过参数指定，传入一个特定算法的指针（暴露了算法） 直接通过参数指定，只不过不是传入指针，而是一个标签（switch和简单工厂结合） 模板实现 （3）适配器模式：系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要适应于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。 （4）单例模式：由于构造函数是私有的，因此无法通过构造函数实例化，可以通过调用静态成员函数GetInstance在类内部构造实例。用户访问唯一实例的方法只有GetInstance()成员函数。GetInstance()使用懒惰初始化，也就是说它的返回值是当这个函数首次被访问时被创建的。这是一种防弹设计——所有GetInstance()之后的调用都返回相同实例的指针。单例模式通过类本身来管理其唯一实例，唯一的实例是类的一个普通对象，但设计这个类时，让它只能创建一个实例并提供对此实例的全局访问。唯一实例类Singleton在静态成员函数中隐藏创建实例的操作。习惯上把这个成员函数叫做Instance()，它的返回值是唯一实例的指针。参考 （5）原型模式：拷贝构造函数 （6）模板方法模式：定义操作的骨架，依次调用子类实现的函数 （7）建造者模式（直接传入特定类型对象作为参数） 最长回文子串 数组中未出现最小正整数 内存管理 udp为什么会丢包？如何减少丢包？ 1、接收端处理时间过长（接收端采用多线程回调机制或尽量简化处理数据包到重新回到监听状态的中间过程） 2、发送包过大，超过接受者缓存（使用setsocketopt修改接收端缓冲区大小） 3、发送包的频率过高（发送端sleep） 4、网络不稳定或拥塞（改善网络环境或实现丢包处理） TCP/UDP传输的应用 TCP流量控制 拥塞机制：慢启动 拥塞避免 快重传 快恢复 非递归快排 封装、继承、多态的目的 封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用，派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性。 最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种方法的目的了。 磁盘的随机读写和顺序读写 顺序读写：文件指针只能从头移动到尾，SAS机械硬盘主要是看顺序读写性能 随机读写：文件指针可以根据需要随意移动，寻道时间和旋转延迟，SSD固态盘主要看随机读写性能 对称密钥加密和非对称密钥加密的区别 对称密钥：又称私钥加密，即信息的发送方和接收方用一个密钥去加密和解密数据。它的最大优势是加/解密速度快，适合于对大数据量进行加密，但密钥管理困难，安全性低。 非对称密钥加密系统：又称公钥密钥加密，它需要使用一对密钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。公钥机制灵活，安全性高，但加密和解密速度却比对称密钥加密慢得多。 垃圾回收机制 Linux操作系统的主要组成部分：内核，shell,文件系统，应用程序 文件系统索引结构B+树 IO cache 用法 Buffer（缓冲区）是系统两端处理速度平衡（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到流量整形的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。Cache（缓存）则是系统两端处理速度不匹配时的一种折衷策略。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。 常规文件系统操作（调用read/fread等类函数）中，函数的调用过程： 进程发起读文件请求。 内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。 inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。 如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。 bitmap 磁盘一亿个数查询target，内存4g linux创建管道命令 1mkfifo [options] NAME #创建有名管道 git命令行 12git branch &lt;name&gt; #创建分支git merge &lt;name&gt; #合并分支 动态链接库和静态链接库的区别:参考 （一）静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，lib中的指令都全部被直接包含在最终生成的exe文件中了（链接器从静态链接库获取所有被引用函数的二进制代码和库一起放到可执行文件中）。但是若使用dll动态链接库，该dll不必被包含在最终的exe文件中，它允许可执行模块（dll或exe文件）仅包含在运行时定位dll函数的可执行代码的所需信息，执行文件执行时可以动态地引用和卸载这个与exe独立的dll文件。如果某个目标文件需要的函数在参与链接的目标文件中找不到的话，链接器就报错了。目标文件中有两个重要的接口来提供这些信息：一个是符号表，另外一个是重定位表。 （二）静态链接库不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。 （三）动态链接库基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，当程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件,也就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果在当前工程中有多处对dll文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但是如果有多处对lib文件中同一个函数的调用，那么执行时，该函数将在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝。 静态链接的优点 (1) 代码装载速度快，执行速度略比动态链接库快，在程序发布的时候就不需要的依赖库（不需要带着库一块发布），程序可以独立执行； (2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 动态链接的优点 (1) DLL 节省内存，减少页面交换，节省磁盘空间，多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝； (2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性； (3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数； (4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。 静态链接和动态链接的不足之处 (1) 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；如果静态库有更新的话，所有可执行文件都得重新链接才能用上新的静态库，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统死掉 (2) 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。但是由于是运行时加载，可能会影响程序的前期执行性能。 从源程序到执行程序的过程:参考 预编译 编译：把预编译之后生成的xxx.i或xxx.ii文件，进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成和优化，生成相应的汇编代码文件。 汇编：将汇编代码转变成机器可以执行的指令(机器码文件)，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)，还有一个问题——变量a和数组arr的地址还没有确定。 链接：静态链接和动态链接，生成可执行文件 mysql怎么创建索引 （索引是一种高效获取数据库数据的数据结构） ？为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引？ MySQL 提供了三种创建索引的方法： （1）使用 CREATE INDEX 语句 （2）ALTER TABLE （3）CREATE TABLE 为什么B+树（有序数组+平衡多叉树）比B树（有序数组链表+平衡多叉树）更适合文件索引系统？扩展 （1）B+树空间利用率更高，因为B+树的内部节点只是作为索引使用，而不像B树那样每个节点都需要存储硬盘指针。 （2）增删文件（节点）时，效率更高，因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。 （十二）网易 海量数据找到最小的k个数 123456789101112131415161718//最大堆，时间复杂度O(nlgk),空间复杂度O(k)typedef multiset&lt;int,greater&lt;int&gt;&gt; inSet;void getLeastNumbers(const vector&lt;int&gt;&amp;data,inSet&amp; leastNumbers,int k)&#123; if(k&lt;1 || data.size()&lt;k) return; vector&lt;itn&gt;::const_iterator iter=data.begin(); for(;iter!=data.end();++iter)&#123; if(leastNumbers.size()&lt;k) leastNumbers.insert(*iter); else&#123; if(*iter&lt;*leastNumbers.begin())&#123; leastNumbers.erase(leastNumbers.begin()); leastNumbers.insert(*iter); &#125; &#125; &#125;&#125;//当我们可以修改输入数组时，可用partition函数，时间复杂度为O(n) 重载一个运算符原则： 1.不能改变运算符的初始意义。 2.不能改变运算符的参数数目。如重载运算符+时只用一个操作数是错误的。 3.运算符函数不能包括缺省的参数。 4.绝大部分C++运算符都可以重载，除以下的例外： . :: .* ? 5．除赋值运算符外，其它运算符函数都可以由派生类继承。 6.运算符重载不改变运算符的优先级和结合性，也不改变运算符的语法结构，即单目、双目运算符只能重载为单目、双目运算符。 7.运算符的重载实际上是函数的重载。编译程序对运算符重载的选择，遵循函数重载的选择原则。当遇到不很明显的运算符时，编译程序将去寻找参数匹配的运算符函数。 8.运算符重载可使程序更简洁，使表达式更直观，增强可读性。但使用不宜过多。 9.重载运算符含义必须清楚. 重载的形式:成员函数形式 和 友元函数形式 (1) 一般情况下，单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数。 (2) 以下双目运算符不能重载为类的友元函数：=、()、[]、-&gt;。 (3) 类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。 (4) 若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好。 (5) 若运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则只能选用友元函数。 (6) 当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一 个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部 类型的对象，该运算符函数必须作为一个友元函数来实现。 (7) 当需要重载运算符具有可交换性时，选择重载为友元函数。 HTTP1.0和HTTP1.1的区别 HTTP1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。 在 HTTP1.1 中,一个连接可用于一次或多次请求/响应交换,尽管连接可能由于各种原因被关闭。HTTP 1.1只能持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延时。 二叉树的高度和节点数 具有n个结点的完全二叉树的高度为log(n+1)向上取整，或者(logn)向下取整+1 高度为h完全二叉树最后一层有n+1-2^(h-1)个结点;完全二叉树第k层至多有2^（k-1）个结点满二叉树深度为h，则有2^h-1个结点；第k层的节点数目为2^（k-1） （十三）腾讯 static变量？ static函数为什么只能用static变量？ （1）静态成员变量： 静态成员变量属于整个类所有，生命期不依赖于任何对象，为程序的生命周期 可以通过类名直接访问公有静态成员变量，也可以通过对象名访问公有静态成员变量 静态成员变量是静态存储的，所以必须对它进行初始化 静态成员变量在类外单独分配空间 静态成员变量在程序内部位于全局/静态存储区 （2）静态成员函数: 类内使用static修饰的特殊成员函数 属于整个类所有，没有this指针（这就是它仅能访问类的静态数据和静态成员函数的原因） 只能直接访问静态成员变量和静态成员函数，调用这个函数不会访问或者修改任何对象非static数据成员 可以通过类名直接访问类的公有静态成员函数，也可以通过对象名访问类的公有静态成员函数 不能将静态成员函数定义为虚函数 其实很好理解，类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，函数地址类型是个“nonmember 函数指针”。static 并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。静态数据成员在&lt;定义或说明&gt;时前面加关键字 static。 静态成员初始化与一般数据成员初始化不同： 初始化在类体外进行，而前面不加 static，以免与一般静态变量或对象相混淆；初始化时不加该成员的访问权限控制符 private、public；初始化时使用作用域运算符来标明它所属类；所以我们得出静态数据成员初始化的格式： 1&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;&#x3D;&lt;值&gt; (9) 为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。 设置静态成员的目的，是为了将和某些类紧密相关的全局变量和全局函数写到类里面，形式上成为一个整体。使用 sizeof 运算符计算对象所占用的存储空间时，不会将静态成员变量计算在内。对上面的 CRectangle 类来说，sizeof(CRectangle) 的值是 8。 12345678class CRectangle&#123;private: int w,h; static int nTotalArea; //静态成员变量 static int nTotalNumber; //静态成员变量public: static void PrintTotal (); //静态成员函数&#125;; 主键索引和非主键索引的区别？ 非主键索引的叶子节点存放的是主键的值，而主键索引的叶子节点存放的是整行数据，其中非主键索引也被称为二级索引，而主键索引也被称为聚簇索引。 孤儿进程 僵尸进程 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。假如它的父进程没有安装SIGCHLD信号处理函数来处理子进程（也即使wait或者waitpid等待儿子结束），又没有显示忽略该信号，那子进程就会一直保持僵尸状态。只有在父进程结束之后，才由init进程接管子进程，为他收尸（好凄惨啊），这个时候才能说子进程才真正的消失在Linux内核中。 僵尸进程的避免 ⒈父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。 ⒉ 如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler，因为子进程结束后， 父进程会收到该信号，可以在handler中调用wait回收。 ⒊ 如果父进程不关心子进程什么时候结束，那么可以用signal（SIGCHLD,SIG_IGN） 通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收， 并不再给父进程发送信号。 ⒋ 还有一些技巧，就是fork两次，父进程fork一个子进程，然后继续工作，子进程fork一 个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做。 链表的选择排序 二叉树的最长路径和 数独 迷宫 printf函数是从右向左计算入栈，输出顺序从左往右；函数调用参数的时候，从右往左依次执行所有会改变变量数值的式子，遇到后置自增的式子则直接把此时的变量代入，得到该自增式的值。全部执行完成后再从左往右依次把改变后的变量值代入各个除后置自增式以外的所有式子，此时这些式子的值是最终要代入函数的参数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//// Created by anranzhai on 2020/4/17.//#include&lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int i = 3, j = 5; printf(\"%d %d\\n\", (i++) - (--j), j = (i += 2)); printf(\"%d %d\\n\", i, j); int k=1; printf(\"%d %d\\n\",(k++,k++),k); int l=1; printf(\"%d %d\\n\",l,(l++,l++)); int a = 1; printf(\"%d %d %d\\n\", a=11, a++, a++); a = 1; printf(\"%d %d %d\\n\", a, a + 1, a = 3); a = 1; printf(\"%d %d %d\\n\", a++, a++, a = 3); a = 1; printf(\"%d %d %d\\n\", a = 11, a = 22, a = 33); int b=1; printf(\"%d %d\\n\", ++b,++b); printf(\"%d %d\\n\", ++b,b++); vector&lt;int&gt; vec&#123;1,2&#125;; vector&lt;char&gt; v&#123;'a'&#125;; cout&lt;&lt; sizeof(vec)&lt;&lt;endl; cout&lt;&lt; sizeof(v)&lt;&lt;endl; cout&lt;&lt;sizeof(vector&lt;int&gt;)&lt;&lt;endl; cout&lt;&lt; sizeof(vector&lt;bool&gt;)&lt;&lt;endl; string s=\"hello\"; cout&lt;&lt; sizeof(s); return 0;&#125;//输出1 46 42 33 211 2 13 4 34 3 511 11 113 35 32424244032 int i=0;i++=1;//错误，后置源码定义函数返回const int右值++i=1;//正确,前置源码定义函数返回int&amp;左值 sizeof printf(\"%d %d\\n\",(k++,k++),k); //为什么带括号？ &lt;!--￼16--&gt; （十五）快手 容器的选择：vector/deque/list的差别 1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。 vector自定义类的要求 自定义的类必须有默认构造函数，因为vector会调用默认构造函数来初始化元素的对象。编译器隐式声明默认构造函数的条件： · 该类没有显式声明任何构造函数。 · 数据成员中没有const和reference。–因为要初始化（？？这点目前不是很理解） 满足则隐式生成默认构造函数。这里强调“任何”，是指即使用户自定义了复制构造函数或一个需要多个参数的构造函数，默认构造函数也不会被隐式声明了。在定义一个类时要保证有默认的构造函数。同时要求： 1、Copy构造函数：原理 2、赋值=操作符 3、能够销毁对象的析构函数 另外： 1、可用的缺省构造函数，序列型容器必须，用于初始化元素 2、==操作符定义，用于判断相等 3、&lt;操作符定义，关联型容器必须，用于缺省排序 程序状态字PSW(Program Status Word) 指在电脑中，一段包含被操作系统和潜在硬件使用的程序状态信息的内存或硬件区域。一般用一个专门的寄存器来指示处理器状态。在计算机系统中，表明系统运行状态的部件是程序状态字。 程序状态字PSW(Program Status Word)包括的状态位有进位标志位(CF)、结果为零标志位(ZF)、符号标志位(SF)、溢出标志位(OF)、陷阱标志位(TF)、中断使能(中断屏蔽)标志位(IF)、虚拟中断标志位(VIF)、虚拟中断待决标志位(VIP)、I0特权级别(IOPL)。 类型变量所占字节数 算术类型 32 64 bool 1 1 char 1 1 short 2 2 int 4 4 long 4 4 long long 8 8 char* 4 8 float 4 4 double 8 8 指针类型存储的是所指向变量的地址，所以32位机器只需要32bit，而64位机器需要64bit。数据类型占内存的位数实际上与操作系统的位数和编译器（不同编译器支持的位数可能有所不同）都有关，具体某种数据类型占字节数需要编译器根据操作系统位数间进行协调好后分配内存大小。 （十六）华为 字符串分隔符分隔和定义比较函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits/stdc++.h&gt;using namespace std;class Person&#123;public: Person(string s,int n):name(s),cnt(n)&#123;&#125;;public: string name; int cnt;//直接在类内重载&lt;运算符// bool operator&lt; (const Person&amp; two) const&#123;//一定要加const// if(cnt==two.cnt)&#123;// if(name.find(two.name)||two.name.find(name))// return name.length()&lt;two.name.length();// else// return name&lt;two.name;// &#125; else// return cnt&gt;two.cnt;// &#125;&#125;;//在类外设计比较函数类struct Isshort&#123;public://一定要加public，不然编译不过去 bool operator()(const Person&amp; one,const Person&amp; two)&#123; if(one.cnt==two.cnt)&#123; if(one.name.find(two.name)||two.name.find(one.name)) return one.name.length()&lt;two.name.length(); else return one.name&lt;two.name; &#125; else return one.cnt&gt;two.cnt; &#125;&#125;;string getStar(map&lt;string,int&gt; &amp;str)&#123; vector&lt;Person&gt; people; for(auto per:str)&#123; people.emplace_back(per.first,per.second); &#125; sort(people.begin(),people.end(),Isshort());//在函数上直接添加lamda表达式// [](const Person &amp;one,const Person&amp; p)&#123;// if(one.cnt==p.cnt)&#123;// if(one.name.find(p.name)||p.name.find(one.name))// return one.name.length()&lt;p.name.length();// else// return one.name&lt;p.name;// &#125; else// return one.cnt&gt;p.cnt;// &#125;); return (*people.cbegin()).name;&#125;int main() &#123; string s; map&lt;string,int&gt; str;//这样输入无法正常停止，遇见'.'或者换行符'\\n'或者结束符'EOF'才能停止// while(getline(cin,s,','))&#123;// if(s==\"\\n\")// break;// if(s[0]&lt;'A'||s[0]&gt;'Z')&#123;// cout&lt;&lt;00001&lt;&lt;endl;// return 0;// &#125;// for(int i=1;i&lt;s.size();i++)&#123;// if(s[i]&lt;'a'||s[i]&gt;'z')&#123;// cout&lt;&lt;00001&lt;&lt;endl;// return 0;// &#125;//// &#125;// if(str.count(s))// str[s]++;// else// str[s]=1;// &#125; cin&gt;&gt;s; //字符串分隔符的两种办法find和strtok const char* delim=new char(','); char* data=(char*)malloc(s.size()* sizeof(char)); copy(s.begin(),s.end(),data); char* per=strtok(data,delim); while(per!=NULL)&#123; if(*per&lt;'A'||*per&gt;'Z')&#123; cout&lt;&lt;00001&lt;&lt;endl; return 0; &#125; for(auto p=per+1;*p!='\\0';p++)&#123; if(*p&lt;'a'||*p&gt;'z')&#123; cout&lt;&lt;00001&lt;&lt;endl; return 0; &#125; &#125; if(str.count(per)) str[per]++; else str[per]=1; per=strtok(NULL,delim); &#125;// for(auto start=s.begin();start&lt;=s.end();)&#123;// auto it=find(start,s.end(),',');// auto per=s.substr(start-s.begin(),it-start);// if(per[0]&lt;'A'||per[0]&gt;'Z')&#123;// cout&lt;&lt;00001&lt;&lt;endl;// return 0;// &#125;// for(int i=1;i&lt;per.size();i++)&#123;// if(per[i]&lt;'a'||per[i]&gt;'z')&#123;// cout&lt;&lt;00001&lt;&lt;endl;// return 0;// &#125;//// &#125;// if(str.count(per))// str[per]++;// else// str[per]=1;// start=it+1;// &#125; int sum=0; for(auto p:str)&#123; sum+=p.second; &#125; if(sum&lt;=0||sum&gt;=100)&#123; cout&lt;&lt;00001&lt;&lt;endl; return 0; &#125; string star=getStar(str); std::cout &lt;&lt; star&lt;&lt;endl; return 0;&#125; （十七）阿里 可以用数据结构红黑树/哈希表存储五万个数查询是否存在x 数据量众多，哈希表地址冲突怎么办 可以直接添加链表等 c++新特性 虚函数 数组和链表的区别 单向链表 双向链表 析构函数 private 堆栈 二叉树的建立 存储结构 函数参数传递方式 值传递 指针传递 ：指针传递把实参的存储地址传递给对应的形参，从而使得形参指针和实参指针指向同一个地址，因此被调用函数中对形参指针所指向的地址中内容的任何改变都会影响到实参。 引用传递：被调函数的形参虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。 如何用vector实现队列 deque的内存模型：map+vector 简易实现可以使用int值记录头和尾下标） static和const谈谈 （十八）华为 std::thread 线程的启动 线程库 MySQL内联和外联 给定一个字符串 找出出现频率最高的字符 频率相同比较index小的 输出第一个值 单例的安全性 （十九）腾讯测开 多态用法示例 测试用例举例(测试边界) 用两个栈实现单向队列 TCP与UDP区别总结：1、TCP面向连接（要先通过三次握手建立连接）;UDP是无连接的，即发送数据之前不需要建立连接2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信5、TCP首部开销20字节;UDP的首部开销小，只有8个字节6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 哈希算法 指针和引用的区别 指针可以为空，引用不可以为空，引用是对象的别名，定义一个引用的时候必须初始化。因此使用指针之前必须做判空操作，引用就不必，引用是类型安全的，而指针不是。 sizeof引用的大小是所指变量的大小；sizeof指针是指针本身的大小-四个字节。 指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名，引用不改变指向，指针可以，所以有常量指针没有常量引用。自增(++)操作对引用的操作是改变所指对象内容，对指针的操作是使指针指向下一个对象。 引用使用时无需解引用（*）,指针需要解引用。 指针传递和引用传递的区别：参考 传递方式 函数定义 函数调用 函数内对A修改 值传递 fun(int a) fun(x) 外部不变 指针传递 fun(int *a) fun(&amp;x) 外部同步更改 引用传递(c++) fun(int &amp;a) fun(x) 外部同步更改 指针传递本质上是值传递，传递的是一个地址值。被调函数的形参作为被调函数的局部变量处理，会在栈中开辟内存空间存放由主调函数传进来的实参值，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行操作。如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。 引用传递，被调函数的形参也作为局部变量在栈中开辟内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。参数的处理是通过一个间接寻址的方式操作到主调函数中的相关变量。 从编译的角度讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后不会再更改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象则不能更改。 指针和引用的区别： （1）引用是别名，创建的同时必须被初始化，一旦被初始化就不能改变引用关系，不能为NULL；指针是变量，独立可变可空 （2）引用是间接寻址；指针是直接寻址 （3）引用有类型检查；指针无类型检查 （二十）美团测开 函数指针和指针函数的区别 函数指针其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。 12345678声明格式：类型说明符 (*函数名) (参数)函数指针是需要把一个函数的地址赋值给它，有两种写法：fun = &amp;Function；fun = Function;取地址运算符&amp;不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。调用函数指针的方式也有两种：x = (*fun)();x = fun(); 指针函数就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。 屏幕适配 屏幕尺寸：手机对角线的物理尺寸 单位：英寸（inch），1英寸=2.54cm Android手机常见的尺寸有5寸、5.5寸、6寸，6.5寸等等 屏幕分辨率：手机在横向、纵向上的像素点数总和 一般描述成屏幕的“宽x高”=AxB 含义：屏幕在横向方向（宽度）上有A个像素点，在纵向方向（高）有B个像素点 例子：1080x1920，即宽度方向上有1080个像素点，在高度方向上有1920个像素点。单位：px（pixel），1px=1像素点 UI设计师的设计图会以px作为统一的计量单位 Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920 屏幕像素密度:每英寸的像素点数 单位：dpi（dots per ich） 假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi 1dpi=(横向分辨率^2+纵向分辨率^2)^(1/2)/屏幕尺寸 屏幕适配的解决方案：参考 1、自定义像素适配：(屏幕真实横纵分辨率/默认横纵分辨率)*所设置的横纵长=适配横纵长 2、百分比适配（添加依赖） 3、修改density实现屏幕适配 4、限定符适配 SQL语句 微信登录测试内容 为什么选测开 支付宝咻咻咻原理 （二十一）知识点 文件描述符 linux内存管理 虚拟内存 物理内存：Linux内核管理物理内存是通过分页机制实现的 内置类型和复合类型 内置类型包括算术类型和空类型。算术类型分为整型和浮点型，其中整型包括字符型和布尔型。 复合类型主要包括：引用、指针、数组。 git log kill进程是进程通信：linux内核发送SIGKILL信号给进程 windows消息驱动机制和时间驱动机制 Linux设备驱动机制 字符设备 块设备 网络设备 同学分享的字节二面编程题：1、求36进制的和 2、判断树是否对称 堆排序是原地算法，空间复杂度O(1)。堆在逻辑上是特殊的完全二叉树，在存储结构上是顺序表。一般用数组实现。堆只分为大堆和小堆大堆：树的父亲节点必须比它的叶子节点大；小堆：树中父亲节点比它的叶子小，只有这两种特殊的情况下一个数组才能被称为堆。 自底向上构建堆时间复杂度O（n）：从最后一个非叶子结点开始循环遍历直到根结点 12345void createHeap(int n)&#123; for (int i = n/2; i != 0; i--) sink(n, i);&#125; 自顶向下构建堆时间复杂度O（nlogn）：从根结点开始 12345void createHeap(int n)&#123; for(int i=1;i&lt;=n;i++) swim(i);&#125; 常见数据结构的查找、插入、删除时间复杂度 数据结构 访问 查找 插入 删除 数组 O(1) O(n) O(n) O(n) 有序数组 O(1) O(logn) O(n) O(n) 链表 O(n) O(n) O(1) O(1) 有序链表 O(n) O(n) O(n) O(1) 二叉查找树 O(logn) O(logn) O(logn) O(logn) 哈希表 — O(1) O(1) O(1) 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出fact(1000)。 1234def fact(n): if n==1: return 1 return n * fact(n - 1) **尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。** 上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，主要是要把每一步的乘积传入到递归函数中： 1234567def fact(n): return fact_iter(n, 1)def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) **栈帧** 每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数的返回地址和局部变量。 栈帧也叫过程活动记录，是编译器用来实现过程/函数调用的一种数据结构。从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等。 栈是从高地址向低地址延伸的。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着所需要的各种信息。寄存器ebp指向当前的栈帧的底部（高地址），寄存器esp指向当前的栈帧的顶部（低地址）。 注意：EBP指向当前位于系统栈最上边一个栈帧的底部，而不是系统栈的底部。严格说来，“栈帧底部”和“栈底”是不同的概念;ESP所指的栈帧顶部和系统栈的顶部是同一个位置。 递归时间复杂度 master公式： T [n] = aT[n/b] + f (n)（直接记为T [n] = aT[n/b] + T (N^d)） 其中 a &gt;= 1 and b &gt; 1 是常量，其表示的意义是n表示问题的规模，a表示递归的次数也就是生成的子问题数，b表示每次递归是原来的1/b之一个规模，f（n）表示分解和合并所要花费的时间之和。 解法：①当d&lt;logb a时，时间复杂度为O(n^(logb a))②当d=logb a时，时间复杂度为O((n^d)*logn)③当d&gt;logb a时，时间复杂度为O(n^d) struct和class的区别 默认成员访问说明符：struct-public;class-private 默认派生访问说明符: struct-public;class-private 构造函数不同：（1）结构体不能包含显示地无参数构造函数，在自定义构造函数中必须为所有成员赋值。结构体成员将自动初始化为它们的默认值。（2）结构体不能包含以下形式的初始值设定类：base(argument-list) 结构体不允许声明析构函数；类可以 对于结构体中的实例字段成员，不能在声明时赋值初始化 声明了结构体类型后，可以使用new运算符创建构造对象，也可以不使用new关键字。如果不使用new,那么在初始化所有字段之前，字段将保持未赋值状态且对象不可用（结构体可以像类一样通过new 构造函数()来创建实例，也可以声明实例之后再赋值，例如：Person xiaoming; xiaoming.name = “xiaoming”;） struct是值类型，栈中创建（栈资源却很有限，因此struct常用来处理作为基类型对待的小对象）；class是引用类型，堆中创建 class能用于表示模板类型；struct不能 注意：struct能包含成员函数；struct能继承；struct能实现多态 两种通用的遍历树的策略 深度优先搜索（DFS） 采用深度作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回根到达另一个分支。深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为前序遍历，中序遍历和后序遍历。 宽度优先搜索（BFS） 按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。 std::funtion和std::bind参考 函数对象：定义了调用操作符（）的类对象。 1234567891011121314151617181920212223242526272829303132class Sort &#123; public: bool operator() (const string &amp;str1, const string &amp;str2) const //带两个参数 &#123; return str1 &gt; str2; &#125; &#125;; 然后我们可以用这个类作为参数来初始化set容器：set&lt;string, Sort&gt; myset; //带比较函数的set构造函数,并用函数对象Sort初始化myset.insert(\"A\"); myset.insert(\"B\"); //输出为：B，A。class Upper &#123; public: Upper(int min = 0):m_min(min)&#123;&#125; bool operator() (int value) const &#123; return value &gt;= m_min; &#125; private: int m_min; &#125;; 从而这样调用 find_if 函数：find_if( dest.begin(), dest.end(), Upper(10) );首先生成类 Upper 的对象，并用 10 初始化，调用find_if 时将用该函数对象进行判断。","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"C++易混点","slug":"C-易混点","date":"2020-03-24T06:44:02.000Z","updated":"2020-05-17T01:19:05.236Z","comments":true,"path":"2020/03/24/C-易混点/","link":"","permalink":"http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/","excerpt":"（一）虚函数表指针、虚基类表指针 非虚继承时，不需要额外增加虚函数表指针。单继承：一个虚函数表，一个虚表指针；多继承：子类的虚表指针数=父类数。 虚继承时：无论是单虚继承还是多虚继承，需要有一个虚基类表来记录虚继承关系，所以此时子类有且仅有一个虚基类表指针；多虚继承时子类可能持有多个虚函数表：如果子类没有构造函数和析构函数，且子类中的虚函数都是在父类中出现的虚函数，这个时候不需要增加任何虚表指针，只需要像多继承那个持有父类个数的虚函数表指针来标识即可。","text":"（一）虚函数表指针、虚基类表指针 非虚继承时，不需要额外增加虚函数表指针。单继承：一个虚函数表，一个虚表指针；多继承：子类的虚表指针数=父类数。 虚继承时：无论是单虚继承还是多虚继承，需要有一个虚基类表来记录虚继承关系，所以此时子类有且仅有一个虚基类表指针；多虚继承时子类可能持有多个虚函数表：如果子类没有构造函数和析构函数，且子类中的虚函数都是在父类中出现的虚函数，这个时候不需要增加任何虚表指针，只需要像多继承那个持有父类个数的虚函数表指针来标识即可。 如果子类中含有构造函数或者析构函数或二者都有，则在子类中只要出现一个父类中的虚函数则需要增加一个虚函数表指针来标识此类的虚函数表；无论是否含有构造函数或者虚构函数，只要继承都是虚继承且出现了父类中没有出现的虚函数，则在子类中需要再增加一个虚函数表指针；如果其中有一个是非虚继承，则按照最省空间的原则，不需要增加虚函数表指针，因为这个时候可以和非虚基类共享一个虚函数表指针。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//32位系统指针占四字节 64位系统指针占8字节，本题按32位系统class Base1&#123;int a;public:virtual void fun1()&#123;cout &lt;&lt; \"Base1::fun1\" &lt;&lt; endl;&#125;&#125;;class Base2&#123;int b;public:virtual void fun1()&#123;cout &lt;&lt; \"Base2::fun1\" &lt;&lt; endl;&#125;virtual void fun2()&#123;cout &lt;&lt; \"Base2::fun2\" &lt;&lt; endl;&#125;&#125;;class Derive1 : public Base1&#123;int d1;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive1::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive1::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive2 : virtual public Base1&#123;int d2;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive2::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive2::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive3 : virtual public Base2&#123;int d3;int add;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive3::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive3::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive4 : public Derive2, public Derive3&#123;int d4;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive4::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive4::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive5 : public Base1, public Base2&#123;virtual void d_fun()&#123;cout &lt;&lt; \"Derive5::d_fun\" &lt;&lt; endl;&#125;&#125;;//输出结果为：pstr1为虚函数表指针，vpstr为虚基类表指针sizeof(Base1):8 //sizeof(int) + sizeof(pstr) = 4+4sizeof(Base2):8 //同上sizeof(Derive1):12 //sizeof(int) + sizeof(pstr) + sizeof(int)= 4+4+4sizeof(Derive2):20 //sizeof(int) + sizeof(Base1的pstr) +sizeof(Derive2的pstr) + sizeof(vpstr)+ sizeof(int)= 4+4+4+4+4sizeof(Derive3):24 //sizeof(int) + sizeof(int) + sizeof(Base1的pstr) +sizeof(Derive2的pstr) + sizeof(vpstr)+ sizeof(int)= 4+4+4+4+4+4sizeof(Derive4):44 //sizeof(Derive2) + sizeof(Derive3) + sizeof(int)sizeof(Derive5):16 //sizeof(Base1) + sizeof(Base2) （二）万能头文件基本上所有的代码只要用了这个头文件就不再写其他头文件了。 #include&lt;bits/stdc++.h&gt;包含了目前c++所包含的所有头文件。 （三）加速c++12345static const auto _ = []()&#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return nullptr;&#125;(); ​ iostream默认是与stdio关联在一起的，以使两者同步，因此消耗了iostream不少性能。C++中的std :: cin和std :: cout为了兼容C，保证在代码中同时出现std :: cin和scanf或std :: cout和printf时输出不发生混乱，所以C++用一个流缓冲区来同步C的标准流。通过std :: ios_base :: sync_with_stdio函数设置为false后可以解除这种同步，让std :: cin和std :: cout不再经过缓冲区，iostream的性能就会提高了很多倍。因此，当解除同步之后，注意不要与scanf和printf混用以免出现问题 ​ tie是将两个stream绑定的函数，空参数的话返回当前的输出流指针。std :: cin默认是与std :: cout绑定的，所以每次操作的时候都要调用flush，这样增加了IO的负担，通过tie(nullptr)来解除std :: cin和std :: cout之间的绑定，进一步加快执行效率。 （四）运算符优先级 ！= 优于 &amp; 。 （五）c++11新特性：参考1、nullptr关键字 解决二义性问题，专门用来区分空指针和0。 2、auto关键字 用于从初始化表达式中推断出变量的数据类型。 auto定义变量时必须初始化（类似引用） auto作为函数返回值时，只能用于定义函数，不能用于声明函数 不允许使用auto定义函数参数 不允许使用auto定义struct/class的成员变量 不允许使用auto定义数组 不允许使用auto作为模板参数传递 12auto i = 5; // i 被推导为 intauto arr = new auto(10) // arr 被推导为 int * 3、decltype 关键字decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。编译器分析表达式并得到它的类型，却不实际计算表达式的值。如果给变量加上了一层括号，编译器会把它当作一个表达式，得到的则是引用类型。 123456int i = 10;float j = 5.1;decltype(i) a; // a的类型是intdecltype((i)) b = i; // b的类型是int&amp;，必须为其初始化，否则会编译报错decltype(i+j) c; // c的类型是int+float =&gt; float 4、新式函数声明C++11 引入了一个叫做拖尾返回类型（trailing return type），利用 auto 关键字将返回类型后置。 1234template&lt;typename T, typename U&gt;auto add(T x, U y) -&gt; decltype(x+y) &#123; return x+y;&#125; 5、基于范围的 for 循环 123for(auto &amp;i : arr) &#123; std::cout &lt;&lt; i &lt;&lt; std::endl;&#125; 6、Lambda表达式 如果mutable,exception,attribute,return type四者只要一种出现，小括号()不可省略，均不出现则可省略。 1234567891011121314151617181920212223[capture] (parameters) opt-&gt; return-type &#123; body&#125;;void noreturnfun() __attribute__((noreturn));//函数不会返回。1. capture是捕获列表； 1).[]不捕获任何变量 2).[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获） 3).[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获) 4).[=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量 5).[bar]按值捕获bar变量，同时不捕获其他变量 6).[this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限 如果已经使用了&amp;或者=，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量2. parameters是参数表；(选填) 3. opt是函数选项；可以填mutable,exception,attribute（选填） 1).mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法 2).exception说明lambda表达式是否抛出异常以及何种异常 3).attribute用来声明属性，GCC使用__attribute__关键字来描述函数，变量和数据类型的属性，用于编译器对源代码的优化。attribute语法格式为：_attribute_ ((attribute-list))4. return-type是返回值类型（拖尾返回类型）(选填) 5. body是函数体 7、std::function/std::bind封装可执行对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Test.hclass Test&#123;public: void Add(std::function&lt;int(int, int)&gt; fun, int a, int b) &#123; int sum = fun(a, b); std::cout &lt;&lt; \"sum:\" &lt;&lt; sum &lt;&lt; std::endl; &#125;&#125;;main.cppint add(int a, int b)&#123; std::cout &lt;&lt; \"add\" &lt;&lt; std::endl; return a + b;&#125;class TestAdd&#123;public: int Add(int a, int b) &#123; std::cout &lt;&lt; \"TestAdd::Add\" &lt;&lt; std::endl; return a + b; &#125;&#125;;int main()&#123; Test test; test.Add(add, 1, 2); TestAdd testAdd; test.Add(std::bind(&amp;TestAdd::Add, testAdd, std::placeholders::_1, std::placeholders::_2), 1, 2); return 0;&#125;运行结果：addsum:3TestAdd::Addsum:3解释：std::bind第一个参数为对象函数指针，表示函数相对于类的首地址的偏移量；testAdd为对象指针；std::placeholders::_1和std::placeholders::_2为参数占位符，表示std::bind封装的可执行对象可以接受两个参数。我们的Test函数在函数指针和类对象函数中，两种情况下都完美运行。 8、初始化列表 123456789#include &lt;initializer_list&gt;class Magic &#123;public: Magic(std::initializer_list&lt;int&gt; list) &#123;&#125;&#125;;Magic magic = &#123;1,2,3,4,5&#125;;std::vector&lt;int&gt; v = &#123;1, 2, 3, 4&#125;; 9、STL容器 std::array&lt;类型，容量&gt;，相对于数组增加了迭代器 std::forward_list单向链表，链表在对数据进行插入和删除是比顺序存储的线性表有优势，因此在插入和删除操作频繁的应用场景中，使用list和forward_list比使用array、vector和deque效率要高很多。 std::unordered_map与std::map用法基本差不多，但STL在内部实现上有很大不同，std::map使用的数据结构为红黑树，而std::unordered_map内部是哈希表的实现方式，哈希map理论上查找效率为O(1)。但在存储效率上，哈希map需要增加哈希表的内存开销。 std::unordered_set的数据存储结构也是哈希表的方式结构，除此之外，std::unordered_set在插入时不会自动排序，这都是std::set表现不同的地方。 10、多线程 std::thread为C++11的线程类，使用方法和boost接口一样非常方便，同时得益于C++11的可变参数的设计风格，C++11的std::thread还解决了boost::thread中构成参数限制的问题：如果线程需要绑定的函数有参数则需要使用boost::bind。比如想使用 boost::thread创建一个线程来执行函数：void f(int i)，如果这样写：boost::thread thrd(f)是不对的，因为thread构造函数声明接受的是一个没有参数且返回类型为void的型别，而且不提供参数i的值f也无法运行，这时就可以写：boost::thread thrd(boost::bind(f,1))。涉及到有参函数的绑定问题基本上都是boost::thread、boost::function、boost::bind结合起来使用。 std::atomic为C++11封装的原子数据类型，在多线程中用户不必对其添加互斥资源锁的类型，其内部已自己加了锁。 C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到被唤醒再从新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。 11、智能指针内存管理 12345678910111213shared_ptr&lt;Foo&gt; factory(T arg)&#123; return make_shared&lt;Foo&gt;(arg);&#125;void use_factory(T arg)&#123; shared_ptr&lt;Foo&gt; p=factory(arg); //使用p&#125;//p离开了作用域，它指向的内存会被自动释放掉auto use_factory(T arg)&#123; shared_ptr&lt;Foo&gt; p=factory(arg); //使用p return p;//当我们返回p时，引用计数进行了递增操作&#125;//p离开了作用域，它指向的内存不会被自动释放掉 C++11新增了std::shared_ptr（共享）、std::weak_ptr（弱引用，指向管理的对象，不会增加引用计数）、std::unique_str(独占)等类型的智能指针，用于解决内存管理的问题，更容易安全的使用动态内存。 12、右值引用于std::move 右值引用 (Rvalue Referene) 是 C++ 新标准 中引入的新特性 , 它实现了移动语义 (Move Sementics) 和完美转发 (Perfect Forwarding)。它的主要目的有两个方面： 1）消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 2）能够更简洁明确地定义泛型函数。 左值持久；右值短暂 左值：非临时对象，要么是字面常量，要么是在表达式求值过程中创建的临时对象右值：临时的对象， 右值引用的转移语义和完美转发 13、模板增强 外部模板扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化。 类型别名模板 在传统 C++中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效。 12345template &lt;typename T&gt;using NewType = SuckType&lt;int, T, 1&gt;; // 合法template&lt; typename U&gt;typedef SuckType&lt;std::vector&lt;int&gt;, U, 1&gt; NewType; // 不合法 默认模板参数 1234template&lt;typename T = int, typename U = int&gt;auto add(T x, U y) -&gt; decltype(x+y) &#123; return x+y;&#125; 14、构造函数 委托构造 C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的 1234567891011class Base &#123;public: int value1; int value2; Base() &#123; value1 = 1; &#125; Base(int value) : Base() &#123; // 委托 Base() 构造函数 value2 = 2; &#125;&#125;; 继承构造 在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明 123456789101112131415161718192021222324252627282930struct A&#123; A(int i) &#123;&#125; A(double d,int i)&#123;&#125; A(float f,int i,const char* c)&#123;&#125; //...等等系列的构造函数版本&#125;；struct B:A&#123; B(int i):A(i)&#123;&#125; B(double d,int i):A(d,i)&#123;&#125; B(folat f,int i,const char* c):A(f,i,e)&#123;&#125; //......等等好多个和基类构造函数对应的构造函数&#125;； //c++11的继承构造struct A&#123; A(int i) &#123;&#125; A(double d,int i)&#123;&#125; A(float f,int i,const char* c)&#123;&#125; //...等等系列的构造函数版本&#125;；struct B:A&#123; using A::A; //关于基类各构造函数的继承一句话搞定 //......&#125;； 15、虚函数的 override 和 final 指示符 override，表示函数应当重写基类中的虚函数 final，表示派生类不应当重写这个虚函数 16、static_assert() 静态断言 C提供的assert()只能在运行时断言 C++11/14 提供的static_assert()可以在编译期断言 （六）十大经典排序算法：参考 冒泡排序 123456789template&lt;typename T&gt; //整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符void bubble_sort(T arr[], int len) &#123; int i, j; for (i = 0; i &lt; len - 1; i++) //注意限制条件j&lt;len-1-i for (j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) swap(arr[j], arr[j + 1]);&#125; 快速排序 插入排序 选择排序 堆排序 归并排序 自顶向下 自底向上：注意底层达不到整数倍length的数据部分 （七）重点知识点 printf 从右向左计算，从左向右输出，符合栈模型 类中变量赋值顺序是变量声明顺序，所以赋值时先执行a(b)，再执行b(i+1)。a赋值为随机数 1234567891011121314class base1&#123; private: int a,b; public: base1 ( int i ) : b(i+1),a(b)&#123;&#125; base1():b(0),a(b)&#123;&#125; int get_a()&#123;return a;&#125; int get_b()&#123;return b;&#125;&#125;;int main()&#123; base1 obj1(11); cout&lt;&lt;obj1.get_a()&lt;&lt;endl&lt;&lt;obj1.get_b()&lt;&lt;endl; return 0;&#125; static 与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。Static修饰的成员函数，在代码区分配内存。 C++多态分为静态多态和动态多态 静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。 C++里面‘/’有点特别，当它两边都是int时，就整除，如果有一个是double或者float，就按照正常的除法，有小数部分。 派生访问说明符 public继承 公有继承时，对基类的公有成员和保护成员的访问属性不变，派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员。派生类的对象只能访问派生类的公有成员（包括继承的公有成员），不能访问派生类和继承基类的保护成员和私有成员。 protected继承 保护继承中，基类的公有成员和保护成员被派生类继承后变成保护成员，派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员。派生类的对象只能访问派生类的公有成员，不能访问继承基类的公有成员、保护成员和私有成员。 private继承 私有继承时，基类的公有成员和保护成员都被派生类继承下来之后变成私有成员，派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员。派生类的对象只能访问派生类的公有成员，不能访问继承基类的公有成员、保护成员和私有成员。 C++枚举类型：限定作用域的枚举类型和不限范围的枚举类型的区别 限定作用域的枚举类型的一般形式和不限范围的枚举类型不同 1234567891011121314151617//非限定作用域enum color&#123; red, green, blue&#125;;color b=green;int c=blue; //正确//限定作用域enum class color:char&#123; red, green, blue&#125;;color a=color::green;char d=color:blue; //错误，限定作用域的枚举类型不能用于初始化int类型的实体 限定作用域的枚举类型不能再作用域外访问枚举成员,必须显示地访问枚举成员，限定作用域的枚举型别带来的名字空间污染降低；不限范围的枚举型别可以 从限定作用域枚举型别到任何其他型别都不存在隐式转换路径（可实施强制型别转换）；不限范围的枚举型别可以 限定作用域的枚举型别和不限范围的枚举型别都支持底层型别指定。限定作用域的枚举型别的默认底层型别是int，而不限范围的枚举型别没有默认底层型别。 限定作用域的枚举型别总是可以进行前置声明，而不限范围的枚举型别却只有在指定了默认底层型别的前提下才可以进行前置声明。 类型转换函数 类型转换函数的语法格式为： 1234operator type()&#123; //TODO: return data;&#125; 1) type 可以是内置类型、类类型以及由 typedef 定义的类型别名，任何可作为函数返回类型的类型（void 除外）都能够被支持。一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的。 2) 类型转换函数一般不会更改被转换的对象，所以通常被定义为 const 成员。 3) 类型转换函数可以被继承，可以是虚函数。 4) 一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性。 5) 转换函数必须是成员函数，它的声明不能指定返回类型和参数列表。 通常一个参数的构造函数在non-explicit的情况下同样能实现类型转换 内存泄漏 内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。三种类型的内存泄漏： （1）堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc,new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。 （2）系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。 （3）没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。 安全的代码 123int* p=new int(1);delete p;p = NULL; （1）delete 一次以后，p成了野指针，但是它作为地址的值还是有效地，还可以访问它以前指向的内存，不过那片内存被重新格式化了；（2）指针非空时，delete运算只释放指针所指的地址空间，不会判断空间是否被占用，delete结束后不会将指针赋值为空，释放后别的指针变量也可以得到这片空间，该空间的值并不一定是NULL，所以delete后不能用是否为NULL来判断。用 if(p) 语句不能判断它指向的内存是否有效（此时它指向的内存无效，p本身有效）；（3）delete 一次以后，不能再次delete，否则会报错；（4）如果p指向的空间再次被new函数分配，即使是分配给别的指针，即使分配大小与原来不一样，此时如果误用p指针，仍然可以修改内存的值和从该处取出数值，甚至可以重新被delete，p的作用与新分配的指针一样； 对同一非空指针delete多次，只有第一次delete被正确执行，之后的delete全部发生异常。对空指针delete多次可以正常执行。良好的习惯是，delete运算后手动将指针赋值为空。 野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）,野指针的成因： 1、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的默认值是随机的，它会乱指一气。2、指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。3、指针操作超越了变量的作用范围。这种情况让人防不胜防。 悬空指针指指针正常初始化，曾指向过一个正常的对象，但是对象销毁了，该指针未置空，就成了悬空指针。例如指针p1、p2均指向对象a，delete p1后p2就是悬空指针，p1是野指针。 sizeof 在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，结构体变量所占空间的大小必定是最宽数据类型大小的整数倍。如有需要会在最后一个成员末尾填充若干字节使得所占空间大小是最宽数据类型大小的整数倍。内存对齐的原因： 某些平台只能在特定的地址处访问特定类型的数据； 提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量 大端小端 大端模式（Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。 小端模式（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。 口诀：大相反（低位存高位），小相同（低位存低位）。 联合体变量共享同一空间，可以通过联合体来判断大端小端。联合体同样存在内存对齐，所以联合长度至少可以容纳最大的成员。但是当最大成员大小不是最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍。 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std; int checkcpu()&#123; union w &#123; int a; char b; &#125;c; c.a = 1; return (c.b == 1);&#125; int main()&#123; if(checkcpu() == 1) printf(\"这是小端\\n\"); else printf(\"这是大端\\n\"); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"MySQL","slug":"MySQL","date":"2020-03-24T06:17:11.000Z","updated":"2020-04-12T07:50:49.994Z","comments":true,"path":"2020/03/24/MySQL/","link":"","permalink":"http://yoursite.com/2020/03/24/MySQL/","excerpt":"MySQL事务实现原理 首先了解什么是事务，事务是执行一系列数据库操作构成的单个逻辑工作单元，要么完全地执行，要么完全地不执行。 简单的说，事务就是并发控制的单位，是用户定义的一个操作序列。 （1）事务四大特性（ACID） 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务前后数据的完整性必须保持一致。 隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。","text":"MySQL事务实现原理 首先了解什么是事务，事务是执行一系列数据库操作构成的单个逻辑工作单元，要么完全地执行，要么完全地不执行。 简单的说，事务就是并发控制的单位，是用户定义的一个操作序列。 （1）事务四大特性（ACID） 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务前后数据的完整性必须保持一致。 隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 （2）事务并发问题 脏读：读到了别的事务回滚前的脏数据,即当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。 不可重复读：当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配. 幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据，产生幻读，即当前事务读第一次取到的数据比后来读取到数据条目少。 不可重复读和幻读比较：两者有些相似，但是前者针对的是update或delete，后者针对的insert。 （3）事务的隔离级别 事务的隔离级别 描述 Serializable（串行化） 可避免脏读、不可重复读、虚读情况的发生 Repeatable read（可重复读） 可避免脏读、不可重复读的发生 Read committed（读已提交） 可避免脏读的发生 Read uncommitted（读未提交） 最低级别，以上情况均无法保证 91道面试题](https://mp.weixin.qq.com/s/9pfCkm2bX01XLIeJv9ngLw) 什么是MySQL索引，什么时候该用索引什么时候不该用？ 索引(Index)是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。Mysql索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特别指明，一般都是指B树结构组织的索引(B+Tree索引)。 优点：所有的MySql列类型(字段类型)都可以被索引，也就是可以给任意字段设置索引；大大加快数据的查询速度 缺点： 1、创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加 2、索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值 3、当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。 使用原则：（并不是每个字段度设置索引就好，也不是索引越多越好，而是需要自己合理的使用） （1）对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引， （2）数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。 （3）在一同值少的列上(字段上)不要建立索引，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。 索引类型 索引我们分为四类来讲 单列索引(普通索引，唯一索引，主键索引)、组合索引、全文索引、空间索引、 单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。 唯一索引：索引列中的值必须是唯一的，但是允许为空值， 主键索引：是一种特殊的唯一索引，不允许有空值。 组合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀原则。 全文索引：全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行。 空间索引：空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。在创建空间索引时，使用SPATIAL关键字。要求引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。 InnoDB和MyISAM的区别 （1）InnoDB支持事务，MyISAM不支持。 （2）InnoDB支持外键，MyISAM不支持。 （3）InnoDB是聚簇索引，使用B+树作为索引结构，行数据是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），主键索引的叶子结点就是数据文件，辅助索引的叶子结点是主键的值，所以InnoDB必须有主键，MyISAM可以没有。主键索引效率很高，但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大；MyISAM是非聚簇索引，使用B+树作为索引结构，索引和数据文件是分离的，主键索引和辅助索引的叶子结点都是数据文件的地址指针（MyISAM的主键索引和辅助索引没有区别，主键索引仅仅只是一个叫做PRIMARY的唯一非空的索引，且MyISAM可以不设主键。参考 （4） InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）。 （5）MyISAM表格可以被压缩后进行查询操作。 （6）InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁。 （7）Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI ​ Innodb：frm是表定义文件，ibd是数据文件 ​ Myisam：frm是表定义文件，myd是数据文件，myi是索引文件 行级锁和表级索的区别 （1）表级锁 table-level locking，锁住整个表 开销小，加锁快 不会死锁(一次性加载所需的所有表) 锁粒度大，发生锁冲突概率大，并发效率低 适合查询 （2）行级锁 row-level locking，锁住一行记录 开销大，加锁慢 会死锁 锁粒度小，发生锁冲突概率小，并发效率高 适合并发写，事务控制 并不是直接给记录行加锁，而是对行对应的索引加锁： 如果sql 语句操作了主键索引，Mysql 就会锁定这条主键索引 如果sql语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引 在InnoDB中，如果SQL语句不涉及索引，则会通过隐藏的聚簇索引来对记录加锁 对聚簇索引加锁，实际效果跟表锁一样，因为找到某一条记录就得扫描全表，要扫描全表，就得锁定表 主键索引和非主键索引的区别 InnoDB中，非主键索引的叶子节点存放的是主键的值，而主键索引的叶子节点存放的是整行数据。非主键索引也被称为二级索引，而主键索引也被称为聚簇索引。 聚簇索引和非聚簇索引的区别 聚集索引：索引项的顺序与表中记录的物理顺序一致，叶子结点存储真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚簇索引，因为真实数据的物理顺序只能有一种。 非聚簇索引：表数据存储顺序与索引顺序无关，叶结点包含索引字段值即指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。 总结一下：聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。与非聚集索引相比，聚集索引有着更快的检索速度。 排他锁悲观锁和乐观锁 共享锁： S锁、读锁。当前线程对共享资源加共享锁，其他线程可以读取此资源、可以继续追加共享锁，但是不能修改此资源、不能追加排他锁。语法：select id from t_table in share mode;多个共享锁可以共存，共享锁与排他锁不能共存. 排他锁： X锁、写锁。当前线程对共享资源加排他锁，其他线程不允许读取此资源，不允许追加共享锁，不允许修改此资源，不允许追加排他锁。语法：update t_table set a =1; // 数据库的增删改操作默认都会加排他锁select * from t_table for update;// for update也是一种增删改。排他锁是独占的，不会与其他锁共存。 乐观锁（乐观锁与悲观锁是逻辑上的锁） 乐观地认为，并发问题很难发生。乐观锁虽然认为并发问题很难发生，但并不是不会发生，所以也会有措施防止问题真的产生：每次数据修改都自增版本号version。进行数据读取时，并不加锁，而是同时读取当前的版本号version1；在对数据进行修改时，要判断当前的版本号version2是否等于之前的版本号version1。版本号不匹配，则代表着并发问题已产生，所以需要回滚此次操作。实现方式：版本号机制、CAS。 悲观锁 悲观地认为，并发问题极易发生。悲观锁认为并发问题极易发生，所以每次操作，无论读写，都会对记录加锁，以防止其他线程对数据进行修改。实现方式：数据库的行锁、读锁和写锁。 覆盖索引 一个包含查询所需字段的索引称为“覆盖索引”，覆盖索引只是特定于具体select语句而言的联合索引。也就是说一个联合索引对于某个select语句，通过索引可以直接获取查询结果，而不再需要回表查询，就称该联合索引覆盖了这条select语句。覆盖索引是sql性能提升的关键，减少IO，提高了效率。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"C++ primer重点记录","slug":"C-primer重点记录","date":"2020-03-24T05:43:26.000Z","updated":"2020-05-04T05:39:04.621Z","comments":true,"path":"2020/03/24/C-primer重点记录/","link":"","permalink":"http://yoursite.com/2020/03/24/C-primer%E9%87%8D%E7%82%B9%E8%AE%B0%E5%BD%95/","excerpt":"第一章 开始 windows或unix编译程序使用命令 cc hello.cc windows输出a.exe unix输出a.out 输入a.exe或者./a.out执行程序 运行GNU编译器的命令是g++","text":"第一章 开始 windows或unix编译程序使用命令 cc hello.cc windows输出a.exe unix输出a.out 输入a.exe或者./a.out执行程序 运行GNU编译器的命令是g++ g++ -o hello hello.cc (-o hello给执行文件命名) cerr 输出警告和错误消息 clog输出程序运行时的一般信息 命名空间可以避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突 使用一个istream对象作为条件，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符(EOF)，或遇到一个无效的输入时(例如读入的值不是一个整数)，istream对象的状态会变成无效，处于无效状态的istream对象会使条件变假。 1while(std::cin&gt;&gt;value) main函数返回值类型必须为int类型，为0表示成功，非0由系统定义，通常指出错误类型 编译为addItems.exe的可执行文件(UNIX中是addItems.out)，从一个名为infile的文件读取销售记录，并将结果输出写入一个名为outfile的文件中，两个文件都位于当前目录。 addItems outfile 第二章 变量和基本类型 一个字节：8bit 一个字：4或8个字节 float：一个字 double：两个字 long double：3或4个字 char与其他整型（整型包括字符、布尔和整数）不同，字符型被分为三种：char /signed char/unsigned char。char实际上表现为哪种类型由编译器决定。 c++算术类型分为两类：整型和浮点型 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8位 short 短整型 16 int 整型 16 long 长整型 32 long long 长整型 64 类型转换 赋值给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。eg:8比特大小的usigned char可以表示0至255区间内的值，如果赋了一个区间以外的值，则实际结果是该值对256取模后所得的余数。因此把-1赋给8比特大小的usigned char所得的结果是255（即256+（-1）=255）。 赋值给带符号类型一个超出它表示范围的值时，结果是未定义的。此时程序可能继续工作、可能崩溃、也可能生成垃圾数据。 如果两个运算符的运算对象类型不一致，首先把这些运算对象执行整型提升，如果结果类型匹配，无须进行进一步的转换。如果两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型运算对象转换成较大的类型。 123ival + ulval; //ival转换成usigned long，无符号类型不小于带符号类型usval + ival; //根据usigned short 和 int 所占空间的大小进行转换uival + lval; //根据usigned int 和 long 所占空间的大小进行转换 表达式里带符号类型不大于无符号类型，带符号类型会自动转换成无符号类型；带符号类型大于无符号类型时转换结果依赖于机器，eg,如果两个运算对象的类型分别是long类型和usigned int类型，long占用的空间比int更多，则usigned int 类型的运算对象转换成long类型；当带符号类型取值为负时会出现异常结果。 转义序列 \\x 后紧跟1个或多个十六进制数字，eg:“\\1234”表示一个16位的字符 \\后紧跟1、2或3个八进制数字，eg:“\\1234”表示两个字符即八进制123对应的字符和字符4 列表初始化 初始化！=赋值 1234567int a=1;int a=&#123;1&#125;;int a&#123;1&#125;;int a(1);long double ld=3.143;int a&#123;ld&#125;,b=&#123;ld&#125;;//错误：窄化转换，转换未执行，因为存在丢失信息的危险int a(ld),b=ld;//正确：转换执行，且确实丢失了部分值 变量能且仅能被定义一次，但是可以被多次声明。如果在多个文件中使用同一个变量，就必须将声明和定义分离，变量的定义必须出现在也只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，但是绝对不能重复定义。 标识符 标识符必须以字母或者下画线开头，要能体现实际含义。 变量名一般要用小写字母，如index,不要使用Index或INDEX。 用户自定义的类名一般以大写字母开头，如Sales_item。 如果标识符由多个单词组成，则单词间应有明显的区分，如student_loan或studentLoan,不要使用studentloan。 用户自定义标识符不能连续出现两个下画线，也不同以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。 按位与&amp; 或者 bitand 按位或 | 或者 bitor 异或^或者xor and_eq与=（赋值） or_eq或=（赋值） compl或者~非 not_eq不等于（赋值） xor_eq异或等于 在块作用域中使用“：：a”,因为全局作用域本身并没有名字，所以作用域左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量（即全局变量）。 引用必须被初始化，且不能更改指向值，而指针无须初始化且可以先后指向几个不同的对象。指针必须初始化，得到空指针的办法就是用字面值nullptr来初始化指针，新标准下，初始化指针最好使用nullptr,同时尽量避免NULL(在头文件cstdlib中定义的值为0的预处理器）和 0（使用NULL和0初始化指针是一样的）；把int变量直接赋值给指针是错误的操作，即使int变量值恰好等于0也不行。 123int zero=0；int *p=zero;//错误：不能直接把int变量赋值给指针（更不能把字面值常量直接赋值给指针）int *p=&amp;zero; void*是一种特殊的指针类型，可用于存放任意对象的指针，但是没办法访问内存空间的对象，因为无法确定这个对象到底是什么类型。 引用本身不是一个对象，因此不能定义指向引用的指针，但指针是对象，所以存在对指针的引用： 123456int i=42;int a=3;int *p;int *&amp;r=p;//r是一个引用，r引用的是一个指针，r引用的是一个int指针（面对一条比较复杂的指针或引用的声明语句时从右向左阅读有助于弄清它的真实含义）r=&amp;i;//r引用了一个指针，因此给r赋值就是零p指向i*r=a;或者*r=3;//解引用r得到i，也就是p指向的对象，将i的值改为3 默认状态下，const对象仅在文件内有效，如果想在多个文件之间共享const对象，必须在每个文件中变量的定义之前添加extern关键字。 1234//file1.cc定义并初始化了一个常量，该常量能被其他文件访问extern const int bugSize=fcn();//file2.cc头文件extern const int bufSize;//与file1.cc中定义的bufSize是同一个 可以利用const对象初始化非常量，但是对const的引用必须是const，且引用及其对应的对象都不能更改，指向常量的指针也必须是const。但是指向常量的指针或者引用可以绑定到一个非常量上。 1234567int i=42;const int ci=i;//正确：i的值被拷贝给了ciint j=ci;//正确：ci的值被拷贝给了jconst int &amp;r1=ci;//正确：引用及其对应的对象都是常量r1=42;//错误：r1是对常量的引用int &amp;r2=ci;//错误：试图让一个非常量引用指向一个常量const int &amp;r3=i;//正确：const int&amp; 可以绑定到一个普通int上 const引用一个非const对象，不允许通过const引用修改非const对象的值，但是允许通过其他途径改变它的值。 12345double i=42;int &amp;r1=i;const int &amp;r2=i;//实际实现过程是：（1）const int tmp=i;//由双精度浮点数生成一个临时的整型变量 （2）const int &amp;r2=tmp;//让r2绑定这个变量 r1=0;//r1非常量，i的值修改为0r2=0;//错误：r2是一个常量引用不允许修改i的值 指向常量的指针！=常量指针，常量指针必须初始化化，且一旦初始化则它的值（存放在指针中的地址）不再改变，但是如果常量指针指向的是一个一般的非常量整数，就能通过常量指针修改这个非常量整数。 1234567int i=0;int *const p=&amp;i;//p将一直指向iconst double pi=3.14159;const double *const pip=&amp;pi;//pip是一个指向常量对象的常量指针*p=3;//把i的值改为3*pip=4;//错误：pip指向的是一个常量对象p=&amp;pi;//p是一个常量指针 顶层const可以表示任意的对象是常量。 底层const则是与指针和引用等符合类型的基本类型部分有关。指针类型既可以是顶层const（表示指针本身是一个常量）也可以是底层const（表示所指的对象是一个常量）。 123456int i=0;int *const p1=&amp;i;//不能改变p1的值，这是一个顶层constconst int ci=42;//不能改变ci的值，这是一个顶层constconst int *p2=&amp;ci;//允许改变p2的值，这是一个底层constconst int *const p3=p2;//靠右的const是顶层const,靠左的是底层const(从你的右手到左手)const int &amp;r=ci;//用于声明引用的const都是底层const(指针是对象而引用不是) 字面值是常量表达式（字面值类型：算术类型、引用、指针；自定义类型如string、Sales_item则不属于字面值类型,也就不能被定义成constexpr），用常量表达式初始化的const对象也是常量表达式，应声明成constexpr(由它的数据类型和初始值共同决定)。尽管指针和引用都可以被定义成constexpr，但它们的初始值却受到严格限制，一个constexpr指针的初始值必须是nullptr或0，或者是存储于某个固定地址中的对象。 constexpr仅对指针有效，与指针所指的对象无关： 12345constexpr int *np=nullptr;//np是一个指向整数的常量指针，其值为空int j=0;constexpr int i=42;//i的类型是整型常量constexpr const int *p=&amp;i;//p是常量指针，指向整数常量iconsterxpr int *p1=&amp;j;//p1是常量指针，指向整数j 类型别名，不能把类型别名替换成它原来的样子 1234typedef char *pstring;const pstring cstr=0;//cstr是指向char的常量指针，顶层constconst pstring *ps;//ps是一个指针，它的对象时指向char的常量指针const char *cs=0;//cs是一个指向const char的指针，底层const auto一般会忽略顶层const,保留底层const。 decltype返回操作数的数据类型（包括顶层const和引用）。变量加上一层或多层括号，编译器就会把它当成给一个表达式，decltype的表达式如果是加上了括号的变量，结果是引用。 12345int i=42,*p=&amp;i,&amp;r=i;decltype(r+0) b;//正确：加法的结果是int，因此b是一个未初始化的intdecltype(*p) c;//错误c是int&amp;，必须初始化decltype((i)) d;//错误：d是一个int&amp;,必须初始化decltype(i) e;//正确：e是一个未初始化的int 第三章 字符串、向量和数组 cin读入字符串遇到空白符停止，getline遇到换行符停止（换行符也被读进来但是不保留）。 字符串字面值与string是不同类型。 可以用列表中元素的拷贝替换v1中的元素或初始化vector，但是列表不能作为形参vector直接使用。 1v1=&#123;a,b,c&#125;; 范围for语句体内不应该改变其所遍历序列的大小。 迭代器不同于指针，获取迭代器不是取地址符。begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，返回const_iterator（能读不能修改它所指的元素值或直接使用cbegin cend）,否则返回iterator（能读能写）。如果对象不是常量，均可。end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用。数组也可以使用begin（arr）和end（arr）获取指向数组首元素的指针和指向数组尾元素的下一位置的指针。 12*iter 返回迭代器iter所指元素的引用iter-&gt;mem 解引用iter并获取该元素的名为mem的成员，等价于（*iter）.mem different_type由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离。使用迭代器可进行二分查找。ptrdiff_t是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离。指针和迭代器都可进行算术运算。允许给空指针加上或者减去一个值为0的整型常量表达式，两个空指针也允许彼此相减，结果为0。 123456789usigned cnt=42;constexpr usigned sz=42;int *parr[sz];//含有42个整型指针的数组string bad[cnt];//错误：cnt不是常量表达式string strs[get_size()];//当get_size是constexpr时正确；否则错误auto n=end(arr)-begin(arr);//auto是ptrdiff_t类型，n=arr中元素的数量int *ip=arr;//等价于int *ip=&amp;arr[0];int *p=arr+sz;//正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置；使用警告：不要解引用！int *pz=arr+sz+1;//错误：arr只有sz个元素，pz的值未定义 如果函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。不允许使用一个数组为另一个内置类型的数组赋初值，但是允许使用数组来初始化vector对象。 1234vector&lt;int&gt; vec(begin(arr)+1,end(arr));//等价于vector&lt;int&gt; vec(arr+1,end(arr))int a[]=&#123;0,1,2&#125;;int a2[]=a; //错误：不允许使用一个数组初始化另一个数组a2=a; //错误：不能把一个数组直接赋值给另一个数组 字符串字面值会自动添加表示字符串结束的空字符。strcpy/strcmp/strlen/strcat此类函数可以传入字符串或者指向以空字符作为结束的数组的指针。比较标准库string对象的时候用的是普通的关系运算符合相等性运算符，把这些运算符用在比较两个C风格字符串上，实际比较的将是指针而非字符串本身。不能用string对象初始化char*，但是可以使用c_str，如果执行完c_str()函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。 12345678910111213141516char a1[]=&#123;'c','+','+'&#125;;//列表初始化,没有空字符char a2[]=&#123;'c','+','+','\\0'&#125;;//列表初始化,含有显式的空字符char a3[]=\"c++\";//自动添加表示字符串结束的空字符const char a4[6]=\"daniel\";//错误：没有空间可存放空字符int &amp;refs[10]=/*?*/;//错误：不存在引用的数组char (&amp;arrRef)[3]=a1;//arrRef引用一个含有3个字符的数组int *(&amp;arry)[42]=parr;//arry是数组的引用，该数组含有42个指针cout&lt;&lt;strlen(a1)&lt;&lt;endl;//错误：啊没有以空字符结束string s1=\"abcd\";string s2=\"cdr\";if(s1&lt;s2)//trueconst char c1[]=\"abcd\";const char c2[]=\"bcde\";if(c1&lt;c2)//未定义：试图比较两个无关地址char *str=s1;//错误const char *str=s1.c_str;//正确，用const char*保证字符数组内容不改变；如果后续操作改变了s1的值就可能让之前返回的数组失去效用 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组；当使用decltype()时上述转换不会发生。 123456int ia[]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;auto ia2(ia);//ia2是一个整型指针，指向ia的第一个元素ia2=42;//错误：ia2是一个指针，不能用整数给指针赋值decltype(ia) ia3=&#123;0,1,2,3,4,5,6,7,8,9&#125;；ia3=p;//错误：不能用整型指针给数组赋值ia3[4]=i;//正确：把i的值赋给ia3的一个元素 数组内置的下标运算符所用的索引值不是无符号类型，这一点与string和vector不同。 123int *p=&amp;a[2];int j=p[1];//等价于*（p+1)，就是a[3]int k=p[-2];//p[-2]是a[0]表示的那个元素 多维数组的初始化和下标引用 123456789int a[2][3]=&#123; &#123;0,1,2&#125;, &#123;3,4,5&#125;&#125;;int a[2][3]=&#123;0,1,2,3,4,5&#125;;//内层嵌套着的花括号并非完全必要int a[2][3]=&#123;&#123;0&#125;,&#123;3&#125;&#125;;//显示初始化每行的首元素int （&amp;row)[3]=a[1];把row绑定到a的第二个3元素数组上int (*p)[3]=a;//p指向含有3个整数的数组p=&amp;a[1];//p指向a的尾元素 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型，因为数组名会被自动地转换成指向该数组首元素的指针。 1234567891011121314151617181920212223242526272829303132//正确for(const auto &amp;row:a)&#123; for(auto clo:row)&#123; cout&lt;&lt;col&lt;&lt;endl; &#125;&#125;//错误：row的类型是int*,显然内层循环不合法for(const auto row:a)&#123; for(auto clo:row)&#123; cout&lt;&lt;col&lt;&lt;endl; &#125;&#125;//p指向含有3个整数的数组，*p解引p得到指向内层数组首元素的指针for(auto p=a;p!=a+2;++p)&#123; for(auto q=*p;q!=*p+3;q++)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125;//简洁版for(auto p=begin(a);p!=end(a);p++)&#123; for(auto q=begin(*p);q!=end(*p);q++)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125;//类型别名简化多维数组的指针using int_arr=int[4];typedef int int_arr[4];//等价的typedegf声明for(int_arr *p=a;p!=a+2;++p)&#123; for(int *q=*p;q!=*p+3;++q)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125; 第四章 表达式 当一个对象被用作右值时，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。使用关键字decltype的时候左值右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。eg.假定p的类型是int，因为解引用运算符生成左值，所以decltype(\\p)的结果是int&amp;。另一方面，因为取地址符生成右值，所以decltype(&amp;p)的结果是int**,也就是说，结果是一个指向整型指针的指针。 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。 123cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;++i&lt;&lt;endl; //产生未定义的行为，可能先计算i再计算i++，或者先计算i++再计算i,或其他不可预知行为，所以编译器生成什么样的代码程序都是错的*beg=toupper(*beg++); //产生未定义的行为，可能先求左侧的值或先求右侧的值，也可能采取别的什么方式处理它*++iter; //正确：先递增再解引用 后置递增运算符的优先级高于解引用运算符，因此pbeg++等价于\\（pbeg++)，先自增，然后返回初始值的副本作为其求值结果，此时解引用运算符的运算对象是pbeg未增加之前得值，最终这条语句输出pbeg开始时指向的那个元素，并将指针向前移动一个位置。 解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号，如果没有括号，代码的含义就大不相同了。 12(*p).size(); //正确*p.size(); //错误：p是一个指针，它没有名为size成员 左移运算符（&lt;&lt;）在右侧插入值为0的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。 sizeof运算符返回一条表达式或一个类型名字所占的字节数，满足右结合律，其所得值是一个size_t类型的常量表达式。在sizeof的运算对象中解引用一个无效指针仍然是一种安全行为，因为指针实际上并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。sizeof运算不会把数组转换成指针来处理，对string和vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中元素的个数。 123sizeof *p; //p所指空间类型的大小，即sizeof(Sales_data),等价于sizeof(*p)，即使p是一个无效（即未初始化）的指针constexpr size_t sz=sizeof(ia)/sizeof(*ia); //返回数组ia的元素数量int arr[sz]; //sizeof返回一个常量表达式 指向任意非常量的指针能转换成void；指向任意对象的指针能转换成const void\\。 123if(cp) //如果指针cp不是0，条件为真while(*cp) //如果*cp不是空字符，条件为真while(cin&gt;&gt;s) //布尔值决定于输入流的状态，最后一次读入成功，true;反之，false 显式转换：cast_name(expression)，cast-name是static_cast（任何具有明确定义的类型转换，只要不包含底层const）/dynamic_cast（支持运行时类型识别）/const_cast（只能改变运算对象的底层const）/reinterpret_cast（通常为运算对象的位模式提供较低层次上的重新解释）中的一种。除了在有重载函数的上下文中使用const_cast无可厚非，其他强制类型转换都不应该频繁使用。 12345678int i,j;double slope=static_cast&lt;double&gt;(j)/i; //进行强制类型转换以便执行浮点数除法void* p=&amp;d; //任何非常量对象的地址都能存入void*double *dp=static_cast&lt;double*&gt;(p); //正确：将void*转换回初始的指针类型const char *pc;char *P=const_cast&lt;char*&gt;(pc); //正确：但是通过p写值时未定义的行为int *ip;char *pc=reinterpret_cast&lt;char*&gt;(ip); //牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误，eg:string str(pc)，具有高危性 第五章 语句 一般不要省略case分支的break语句，否则，程序将跨越case标签的边界；如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧跟在default标签后面的语句。 如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是违法行为。因此c++语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域的另一个位置。 for语句头能省略掉init-statement、condition和expression中的任何一个（或全部）。省略condition的效果等价于在条件部分写了一个true，则循环体内必须有语句负责退出循环。 123vector&lt;int&gt; v;for(int i;cin&gt;&gt;i;/*表达式为空*/) //条件部分能改变i值，所以这个循环无须表达式部分 v.push_back(i); 尽量不要使用goto语句，因为它使得程序既难理解又难修改。 try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问。 12345678910111213141516while(cin&gt;&gt;item1&gt;&gt;item2)&#123; try&#123; //执行添加两个Sales_item对象的代码 //如果添加失败，代码抛出一个runtime_error异常 &#125;catch(runtime_error err)&#123; cout&lt;&lt;err.what() &lt;&lt;\"\\nTry Again? Enter y or n\"&lt;&lt;endl; char c; cin&gt;&gt;c; if(!cin || c=='n') break;跳出while循环 &#125;&#125;//类型runtime_error是标准库异常类型的一种，必须提供一个string对象或者C风格的字符串初始化runtime_error的对象if(item1.isbn()!=item2.isbn()) throw runtime_error(\"Data must refer to same ISBN\"); 标准库异常类只定义了几种运算，包括创建或拷贝异常类型对象，以及为异常类型的对象赋值。异常类型只定义了一个名为what的成员函数，该函数没有参数，返回值是一个指向C风格字符串的const char*。该字符串的目的是提供关于异常的一些文本信息。如果异常类型有一个字符串初始值，则what返回该字符串。对于其他无初始值的异常类型来说，what返回的内容由编译器决定。 寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果最终还是没找到任何匹配的catch子句，程序转到名为terminate的标准函数库。对于那些没有任何try语句块定义的异常，系统同样会调用terminate函数并终止当前程序的执行。 第六章 函数 局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。 参数传递包括值传递和引用传递（引用传递直接传入对象而无须传递对象的地址，eg.可以给函数传入一个额外的引用实参，令其保存字符出现的次数）。指针传递属于值传递，当执行指针拷贝操作时，拷贝的是指针的值，拷贝之后两个指针是不同的指针，因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指的对象，但是改变局部拷贝的值并不能改变实参以及实参所指对象。 顶层const可以初始化非const,非const可以初始化顶层const,所以实参初始化形参时就会忽略掉顶层const.想调用引用版本的reset(int &amp;i)只能使用int类型的对象，而不能使用字面值、求值结果为int的表达式、需要转换的对象或者const int类型的对象，类似的，想要调用指针版本的reset(int p)只能使用int\\。 12345678910111213141516171819void fcn(const int i)&#123;/*fcn能读取i,但是不能向i写值*/&#125;void fcn(int i)&#123;/*值传递本身写值就没有意义*/&#125; //错误：重复定义了fcn(int)Record lookup(Acount*);Record lookup(Acount* const); //错误：重复声明Record lookup(Acount*);Record lookup(const Acount*); //新函数，作用于常量引用Record lookup(Acount&amp;);Record lookup(const Acount&amp;); //新函数，作用于指向常量的指针int i=1;const int ci=42; //不能改变ci的值这是一个顶层constconst int *p2=&amp;ci; //允许改变p2的值，这是一个底层constconst int *const p3=p2; //靠右的是顶层const，靠左的是底层constconst int &amp;r=ci; //用于声明引用的const都是底层const（从这里也说明不能使用指向const int对象的指针初始化int*因为int*没有底层const,eg.void reset(int *p);reset(&amp;ci)错误）int *p=p3; //错误：p3包含底层const的定义，而p没有p2=p3; //正确：p2和p3都是底层constp2=&amp;i; //正确：int*能转换成const int*int &amp;r=ci; //错误：普通的int&amp;不能绑定到int常量上const int &amp;r2=i; //正确：const int&amp;可以绑定到一个普通的int上reset(42)； //不能把普通引用绑定到字面值上，只能把const引用绑定到字面值上 数组不能拷贝所以无法以值传递的方式传递数组,因为数组会被转换成指针，所以我们为函数传递一个数组时实际上传递的是指向数组元素的指针。 1234567//尽管形式不同，但是三个print函数是等价的，每个函数都有一个const int*类型的唯一形参void print(const int*);void print(const int[]); //可以看出了，函数的意图是作用于一个数组void print(const int[10]); //这里的维度表示我们期望数组含有多少元素，实际不一定int i=0,j[2]=&#123;0,1&#125;;print(&amp;i); //正确：&amp;i的类型是int*print(j); //正确：j转换成int*并指向j[0] c++允许将变量定义成数组的引用，同理，形参也可以是数组的引用（维度是类型的一部分）。因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。 123456f(int &amp;arr[10])&#123;/*...*/&#125;; //错误：将arr声明成了引用的数组f(int (&amp;arr)[10])&#123;/*...*/&#125;; //正确：arr是具有10个整数的整型数组的引用int k[10]=&#123;0,1,2,3,4,5,6,9&#125;;print(&amp;i); //错误：实参不是含有10个整数的数组print(j); //错误：实参不是含有10个整数的数组print(k); //正确：实参是含有10个整数的数组 多维数组实际上是数组的数组，所以由多维数组名转换得到的指针实际上是指向第一个内层数组的指针。和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，由于首元素本身就是一个数组，指针就是一个指向数组的指针，数组第二维（以及后面所有的维度）的大小都是数组类型的一部分，不能省略。 123456int a[3][4];int (*p)[4]=ia; //p指向含有4个整数的数组p=&amp;a[2]; //p指向a的尾元素int *matrix[10]; //错误：10个指针构成的数组int (*matrix)[10]; //正确：指向含有10个整数的数组指针void print(int matrix[][10],int rowSize)&#123;/*...*/&#125;; //matrix的声明看起来是一个二维数组，实际上形参是一个指向含有10个整数的数组指针，等价于int (*matrix)[10] 如果函数的实参数量未知，但是全部实参的类型都相同，可以采用initializer_list类型的形参，initializer_list是一种标准库类型，用于表示某种特定类型的值的数组，initializer_list类型定义在同名的头文件中，拷贝或者赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 1234initializer_list&lt;T&gt; lst2; //默认初始化：T类型元素的空列表initializer_list&lt;T&gt; lst&#123;a,b,c...&#125; //lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是constlst2(lst);lst2=lst; 返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。不要返回局部对象的引用或指针，局部变量在函数结束后所占用的存储空间也随之被释放掉，函数终止意味着局部变量的引用将指向不再有效的内存区域。 1234567891011121314151617181920212223const string &amp;mainp()&#123; string ret; //以某种方式改变一下ret if(ret.empty())&#123; return ret; //错误：返回局部对象的引用 else return \"Empty\"; //错误：\"Empty\"是一个局部临时量 &#125;&#125;//引用返回左值：调用一个返回引用的函数得到左值，其他类型得到右值可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值char &amp;get_val(string &amp;str,string::size_type ix)&#123; return str[ix]; //get_val假定索引值是有效的&#125;int main()&#123; string a(\"a value\"); get_val(s,0)='A'; cout&lt;&lt;s&lt;&lt;endl; //输出A value&#125;//c++11规定函数可以返回花括号包围的值的列表vector&lt;string&gt; process()&#123; return &#123;&#125;; //返回一个空vector return &#123;\"functionX\",\"okay\"&#125;; //返回列表初始化的vector对象&#125; type (*function(parameter_list))[dimension]声明一个返回数组指针的函数 1234567typedef int arrT[10];using arrT=int[10];//func返回一个指向含有10个整数的数组指针arrT* func(int i); auto func(int i)-&gt;int(*)[10];int odd[]=&#123;1,2,3,4,5,6,7,8,9,0&#125;decltype(odd) *func(int i); //decltype不负责把数组类型转换成对应的指针 不允许两个函数除了返回类型外其他所有的要素都相同，对于重载函数来说，应该在形参数量或者形参类型上有所不同。 一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 123456789sz wd=80;char def=' ';sz ht();string screen(sz=ht(),sz=wd,char def);void f()&#123; def='*'; //改变默认参数值 sz wd=100; //隐藏了外层定义的wd,但是没有改变默认值，该局部变量与传递给screen的默认实参没有任何关系 window=screen(); //调用screen(ht(),80,'*')&#125; constexpr函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。内联函数和constexpr函数可以在程序中多次定义，通常定义在头文件中。 123456constexpr int new_sz()&#123;return 42;&#125; //编译器能在程序编译时验证new_sz函数返回的是常量表达式，所以可以用new_sz函数初始化constexpr类型的变量fooconstexpr int foo = new_sz();constexpr size_t scale(size_t cnt)&#123;return new_sz()*cnt;&#125; //允许constexpr函数的返回值并非一个常量，当scale的实参是常量表达式时，它的返回值也是常量表达式；反之，则不然int arr[scale(2)]; //正确：scale（2）是常量表达式int i=2; //i不是常量表达式int a2[scale(i)]; //错误：scale(i)不是常量表达式 编译器会因为函数调用具有二义性而拒绝其请求；为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下所示： 精确匹配，包括以下情况： 实参类型和形参类型相同。 实参从数组类型或函数类型转换成对应的指针类型 向实参添加顶层const或者从实参中删除顶层const 通过const转换实现的匹配 通过类型提升实现的匹配 通过算术类型转换或指针转换实现的匹配（所有算术类型转换的级别都一样，例如,从int向usigned int的转换并不比从int向double的转换级别高） 通过类类型转换实现的匹配 当我们把函数名作为一个值使用时，该函数自动转换成指针。 123456789bool lengthCompare(const string &amp;,const string &amp;);bool (*pf)(const string &amp;,const string &amp;); //未初始化pf=lengthCompare; //pf指向名为lengthCompare的函数（返回类型和形参列表要精确匹配）pf=&amp;lengthCompare; //等价的赋值语句：取地址符是可选的//调用lengthCompare函数bool b1=pf(\"hello\",\"good\");bool b2=(*pf)(\"hello\",\"goodbye\");bool b3=lengthCompare(\"hello\",\"goodbye\");pf=0; //正确：pf不指向任何函数 函数的形参：和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用。 12345678910void useBigger(const string &amp;s,bool pf(const string &amp;,const string &amp;)); //第三个形参是函数类型，它会自动地转换成指向函数的指针void useBigger(const string &amp;s,bool (*pf)(const string &amp;,const string &amp;)); //等价的声明：显式地将形参定义成指向函数的指针//Func和Func2是函数类型typedef bool Func(const string &amp;,const string &amp;);typedef decltype(lengthCompare) Func2;//FuncP和FuncP2是指向函数的指针typedef bool (*FuncP)(const string&amp;,const string&amp;);typedef decltype(lengthCompare) *FuncP2; //decltype不会将函数类型自动转换成指针类型void useBigger(const string&amp;,Func); //编译器自动地将Func表示的函数类型转换成指针void useBigger(const string&amp;,FuncP); 返回指向函数的指针：和函数类型的形参不一样，返回类型不会自动地转换成指针，我们必须显式地将返回类型指定为指针。 1234567using F=int(int*,int); //F是函数类型，不是指针using PF=int(*)(int*,int); //PF是指针类型PF f(int); //正确：PF是指向函数的指针，f返回指向函数的指针F f(int); //错误：F是函数类型，f不能返回一个函数F *f(int); //正确：显式地指定返回类型是指向函数的指针int (*f(int))(int*,int); //可以直接声明f,按照由内向外的顺序阅读这条声明：f有形参列表，所以f是个函数；f前面有*，所以f返回一个指针；指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int.auto f(int)-&gt;int(*)(int*,int); //使用尾置返回类型的方式声明一个返回函数指针的函数 编译器将所有.cpp文件编译为.obj或.o文件再把对象文件链接在一起形成可执行文件.exe或.out。如果.cpp中有#include X.h文件，那么第一步预处理会把X.h代码粘贴到.cpp中代替#include语句。 如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件。 12345678g++ factMain.cc fact.cc //生成 factMain.exe or a.outg++ factMain.cc fact.cc -o main //生成 main or main.exe//分离式编译g++ -c factMain.cc //生成factMain.og++ -c fact.cc //生成fact.og++ fact.o factMain.o //生成factMain.exe or a.outg++ factMain.o fact.o -o main //生成 main or main.exe 第七章 类 只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数；当既需要其他形式的构造函数，也需要默认的构造函数时使用 Sales_data() = defalut;来要求编译器生成构造函数。 如果类包含内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。 使用class和struct定义类唯一的区别就是默认的访问权限。struct关键字在第一个访问说明符之前的成员是public；class关键字在第一个访问说明符之前的成员是private。 class默认的继承访问权是private,struct默认的是public。 class关键字可用于定义模板参数，就像typename，但struct关键字不能。 友元的声明只能出现在类定义的内部（最好在类定义开始或者结束前的位置集中声明友元）仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，必须在友元声明之外再转名对函数进行一次声明。每个类负责控制自己的友元类或友元函数，友元关系不存在传递性。 12345678910111213141516class Screen&#123; //首先定义Window_mgr类，其中声明cleat函数，但不能定义它。在 //clear使用Screen的成员之前必须先声明Screen。 friend void Window_mgr::clear(ScreenIndex); //Screen类的剩余部分&#125;//最后定义clear，此时它才可以使用Screen的成员struct X&#123; friend void f()(/*友元函数可以定义在类的内部＊/&#125; X()｛f();｝ //错误:还没有被声明 void g(); void h();&#125;;void X::g()( return f();&#125; //错误:f还没有被声明void f(); //声明那个定义在X中的函数void X::h()&#123;return f();&#125; //正确:现在王的声明在作用域 使用类型别名等价地声明一个类型名字 12typedef std::string::size_type pos;using pos=std::string::size_type; 在变量声明中加入mutable关键字能修改类的某个数据成员，即使是在一个const函数内。 常量引用不能修改对象。常量对象不能调用非常量函数，但是非常量对象能调用常量函数。 12345怎么选择使用哪种返回传值方式-&gt;拷贝开销大吗 -&gt;不大-&gt;按值返回return-by-value(拷贝，c++11自动转化为移动来节省拷贝开销) -&gt;很大-&gt;希望对返回值的内部数据进行修改吗(引用避免拷贝开销) -&gt;不需要-&gt;按常量引用返回return-by-constant-reference -&gt;需要-&gt;按引用返回return-by-reference 即使两个类的成员列表完全一致，它们也是不同的类型。我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类名跟在关键字class或struct后面。 12Sales_data item; //默认初始化Sales_data类型的对象class Sales_data item; //一条等价的声明 只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被人为是声明过了(但尚未定义)，因此类允许包含指向它自身类型的引用或指针。 12345class Link_screen&#123; Screen window; Link_screen *next; Link_screen &amp;other;&#125;; 类内初始化，必须使用=的初始化形式(初始化Screen的数据成员时所用的)或者花括号括起来的直接初始化形式(初始化screens所用的)。Screen的构造函数接受两个尺寸参数和一个字符值，创建了一个给定大小的空白屏幕对象。 12private: std::vector&lt;Screen&gt; screens&#123;Screen(24,80,' ')&#125;; 第十章 泛型算法 泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作，所以算法容器中保存的元素，也可能在容器中移动元素，但永远不会直接添加或删除元素。 replace_copy保持原序列不变，接受额外第三个迭代器参数，之处调整后序列的保存位置；back_inserter按需要增长目标序列。 1replace_copy(ilst.cbegin(),ilst.cend,back_inserter(ivec),0,42); //ilst未改变，ivec包含ilst的一份拷贝，不过原来ilst中值为0的元素在ivec中都变为42 第十二章 动态内存、智能指针和动态数组 常量指针：指针指向的地址能改变，只能指向的内容不能改变 指针常量：指针地址不能改变，指针指向的内容可以改变 new后必须delete（传递给delete的指针必须指向动态分配的内存或者是一个空指针）；智能指针可以自动销毁 内存泄漏：内存永远不可能被归还给自由空间 不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化的形式 12shared_ptr&lt;int&gt; p1=new int(1024);//错误，隐式转换shared_ptr&lt;int&gt; p12(new int(1024));//正确，直接初始化 当将shared_ptr绑定到一个普通指针时，内存管理就交给了这个shared_ptr，就不能使用那个内置指针来访问shared_ptr指向的内存了。 unique_ptr通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique_ptr 1auto p=p2.release();//p2放弃对指针的控制权，返回指针，并将p2置空；必须记得delete(p)，此时auto代表普通指针 当创建weak_ptr时要用shared_ptr来初始化 12auto p=make_shared&lt;int&gt;(42);weak_ptr&lt;int&gt; wp(p);//wp弱共享p；p的引用计数不变 weak_ptr的lock()如果expired()为true（表示use_count==0），返回一个空shared_ptr；否则返回一个指向对象的shared_ptr 销毁动态数组时数组中的元素按逆序销毁 1delete [] p；//p必须指向一个动态分配的数组或为空 动态分配一个空数组是合法的 12char arr[0];//错误：不能定义长度为0的数组char *cp=new char[0];//正确：但cp不能解引用 unique_ptr支持管理动态数组，shared_ptr不支持除非提供自己定义的删除器 12unique_ptr&lt;int[]&gt; up(new int[10]());//up指向一个包含10个初始化为0的int的数组share_ptr&lt;int&gt; sp(new int[10]，[](int *p)&#123;delete [] p;&#125;);//sp指向一个包含10个未初始化的int数组，并提供一个删除器 make_shared函数构造shared_ptr对象时在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，使用一次内存分配；shared_ptr构造shared_ptr对象时需要进行两次内存分配 new：没有默认构造函数的类不能动态分配数组 allocator:定义在memory中，将内存分配和对象构造分离开来 管理“动态数组”时，需要制定Deleter以使用delete[]操作符销毁内存，因为shared_ptr并没有针对数组的特化版本，而unique_ptr有针对数组的特化版本。我们常常需要对动态数组中的某一个元素进行操作，但shared_ptr没有提供[]操作符，不过我们可以使用 sp.get()先获取原始指针，再对原始指针进行下标操作。而unique_ptr对动态数组提供了支持，指定删除器是一个可选项。也可以直接使用下标操作 make_unique完美传递了参数给对象的构造函数，从一个原始指针构造出一个std::unique_ptr，返回创建的std::unique_ptr。这个形式的函数不支持数组和定制删除器（见条款18） 要解决环形引用的问题，没有特别好的办法，一般都是在可能出现环形引用的地方使用weak_ptr来代替shared_ptr。weak_ptr指向shared_ptr指针指向的对象的内存，却并不拥有该内存。 但是，使用weak_ptr成员lock，则可返回其指向内存的一个shared_ptr对象，且在所指对象内存已经无效时，返回指针空值（nullptr）。由于weak_ptr是指向shared_ptr所指向的内存的，所以，weak_ptr并不能独立存在 文本查询程序——优质程序 第十五章 面向对象程序设计 类型转换与继承 虚函数：通常情况下，如果我们不使用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到，因为连编译器也无法确定到底会使用哪个虚函数。virtual函数意味着“接口必须被继承”，non-virtual函数意味着“接口和实现都必须被继承”。 抽象基类 访问控制与继承 继承中的类作用域 构造函数与拷贝控制 虚析构函数：虚析构函数阻止合成移动操作 合成拷贝控制与继承 派生类的拷贝控制成员 继承的构造函数 容器与继承 一般在容器中放置（智能）指针而非对象 Basket 文本查询程序再探 第十六章 模板与泛型编程 模板实参推断 重载与模板 可变参数模板 模板特例化","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Hexo+GitHub+NexT搭建博客","slug":"Hexo-GitHub-nexT搭建博客","date":"2020-03-23T14:26:43.000Z","updated":"2020-03-25T17:04:36.109Z","comments":true,"path":"2020/03/23/Hexo-GitHub-nexT搭建博客/","link":"","permalink":"http://yoursite.com/2020/03/23/Hexo-GitHub-nexT%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask on GitHub. （一）搭建博客操作过程 安装 Node.js 和 Git。 Node.js：https://nodejs.org/zh-cn Git：https://git-scm.com/downloads","text":"Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask on GitHub. （一）搭建博客操作过程 安装 Node.js 和 Git。 Node.js：https://nodejs.org/zh-cn Git：https://git-scm.com/downloads 下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。 安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git --version出现版本号说明安装成功。 创建GitHub Pages仓库 GitHub 主页右上角加号 -&gt; New repository： Repository name 中输入 用户名.github.io 勾选 “Initialize this repository with a README” 勾选public Description 选填 填好后点击 Create repository 创建。创建后默认自动启用 HTTPS，博客地址为：https://用户名.github.io,浏览器输入博客地址正常显示用户名.github.io。 本地安装Hexo博客程序 新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。打开该文件夹，右键 -&gt; Git Bash Here。 使用 npm 一键安装 Hexo 博客程序： 1npm install -g hexo-cli Mac 用户需要管理员权限（sudo），运行这条命令： 1sudo npm install -g hexo-cli 安装时间有点久（真的很慢！），界面也没任何反应，耐心等待 Hexo初始化和本地预览 初始化并安装所需组件： 12hexo init # 初始化npm install # 安装组件 完成后依次输入下面命令，启动本地服务器进行预览： 12hexo g # 生成页面hexo s # 启动预览 访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功！ 部署Hexo到GitHub Pages 本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。 首先安装 hexo-deployer-git： 1npm install hexo-deployer-git --save 然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下： 1234deploy: type: git repository: https:&#x2F;&#x2F;github.com&#x2F;用户名&#x2F;用户名.github.io branch: master 完成后运行 hexo d 将网站上传部署到 GitHub Pages,访问我们的 GitHub 域名 https://用户名.github.io 就可以看到 Hexo 网站了。 更换主题 在 Themes | Hexo 选择一个喜欢的主题，比如 NexT，进入网站目录打开 Git Bash Here 下载主题： 1git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next 然后修改 _config.yml 中的 theme 为新主题名称 next，发布。 （二）Hexo常用命令123456789101112131415161718192021222324252627hexo n &quot;name&quot; # 新建文章&#x3D;hexo new &quot;name&quot; hexo new page &quot;name&quot; # 新建页面hexo g # 生成页面&#x3D;hexo generatehexo d # 部署&#x3D;hexo deployhexo g -d # 生成页面并部署hexo s --debug # 调试模式下本地预览，可也用非调试模式hexo serverhexo clean # 清除缓存和已生成的静态文件hexo help # 帮助npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP&#x2F;&#x2F;新建文章三连hexo n &quot;name&quot; hexo g hexo s --debug&#x2F;&#x2F;预览效果满意则推到git上hexo d&#x2F;&#x2F;部署网站三连hexo clean hexo g hexo d （三）常见问题和注意事项1、Hexo 设置显示文章摘要，首页不显示全文 Hexo 主页文章列表默认会显示文章全文，浏览时很不方便，可以在文章中插入 `` 进行分段。该代码前面的内容会作为摘要显示，而后面的内容会替换为 “Read More” 隐藏起来。 2、设置网站图标 进入 themes/主题 文件夹，打开 _config.yml 配置文件，找到 favicon 修改，一般格式为：favicon: 图标地址。（不同主题可能略有差别） 3、修改并部署后没有效果 使用 hexo clean 清理后重新部署。 4、开启 HTTPS 后访问网站显示连接不安全？ 证书还未部署生效，等待一会儿，清除浏览器缓存再试。 5、Mac 安装 Hexo 报错无法安装 Mac 用户需要管理员权限运行，使用 sudo npm install -g hexo-cli 命令安装。 6、npm 下载速度慢，甚至完全没反应 使用 npm 安装程序等待很久也没反应，或者下载速度很慢，可以更换 npm 源为国内 npm 镜像。 临时更换方法：在 npm 安装命令后面加上： 1--registry https:&#x2F;&#x2F;registry.npm.taobao.org 7、注意格式标准 123title:(有空格)[文件名]tag:#标签-（有空格）c++ 8、设置SSH或HTTPS实现免密hexo deploy 方案一：如下图#号注释掉的代码，填写https：//账号:密码@github.com/账号/博客仓库名，实现HTTPS免密执行hexo d 方案二： 设置user.name和user.email配置信息，打开git bash输入： 12git config --global user.name \"你的GitHub用户名\"git config --global user.email \"你的GitHub注册邮箱\" 生成ssh密钥文件： 1ssh-keygen -t rsa -C \"你的GitHub注册邮箱\" 然后直接三个回车即可，默认不需要设置密码然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制。 打开GitHub_Settings_keys 页面，新建new SSH Key，随便填title,把刚复制的密钥粘贴到key,最后点击Add SSH key。 验证ssh是否设置成功： 1ssh git@github.com 配置站点的_config.yml文件，修改或添加repository值为ssh地址,填写git@github.com:账号/博客仓库名.git 9、hexo引用本地图片上传 安装一个图片路径转换的插件，这个插件名字是hexo-asset-image 1npm install https://github.com/CodeFalling/hexo-asset-image --save 打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For \"about\" page, the first part of \"src\" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info(\"update link as:--&gt;\"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(\"no src attr, skipped...\"); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 打开_config.yml文件，修改下述内容 1post_asset_folder: true 在md所在文件内新建一个同名文件，把图片放在该文件内 10、hexo+nexT的标签页面不显示 步骤按NexT主题配置操作 _config.yml中menu下||前面的空格删掉（||前面是链接，后面是图标） More info: HexoDoc MarkDown","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"NexT","slug":"NexT","permalink":"http://yoursite.com/tags/NexT/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"常用技巧","slug":"常用技巧","permalink":"http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"安装编译","slug":"安装编译","permalink":"http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"},{"name":"搭建博客","slug":"搭建博客","permalink":"http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"effective","slug":"effective","permalink":"http://yoursite.com/tags/effective/"},{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"},{"name":"截屏","slug":"截屏","permalink":"http://yoursite.com/tags/%E6%88%AA%E5%B1%8F/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"素数筛","slug":"素数筛","permalink":"http://yoursite.com/tags/%E7%B4%A0%E6%95%B0%E7%AD%9B/"},{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"Clion","slug":"Clion","permalink":"http://yoursite.com/tags/Clion/"},{"name":"Boost","slug":"Boost","permalink":"http://yoursite.com/tags/Boost/"},{"name":"Opencv","slug":"Opencv","permalink":"http://yoursite.com/tags/Opencv/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"NexT","slug":"NexT","permalink":"http://yoursite.com/tags/NexT/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}