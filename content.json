{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"MySQL","slug":"MySQL","date":"2020-03-24T06:17:11.000Z","updated":"2020-03-24T06:24:04.377Z","comments":true,"path":"2020/03/24/MySQL/","link":"","permalink":"http://yoursite.com/2020/03/24/MySQL/","excerpt":"脏读、不可重复读、幻读： 脏读：读到了别的事务回滚前的脏数据,即当前事务读到的数据是别的事务想要修改成- 为的但是没有修改成功的数据。 不可重复读：当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配.","text":"脏读、不可重复读、幻读： 脏读：读到了别的事务回滚前的脏数据,即当前事务读到的数据是别的事务想要修改成- 为的但是没有修改成功的数据。 不可重复读：当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配. 幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据，产生幻读，即当前事务读第一次取到的数据比后来读取到数据条目少。 不可重复读和幻读比较：两者有些相似，但是前者针对的是update或delete，后者针对的insert。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"C++ primer重点记录","slug":"C-primer重点记录","date":"2020-03-24T05:43:26.000Z","updated":"2020-03-24T05:59:20.211Z","comments":true,"path":"2020/03/24/C-primer重点记录/","link":"","permalink":"http://yoursite.com/2020/03/24/C-primer%E9%87%8D%E7%82%B9%E8%AE%B0%E5%BD%95/","excerpt":"第一章 开始 windows或unix编译程序使用命令 cc hello.cc windows输出a.exe unix输出a.out 输入a.exe或者./a.out执行程序 运行GNU编译器的命令是g++ g++ -o hello hello.cc (-o hello给执行文件命名)","text":"第一章 开始 windows或unix编译程序使用命令 cc hello.cc windows输出a.exe unix输出a.out 输入a.exe或者./a.out执行程序 运行GNU编译器的命令是g++ g++ -o hello hello.cc (-o hello给执行文件命名) cerr 输出警告和错误消息 clog输出程序运行时的一般信息 命名空间可以避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突 使用一个istream对象作为条件，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符(EOF)，或遇到一个无效的输入时(例如读入的值不是一个整数)，istream对象的状态会变成无效，处于无效状态的istream对象会使条件变假。 1while(std::cin&gt;&gt;value) main函数返回值类型必须为int类型，为0表示成功，非0由系统定义，通常指出错误类型 编译为addItems.exe的可执行文件(UNIX中是addItems.out)，从一个名为infile的文件读取销售记录，并将结果输出写入一个名为outfile的文件中，两个文件都位于当前目录。 addItems outfile 第二章 变量和基本类型 一个字节：8bit 一个字：4或8个字节 float：一个字 double：两个字 long double：3或4个字 char与其他整型（整型包括字符、布尔和整数）不同，字符型被分为三种：char /signed char/unsigned char。char实际上表现为哪种类型由编译器决定。 c++算术类型分为两类：整型和浮点型 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8位 short 短整型 16 int 整型 16 long 长整型 32 long long 长整型 64 类型转换 赋值给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。eg:8比特大小的usigned char可以表示0至255区间内的值，如果赋了一个区间以外的值，则实际结果是该值对256取模后所得的余数。因此把-1赋给8比特大小的usigned char所得的结果是255（即256+（-1）=255）。 赋值给带符号类型一个超出它表示范围的值时，结果是未定义的。此时程序可能继续工作、可能崩溃、也可能生成垃圾数据。 如果两个运算符的运算对象类型不一致，首先把这些运算对象执行整型提升，如果结果类型匹配，无须进行进一步的转换。如果两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型运算对象转换成较大的类型。 123ival + ulval; //ival转换成usigned long，无符号类型不小于带符号类型usval + ival; //根据usigned short 和 int 所占空间的大小进行转换uival + lval; //根据usigned int 和 long 所占空间的大小进行转换 表达式里带符号类型不大于无符号类型，带符号类型会自动转换成无符号类型；带符号类型大于无符号类型时转换结果依赖于机器，eg,如果两个运算对象的类型分别是long类型和usigned int类型，long占用的空间比int更多，则usigned int 类型的运算对象转换成long类型；当带符号类型取值为负时会出现异常结果。 转义序列 \\x 后紧跟1个或多个十六进制数字，eg:“\\1234”表示一个16位的字符 \\后紧跟1、2或3个八进制数字，eg:“\\1234”表示两个字符即八进制123对应的字符和字符4 列表初始化 初始化！=赋值 1234567int a=1;int a=&#123;1&#125;;int a&#123;1&#125;;int a(1);long double ld=3.143;int a&#123;ld&#125;,b=&#123;ld&#125;;//错误：窄化转换，转换未执行，因为存在丢失信息的危险int a(ld),b=ld;//正确：转换执行，且确实丢失了部分值 变量能且仅能被定义一次，但是可以被多次声明。如果在多个文件中使用同一个变量，就必须将声明和定义分离，变量的定义必须出现在也只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，但是绝对不能重复定义。 标识符 标识符必须以字母或者下画线开头，要能体现实际含义。 变量名一般要用小写字母，如index,不要使用Index或INDEX。 用户自定义的类名一般以大写字母开头，如Sales_item。 如果标识符由多个单词组成，则单词间应有明显的区分，如student_loan或studentLoan,不要使用studentloan。 用户自定义标识符不能连续出现两个下画线，也不同以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。 按位与&amp; 或者 bitand 按位或 | 或者 bitor 异或^或者xor and_eq与=（赋值） or_eq或=（赋值） compl或者~非 not_eq不等于（赋值） xor_eq异或等于 在块作用域中使用“：：a”,因为全局作用域本身并没有名字，所以作用域左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量（即全局变量）。 引用必须被初始化，且不能更改指向值，而指针无须初始化且可以先后指向几个不同的对象。指针必须初始化，得到空指针的办法就是用字面值nullptr来初始化指针，新标准下，初始化指针最好使用nullptr,同时尽量避免NULL(在头文件cstdlib中定义的值为0的预处理器）和 0（使用NULL和0初始化指针是一样的）；把int变量直接赋值给指针是错误的操作，即使int变量值恰好等于0也不行。 123int zero=0；int *p=zero;//错误：不能直接把int变量赋值给指针（更不能把字面值常量直接赋值给指针）int *p=&amp;zero; void*是一种特殊的指针类型，可用于存放任意对象的指针，但是没办法访问内存空间的对象，因为无法确定这个对象到底是什么类型。 引用本身不是一个对象，因此不能定义指向引用的指针，但指针是对象，所以存在对指针的引用： 123456int i=42;int a=3;int *p;int *&amp;r=p;//r是一个引用，r引用的是一个指针，r引用的是一个int指针（面对一条比较复杂的指针或引用的声明语句时从右向左阅读有助于弄清它的真实含义）r=&amp;i;//r引用了一个指针，因此给r赋值就是零p指向i*r=a;或者*r=3;//解引用r得到i，也就是p指向的对象，将i的值改为3 默认状态下，const对象仅在文件内有效，如果想在多个文件之间共享const对象，必须在每个文件中变量的定义之前添加extern关键字。 1234//file1.cc定义并初始化了一个常量，该常量能被其他文件访问extern const int bugSize=fcn();//file2.cc头文件extern const int bufSize;//与file1.cc中定义的bufSize是同一个 可以利用const对象初始化非常量，但是对const的引用必须是const，且引用及其对应的对象都不能更改，指向常量的指针也必须是const。但是指向常量的指针或者引用可以绑定到一个非常量上。 1234567int i=42;const int ci=i;//正确：i的值被拷贝给了ciint j=ci;//正确：ci的值被拷贝给了jconst int &amp;r1=ci;//正确：引用及其对应的对象都是常量r1=42;//错误：r1是对常量的引用int &amp;r2=ci;//错误：试图让一个非常量引用指向一个常量const int &amp;r3=i;//正确：const int&amp; 可以绑定到一个普通int上 const引用一个非const对象，不允许通过const引用修改非const对象的值，但是允许通过其他途径改变它的值。 12345double i=42;int &amp;r1=i;const int &amp;r2=i;//实际实现过程是：（1）const int tmp=i;//由双精度浮点数生成一个临时的整型变量 （2）const int &amp;r2=tmp;//让r2绑定这个变量 r1=0;//r1非常量，i的值修改为0r2=0;//错误：r2是一个常量引用不允许修改i的值 指向常量的指针！=常量指针，常量指针必须初始化化，且一旦初始化则它的值（存放在指针中的地址）不再改变，但是如果常量指针指向的是一个一般的非常量整数，就能通过常量指针修改这个非常量整数。 1234567int i=0;int *const p=&amp;i;//p将一直指向iconst double pi=3.14159;const double *const pip=&amp;pi;//pip是一个指向常量对象的常量指针*p=3;//把i的值改为3*pip=4;//错误：pip指向的是一个常量对象p=&amp;pi;//p是一个常量指针 顶层const可以表示任意的对象是常量。 底层const则是与指针和引用等符合类型的基本类型部分有关。指针类型既可以是顶层const（表示指针本身是一个常量）也可以是底层const（表示所指的对象时一个常量）。 123456int i=0;int *const p1=&amp;i;//不能改变p1的值，这是一个顶层constconst int ci=42;//不能改变ci的值，这是一个顶层constconst int *p2=&amp;ci;//允许改变p2的值，这是一个底层constconst int *const p3=p2;//靠右的const是顶层const,靠左的是底层const(从你的右手到左手)const int &amp;r=ci;//用于声明引用的const都是底层const(指针是对象而引用不是) 字面值是常量表达式（字面值类型：算术类型、引用、指针；自定义类型如string、Sales_item则不属于字面值类型,也就不能被定义成constexpr），用常量表达式初始化的const对象也是常量表达式，应声明成constexpr(由它的数据类型和初始值共同决定)。尽管指针和引用都可以被定义成constexpr，但它们的初始值却受到严格限制，一个constexpr指针的初始值必须是nullptr或0，或者是存储于某个固定地址中的对象。 constexpr仅对指针有效，与指针所指的对象无关： 12345constexpr int *np=nullptr;//np是一个指向整数的常量指针，其值为空int j=0;constexpr int i=42;//i的类型是整型常量constexpr const int *p=&amp;i;//p是常量指针，指向整数常量iconsterxpr int *p1=&amp;j;//p1是常量指针，指向整数j 类型别名，不能把类型别名替换成它原来的样子 1234typedef char *pstring;const pstring cstr=0;//cstr是指向char的常量指针，顶层constconst pstring *ps;//ps是一个指针，它的对象时指向char的常量指针const char *cs=0;//cs是一个指向const char的指针，底层const auto一般会忽略顶层const,保留底层const。 decltype返回操作数的数据类型（包括顶层const和引用）。变量加上一层或多层括号，编译器就会把它当成给一个表达式，decltype的表达式如果是加上了括号的变量，结果是引用。 12345int i=42,*p=&amp;i,&amp;r=i;decltype(r+0) b;//正确：加法的结果是int，因此b是一个未初始化的intdecltype(*p) c;//错误c是int&amp;，必须初始化decltype((i)) d;//错误：d是一个int&amp;,必须初始化decltype(i) e;//正确：e是一个未初始化的int 第三章 字符串、向量和数组 cin读入字符串遇到空白符停止，getline遇到换行符停止（换行符也被读进来但是不保留）。 字符串字面值与string是不同类型。 可以用列表中元素的拷贝替换v1中的元素或初始化vector，但是列表不能作为形参vector直接使用。 1v1=&#123;a,b,c&#125;; 范围for语句体内不应该改变其所遍历序列的大小。 迭代器不同于指针，获取迭代器不是取地址符。begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，返回const_iterator（能读不能修改它所指的元素值或直接使用cbegin cend）,否则返回iterator（能读能写）。如果对象不是常量，均可。end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用。数组也可以使用begin（arr）和end（arr）获取指向数组首元素的指针和指向数组尾元素的下一位置的指针。 12*iter 返回迭代器iter所指元素的引用iter-&gt;mem 解引用iter并获取该元素的名为mem的成员，等价于（*iter）.mem different_type由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离。使用迭代器可进行二分查找。ptrdiff_t是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离。指针和迭代器都可进行算术运算。允许给空指针加上或者减去一个值为0的整型常量表达式，两个空指针也允许彼此相减，结果为0。 123456789usigned cnt=42;constexpr usigned sz=42;int *parr[sz];//含有42个整型指针的数组string bad[cnt];//错误：cnt不是常量表达式string strs[get_size()];//当get_size是constexpr时正确；否则错误auto n=end(arr)-begin(arr);//auto是ptrdiff_t类型，n=arr中元素的数量int *ip=arr;//等价于int *ip=&amp;arr[0];int *p=arr+sz;//正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置；使用警告：不要解引用！int *pz=arr+sz+1;//错误：arr只有sz个元素，pz的值未定义 如果函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。不允许使用一个数组为另一个内置类型的数组赋初值，但是允许使用数组来初始化vector对象。 1234vector&lt;int&gt; vec(begin(arr)+1,end(arr));//等价于vector&lt;int&gt; vec(arr+1,end(arr))int a[]=&#123;0,1,2&#125;;int a2[]=a; //错误：不允许使用一个数组初始化另一个数组a2=a; //错误：不能把一个数组直接赋值给另一个数组 字符串字面值会自动添加表示字符串结束的空字符。strcpy/strcmp/strlen/strcat此类函数可以传入字符串或者指向以空字符作为结束的数组的指针。比较标准库string对象的时候用的是普通的关系运算符合相等性运算符，把这些运算符用在比较两个C风格字符串上，实际比较的将是指针而非字符串本身。不能用string对象初始化char*，但是可以使用c_str，如果执行完c_str()函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。 12345678910111213141516char a1[]=&#123;'c','+','+'&#125;;//列表初始化,没有空字符char a2[]=&#123;'c','+','+','\\0'&#125;;//列表初始化,含有显式的空字符char a3[]=\"c++\";//自动添加表示字符串结束的空字符const char a4[6]=\"daniel\";//错误：没有空间可存放空字符int &amp;refs[10]=/*?*/;//错误：不存在引用的数组char (&amp;arrRef)[3]=a1;//arrRef引用一个含有3个字符的数组int *(&amp;arry)[42]=parr;//arry是数组的引用，该数组含有42个指针cout&lt;&lt;strlen(a1)&lt;&lt;endl;//错误：啊没有以空字符结束string s1=\"abcd\";string s2=\"cdr\";if(s1&lt;s2)//trueconst char c1[]=\"abcd\";const char c2[]=\"bcde\";if(c1&lt;c2)//未定义：试图比较两个无关地址char *str=s1;//错误const char *str=s1.c_str;//正确，用const char*保证字符数组内容不改变；如果后续操作改变了s1的值就可能让之前返回的数组失去效用 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组；当使用decltype()时上述转换不会发生。 123456int ia[]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;auto ia2(ia);//ia2是一个整型指针，指向ia的第一个元素ia2=42;//错误：ia2是一个指针，不能用整数给指针赋值decltype(ia) ia3=&#123;0,1,2,3,4,5,6,7,8,9&#125;；ia3=p;//错误：不能用整型指针给数组赋值ia3[4]=i;//正确：把i的值赋给ia3的一个元素 数组内置的下标运算符所用的索引值不是无符号类型，这一点与string和vector不同。 123int *p=&amp;a[2];int j=p[1];//等价于*（p+1)，就是a[3]int k=p[-2];//p[-2]是a[0]表示的那个元素 多维数组的初始化和下标引用 123456789int a[2][3]=&#123; &#123;0,1,2&#125;, &#123;3,4,5&#125;&#125;;int a[2][3]=&#123;0,1,2,3,4,5&#125;;//内层嵌套着的花括号并非完全必要int a[2][3]=&#123;&#123;0&#125;,&#123;3&#125;&#125;;//显示初始化每行的首元素int （&amp;row)[3]=a[1];把row绑定到a的第二个3元素数组上int (*p)[3]=a;//p指向含有3个整数的数组p=&amp;a[1];//p指向a的尾元素 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型，因为数组名会被自动地转换成指向该数组首元素的指针。 1234567891011121314151617181920212223242526272829303132//正确for(const auto &amp;row:a)&#123; for(auto clo:row)&#123; cout&lt;&lt;col&lt;&lt;endl; &#125;&#125;//错误：row的类型是int*,显然内层循环不合法for(const auto row:a)&#123; for(auto clo:row)&#123; cout&lt;&lt;col&lt;&lt;endl; &#125;&#125;//p指向含有3个整数的数组，*p解引p得到指向内层数组首元素的指针for(auto p=a;p!=a+2;++p)&#123; for(auto q=*p;q!=*p+3;q++)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125;//简洁版for(auto p=begin(a);p!=end(a);p++)&#123; for(auto q=begin(*p);q!=end(*p);q++)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125;//类型别名简化多维数组的指针using int_arr=int[4];typedef int int_arr[4];//等价的typedegf声明for(int_arr *p=a;p!=a+2;++p)&#123; for(int *q=*p;q!=*p+3;++q)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125; 第四章 表达式 当一个对象被用作右值时，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。使用关键字decltype的时候左值右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。eg.假定p的类型是int，因为解引用运算符生成左值，所以decltype(\\p)的结果是int&amp;。另一方面，因为取地址符生成右值，所以decltype(&amp;p)的结果是int**,也就是说，结果是一个指向整型指针的指针。 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。 123cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;++i&lt;&lt;endl; //产生未定义的行为，可能先计算i再计算i++，或者先计算i++再计算i,或其他不可预知行为，所以编译器生成什么样的代码程序都是错的*beg=toupper(*beg++); //产生未定义的行为，可能先求左侧的值或先求右侧的值，也可能采取别的什么方式处理它*++iter; //正确：先递增再解引用 后置递增运算符的优先级高于解引用运算符，因此pbeg++等价于\\（pbeg++)，先自增，然后返回初始值的副本作为其求值结果，此时解引用运算符的运算对象是pbeg未增加之前得值，最终这条语句输出pbeg开始时指向的那个元素，并将指针向前移动一个位置。 解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号，如果没有括号，代码的含义就大不相同了。 12(*p).size(); //正确*p.size(); //错误：p是一个指针，它没有名为size成员 左移运算符（&lt;&lt;）在右侧插入值为0的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。 sizeof运算符返回一条表达式或一个类型名字所占的字节数，满足右结合律，其所得值是一个size_t类型的常量表达式。在sizeof的运算对象中解引用一个无效指针仍然是一种安全行为，因为指针实际上并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。sizeof运算不会把数组转换成指针来处理，对string和vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中元素的个数。 123sizeof *p; //p所指空间类型的大小，即sizeof(Sales_data),等价于sizeof(*p)，即使p是一个无效（即未初始化）的指针constexpr size_t sz=sizeof(ia)/sizeof(*ia); //返回数组ia的元素数量int arr[sz]; //sizeof返回一个常量表达式 指向任意非常量的指针能转换成void；指向任意对象的指针能转换成const void\\。 123if(cp) //如果指针cp不是0，条件为真while(*cp) //如果*cp不是空字符，条件为真while(cin&gt;&gt;s) //布尔值决定于输入流的状态，最后一次读入成功，true;反之，false 显式转换：cast_name(expression)，cast-name是static_cast（任何具有明确定义的类型转换，只要不包含底层const）/dynamic_cast（支持运行时类型识别）/const_cast（只能改变运算对象的底层const）/reinterpret_cast（通常为运算对象的位模式提供较低层次上的重新解释）中的一种。除了在有重载函数的上下文中使用const_cast无可厚非，其他强制类型转换都不应该频繁使用。 12345678int i,j;double slope=static_cast&lt;double&gt;(j)/i; //进行强制类型转换以便执行浮点数除法void* p=&amp;d; //任何非常量对象的地址都能存入void*double *dp=static_cast&lt;double*&gt;(p); //正确：将void*转换回初始的指针类型const char *pc;char *P=const_cast&lt;char*&gt;(pc); //正确：但是通过p写值时未定义的行为int *ip;char *pc=reinterpret_cast&lt;char*&gt;(ip); //牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误，eg:string str(pc)，具有高危性 第五章 语句 一般不要省略case分支的break语句，否则，程序将跨越case标签的边界；如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧跟在default标签后面的语句。 如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是违法行为。因此c++语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域的另一个位置。 for语句头能省略掉init-statement、condition和expression中的任何一个（或全部）。省略condition的效果等价于在条件部分写了一个true，则循环体内必须有语句负责退出循环。 123vector&lt;int&gt; v;for(int i;cin&gt;&gt;i;/*表达式为空*/) //条件部分能改变i值，所以这个循环无须表达式部分 v.push_back(i); 尽量不要使用goto语句，因为它使得程序既难理解又难修改。 try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问。 12345678910111213141516while(cin&gt;&gt;item1&gt;&gt;item2)&#123; try&#123; //执行添加两个Sales_item对象的代码 //如果添加失败，代码抛出一个runtime_error异常 &#125;catch(runtime_error err)&#123; cout&lt;&lt;err.what() &lt;&lt;\"\\nTry Again? Enter y or n\"&lt;&lt;endl; char c; cin&gt;&gt;c; if(!cin || c=='n') break;跳出while循环 &#125;&#125;//类型runtime_error是标准库异常类型的一种，必须提供一个string对象或者C风格的字符串初始化runtime_error的对象if(item1.isbn()!=item2.isbn()) throw runtime_error(\"Data must refer to same ISBN\"); 标准库异常类只定义了几种运算，包括创建或拷贝异常类型对象，以及为异常类型的对象赋值。异常类型只定义了一个名为what的成员函数，该函数没有参数，返回值是一个指向C风格字符串的const char*。该字符串的目的是提供关于异常的一些文本信息。如果异常类型有一个字符串初始值，则what返回该字符串。对于其他无初始值的异常类型来说，what返回的内容由编译器决定。 寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果最终还是没找到任何匹配的catch子句，程序转到名为terminate的标准函数库。对于那些没有任何try语句块定义的异常，系统同样会调用terminate函数并终止当前程序的执行。 第六章 函数 局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。 参数传递包括值传递和引用传递（引用传递直接传入对象而无须传递对象的地址，eg.可以给函数传入一个额外的引用实参，令其保存字符出现的次数）。指针传递属于值传递，当执行指针拷贝操作时，拷贝的是指针的值，拷贝之后两个指针是不同的指针，因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指的对象，但是改变局部拷贝的值并不能改变实参以及实参所指对象。 顶层const可以初始化非const,非const可以初始化顶层const,所以实参初始化形参时就会忽略掉顶层const.想调用引用版本的reset(int &amp;i)只能使用int类型的对象，而不能使用字面值、求值结果为int的表达式、需要转换的对象或者const int类型的对象，类似的，想要调用指针版本的reset(int p)只能使用int\\。 12345678910111213141516171819void fcn(const int i)&#123;/*fcn能读取i,但是不能向i写值*/&#125;void fcn(int i)&#123;/*值传递本身写值就没有意义*/&#125; //错误：重复定义了fcn(int)Record lookup(Acount*);Record lookup(Acount* const); //错误：重复声明Record lookup(Acount*);Record lookup(const Acount*); //新函数，作用于常量引用Record lookup(Acount&amp;);Record lookup(const Acount&amp;); //新函数，作用于指向常量的指针int i=1;const int ci=42; //不能改变ci的值这是一个顶层constconst int *p2=&amp;ci; //允许改变p2的值，这是一个底层constconst int *const p3=p2; //靠右的是顶层const，靠左的是底层constconst int &amp;r=ci; //用于声明引用的const都是底层const（从这里也说明不能使用指向const int对象的指针初始化int*因为int*没有底层const,eg.void reset(int *p);reset(&amp;ci)错误）int *p=p3; //错误：p3包含底层const的定义，而p没有p2=p3; //正确：p2和p3都是底层constp2=&amp;i; //正确：int*能转换成const int*int &amp;r=ci; //错误：普通的int&amp;不能绑定到int常量上const int &amp;r2=i; //正确：const int&amp;可以绑定到一个普通的int上reset(42)； //不能把普通引用绑定到字面值上，只能把const引用绑定到字面值上 数组不能拷贝所以无法以值传递的方式传递数组,因为数组会被转换成指针，所以我们为函数传递一个数组时实际上传递的是指向数组元素的指针。 1234567//尽管形式不同，但是三个print函数是等价的，每个函数都有一个const int*类型的唯一形参void print(const int*);void print(const int[]); //可以看出了，函数的意图是作用于一个数组void print(const int[10]); //这里的维度表示我们期望数组含有多少元素，实际不一定int i=0,j[2]=&#123;0,1&#125;;print(&amp;i); //正确：&amp;i的类型是int*print(j); //正确：j转换成int*并指向j[0] c++允许将变量定义成数组的引用，同理，形参也可以是数组的引用（维度是类型的一部分）。因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。 123456f(int &amp;arr[10])&#123;/*...*/&#125;; //错误：将arr声明成了引用的数组f(int (&amp;arr)[10])&#123;/*...*/&#125;; //正确：arr是具有10个整数的整型数组的引用int k[10]=&#123;0,1,2,3,4,5,6,9&#125;;print(&amp;i); //错误：实参不是含有10个整数的数组print(j); //错误：实参不是含有10个整数的数组print(k); //正确：实参是含有10个整数的数组 多维数组实际上是数组的数组，所以由多维数组名转换得到的指针实际上是指向第一个内层数组的指针。和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，由于首元素本身就是一个数组，指针就是一个指向数组的指针，数组第二维（以及后面所有的维度）的大小都是数组类型的一部分，不能省略。 123456int a[3][4];int (*p)[4]=ia; //p指向含有4个整数的数组p=&amp;a[2]; //p指向a的尾元素int *matrix[10]; //错误：10个指针构成的数组int (*matrix)[10]; //正确：指向含有10个整数的数组指针void print(int matrix[][10],int rowSize)&#123;/*...*/&#125;; //matrix的声明看起来是一个二维数组，实际上形参是一个指向含有10个整数的数组指针，等价于int (*matrix)[10] 如果函数的实参数量未知，但是全部实参的类型都相同，可以采用initializer_list类型的形参，initializer_list是一种标准库类型，用于表示某种特定类型的值的数组，initializer_list类型定义在同名的头文件中，拷贝或者赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 1234initializer_list&lt;T&gt; lst2; //默认初始化：T类型元素的空列表initializer_list&lt;T&gt; lst&#123;a,b,c...&#125; //lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是constlst2(lst);lst2=lst; 返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。不要返回局部对象的引用或指针，局部变量在函数结束后所占用的存储空间也随之被释放掉，函数终止意味着局部变量的引用将指向不再有效的内存区域。 1234567891011121314151617181920212223const string &amp;mainp()&#123; string ret; //以某种方式改变一下ret if(ret.empty())&#123; return ret; //错误：返回局部对象的引用 else return \"Empty\"; //错误：\"Empty\"是一个局部临时量 &#125;&#125;//引用返回左值：调用一个返回引用的函数得到左值，其他类型得到右值可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值char &amp;get_val(string &amp;str,string::size_type ix)&#123; return str[ix]; //get_val假定索引值是有效的&#125;int main()&#123; string a(\"a value\"); get_val(s,0)='A'; cout&lt;&lt;s&lt;&lt;endl; //输出A value&#125;//c++11规定函数可以返回花括号包围的值的列表vector&lt;string&gt; process()&#123; return &#123;&#125;; //返回一个空vector return &#123;\"functionX\",\"okay\"&#125;; //返回列表初始化的vector对象&#125; type (*function(parameter_list))[dimension]声明一个返回数组指针的函数 1234567typedef int arrT[10];using arrT=int[10];//func返回一个指向含有10个整数的数组指针arrT* func(int i); auto func(int i)-&gt;int(*)[10];int odd[]=&#123;1,2,3,4,5,6,7,8,9,0&#125;decltype(odd) *func(int i); //decltype不负责把数组类型转换成对应的指针 不允许两个函数除了返回类型外其他所有的要素都相同，对于重载函数来说，应该在形参数量或者形参类型上有所不同。 一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 123456789sz wd=80;char def=' ';sz ht();string screen(sz=ht(),sz=wd,char def);void f()&#123; def='*'; //改变默认参数值 sz wd=100; //隐藏了外层定义的wd,但是没有改变默认值，该局部变量与传递给screen的默认实参没有任何关系 window=screen(); //调用screen(ht(),80,'*')&#125; constexpr函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。内联函数和constexpr函数可以在程序中多次定义，通常定义在头文件中。 123456constexpr int new_sz()&#123;return 42;&#125; //编译器能在程序编译时验证new_sz函数返回的是常量表达式，所以可以用new_sz函数初始化constexpr类型的变量fooconstexpr int foo = new_sz();constexpr size_t scale(size_t cnt)&#123;return new_sz()*cnt;&#125; //允许constexpr函数的返回值并非一个常量，当scale的实参是常量表达式时，它的返回值也是常量表达式；反之，则不然int arr[scale(2)]; //正确：scale（2）是常量表达式int i=2; //i不是常量表达式int a2[scale(i)]; //错误：scale(i)不是常量表达式 编译器会因为函数调用具有二义性而拒绝其请求；为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下所示： 精确匹配，包括以下情况： 实参类型和形参类型相同。 实参从数组类型或函数类型转换成对应的指针类型 向实参添加顶层const或者从实参中删除顶层const 通过const转换实现的匹配 通过类型提升实现的匹配 通过算术类型转换或指针转换实现的匹配（所有算术类型转换的级别都一样，例如,从int向usigned int的转换并不比从int向double的转换级别高） 通过类类型转换实现的匹配 当我们把函数名作为一个值使用时，该函数自动转换成指针。 123456789bool lengthCompare(const string &amp;,const string &amp;);bool (*pf)(const string &amp;,const string &amp;); //未初始化pf=lengthCompare; //pf指向名为lengthCompare的函数（返回类型和形参列表要精确匹配）pf=&amp;lengthCompare; //等价的赋值语句：取地址符是可选的//调用lengthCompare函数bool b1=pf(\"hello\",\"good\");bool b2=(*pf)(\"hello\",\"goodbye\");bool b3=lengthCompare(\"hello\",\"goodbye\");pf=0; //正确：pf不指向任何函数 函数的形参：和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用。 12345678910void useBigger(const string &amp;s,bool pf(const string &amp;,const string &amp;)); //第三个形参是函数类型，它会自动地转换成指向函数的指针void useBigger(const string &amp;s,bool (*pf)(const string &amp;,const string &amp;)); //等价的声明：显式地将形参定义成指向函数的指针//Func和Func2是函数类型typedef bool Func(const string &amp;,const string &amp;);typedef decltype(lengthCompare) Func2;//FuncP和FuncP2是指向函数的指针typedef bool (*FuncP)(const string&amp;,const string&amp;);typedef decltype(lengthCompare) *FuncP2; //decltype不会将函数类型自动转换成指针类型void useBigger(const string&amp;,Func); //编译器自动地将Func表示的函数类型转换成指针void useBigger(const string&amp;,FuncP); 返回指向函数的指针：和函数类型的形参不一样，返回类型不会自动地转换成指针，我们必须显式地将返回类型指定为指针。 1234567using F=int(int*,int); //F是函数类型，不是指针using PF=int(*)(int*,int); //PF是指针类型PF f(int); //正确：PF是指向函数的指针，f返回指向函数的指针F f(int); //错误：F是函数类型，f不能返回一个函数F *f(int); //正确：显式地指定返回类型是指向函数的指针int (*f(int))(int*,int); //可以直接声明f,按照由内向外的顺序阅读这条声明：f有形参列表，所以f是个函数；f前面有*，所以f返回一个指针；指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int.auto f(int)-&gt;int(*)(int*,int); //使用尾置返回类型的方式声明一个返回函数指针的函数 编译器将所有.cpp文件编译为.obj或.o文件再把对象文件链接在一起形成可执行文件.exe或.out。如果.cpp中有#include X.h文件，那么第一步预处理会把X.h代码粘贴到.cpp中代替#include语句。 如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件。 12345678g++ factMain.cc fact.cc //生成 factMain.exe or a.outg++ factMain.cc fact.cc -o main //生成 main or main.exe//分离式编译g++ -c factMain.cc //生成factMain.og++ -c fact.cc //生成fact.og++ fact.o factMain.o //生成factMain.exe or a.outg++ factMain.o fact.o -o main //生成 main or main.exe 第七章 类 只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数；当既需要其他形式的构造函数，也需要默认的构造函数时使用 Sales_data() = defalut;来要求编译器生成构造函数。 如果类包含内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。 使用class和struct定义类唯一的区别就是默认的访问权限。struct关键字在第一个访问说明符之前的成员是public；class关键字在第一个访问说明符之前的成员是private。 class默认的继承访问权是private,struct默认的是public。 class关键字可用于定义模板参数，就像typename，但struct关键字不能。 友元的声明只能出现在类定义的内部（最好在类定义开始或者结束前的位置集中声明友元）仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，必须在友元声明之外再转名对函数进行一次声明。每个类负责控制自己的友元类或友元函数，友元关系不存在传递性。 12345678910111213141516class Screen&#123; //首先定义Window_mgr类，其中声明cleat函数，但不能定义它。在 //clear使用Screen的成员之前必须先声明Screen。 friend void Window_mgr::clear(ScreenIndex); //Screen类的剩余部分&#125;//最后定义clear，此时它才可以使用Screen的成员struct X&#123; friend void f()(/*友元函数可以定义在类的内部＊/&#125; X()｛f();｝ //错误:还没有被声明 void g(); void h();&#125;;void X::g()( return f();&#125; //错误:f还没有被声明void f(); //声明那个定义在X中的函数void X::h()&#123;return f();&#125; //正确:现在王的声明在作用域 使用类型别名等价地声明一个类型名字 12typedef std::string::size_type pos;using pos=std::string::size_type; 在变量声明中加入mutable关键字能修改类的某个数据成员，即使是在一个const函数内。 常量引用不能修改对象。常量对象不能调用非常量函数，但是非常量对象能调用常量函数。 12345怎么选择使用哪种返回传值方式-&gt;拷贝开销大吗 -&gt;不大-&gt;按值返回return-by-value(拷贝，c++11自动转化为移动来节省拷贝开销) -&gt;很大-&gt;希望对返回值的内部数据进行修改吗(引用避免拷贝开销) -&gt;不需要-&gt;按常量引用返回return-by-constant-reference -&gt;需要-&gt;按引用返回return-by-reference 即使两个类的成员列表完全一致，它们也是不同的类型。我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类名跟在关键字class或struct后面。 12Sales_data item; //默认初始化Sales_data类型的对象class Sales_data item; //一条等价的声明 只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被人为是声明过了(但尚未定义)，因此类允许包含指向它自身类型的引用或指针。 12345class Link_screen&#123; Screen window; Link_screen *next; Link_screen &amp;other;&#125;; 类内初始化，必须使用=的初始化形式(初始化Screen的数据成员时所用的)或者花括号括起来的直接初始化形式(初始化screens所用的)。Screen的构造函数接受两个尺寸参数和一个字符值，创建了一个给定大小的空白屏幕对象。 12private: std::vector&lt;Screen&gt; screens&#123;Screen(24,80,' ')&#125;; 第十章 泛型算法 泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作，所以算法容器中保存的元素，也可能在容器中移动元素，但永远不会直接添加或删除元素。 replace_copy保持原序列不变，接受额外第三个迭代器参数，之处调整后序列的保存位置；back_inserter按需要增长目标序列。 1replace_copy(ilst.cbegin(),ilst.cend,back_inserter(ivec),0,42); //ilst未改变，ivec包含ilst的一份拷贝，不过原来ilst中值为0的元素在ivec中都变为42 第十二章 动态内存、智能指针和动态数组 常量指针：指针指向的地址能改变，只能指向的内容不能改变 指针常量：指针地址不能改变，指针指向的内容可以改变 new后必须delete（传递给delete的指针必须指向动态分配的内存或者是一个空指针）；智能指针可以自动销毁 内存泄漏：内存永远不可能被归还给自由空间 不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化的形式 12shared_ptr&lt;int&gt; p1=new int(1024);//错误，隐式转换shared_ptr&lt;int&gt; p12(new int(1024));//正确，直接初始化 当将shared_ptr绑定到一个普通指针时，内存管理就交给了这个shared_ptr，就不能使用那个内置指针来访问shared_ptr指向的内存了。 unique_ptr通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique_ptr 1auto p=p2.release();//p2放弃对指针的控制权，返回指针，并将p2置空；必须记得delete(p)，此时auto代表普通指针 当创建weak_ptr时要用shared_ptr来初始化 12auto p=make_shared&lt;int&gt;(42);weak_ptr&lt;int&gt; wp(p);//wp弱共享p；p的引用计数不变 weak_ptr的lock()如果expired()为true（表示use_count==0），返回一个空shared_ptr；否则返回一个指向对象的shared_ptr 销毁动态数组时数组中的元素按逆序销毁 1delete [] p；//p必须指向一个动态分配的数组或为空 动态分配一个空数组是合法的 12char arr[0];//错误：不能定义长度为0的数组char *cp=new char[0];//正确：但cp不能解引用 unique_ptr支持管理动态数组，shared_ptr不支持除非提供自己定义的删除器 12unique_ptr&lt;int[]&gt; up(new int[10]());//up指向一个包含10个初始化为0的int的数组share_ptr&lt;int&gt; sp(new int[10]，[](int *p)&#123;delete [] p;&#125;);//sp指向一个包含10个未初始化的int数组，并提供一个删除器 make_shared函数构造shared_ptr对象时在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，使用一次内存分配；shared_ptr构造shared_ptr对象时需要进行两次内存分配 new：没有默认构造函数的类不能动态分配数组 allocator:定义在memory中，将内存分配和对象构造分离开来 管理“动态数组”时，需要制定Deleter以使用delete[]操作符销毁内存，因为shared_ptr并没有针对数组的特化版本，而unique_ptr有针对数组的特化版本。我们常常需要对动态数组中的某一个元素进行操作，但shared_ptr没有提供[]操作符，不过我们可以使用 sp.get()先获取原始指针，再对原始指针进行下标操作。而unique_ptr对动态数组提供了支持，指定删除器是一个可选项。也可以直接使用下标操作 make_unique完美传递了参数给对象的构造函数，从一个原始指针构造出一个std::unique_ptr，返回创建的std::unique_ptr。这个形式的函数不支持数组和定制删除器（见条款18） 要解决环形引用的问题，没有特别好的办法，一般都是在可能出现环形引用的地方使用weak_ptr来代替shared_ptr。weak_ptr指向shared_ptr指针指向的对象的内存，却并不拥有该内存。 但是，使用weak_ptr成员lock，则可返回其指向内存的一个shared_ptr对象，且在所指对象内存已经无效时，返回指针空值（nullptr）。由于weak_ptr是指向shared_ptr所指向的内存的，所以，weak_ptr并不能独立存在 文本查询程序——优质程序","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-23T15:07:54.652Z","updated":"2020-03-24T05:42:02.989Z","comments":true,"path":"2020/03/23/hello-world/","link":"","permalink":"http://yoursite.com/2020/03/23/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]}