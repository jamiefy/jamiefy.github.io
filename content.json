{"meta":{"title":"翟安然's Blog","subtitle":"","description":"","author":"翟安然","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-03-25T10:41:58.000Z","updated":"2020-03-25T14:54:20.795Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-03-25T10:42:40.000Z","updated":"2020-03-25T13:48:56.355Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-25T10:37:44.000Z","updated":"2020-03-25T15:00:42.002Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-25T10:41:44.000Z","updated":"2020-03-25T13:49:16.049Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"日常常用技巧","slug":"日常常用技巧","date":"2020-03-27T06:11:04.000Z","updated":"2020-03-27T06:14:18.674Z","comments":true,"path":"2020/03/27/日常常用技巧/","link":"","permalink":"http://yoursite.com/2020/03/27/%E6%97%A5%E5%B8%B8%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"","text":"1、windows+chrome原生长截屏123Fn+F12Ctrl+Shift+p搜索capture full size screenshot","categories":[{"name":"常用技巧","slug":"常用技巧","permalink":"http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"},{"name":"长截屏","slug":"长截屏","permalink":"http://yoursite.com/tags/%E9%95%BF%E6%88%AA%E5%B1%8F/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"高效算法","slug":"高效算法","date":"2020-03-25T16:51:01.000Z","updated":"2020-03-25T17:00:28.407Z","comments":true,"path":"2020/03/26/高效算法/","link":"","permalink":"http://yoursite.com/2020/03/26/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95/","excerpt":"（一）素数筛（埃拉托斯特尼sieve of Eratosthenes ）埃拉托斯特尼筛法–后续继续整理…… 素数的性质： 任意一个合数都可以表示几个质数的乘积-&gt;任意一个合数都可以表示成一个质数和另一个数的乘积","text":"（一）素数筛（埃拉托斯特尼sieve of Eratosthenes ）埃拉托斯特尼筛法–后续继续整理…… 素数的性质： 任意一个合数都可以表示几个质数的乘积-&gt;任意一个合数都可以表示成一个质数和另一个数的乘积 一个合数和一个质数的乘积=一个更大的合数和一个更小的质数的乘积 知识点扩展：判断互质数的五种方法 概念判断法。公约数只有1的两个数叫做互质数。根据互质数的概念可以对一组数是否互质进行判断。如：9和11的公约数只有1，则它们是互质数。 规律判断法。根据互质数的定义，可总结出一些规律，利用这些规律能迅速判断一组数是否互质。 （1）两个不相同的质数一定是互质数。如：7和11、17和31是互质数。 （2）两个连续的自然数一定是互质数。如：4和5、13和14是互质数。 （3）相邻的两个奇数一定是互质数。如：5和7、75和77是互质数。 （4）1和其他所有的自然数一定是互质数。如：1和4、1和13是互质数。 （5）两个数中的较大一个是质数，这两个数一定是互质数。如：3和19、16和97是互质数。 （6）两个数中的较小一个是质数，而较大数是合数且不是较小数的倍数，这两个数一定是互质数。如：2和15、7和54是互质数。 （7）较大数比较小数的2倍多1或少1，这两个数一定是互质数。如：13和27、13和25是互质数。 分解判断法。如果两个数都是合数，可先将两个数分别分解质因数，再看两个数是否含有相同的质因数。如果没有，这两个数是互质数。如：130和231，先将它们分解质因数：130＝2×5×13，231＝3×7×11。分解后，发现它们没有相同的质因数，则130和231是互质数。 求差判断法。如果两个数相差不大，可先求出它们的差，再看差与其中较小数是否互质。如果互质，则原来两个数一定是互质数。如：194和201，先求出它们的差，201－194＝7，因7和194互质，则194和201是互质数。 求商判断法用大数除以小数，如果除得的余数与其中较小数互质，则原来两个数是互质数。如：317和52，317÷52＝6……5，因余数5与52互质，则317和52是互质数。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Linux安装Qt/Clion编译Boost/Opencv","slug":"Linux安装Qt-Clion编译Boost-Opencv","date":"2020-03-25T16:35:36.000Z","updated":"2020-03-25T16:59:55.697Z","comments":true,"path":"2020/03/26/Linux安装Qt-Clion编译Boost-Opencv/","link":"","permalink":"http://yoursite.com/2020/03/26/Linux%E5%AE%89%E8%A3%85Qt-Clion%E7%BC%96%E8%AF%91Boost-Opencv/","excerpt":"（一）qt 安装: 首先从Qt官网上下载安装包，下载网址 给.run文件添加执行权限 1sudo chmod +x qt-opensource-linux-x64-5.12.0.run","text":"（一）qt 安装: 首先从Qt官网上下载安装包，下载网址 给.run文件添加执行权限 1sudo chmod +x qt-opensource-linux-x64-5.12.0.run 执行.run进行qt的安装 1sudo ./qt-opensource-linux-x64-5.12.0.run (二)clion安装: 官网下载 解压 1tar -zxvf CLion-2016.2.2.tar.gz 运行脚本 12cd clion-2016.2.2/bin/ ./clion.sh (三)boost编译: 官网下载压缩包.tar.gz tar -xvf boost(tab) cd boost_1_71_0 chmod 777 bootstrap.sh ./bootstrap.sh --with-libraries=all --with-toolset=gcc 指定编译boost的哪些库,all是全编译,只想编译部分库的话就把库名写上用逗号分隔开(在这步之前保证gcc g++至少为version 7),编译器用gcc 提示:to build,run:./b2 sudo ./b2 install 编译大约十分钟，提示…failed updating 60… (四)opencv编译： 到官网下载opencv4.1.0点击此处，选择source进行下载(opencv4.1.2会出错) 解压缩包unzip opencv-4.1.0.zip 对解压的文件夹进行重命名mv opencv-4.1.0 opencv sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev cd ~/opencv mkdir build cd build cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. make -j n # n为你的CPU线程数（几核就填几，电脑能力范围内的最大值） sudo make install","categories":[{"name":"安装编译","slug":"安装编译","permalink":"http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"Clion","slug":"Clion","permalink":"http://yoursite.com/tags/Clion/"},{"name":"Boost","slug":"Boost","permalink":"http://yoursite.com/tags/Boost/"},{"name":"Opencv","slug":"Opencv","permalink":"http://yoursite.com/tags/Opencv/"}]},{"title":"操作系统","slug":"操作系统","date":"2020-03-25T16:23:38.000Z","updated":"2020-03-25T17:00:13.070Z","comments":true,"path":"2020/03/26/操作系统/","link":"","permalink":"http://yoursite.com/2020/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"1. sizeof在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，结构体变量所占空间的大小必定是最宽数据类型大小的整数倍。如有需要会在最后一个成员末尾填充若干字节使得所占空间大小是最宽数据类型大小的整数倍。内存对齐的原因： 某些平台只能在特定的地址处访问特定类型的数据；","text":"1. sizeof在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，结构体变量所占空间的大小必定是最宽数据类型大小的整数倍。如有需要会在最后一个成员末尾填充若干字节使得所占空间大小是最宽数据类型大小的整数倍。内存对齐的原因： 某些平台只能在特定的地址处访问特定类型的数据； 提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量 2. static与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。Static修饰的成员函数，在代码区分配内存。 3. C++多态分为静态多态和动态多态静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。 4. 大端小端 大端模式（Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。 小端模式（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。 口诀：大相反（低位存高位），小相同（低位存低位）。 联合体变量共享同一空间，可以通过联合体来判断大端小端。联合体同样存在内存对齐，所以联合长度至少可以容纳最大的成员。但是当最大成员大小不是** 最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍。 5.内存泄漏内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏的分类： 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc,new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。 6. 程序内存区域分配 一个程序本质上都是由 bss段、data段、text段三个组成的。bss段通常是指用来存放程序中未初始化的全局变量的一块内存区域，一般在初始化时bss 段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。比如，在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中未初始化的全局变量保存在.bss 段中。text和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化。bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小；bss段的大小从可执行文件中得到 ，然后链接器得到这个大小的内存块，紧跟在数据段后面。data段（已手动初始化的数据）则为数据分配空间，数据保存在目标文件中；data段包含经过初始化的全局变量以及它们的值。当这个内存区进入程序的地址空间后全部清零。包含data段和bss段的整个区段此时通常称为数据区。 同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Linux或windows安装Matlab注意事项","slug":"Linux安装Matlab","date":"2020-03-25T15:59:41.000Z","updated":"2020-03-25T17:00:55.060Z","comments":true,"path":"2020/03/25/Linux安装Matlab/","link":"","permalink":"http://yoursite.com/2020/03/25/Linux%E5%AE%89%E8%A3%85Matlab/","excerpt":"1、一定要把iso挂载的文件复制到home目录下，使用完整路径启动install,而不能直接进入挂载的dvd中sudo ./install","text":"1、一定要把iso挂载的文件复制到home目录下，使用完整路径启动install,而不能直接进入挂载的dvd中sudo ./install 2、windows安装注意事项： 如果之前安装过即使没安装成功，要彻底删除安装过程中产生的所有文件 安装路径不能存在中文 防火墙等杀毒软件要关闭","categories":[{"name":"安装编译","slug":"安装编译","permalink":"http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"}]},{"title":"Git操作注意事项","slug":"Git操作注意事项","date":"2020-03-25T15:53:25.000Z","updated":"2020-03-25T17:00:45.990Z","comments":true,"path":"2020/03/25/Git操作注意事项/","link":"","permalink":"http://yoursite.com/2020/03/25/Git%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"Git常规笔记及注意事项 切换到历史版本(要求此时本地项目没有未提交的修改)：git checkout &lt;版本号&gt; 查看文件的历史记录、查看某个文件在某次提交中的修改参照：使用git查看版本记录","text":"Git常规笔记及注意事项 切换到历史版本(要求此时本地项目没有未提交的修改)：git checkout &lt;版本号&gt; 查看文件的历史记录、查看某个文件在某次提交中的修改参照：使用git查看版本记录 从缓存中删除的文件git rm -r . –cached可以采用git reset HEAD .进行恢复 git reset --mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息git reset --soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git reset --hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，此命令 慎用！","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"面试要点记录","slug":"面试要点记录","date":"2020-03-24T13:59:01.000Z","updated":"2020-03-27T06:16:26.608Z","comments":true,"path":"2020/03/24/面试要点记录/","link":"","permalink":"http://yoursite.com/2020/03/24/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/","excerpt":"（一）面向对象的三个基本特征：封装、继承、多态 继承 子类对象可以直接调用父类中的成员函数 子类对象可以直接赋值给父类对象。 子类对象可以直接初始化父类对象。 父类引用可以直接引用子类对象。 父类指针可以直接指向子类对象。","text":"（一）面向对象的三个基本特征：封装、继承、多态 继承 子类对象可以直接调用父类中的成员函数 子类对象可以直接赋值给父类对象。 子类对象可以直接初始化父类对象。 父类引用可以直接引用子类对象。 父类指针可以直接指向子类对象。 子类初始化一定会先初始化父类，析构顺序相反。 虚继承对构造函数的影响：指南。构造函数的调用可能内带大量的隐藏码，因为编译器会对构造函数进行扩充，一般而言编译器所作的扩充规则如下： （1）记录在成员初始化列表中的数据成员的初始化操作会被放到构造函数本身中，按照数据成员声明的顺序 （2）如果有一个数据成员没有出现在初始化列表中，但是它有一个默认构造函数，那么这个默认构造函数会被调用 （3）在那之前，如果有虚函数表，会调整虚函数表指针 （4）在那之前，会对上一层基类的构造函数进行调用 （5）在那之前，所有虚基类的构造函数必须被调用，按照声明的继承顺序从左往右，从最深到最浅的顺序 多态 多态发生的三个必要条件： 要有继承。 要有虚函数重写。 父类指针或引用 指向 子类对象。 虚析构函数：在多态时，要调用析构函数时，注意在父类的析构成员函数前加virtual。 重载/重写（覆盖）/重定义（隐藏） 重载（overload）-编译时的多态性 （1）重载只能通过不同的参数样式（参数类型、个数、顺序至少有一个不相同），不能通过访问权限、返回类型、抛出的异常进行重载。 重写（override）-运行时的多态性 （1）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 （2）被定义为final的方法不能被重写。 重定义（隐藏hiding） （1）隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt; using namespace std; class Base &#123; private: virtual void display() &#123; cout&lt;&lt;\"Base display()\"&lt;&lt;endl; &#125; void show()&#123; cout&lt;&lt;\"Base show()\"&lt;&lt;endl; &#125; public: void exec()&#123; display(); show(); &#125; void fun(string s) &#123; cout&lt;&lt;\"Base fun(string)\"&lt;&lt;endl; &#125; void fun(int a) &#123; cout&lt;&lt;\"Base fun(int)\"&lt;&lt;endl; &#125;//overload:两个fun函数在Base类的内部被重载 virtual int function()&#123;&#125; &#125;; class ClassA:public Base &#123; public: void display() &#123; cout&lt;&lt;\"ClassA display()\"&lt;&lt;endl; &#125;//override:基类中display为虚函数，且参数列表一直，故此处为重写 void fun(int a,int b) &#123; cout&lt;&lt;\"ClassA fun(int,int)\"&lt;&lt;endl; &#125;//redefining:fun函数在Base类中不为虚函数，故此处为重定义 void show() &#123; cout&lt;&lt;\"ClassA show()\"&lt;&lt;endl; &#125;//redefining:理由同上 int function(int a)&#123;&#125;//overload:注意这是重载而不是重写，因为参数列表不同，在编译时ClassA中其实还有个编译器自己偷偷加上的从Base继承来的int function()&#123;&#125;; &#125;; int main()&#123; ClassA a; Base *base=&amp;a; base-&gt;exec();//display()是ClassA的，因为覆盖了，show()是Base自己的 a.exec();//结果同上,子类对象可以直接调用父类中的成员函数 a.show();//show()是ClassA重定义的 base-&gt;fun(1);//fun()是Base自己的，因为直接从对象base调用 a.fun(1, 1);//fun()是ClassA重定义的 return 0; &#125; //输出结果ClassA display()Base show()ClassA display()Base show()//父类中的成员函数直接调用自身的Base show()ClassA show()Base fun(int)ClassA fun(int,int) 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual void f(float x)&#123; cout &lt;&lt; \"Base::f(float) \" &lt;&lt; x &lt;&lt; endl; &#125; void g(float x)&#123; cout &lt;&lt; \"Base::g(float) \" &lt;&lt; x &lt;&lt; endl; &#125; void h(float x)&#123; cout &lt;&lt; \"Base::h(float) \" &lt;&lt; x &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: virtual void f(float x)&#123; cout &lt;&lt; \"Derived::f(float) \" &lt;&lt; x &lt;&lt; endl; &#125; void g(int x)&#123; cout &lt;&lt; \"Derived::g(int) \" &lt;&lt; x &lt;&lt; endl; &#125; void h(float x)&#123; cout &lt;&lt; \"Derived::h(float) \" &lt;&lt; x &lt;&lt; endl; &#125;&#125;;int main(void)&#123; Derived d; Base *pb = &amp;d; Derived *pd = &amp;d; // Good : behavior depends solely on type of the object pb-&gt;f(3.14f); //Derived::f(float) 3.14 pd-&gt;f(3.14f); //Derived::f(float) 3.14 // Bad : behavior depends on type of the pointer pb-&gt;g(3.14f); //Base::g(float) 3.14 pd-&gt;g(3.14f); //Derived::g(int) 3 // Bad : behavior depends on type of the pointer pb-&gt;h(3.14f); //Base::h(float) 3.14 pd-&gt;h(3.14f); //Derived::h(float) 3.14 system(\"pause\"); return 0;&#125;//函数Derived::f(float)覆盖了Base::f(float)。//函数Derived::g(int)隐藏了Base::g(float)，而不是重载。//函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。 三者 作用域 有无virtual 函数名 参数列表 返回类型 重载 相同 可有可无 相同 不同 可同可不同 重写 不同 必有 相同 相同 相同（协变） 隐藏 不同 可有可无 相同 可同可不同 可同可不同 （二）bash shell bash是borne again shell的缩写，是shell的一种,Linux上默认采用的是bash。 Shell 是一个 C 语言编写的程序，一般都是放在/bin或者/user/bin目录下，当前 Linux 系统可用的 Shell 都记录在/etc/shells文件中。/etc/shells是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令查看它。 123$ cat /etc/shells #通过 cat 命令来查看当前 Linux 系统的可用 Shell$ echo $SHELL #查看当前Linux默认的shell，输出 SHELL 环境变量$ echo $BASH_VERSION #查看shell版本 设置取消alias：指南 PHP即“超文本预处理器”，是一种通用开源脚本语言。PHP是一种在服务器端执行的嵌入HTML文档的脚本语言。PHP 独特的语法混合了C、Java、Perl 以及 PHP 自创新的语法，它可以比 CGI 或者 Perl 更快速的执行动态网页，主要适用于Web开发领域。 （三）图 拓扑排序 一个有向无环图可以有一个或多个拓扑排序序列。 判断有向图是否有环的两种方法：(1)拓扑排序 (2)DFS 有向图最短路径；贪心算法；Dijskstr；floyd；最小生成树 （四）输出格式 cout输出指定小数点位数且自动补零","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"C++易混点","slug":"C-易混点","date":"2020-03-24T06:44:02.000Z","updated":"2020-03-25T15:26:23.005Z","comments":true,"path":"2020/03/24/C-易混点/","link":"","permalink":"http://yoursite.com/2020/03/24/C-%E6%98%93%E6%B7%B7%E7%82%B9/","excerpt":"虚函数表指针、虚基类表指针 非虚继承时，不需要额外增加虚函数表指针。单继承：一个虚函数表，一个虚表指针；多继承：子类的虚表指针数=父类数。","text":"虚函数表指针、虚基类表指针 非虚继承时，不需要额外增加虚函数表指针。单继承：一个虚函数表，一个虚表指针；多继承：子类的虚表指针数=父类数。 虚继承时：无论是单虚继承还是多虚继承，需要有一个虚基类表来记录虚继承关系，所以此时子类有且仅有一个虚基类表指针；多虚继承时子类可能持有多个虚函数表：如果子类没有构造函数和析构函数，且子类中的虚函数都是在父类中出现的虚函数，这个时候不需要增加任何虚表指针，只需要像多继承那个持有父类个数的虚函数表指针来标识即可。 如果子类中含有构造函数或者析构函数或二者都有，则在子类中只要出现一个父类中的虚函数则需要增加一个虚函数表指针来标识此类的虚函数表；无论是否含有构造函数或者虚构函数，只要继承都是虚继承且出现了父类中没有出现的虚函数，则在子类中需要再增加一个虚函数表指针；如果其中有一个是非虚继承，则按照最省空间的原则，不需要增加虚函数表指针，因为这个时候可以和非虚基类共享一个虚函数表指针。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class Base1&#123;int a;public:virtual void fun1()&#123;cout &lt;&lt; \"Base1::fun1\" &lt;&lt; endl;&#125;&#125;;class Base2&#123;int b;public:virtual void fun1()&#123;cout &lt;&lt; \"Base2::fun1\" &lt;&lt; endl;&#125;virtual void fun2()&#123;cout &lt;&lt; \"Base2::fun2\" &lt;&lt; endl;&#125;&#125;;class Derive1 : public Base1&#123;int d1;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive1::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive1::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive2 : virtual public Base1&#123;int d2;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive2::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive2::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive3 : virtual public Base2&#123;int d3;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive3::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive3::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive4 : public Derive2, public Derive3&#123;int d4;public:virtual void fun1()&#123;cout &lt;&lt; \"Derive4::fun1\" &lt;&lt; endl;&#125;virtual void d_fun1()&#123;cout &lt;&lt; \"Derive4::d_fun1\" &lt;&lt; endl;&#125;&#125;;class Derive5 : public Base1, public Base2&#123;virtual void d_fun()&#123;cout &lt;&lt; \"Derive5::d_fun\" &lt;&lt; endl;&#125;&#125;;//输出结果为：pstr1为虚函数表指针，vpstr为虚基类表指针sizeof(Base1):8 //sizeof(int) + sizeof(pstr) = 4+4sizeof(Base2):8 //同上sizeof(Derive1):12 //sizeof(int) + sizeof(pstr) + sizeof(int)= 4+4+4sizeof(Derive2):20 //sizeof(int) + sizeof(Base1的pstr) +sizeof(Derive2的pstr) + sizeof(vpstr)+ sizeof(int)= 4+4+4+4+4sizeof(Derive3):20 //同上sizeof(Derive4):44 //sizeof(Derive2) + sizeof(Derive3) + sizeof(int)sizeof(Derive5):16 //sizeof(Base1) + sizeof(Base2) 万能头文件 基本上所有的代码只要用了这个头文件就不再写其他头文件了。 #include&lt;bits/stdc++.h&gt;包含了目前c++所包含的所有头文件。","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"MySQL","slug":"MySQL","date":"2020-03-24T06:17:11.000Z","updated":"2020-03-25T15:27:38.988Z","comments":true,"path":"2020/03/24/MySQL/","link":"","permalink":"http://yoursite.com/2020/03/24/MySQL/","excerpt":"脏读、不可重复读、幻读： 脏读：读到了别的事务回滚前的脏数据,即当前事务读到的数据是别的事务想要修改成- 为的但是没有修改成功的数据。 不可重复读：当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配.","text":"脏读、不可重复读、幻读： 脏读：读到了别的事务回滚前的脏数据,即当前事务读到的数据是别的事务想要修改成- 为的但是没有修改成功的数据。 不可重复读：当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配. 幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据，产生幻读，即当前事务读第一次取到的数据比后来读取到数据条目少。 不可重复读和幻读比较：两者有些相似，但是前者针对的是update或delete，后者针对的insert。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"C++ primer重点记录","slug":"C-primer重点记录","date":"2020-03-24T05:43:26.000Z","updated":"2020-03-25T15:25:56.351Z","comments":true,"path":"2020/03/24/C-primer重点记录/","link":"","permalink":"http://yoursite.com/2020/03/24/C-primer%E9%87%8D%E7%82%B9%E8%AE%B0%E5%BD%95/","excerpt":"第一章 开始 windows或unix编译程序使用命令 cc hello.cc windows输出a.exe unix输出a.out 输入a.exe或者./a.out执行程序 运行GNU编译器的命令是g++","text":"第一章 开始 windows或unix编译程序使用命令 cc hello.cc windows输出a.exe unix输出a.out 输入a.exe或者./a.out执行程序 运行GNU编译器的命令是g++ g++ -o hello hello.cc (-o hello给执行文件命名) cerr 输出警告和错误消息 clog输出程序运行时的一般信息 命名空间可以避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突 使用一个istream对象作为条件，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符(EOF)，或遇到一个无效的输入时(例如读入的值不是一个整数)，istream对象的状态会变成无效，处于无效状态的istream对象会使条件变假。 1while(std::cin&gt;&gt;value) main函数返回值类型必须为int类型，为0表示成功，非0由系统定义，通常指出错误类型 编译为addItems.exe的可执行文件(UNIX中是addItems.out)，从一个名为infile的文件读取销售记录，并将结果输出写入一个名为outfile的文件中，两个文件都位于当前目录。 addItems outfile 第二章 变量和基本类型 一个字节：8bit 一个字：4或8个字节 float：一个字 double：两个字 long double：3或4个字 char与其他整型（整型包括字符、布尔和整数）不同，字符型被分为三种：char /signed char/unsigned char。char实际上表现为哪种类型由编译器决定。 c++算术类型分为两类：整型和浮点型 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8位 short 短整型 16 int 整型 16 long 长整型 32 long long 长整型 64 类型转换 赋值给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。eg:8比特大小的usigned char可以表示0至255区间内的值，如果赋了一个区间以外的值，则实际结果是该值对256取模后所得的余数。因此把-1赋给8比特大小的usigned char所得的结果是255（即256+（-1）=255）。 赋值给带符号类型一个超出它表示范围的值时，结果是未定义的。此时程序可能继续工作、可能崩溃、也可能生成垃圾数据。 如果两个运算符的运算对象类型不一致，首先把这些运算对象执行整型提升，如果结果类型匹配，无须进行进一步的转换。如果两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型运算对象转换成较大的类型。 123ival + ulval; //ival转换成usigned long，无符号类型不小于带符号类型usval + ival; //根据usigned short 和 int 所占空间的大小进行转换uival + lval; //根据usigned int 和 long 所占空间的大小进行转换 表达式里带符号类型不大于无符号类型，带符号类型会自动转换成无符号类型；带符号类型大于无符号类型时转换结果依赖于机器，eg,如果两个运算对象的类型分别是long类型和usigned int类型，long占用的空间比int更多，则usigned int 类型的运算对象转换成long类型；当带符号类型取值为负时会出现异常结果。 转义序列 \\x 后紧跟1个或多个十六进制数字，eg:“\\1234”表示一个16位的字符 \\后紧跟1、2或3个八进制数字，eg:“\\1234”表示两个字符即八进制123对应的字符和字符4 列表初始化 初始化！=赋值 1234567int a=1;int a=&#123;1&#125;;int a&#123;1&#125;;int a(1);long double ld=3.143;int a&#123;ld&#125;,b=&#123;ld&#125;;//错误：窄化转换，转换未执行，因为存在丢失信息的危险int a(ld),b=ld;//正确：转换执行，且确实丢失了部分值 变量能且仅能被定义一次，但是可以被多次声明。如果在多个文件中使用同一个变量，就必须将声明和定义分离，变量的定义必须出现在也只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，但是绝对不能重复定义。 标识符 标识符必须以字母或者下画线开头，要能体现实际含义。 变量名一般要用小写字母，如index,不要使用Index或INDEX。 用户自定义的类名一般以大写字母开头，如Sales_item。 如果标识符由多个单词组成，则单词间应有明显的区分，如student_loan或studentLoan,不要使用studentloan。 用户自定义标识符不能连续出现两个下画线，也不同以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。 按位与&amp; 或者 bitand 按位或 | 或者 bitor 异或^或者xor and_eq与=（赋值） or_eq或=（赋值） compl或者~非 not_eq不等于（赋值） xor_eq异或等于 在块作用域中使用“：：a”,因为全局作用域本身并没有名字，所以作用域左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量（即全局变量）。 引用必须被初始化，且不能更改指向值，而指针无须初始化且可以先后指向几个不同的对象。指针必须初始化，得到空指针的办法就是用字面值nullptr来初始化指针，新标准下，初始化指针最好使用nullptr,同时尽量避免NULL(在头文件cstdlib中定义的值为0的预处理器）和 0（使用NULL和0初始化指针是一样的）；把int变量直接赋值给指针是错误的操作，即使int变量值恰好等于0也不行。 123int zero=0；int *p=zero;//错误：不能直接把int变量赋值给指针（更不能把字面值常量直接赋值给指针）int *p=&amp;zero; void*是一种特殊的指针类型，可用于存放任意对象的指针，但是没办法访问内存空间的对象，因为无法确定这个对象到底是什么类型。 引用本身不是一个对象，因此不能定义指向引用的指针，但指针是对象，所以存在对指针的引用： 123456int i=42;int a=3;int *p;int *&amp;r=p;//r是一个引用，r引用的是一个指针，r引用的是一个int指针（面对一条比较复杂的指针或引用的声明语句时从右向左阅读有助于弄清它的真实含义）r=&amp;i;//r引用了一个指针，因此给r赋值就是零p指向i*r=a;或者*r=3;//解引用r得到i，也就是p指向的对象，将i的值改为3 默认状态下，const对象仅在文件内有效，如果想在多个文件之间共享const对象，必须在每个文件中变量的定义之前添加extern关键字。 1234//file1.cc定义并初始化了一个常量，该常量能被其他文件访问extern const int bugSize=fcn();//file2.cc头文件extern const int bufSize;//与file1.cc中定义的bufSize是同一个 可以利用const对象初始化非常量，但是对const的引用必须是const，且引用及其对应的对象都不能更改，指向常量的指针也必须是const。但是指向常量的指针或者引用可以绑定到一个非常量上。 1234567int i=42;const int ci=i;//正确：i的值被拷贝给了ciint j=ci;//正确：ci的值被拷贝给了jconst int &amp;r1=ci;//正确：引用及其对应的对象都是常量r1=42;//错误：r1是对常量的引用int &amp;r2=ci;//错误：试图让一个非常量引用指向一个常量const int &amp;r3=i;//正确：const int&amp; 可以绑定到一个普通int上 const引用一个非const对象，不允许通过const引用修改非const对象的值，但是允许通过其他途径改变它的值。 12345double i=42;int &amp;r1=i;const int &amp;r2=i;//实际实现过程是：（1）const int tmp=i;//由双精度浮点数生成一个临时的整型变量 （2）const int &amp;r2=tmp;//让r2绑定这个变量 r1=0;//r1非常量，i的值修改为0r2=0;//错误：r2是一个常量引用不允许修改i的值 指向常量的指针！=常量指针，常量指针必须初始化化，且一旦初始化则它的值（存放在指针中的地址）不再改变，但是如果常量指针指向的是一个一般的非常量整数，就能通过常量指针修改这个非常量整数。 1234567int i=0;int *const p=&amp;i;//p将一直指向iconst double pi=3.14159;const double *const pip=&amp;pi;//pip是一个指向常量对象的常量指针*p=3;//把i的值改为3*pip=4;//错误：pip指向的是一个常量对象p=&amp;pi;//p是一个常量指针 顶层const可以表示任意的对象是常量。 底层const则是与指针和引用等符合类型的基本类型部分有关。指针类型既可以是顶层const（表示指针本身是一个常量）也可以是底层const（表示所指的对象时一个常量）。 123456int i=0;int *const p1=&amp;i;//不能改变p1的值，这是一个顶层constconst int ci=42;//不能改变ci的值，这是一个顶层constconst int *p2=&amp;ci;//允许改变p2的值，这是一个底层constconst int *const p3=p2;//靠右的const是顶层const,靠左的是底层const(从你的右手到左手)const int &amp;r=ci;//用于声明引用的const都是底层const(指针是对象而引用不是) 字面值是常量表达式（字面值类型：算术类型、引用、指针；自定义类型如string、Sales_item则不属于字面值类型,也就不能被定义成constexpr），用常量表达式初始化的const对象也是常量表达式，应声明成constexpr(由它的数据类型和初始值共同决定)。尽管指针和引用都可以被定义成constexpr，但它们的初始值却受到严格限制，一个constexpr指针的初始值必须是nullptr或0，或者是存储于某个固定地址中的对象。 constexpr仅对指针有效，与指针所指的对象无关： 12345constexpr int *np=nullptr;//np是一个指向整数的常量指针，其值为空int j=0;constexpr int i=42;//i的类型是整型常量constexpr const int *p=&amp;i;//p是常量指针，指向整数常量iconsterxpr int *p1=&amp;j;//p1是常量指针，指向整数j 类型别名，不能把类型别名替换成它原来的样子 1234typedef char *pstring;const pstring cstr=0;//cstr是指向char的常量指针，顶层constconst pstring *ps;//ps是一个指针，它的对象时指向char的常量指针const char *cs=0;//cs是一个指向const char的指针，底层const auto一般会忽略顶层const,保留底层const。 decltype返回操作数的数据类型（包括顶层const和引用）。变量加上一层或多层括号，编译器就会把它当成给一个表达式，decltype的表达式如果是加上了括号的变量，结果是引用。 12345int i=42,*p=&amp;i,&amp;r=i;decltype(r+0) b;//正确：加法的结果是int，因此b是一个未初始化的intdecltype(*p) c;//错误c是int&amp;，必须初始化decltype((i)) d;//错误：d是一个int&amp;,必须初始化decltype(i) e;//正确：e是一个未初始化的int 第三章 字符串、向量和数组 cin读入字符串遇到空白符停止，getline遇到换行符停止（换行符也被读进来但是不保留）。 字符串字面值与string是不同类型。 可以用列表中元素的拷贝替换v1中的元素或初始化vector，但是列表不能作为形参vector直接使用。 1v1=&#123;a,b,c&#125;; 范围for语句体内不应该改变其所遍历序列的大小。 迭代器不同于指针，获取迭代器不是取地址符。begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，返回const_iterator（能读不能修改它所指的元素值或直接使用cbegin cend）,否则返回iterator（能读能写）。如果对象不是常量，均可。end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用。数组也可以使用begin（arr）和end（arr）获取指向数组首元素的指针和指向数组尾元素的下一位置的指针。 12*iter 返回迭代器iter所指元素的引用iter-&gt;mem 解引用iter并获取该元素的名为mem的成员，等价于（*iter）.mem different_type由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离。使用迭代器可进行二分查找。ptrdiff_t是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离。指针和迭代器都可进行算术运算。允许给空指针加上或者减去一个值为0的整型常量表达式，两个空指针也允许彼此相减，结果为0。 123456789usigned cnt=42;constexpr usigned sz=42;int *parr[sz];//含有42个整型指针的数组string bad[cnt];//错误：cnt不是常量表达式string strs[get_size()];//当get_size是constexpr时正确；否则错误auto n=end(arr)-begin(arr);//auto是ptrdiff_t类型，n=arr中元素的数量int *ip=arr;//等价于int *ip=&amp;arr[0];int *p=arr+sz;//正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置；使用警告：不要解引用！int *pz=arr+sz+1;//错误：arr只有sz个元素，pz的值未定义 如果函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。不允许使用一个数组为另一个内置类型的数组赋初值，但是允许使用数组来初始化vector对象。 1234vector&lt;int&gt; vec(begin(arr)+1,end(arr));//等价于vector&lt;int&gt; vec(arr+1,end(arr))int a[]=&#123;0,1,2&#125;;int a2[]=a; //错误：不允许使用一个数组初始化另一个数组a2=a; //错误：不能把一个数组直接赋值给另一个数组 字符串字面值会自动添加表示字符串结束的空字符。strcpy/strcmp/strlen/strcat此类函数可以传入字符串或者指向以空字符作为结束的数组的指针。比较标准库string对象的时候用的是普通的关系运算符合相等性运算符，把这些运算符用在比较两个C风格字符串上，实际比较的将是指针而非字符串本身。不能用string对象初始化char*，但是可以使用c_str，如果执行完c_str()函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。 12345678910111213141516char a1[]=&#123;'c','+','+'&#125;;//列表初始化,没有空字符char a2[]=&#123;'c','+','+','\\0'&#125;;//列表初始化,含有显式的空字符char a3[]=\"c++\";//自动添加表示字符串结束的空字符const char a4[6]=\"daniel\";//错误：没有空间可存放空字符int &amp;refs[10]=/*?*/;//错误：不存在引用的数组char (&amp;arrRef)[3]=a1;//arrRef引用一个含有3个字符的数组int *(&amp;arry)[42]=parr;//arry是数组的引用，该数组含有42个指针cout&lt;&lt;strlen(a1)&lt;&lt;endl;//错误：啊没有以空字符结束string s1=\"abcd\";string s2=\"cdr\";if(s1&lt;s2)//trueconst char c1[]=\"abcd\";const char c2[]=\"bcde\";if(c1&lt;c2)//未定义：试图比较两个无关地址char *str=s1;//错误const char *str=s1.c_str;//正确，用const char*保证字符数组内容不改变；如果后续操作改变了s1的值就可能让之前返回的数组失去效用 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组；当使用decltype()时上述转换不会发生。 123456int ia[]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;auto ia2(ia);//ia2是一个整型指针，指向ia的第一个元素ia2=42;//错误：ia2是一个指针，不能用整数给指针赋值decltype(ia) ia3=&#123;0,1,2,3,4,5,6,7,8,9&#125;；ia3=p;//错误：不能用整型指针给数组赋值ia3[4]=i;//正确：把i的值赋给ia3的一个元素 数组内置的下标运算符所用的索引值不是无符号类型，这一点与string和vector不同。 123int *p=&amp;a[2];int j=p[1];//等价于*（p+1)，就是a[3]int k=p[-2];//p[-2]是a[0]表示的那个元素 多维数组的初始化和下标引用 123456789int a[2][3]=&#123; &#123;0,1,2&#125;, &#123;3,4,5&#125;&#125;;int a[2][3]=&#123;0,1,2,3,4,5&#125;;//内层嵌套着的花括号并非完全必要int a[2][3]=&#123;&#123;0&#125;,&#123;3&#125;&#125;;//显示初始化每行的首元素int （&amp;row)[3]=a[1];把row绑定到a的第二个3元素数组上int (*p)[3]=a;//p指向含有3个整数的数组p=&amp;a[1];//p指向a的尾元素 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型，因为数组名会被自动地转换成指向该数组首元素的指针。 1234567891011121314151617181920212223242526272829303132//正确for(const auto &amp;row:a)&#123; for(auto clo:row)&#123; cout&lt;&lt;col&lt;&lt;endl; &#125;&#125;//错误：row的类型是int*,显然内层循环不合法for(const auto row:a)&#123; for(auto clo:row)&#123; cout&lt;&lt;col&lt;&lt;endl; &#125;&#125;//p指向含有3个整数的数组，*p解引p得到指向内层数组首元素的指针for(auto p=a;p!=a+2;++p)&#123; for(auto q=*p;q!=*p+3;q++)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125;//简洁版for(auto p=begin(a);p!=end(a);p++)&#123; for(auto q=begin(*p);q!=end(*p);q++)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125;//类型别名简化多维数组的指针using int_arr=int[4];typedef int int_arr[4];//等价的typedegf声明for(int_arr *p=a;p!=a+2;++p)&#123; for(int *q=*p;q!=*p+3;++q)&#123; cout&lt;&lt;*q&lt;&lt;endl; &#125;&#125; 第四章 表达式 当一个对象被用作右值时，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。使用关键字decltype的时候左值右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。eg.假定p的类型是int，因为解引用运算符生成左值，所以decltype(\\p)的结果是int&amp;。另一方面，因为取地址符生成右值，所以decltype(&amp;p)的结果是int**,也就是说，结果是一个指向整型指针的指针。 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。 123cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;++i&lt;&lt;endl; //产生未定义的行为，可能先计算i再计算i++，或者先计算i++再计算i,或其他不可预知行为，所以编译器生成什么样的代码程序都是错的*beg=toupper(*beg++); //产生未定义的行为，可能先求左侧的值或先求右侧的值，也可能采取别的什么方式处理它*++iter; //正确：先递增再解引用 后置递增运算符的优先级高于解引用运算符，因此pbeg++等价于\\（pbeg++)，先自增，然后返回初始值的副本作为其求值结果，此时解引用运算符的运算对象是pbeg未增加之前得值，最终这条语句输出pbeg开始时指向的那个元素，并将指针向前移动一个位置。 解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号，如果没有括号，代码的含义就大不相同了。 12(*p).size(); //正确*p.size(); //错误：p是一个指针，它没有名为size成员 左移运算符（&lt;&lt;）在右侧插入值为0的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。 sizeof运算符返回一条表达式或一个类型名字所占的字节数，满足右结合律，其所得值是一个size_t类型的常量表达式。在sizeof的运算对象中解引用一个无效指针仍然是一种安全行为，因为指针实际上并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。sizeof运算不会把数组转换成指针来处理，对string和vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中元素的个数。 123sizeof *p; //p所指空间类型的大小，即sizeof(Sales_data),等价于sizeof(*p)，即使p是一个无效（即未初始化）的指针constexpr size_t sz=sizeof(ia)/sizeof(*ia); //返回数组ia的元素数量int arr[sz]; //sizeof返回一个常量表达式 指向任意非常量的指针能转换成void；指向任意对象的指针能转换成const void\\。 123if(cp) //如果指针cp不是0，条件为真while(*cp) //如果*cp不是空字符，条件为真while(cin&gt;&gt;s) //布尔值决定于输入流的状态，最后一次读入成功，true;反之，false 显式转换：cast_name(expression)，cast-name是static_cast（任何具有明确定义的类型转换，只要不包含底层const）/dynamic_cast（支持运行时类型识别）/const_cast（只能改变运算对象的底层const）/reinterpret_cast（通常为运算对象的位模式提供较低层次上的重新解释）中的一种。除了在有重载函数的上下文中使用const_cast无可厚非，其他强制类型转换都不应该频繁使用。 12345678int i,j;double slope=static_cast&lt;double&gt;(j)/i; //进行强制类型转换以便执行浮点数除法void* p=&amp;d; //任何非常量对象的地址都能存入void*double *dp=static_cast&lt;double*&gt;(p); //正确：将void*转换回初始的指针类型const char *pc;char *P=const_cast&lt;char*&gt;(pc); //正确：但是通过p写值时未定义的行为int *ip;char *pc=reinterpret_cast&lt;char*&gt;(ip); //牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误，eg:string str(pc)，具有高危性 第五章 语句 一般不要省略case分支的break语句，否则，程序将跨越case标签的边界；如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧跟在default标签后面的语句。 如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是违法行为。因此c++语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域的另一个位置。 for语句头能省略掉init-statement、condition和expression中的任何一个（或全部）。省略condition的效果等价于在条件部分写了一个true，则循环体内必须有语句负责退出循环。 123vector&lt;int&gt; v;for(int i;cin&gt;&gt;i;/*表达式为空*/) //条件部分能改变i值，所以这个循环无须表达式部分 v.push_back(i); 尽量不要使用goto语句，因为它使得程序既难理解又难修改。 try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问。 12345678910111213141516while(cin&gt;&gt;item1&gt;&gt;item2)&#123; try&#123; //执行添加两个Sales_item对象的代码 //如果添加失败，代码抛出一个runtime_error异常 &#125;catch(runtime_error err)&#123; cout&lt;&lt;err.what() &lt;&lt;\"\\nTry Again? Enter y or n\"&lt;&lt;endl; char c; cin&gt;&gt;c; if(!cin || c=='n') break;跳出while循环 &#125;&#125;//类型runtime_error是标准库异常类型的一种，必须提供一个string对象或者C风格的字符串初始化runtime_error的对象if(item1.isbn()!=item2.isbn()) throw runtime_error(\"Data must refer to same ISBN\"); 标准库异常类只定义了几种运算，包括创建或拷贝异常类型对象，以及为异常类型的对象赋值。异常类型只定义了一个名为what的成员函数，该函数没有参数，返回值是一个指向C风格字符串的const char*。该字符串的目的是提供关于异常的一些文本信息。如果异常类型有一个字符串初始值，则what返回该字符串。对于其他无初始值的异常类型来说，what返回的内容由编译器决定。 寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果最终还是没找到任何匹配的catch子句，程序转到名为terminate的标准函数库。对于那些没有任何try语句块定义的异常，系统同样会调用terminate函数并终止当前程序的执行。 第六章 函数 局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。 参数传递包括值传递和引用传递（引用传递直接传入对象而无须传递对象的地址，eg.可以给函数传入一个额外的引用实参，令其保存字符出现的次数）。指针传递属于值传递，当执行指针拷贝操作时，拷贝的是指针的值，拷贝之后两个指针是不同的指针，因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指的对象，但是改变局部拷贝的值并不能改变实参以及实参所指对象。 顶层const可以初始化非const,非const可以初始化顶层const,所以实参初始化形参时就会忽略掉顶层const.想调用引用版本的reset(int &amp;i)只能使用int类型的对象，而不能使用字面值、求值结果为int的表达式、需要转换的对象或者const int类型的对象，类似的，想要调用指针版本的reset(int p)只能使用int\\。 12345678910111213141516171819void fcn(const int i)&#123;/*fcn能读取i,但是不能向i写值*/&#125;void fcn(int i)&#123;/*值传递本身写值就没有意义*/&#125; //错误：重复定义了fcn(int)Record lookup(Acount*);Record lookup(Acount* const); //错误：重复声明Record lookup(Acount*);Record lookup(const Acount*); //新函数，作用于常量引用Record lookup(Acount&amp;);Record lookup(const Acount&amp;); //新函数，作用于指向常量的指针int i=1;const int ci=42; //不能改变ci的值这是一个顶层constconst int *p2=&amp;ci; //允许改变p2的值，这是一个底层constconst int *const p3=p2; //靠右的是顶层const，靠左的是底层constconst int &amp;r=ci; //用于声明引用的const都是底层const（从这里也说明不能使用指向const int对象的指针初始化int*因为int*没有底层const,eg.void reset(int *p);reset(&amp;ci)错误）int *p=p3; //错误：p3包含底层const的定义，而p没有p2=p3; //正确：p2和p3都是底层constp2=&amp;i; //正确：int*能转换成const int*int &amp;r=ci; //错误：普通的int&amp;不能绑定到int常量上const int &amp;r2=i; //正确：const int&amp;可以绑定到一个普通的int上reset(42)； //不能把普通引用绑定到字面值上，只能把const引用绑定到字面值上 数组不能拷贝所以无法以值传递的方式传递数组,因为数组会被转换成指针，所以我们为函数传递一个数组时实际上传递的是指向数组元素的指针。 1234567//尽管形式不同，但是三个print函数是等价的，每个函数都有一个const int*类型的唯一形参void print(const int*);void print(const int[]); //可以看出了，函数的意图是作用于一个数组void print(const int[10]); //这里的维度表示我们期望数组含有多少元素，实际不一定int i=0,j[2]=&#123;0,1&#125;;print(&amp;i); //正确：&amp;i的类型是int*print(j); //正确：j转换成int*并指向j[0] c++允许将变量定义成数组的引用，同理，形参也可以是数组的引用（维度是类型的一部分）。因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。 123456f(int &amp;arr[10])&#123;/*...*/&#125;; //错误：将arr声明成了引用的数组f(int (&amp;arr)[10])&#123;/*...*/&#125;; //正确：arr是具有10个整数的整型数组的引用int k[10]=&#123;0,1,2,3,4,5,6,9&#125;;print(&amp;i); //错误：实参不是含有10个整数的数组print(j); //错误：实参不是含有10个整数的数组print(k); //正确：实参是含有10个整数的数组 多维数组实际上是数组的数组，所以由多维数组名转换得到的指针实际上是指向第一个内层数组的指针。和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，由于首元素本身就是一个数组，指针就是一个指向数组的指针，数组第二维（以及后面所有的维度）的大小都是数组类型的一部分，不能省略。 123456int a[3][4];int (*p)[4]=ia; //p指向含有4个整数的数组p=&amp;a[2]; //p指向a的尾元素int *matrix[10]; //错误：10个指针构成的数组int (*matrix)[10]; //正确：指向含有10个整数的数组指针void print(int matrix[][10],int rowSize)&#123;/*...*/&#125;; //matrix的声明看起来是一个二维数组，实际上形参是一个指向含有10个整数的数组指针，等价于int (*matrix)[10] 如果函数的实参数量未知，但是全部实参的类型都相同，可以采用initializer_list类型的形参，initializer_list是一种标准库类型，用于表示某种特定类型的值的数组，initializer_list类型定义在同名的头文件中，拷贝或者赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 1234initializer_list&lt;T&gt; lst2; //默认初始化：T类型元素的空列表initializer_list&lt;T&gt; lst&#123;a,b,c...&#125; //lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是constlst2(lst);lst2=lst; 返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。不要返回局部对象的引用或指针，局部变量在函数结束后所占用的存储空间也随之被释放掉，函数终止意味着局部变量的引用将指向不再有效的内存区域。 1234567891011121314151617181920212223const string &amp;mainp()&#123; string ret; //以某种方式改变一下ret if(ret.empty())&#123; return ret; //错误：返回局部对象的引用 else return \"Empty\"; //错误：\"Empty\"是一个局部临时量 &#125;&#125;//引用返回左值：调用一个返回引用的函数得到左值，其他类型得到右值可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值char &amp;get_val(string &amp;str,string::size_type ix)&#123; return str[ix]; //get_val假定索引值是有效的&#125;int main()&#123; string a(\"a value\"); get_val(s,0)='A'; cout&lt;&lt;s&lt;&lt;endl; //输出A value&#125;//c++11规定函数可以返回花括号包围的值的列表vector&lt;string&gt; process()&#123; return &#123;&#125;; //返回一个空vector return &#123;\"functionX\",\"okay\"&#125;; //返回列表初始化的vector对象&#125; type (*function(parameter_list))[dimension]声明一个返回数组指针的函数 1234567typedef int arrT[10];using arrT=int[10];//func返回一个指向含有10个整数的数组指针arrT* func(int i); auto func(int i)-&gt;int(*)[10];int odd[]=&#123;1,2,3,4,5,6,7,8,9,0&#125;decltype(odd) *func(int i); //decltype不负责把数组类型转换成对应的指针 不允许两个函数除了返回类型外其他所有的要素都相同，对于重载函数来说，应该在形参数量或者形参类型上有所不同。 一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 123456789sz wd=80;char def=' ';sz ht();string screen(sz=ht(),sz=wd,char def);void f()&#123; def='*'; //改变默认参数值 sz wd=100; //隐藏了外层定义的wd,但是没有改变默认值，该局部变量与传递给screen的默认实参没有任何关系 window=screen(); //调用screen(ht(),80,'*')&#125; constexpr函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。内联函数和constexpr函数可以在程序中多次定义，通常定义在头文件中。 123456constexpr int new_sz()&#123;return 42;&#125; //编译器能在程序编译时验证new_sz函数返回的是常量表达式，所以可以用new_sz函数初始化constexpr类型的变量fooconstexpr int foo = new_sz();constexpr size_t scale(size_t cnt)&#123;return new_sz()*cnt;&#125; //允许constexpr函数的返回值并非一个常量，当scale的实参是常量表达式时，它的返回值也是常量表达式；反之，则不然int arr[scale(2)]; //正确：scale（2）是常量表达式int i=2; //i不是常量表达式int a2[scale(i)]; //错误：scale(i)不是常量表达式 编译器会因为函数调用具有二义性而拒绝其请求；为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下所示： 精确匹配，包括以下情况： 实参类型和形参类型相同。 实参从数组类型或函数类型转换成对应的指针类型 向实参添加顶层const或者从实参中删除顶层const 通过const转换实现的匹配 通过类型提升实现的匹配 通过算术类型转换或指针转换实现的匹配（所有算术类型转换的级别都一样，例如,从int向usigned int的转换并不比从int向double的转换级别高） 通过类类型转换实现的匹配 当我们把函数名作为一个值使用时，该函数自动转换成指针。 123456789bool lengthCompare(const string &amp;,const string &amp;);bool (*pf)(const string &amp;,const string &amp;); //未初始化pf=lengthCompare; //pf指向名为lengthCompare的函数（返回类型和形参列表要精确匹配）pf=&amp;lengthCompare; //等价的赋值语句：取地址符是可选的//调用lengthCompare函数bool b1=pf(\"hello\",\"good\");bool b2=(*pf)(\"hello\",\"goodbye\");bool b3=lengthCompare(\"hello\",\"goodbye\");pf=0; //正确：pf不指向任何函数 函数的形参：和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用。 12345678910void useBigger(const string &amp;s,bool pf(const string &amp;,const string &amp;)); //第三个形参是函数类型，它会自动地转换成指向函数的指针void useBigger(const string &amp;s,bool (*pf)(const string &amp;,const string &amp;)); //等价的声明：显式地将形参定义成指向函数的指针//Func和Func2是函数类型typedef bool Func(const string &amp;,const string &amp;);typedef decltype(lengthCompare) Func2;//FuncP和FuncP2是指向函数的指针typedef bool (*FuncP)(const string&amp;,const string&amp;);typedef decltype(lengthCompare) *FuncP2; //decltype不会将函数类型自动转换成指针类型void useBigger(const string&amp;,Func); //编译器自动地将Func表示的函数类型转换成指针void useBigger(const string&amp;,FuncP); 返回指向函数的指针：和函数类型的形参不一样，返回类型不会自动地转换成指针，我们必须显式地将返回类型指定为指针。 1234567using F=int(int*,int); //F是函数类型，不是指针using PF=int(*)(int*,int); //PF是指针类型PF f(int); //正确：PF是指向函数的指针，f返回指向函数的指针F f(int); //错误：F是函数类型，f不能返回一个函数F *f(int); //正确：显式地指定返回类型是指向函数的指针int (*f(int))(int*,int); //可以直接声明f,按照由内向外的顺序阅读这条声明：f有形参列表，所以f是个函数；f前面有*，所以f返回一个指针；指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int.auto f(int)-&gt;int(*)(int*,int); //使用尾置返回类型的方式声明一个返回函数指针的函数 编译器将所有.cpp文件编译为.obj或.o文件再把对象文件链接在一起形成可执行文件.exe或.out。如果.cpp中有#include X.h文件，那么第一步预处理会把X.h代码粘贴到.cpp中代替#include语句。 如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件。 12345678g++ factMain.cc fact.cc //生成 factMain.exe or a.outg++ factMain.cc fact.cc -o main //生成 main or main.exe//分离式编译g++ -c factMain.cc //生成factMain.og++ -c fact.cc //生成fact.og++ fact.o factMain.o //生成factMain.exe or a.outg++ factMain.o fact.o -o main //生成 main or main.exe 第七章 类 只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数；当既需要其他形式的构造函数，也需要默认的构造函数时使用 Sales_data() = defalut;来要求编译器生成构造函数。 如果类包含内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。 使用class和struct定义类唯一的区别就是默认的访问权限。struct关键字在第一个访问说明符之前的成员是public；class关键字在第一个访问说明符之前的成员是private。 class默认的继承访问权是private,struct默认的是public。 class关键字可用于定义模板参数，就像typename，但struct关键字不能。 友元的声明只能出现在类定义的内部（最好在类定义开始或者结束前的位置集中声明友元）仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，必须在友元声明之外再转名对函数进行一次声明。每个类负责控制自己的友元类或友元函数，友元关系不存在传递性。 12345678910111213141516class Screen&#123; //首先定义Window_mgr类，其中声明cleat函数，但不能定义它。在 //clear使用Screen的成员之前必须先声明Screen。 friend void Window_mgr::clear(ScreenIndex); //Screen类的剩余部分&#125;//最后定义clear，此时它才可以使用Screen的成员struct X&#123; friend void f()(/*友元函数可以定义在类的内部＊/&#125; X()｛f();｝ //错误:还没有被声明 void g(); void h();&#125;;void X::g()( return f();&#125; //错误:f还没有被声明void f(); //声明那个定义在X中的函数void X::h()&#123;return f();&#125; //正确:现在王的声明在作用域 使用类型别名等价地声明一个类型名字 12typedef std::string::size_type pos;using pos=std::string::size_type; 在变量声明中加入mutable关键字能修改类的某个数据成员，即使是在一个const函数内。 常量引用不能修改对象。常量对象不能调用非常量函数，但是非常量对象能调用常量函数。 12345怎么选择使用哪种返回传值方式-&gt;拷贝开销大吗 -&gt;不大-&gt;按值返回return-by-value(拷贝，c++11自动转化为移动来节省拷贝开销) -&gt;很大-&gt;希望对返回值的内部数据进行修改吗(引用避免拷贝开销) -&gt;不需要-&gt;按常量引用返回return-by-constant-reference -&gt;需要-&gt;按引用返回return-by-reference 即使两个类的成员列表完全一致，它们也是不同的类型。我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类名跟在关键字class或struct后面。 12Sales_data item; //默认初始化Sales_data类型的对象class Sales_data item; //一条等价的声明 只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被人为是声明过了(但尚未定义)，因此类允许包含指向它自身类型的引用或指针。 12345class Link_screen&#123; Screen window; Link_screen *next; Link_screen &amp;other;&#125;; 类内初始化，必须使用=的初始化形式(初始化Screen的数据成员时所用的)或者花括号括起来的直接初始化形式(初始化screens所用的)。Screen的构造函数接受两个尺寸参数和一个字符值，创建了一个给定大小的空白屏幕对象。 12private: std::vector&lt;Screen&gt; screens&#123;Screen(24,80,' ')&#125;; 第十章 泛型算法 泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作，所以算法容器中保存的元素，也可能在容器中移动元素，但永远不会直接添加或删除元素。 replace_copy保持原序列不变，接受额外第三个迭代器参数，之处调整后序列的保存位置；back_inserter按需要增长目标序列。 1replace_copy(ilst.cbegin(),ilst.cend,back_inserter(ivec),0,42); //ilst未改变，ivec包含ilst的一份拷贝，不过原来ilst中值为0的元素在ivec中都变为42 第十二章 动态内存、智能指针和动态数组 常量指针：指针指向的地址能改变，只能指向的内容不能改变 指针常量：指针地址不能改变，指针指向的内容可以改变 new后必须delete（传递给delete的指针必须指向动态分配的内存或者是一个空指针）；智能指针可以自动销毁 内存泄漏：内存永远不可能被归还给自由空间 不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化的形式 12shared_ptr&lt;int&gt; p1=new int(1024);//错误，隐式转换shared_ptr&lt;int&gt; p12(new int(1024));//正确，直接初始化 当将shared_ptr绑定到一个普通指针时，内存管理就交给了这个shared_ptr，就不能使用那个内置指针来访问shared_ptr指向的内存了。 unique_ptr通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique_ptr 1auto p=p2.release();//p2放弃对指针的控制权，返回指针，并将p2置空；必须记得delete(p)，此时auto代表普通指针 当创建weak_ptr时要用shared_ptr来初始化 12auto p=make_shared&lt;int&gt;(42);weak_ptr&lt;int&gt; wp(p);//wp弱共享p；p的引用计数不变 weak_ptr的lock()如果expired()为true（表示use_count==0），返回一个空shared_ptr；否则返回一个指向对象的shared_ptr 销毁动态数组时数组中的元素按逆序销毁 1delete [] p；//p必须指向一个动态分配的数组或为空 动态分配一个空数组是合法的 12char arr[0];//错误：不能定义长度为0的数组char *cp=new char[0];//正确：但cp不能解引用 unique_ptr支持管理动态数组，shared_ptr不支持除非提供自己定义的删除器 12unique_ptr&lt;int[]&gt; up(new int[10]());//up指向一个包含10个初始化为0的int的数组share_ptr&lt;int&gt; sp(new int[10]，[](int *p)&#123;delete [] p;&#125;);//sp指向一个包含10个未初始化的int数组，并提供一个删除器 make_shared函数构造shared_ptr对象时在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，使用一次内存分配；shared_ptr构造shared_ptr对象时需要进行两次内存分配 new：没有默认构造函数的类不能动态分配数组 allocator:定义在memory中，将内存分配和对象构造分离开来 管理“动态数组”时，需要制定Deleter以使用delete[]操作符销毁内存，因为shared_ptr并没有针对数组的特化版本，而unique_ptr有针对数组的特化版本。我们常常需要对动态数组中的某一个元素进行操作，但shared_ptr没有提供[]操作符，不过我们可以使用 sp.get()先获取原始指针，再对原始指针进行下标操作。而unique_ptr对动态数组提供了支持，指定删除器是一个可选项。也可以直接使用下标操作 make_unique完美传递了参数给对象的构造函数，从一个原始指针构造出一个std::unique_ptr，返回创建的std::unique_ptr。这个形式的函数不支持数组和定制删除器（见条款18） 要解决环形引用的问题，没有特别好的办法，一般都是在可能出现环形引用的地方使用weak_ptr来代替shared_ptr。weak_ptr指向shared_ptr指针指向的对象的内存，却并不拥有该内存。 但是，使用weak_ptr成员lock，则可返回其指向内存的一个shared_ptr对象，且在所指对象内存已经无效时，返回指针空值（nullptr）。由于weak_ptr是指向shared_ptr所指向的内存的，所以，weak_ptr并不能独立存在 文本查询程序——优质程序","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Hexo+GitHub+NexT搭建博客","slug":"Hexo-GitHub-nexT搭建博客","date":"2020-03-23T14:26:43.000Z","updated":"2020-03-25T17:04:36.109Z","comments":true,"path":"2020/03/23/Hexo-GitHub-nexT搭建博客/","link":"","permalink":"http://yoursite.com/2020/03/23/Hexo-GitHub-nexT%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask on GitHub. （一）搭建博客操作过程 安装 Node.js 和 Git。 Node.js：https://nodejs.org/zh-cn Git：https://git-scm.com/downloads","text":"Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask on GitHub. （一）搭建博客操作过程 安装 Node.js 和 Git。 Node.js：https://nodejs.org/zh-cn Git：https://git-scm.com/downloads 下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。 安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git --version出现版本号说明安装成功。 创建GitHub Pages仓库 GitHub 主页右上角加号 -&gt; New repository： Repository name 中输入 用户名.github.io 勾选 “Initialize this repository with a README” 勾选public Description 选填 填好后点击 Create repository 创建。创建后默认自动启用 HTTPS，博客地址为：https://用户名.github.io,浏览器输入博客地址正常显示用户名.github.io。 本地安装Hexo博客程序 新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。打开该文件夹，右键 -&gt; Git Bash Here。 使用 npm 一键安装 Hexo 博客程序： 1npm install -g hexo-cli Mac 用户需要管理员权限（sudo），运行这条命令： 1sudo npm install -g hexo-cli 安装时间有点久（真的很慢！），界面也没任何反应，耐心等待 Hexo初始化和本地预览 初始化并安装所需组件： 12hexo init # 初始化npm install # 安装组件 完成后依次输入下面命令，启动本地服务器进行预览： 12hexo g # 生成页面hexo s # 启动预览 访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功！ 部署Hexo到GitHub Pages 本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。 首先安装 hexo-deployer-git： 1npm install hexo-deployer-git --save 然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下： 1234deploy: type: git repository: https:&#x2F;&#x2F;github.com&#x2F;用户名&#x2F;用户名.github.io branch: master 完成后运行 hexo d 将网站上传部署到 GitHub Pages,访问我们的 GitHub 域名 https://用户名.github.io 就可以看到 Hexo 网站了。 更换主题 在 Themes | Hexo 选择一个喜欢的主题，比如 NexT，进入网站目录打开 Git Bash Here 下载主题： 1git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next 然后修改 _config.yml 中的 theme 为新主题名称 next，发布。 （二）Hexo常用命令123456789101112131415161718192021222324252627hexo n &quot;name&quot; # 新建文章&#x3D;hexo new &quot;name&quot; hexo new page &quot;name&quot; # 新建页面hexo g # 生成页面&#x3D;hexo generatehexo d # 部署&#x3D;hexo deployhexo g -d # 生成页面并部署hexo s --debug # 调试模式下本地预览，可也用非调试模式hexo serverhexo clean # 清除缓存和已生成的静态文件hexo help # 帮助npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP&#x2F;&#x2F;新建文章三连hexo n &quot;name&quot; hexo g hexo s --debug&#x2F;&#x2F;预览效果满意则推到git上hexo d&#x2F;&#x2F;部署网站三连hexo clean hexo g hexo d （三）常见问题和注意事项1、Hexo 设置显示文章摘要，首页不显示全文 Hexo 主页文章列表默认会显示文章全文，浏览时很不方便，可以在文章中插入 `` 进行分段。该代码前面的内容会作为摘要显示，而后面的内容会替换为 “Read More” 隐藏起来。 2、设置网站图标 进入 themes/主题 文件夹，打开 _config.yml 配置文件，找到 favicon 修改，一般格式为：favicon: 图标地址。（不同主题可能略有差别） 3、修改并部署后没有效果 使用 hexo clean 清理后重新部署。 4、开启 HTTPS 后访问网站显示连接不安全？ 证书还未部署生效，等待一会儿，清除浏览器缓存再试。 5、Mac 安装 Hexo 报错无法安装 Mac 用户需要管理员权限运行，使用 sudo npm install -g hexo-cli 命令安装。 6、npm 下载速度慢，甚至完全没反应 使用 npm 安装程序等待很久也没反应，或者下载速度很慢，可以更换 npm 源为国内 npm 镜像。 临时更换方法：在 npm 安装命令后面加上： 1--registry https:&#x2F;&#x2F;registry.npm.taobao.org 7、注意格式标准 123title:(有空格)[文件名]tag:#标签-（有空格）c++ 8、设置SSH或HTTPS实现免密hexo deploy 方案一：如下图#号注释掉的代码，填写https：//账号:密码@github.com/账号/博客仓库名，实现HTTPS免密执行hexo d 方案二： 设置user.name和user.email配置信息，打开git bash输入： 12git config --global user.name \"你的GitHub用户名\"git config --global user.email \"你的GitHub注册邮箱\" 生成ssh密钥文件： 1ssh-keygen -t rsa -C \"你的GitHub注册邮箱\" 然后直接三个回车即可，默认不需要设置密码然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制。 打开GitHub_Settings_keys 页面，新建new SSH Key，随便填title,把刚复制的密钥粘贴到key,最后点击Add SSH key。 验证ssh是否设置成功： 1ssh git@github.com 配置站点的_config.yml文件，修改或添加repository值为ssh地址,填写git@github.com:账号/博客仓库名.git 9、hexo引用本地图片上传 安装一个图片路径转换的插件，这个插件名字是hexo-asset-image 1npm install https://github.com/CodeFalling/hexo-asset-image --save 打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For \"about\" page, the first part of \"src\" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info(\"update link as:--&gt;\"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(\"no src attr, skipped...\"); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 打开_config.yml文件，修改下述内容 1post_asset_folder: true 在md所在文件内新建一个同名文件，把图片放在该文件内 10、hexo+nexT的标签页面不显示 步骤按NexT主题配置操作 _config.yml中menu下||前面的空格删掉（||前面是链接，后面是图标） More info: HexoDoc MarkDown","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"NexT","slug":"NexT","permalink":"http://yoursite.com/tags/NexT/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}],"categories":[{"name":"常用技巧","slug":"常用技巧","permalink":"http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"安装编译","slug":"安装编译","permalink":"http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"},{"name":"搭建博客","slug":"搭建博客","permalink":"http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"},{"name":"长截屏","slug":"长截屏","permalink":"http://yoursite.com/tags/%E9%95%BF%E6%88%AA%E5%B1%8F/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"Clion","slug":"Clion","permalink":"http://yoursite.com/tags/Clion/"},{"name":"Boost","slug":"Boost","permalink":"http://yoursite.com/tags/Boost/"},{"name":"Opencv","slug":"Opencv","permalink":"http://yoursite.com/tags/Opencv/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"NexT","slug":"NexT","permalink":"http://yoursite.com/tags/NexT/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}